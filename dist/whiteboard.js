var bundle = (function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var findDom = function findDom(sel) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    return el.querySelector(sel);
  };

  var log = {
    'log': function log(logMsg) {
      console.log(logMsg);
    },
    'error': function error(msg) {
      console.error(msg);
    }
  };

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read$$1 (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read$$1(arr, i + j) !== read$$1(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var empty = {};

  var empty$1 = /*#__PURE__*/Object.freeze({
    default: empty
  });

  var require$$3 = ( empty$1 && empty ) || empty$1;

  var fabric_1 = createCommonjsModule(function (module, exports) {
  /* build: `node build.js modules=ALL exclude=gestures,accessors requirejs minifier=uglifyjs` */
  /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

  var fabric = fabric || { version: '2.3.3' };
  {
    exports.fabric = fabric;
  }
  /* _AMD_END_ */
  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    fabric.document = document;
    fabric.window = window;
  }
  else {
    // assume we're running under node.js when document/window are not present
    fabric.document = require$$3
      .jsdom(
        decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
        { features: {
          FetchExternalResources: ['img']
        }
        });
    fabric.jsdomImplForWrapper = require$$3.implForWrapper;
    fabric.nodeCanvas = require$$3.Canvas;
    fabric.window = fabric.document.defaultView;
    DOMParser = require$$3.DOMParser;
  }

  /**
   * True when in environment that supports touch events
   * @type boolean
   */
  fabric.isTouchSupported = 'ontouchstart' in fabric.window;

  /**
   * True when in environment that's probably Node.js
   * @type boolean
   */
  fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                        typeof window === 'undefined';

  /* _FROM_SVG_START_ */
  /**
   * Attributes parsed from all SVG elements
   * @type array
   */
  fabric.SHARED_ATTRIBUTES = [
    "display",
    "transform",
    "fill", "fill-opacity", "fill-rule",
    "opacity",
    "stroke", "stroke-dasharray", "stroke-linecap",
    "stroke-linejoin", "stroke-miterlimit",
    "stroke-opacity", "stroke-width",
    "id", "paint-order",
    "instantiated_by_use"
  ];
  /* _FROM_SVG_END_ */

  /**
   * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
   */
  fabric.DPI = 96;
  fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
  fabric.fontPaths = { };
  fabric.iMatrix = [1, 0, 0, 1, 0, 0];
  fabric.canvasModule = 'canvas';

  /**
   * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.perfLimitSizeTotal = 2097152;

  /**
   * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.maxCacheSideLimit = 4096;

  /**
   * Lowest pixel limit for cache canvases, set at 256PX
   * @since 1.7.14
   * @type Number
   * @default
   */
  fabric.minCacheSideLimit = 256;

  /**
   * Cache Object for widths of chars in text rendering.
   */
  fabric.charWidthsCache = { };

  /**
   * if webgl is enabled and available, textureSize will determine the size
   * of the canvas backend
   * @since 2.0.0
   * @type Number
   * @default
   */
  fabric.textureSize = 2048;

  /**
   * Enable webgl for filtering picture is available
   * A filtering backend will be initialized, this will both take memory and
   * time since a default 2048x2048 canvas will be created for the gl context
   * @since 2.0.0
   * @type Boolean
   * @default
   */
  fabric.enableGLFiltering = true;

  /**
   * Device Pixel Ratio
   * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
   */
  fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                            fabric.window.webkitDevicePixelRatio ||
                            fabric.window.mozDevicePixelRatio ||
                            1;
  /**
   * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
   * which is unitless and not rendered equally across browsers.
   *
   * Values that work quite well (as of October 2017) are:
   * - Chrome: 1.5
   * - Edge: 1.75
   * - Firefox: 0.9
   * - Safari: 0.95
   *
   * @since 2.0.0
   * @type Number
   * @default 1
   */
  fabric.browserShadowBlurConstant = 1;

  fabric.initFilterBackend = function() {
    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
      console.log('max texture size: ' + fabric.maxTextureSize);
      return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
    }
    else if (fabric.Canvas2dFilterBackend) {
      return (new fabric.Canvas2dFilterBackend());
    }
  };


  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
    window.fabric = fabric;
  }


  (function() {

    /**
     * @private
     * @param {String} eventName
     * @param {Function} handler
     */
    function _removeEventListener(eventName, handler) {
      if (!this.__eventListeners[eventName]) {
        return;
      }
      var eventListener = this.__eventListeners[eventName];
      if (handler) {
        eventListener[eventListener.indexOf(handler)] = false;
      }
      else {
        fabric.util.array.fill(eventListener, false);
      }
    }

    /**
     * Observes specified event
     * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
     * @memberOf fabric.Observable
     * @alias on
     * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param {Function} handler Function that receives a notification when an event of the specified type occurs
     * @return {Self} thisArg
     * @chainable
     */
    function observe(eventName, handler) {
      if (!this.__eventListeners) {
        this.__eventListeners = { };
      }
      // one object with key/value pairs was passed
      if (arguments.length === 1) {
        for (var prop in eventName) {
          this.on(prop, eventName[prop]);
        }
      }
      else {
        if (!this.__eventListeners[eventName]) {
          this.__eventListeners[eventName] = [];
        }
        this.__eventListeners[eventName].push(handler);
      }
      return this;
    }

    /**
     * Stops event observing for a particular event handler. Calling this method
     * without arguments removes all handlers for all events
     * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
     * @memberOf fabric.Observable
     * @alias off
     * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param {Function} handler Function to be deleted from EventListeners
     * @return {Self} thisArg
     * @chainable
     */
    function stopObserving(eventName, handler) {
      if (!this.__eventListeners) {
        return;
      }

      // remove all key/value pairs (event name -> event handler)
      if (arguments.length === 0) {
        for (eventName in this.__eventListeners) {
          _removeEventListener.call(this, eventName);
        }
      }
      // one object with key/value pairs was passed
      else if (arguments.length === 1 && typeof arguments[0] === 'object') {
        for (var prop in eventName) {
          _removeEventListener.call(this, prop, eventName[prop]);
        }
      }
      else {
        _removeEventListener.call(this, eventName, handler);
      }
      return this;
    }

    /**
     * Fires event with an optional options object
     * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
     * @memberOf fabric.Observable
     * @alias trigger
     * @param {String} eventName Event name to fire
     * @param {Object} [options] Options object
     * @return {Self} thisArg
     * @chainable
     */
    function fire(eventName, options) {
      if (!this.__eventListeners) {
        return;
      }

      var listenersForEvent = this.__eventListeners[eventName];
      if (!listenersForEvent) {
        return;
      }

      for (var i = 0, len = listenersForEvent.length; i < len; i++) {
        listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
      }
      this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
        return value !== false;
      });
      return this;
    }

    /**
     * @namespace fabric.Observable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
     * @see {@link http://fabricjs.com/events|Events demo}
     */
    fabric.Observable = {
      observe: observe,
      stopObserving: stopObserving,
      fire: fire,

      on: observe,
      off: stopObserving,
      trigger: fire
    };
  })();


  /**
   * @namespace fabric.Collection
   */
  fabric.Collection = {

    _objects: [],

    /**
     * Adds objects to collection, Canvas or Group, then renders canvas
     * (if `renderOnAddRemove` is not `false`).
     * in case of Group no changes to bounding box are made.
     * Objects should be instances of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the add method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    add: function () {
      this._objects.push.apply(this._objects, arguments);
      if (this._onObjectAdded) {
        for (var i = 0, length = arguments.length; i < length; i++) {
          this._onObjectAdded(arguments[i]);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
     * An object should be an instance of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the insertAt method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {Object} object Object to insert
     * @param {Number} index Index to insert object at
     * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
     * @return {Self} thisArg
     * @chainable
     */
    insertAt: function (object, index, nonSplicing) {
      var objects = this.getObjects();
      if (nonSplicing) {
        objects[index] = object;
      }
      else {
        objects.splice(index, 0, object);
      }
      this._onObjectAdded && this._onObjectAdded(object);
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    remove: function() {
      var objects = this.getObjects(),
          index, somethingRemoved = false;

      for (var i = 0, length = arguments.length; i < length; i++) {
        index = objects.indexOf(arguments[i]);

        // only call onObjectRemoved if an object was actually removed
        if (index !== -1) {
          somethingRemoved = true;
          objects.splice(index, 1);
          this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
        }
      }

      this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
      return this;
    },

    /**
     * Executes given function for each object in this group
     * @param {Function} callback
     *                   Callback invoked with current object as first argument,
     *                   index - as second and an array of all objects - as third.
     *                   Callback is invoked in a context of Global Object (e.g. `window`)
     *                   when no `context` argument is given
     *
     * @param {Object} context Context (aka thisObject)
     * @return {Self} thisArg
     * @chainable
     */
    forEachObject: function(callback, context) {
      var objects = this.getObjects();
      for (var i = 0, len = objects.length; i < len; i++) {
        callback.call(context, objects[i], i, objects);
      }
      return this;
    },

    /**
     * Returns an array of children objects of this instance
     * Type parameter introduced in 1.3.10
     * @param {String} [type] When specified, only objects of this type are returned
     * @return {Array}
     */
    getObjects: function(type) {
      if (typeof type === 'undefined') {
        return this._objects;
      }
      return this._objects.filter(function(o) {
        return o.type === type;
      });
    },

    /**
     * Returns object at specified index
     * @param {Number} index
     * @return {Self} thisArg
     */
    item: function (index) {
      return this.getObjects()[index];
    },

    /**
     * Returns true if collection contains no objects
     * @return {Boolean} true if collection is empty
     */
    isEmpty: function () {
      return this.getObjects().length === 0;
    },

    /**
     * Returns a size of a collection (i.e: length of an array containing its objects)
     * @return {Number} Collection size
     */
    size: function() {
      return this.getObjects().length;
    },

    /**
     * Returns true if collection contains an object
     * @param {Object} object Object to check against
     * @return {Boolean} `true` if collection contains an object
     */
    contains: function(object) {
      return this.getObjects().indexOf(object) > -1;
    },

    /**
     * Returns number representation of a collection complexity
     * @return {Number} complexity
     */
    complexity: function () {
      return this.getObjects().reduce(function (memo, current) {
        memo += current.complexity ? current.complexity() : 0;
        return memo;
      }, 0);
    }
  };


  /**
   * @namespace fabric.CommonMethods
   */
  fabric.CommonMethods = {

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    _setOptions: function(options) {
      for (var prop in options) {
        this.set(prop, options[prop]);
      }
    },

    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Gradient to
     */
    _initGradient: function(filler, property) {
      if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
        this.set(property, new fabric.Gradient(filler));
      }
    },

    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Pattern to
     * @param {Function} [callback] callback to invoke after pattern load
     */
    _initPattern: function(filler, property, callback) {
      if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
        this.set(property, new fabric.Pattern(filler, callback));
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initClipping: function(options) {
      if (!options.clipTo || typeof options.clipTo !== 'string') {
        return;
      }

      var functionBody = fabric.util.getFunctionBody(options.clipTo);
      if (typeof functionBody !== 'undefined') {
        this.clipTo = new Function('ctx', functionBody);
      }
    },

    /**
     * @private
     */
    _setObject: function(obj) {
      for (var prop in obj) {
        this._set(prop, obj[prop]);
      }
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      if (typeof key === 'object') {
        this._setObject(key);
      }
      else {
        if (typeof value === 'function' && key !== 'clipTo') {
          this._set(key, value(this.get(key)));
        }
        else {
          this._set(key, value);
        }
      }
      return this;
    },

    _set: function(key, value) {
      this[key] = value;
    },

    /**
     * Toggles specified property from `true` to `false` or from `false` to `true`
     * @param {String} property Property to toggle
     * @return {fabric.Object} thisArg
     * @chainable
     */
    toggle: function(property) {
      var value = this.get(property);
      if (typeof value === 'boolean') {
        this.set(property, !value);
      }
      return this;
    },

    /**
     * Basic getter
     * @param {String} property Property name
     * @return {*} value of a property
     */
    get: function(property) {
      return this[property];
    }
  };


  (function(global) {

    var sqrt = Math.sqrt,
        atan2 = Math.atan2,
        pow = Math.pow,
        abs = Math.abs,
        PiBy180 = Math.PI / 180,
        PiBy2 = Math.PI / 2;

    /**
     * @namespace fabric.util
     */
    fabric.util = {

      /**
       * Calculate the cos of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      cos: function(angle) {
        if (angle === 0) { return 1; }
        if (angle < 0) {
          // cos(a) = cos(-a)
          angle = -angle;
        }
        var angleSlice = angle / PiBy2;
        switch (angleSlice) {
          case 1: case 3: return 0;
          case 2: return -1;
        }
        return Math.cos(angle);
      },

      /**
       * Calculate the sin of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      sin: function(angle) {
        if (angle === 0) { return 0; }
        var angleSlice = angle / PiBy2, sign = 1;
        if (angle < 0) {
          // sin(-a) = -sin(a)
          sign = -1;
        }
        switch (angleSlice) {
          case 1: return sign;
          case 2: return 0;
          case 3: return -sign;
        }
        return Math.sin(angle);
      },

      /**
       * Removes value from an array.
       * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
       * @static
       * @memberOf fabric.util
       * @param {Array} array
       * @param {*} value
       * @return {Array} original array
       */
      removeFromArray: function(array, value) {
        var idx = array.indexOf(value);
        if (idx !== -1) {
          array.splice(idx, 1);
        }
        return array;
      },

      /**
       * Returns random number between 2 specified ones.
       * @static
       * @memberOf fabric.util
       * @param {Number} min lower limit
       * @param {Number} max upper limit
       * @return {Number} random value (between min and max)
       */
      getRandomInt: function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      },

      /**
       * Transforms degrees to radians.
       * @static
       * @memberOf fabric.util
       * @param {Number} degrees value in degrees
       * @return {Number} value in radians
       */
      degreesToRadians: function(degrees) {
        return degrees * PiBy180;
      },

      /**
       * Transforms radians to degrees.
       * @static
       * @memberOf fabric.util
       * @param {Number} radians value in radians
       * @return {Number} value in degrees
       */
      radiansToDegrees: function(radians) {
        return radians / PiBy180;
      },

      /**
       * Rotates `point` around `origin` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {fabric.Point} point The point to rotate
       * @param {fabric.Point} origin The origin of the rotation
       * @param {Number} radians The radians of the angle for the rotation
       * @return {fabric.Point} The new rotated point
       */
      rotatePoint: function(point, origin, radians) {
        point.subtractEquals(origin);
        var v = fabric.util.rotateVector(point, radians);
        return new fabric.Point(v.x, v.y).addEquals(origin);
      },

      /**
       * Rotates `vector` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {Object} vector The vector to rotate (x and y)
       * @param {Number} radians The radians of the angle for the rotation
       * @return {Object} The new rotated point
       */
      rotateVector: function(vector, radians) {
        var sin = fabric.util.sin(radians),
            cos = fabric.util.cos(radians),
            rx = vector.x * cos - vector.y * sin,
            ry = vector.x * sin + vector.y * cos;
        return {
          x: rx,
          y: ry
        };
      },

      /**
       * Apply transform t to point p
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Point} p The point to transform
       * @param  {Array} t The transform
       * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
       * @return {fabric.Point} The transformed point
       */
      transformPoint: function(p, t, ignoreOffset) {
        if (ignoreOffset) {
          return new fabric.Point(
            t[0] * p.x + t[2] * p.y,
            t[1] * p.x + t[3] * p.y
          );
        }
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y + t[4],
          t[1] * p.x + t[3] * p.y + t[5]
        );
      },

      /**
       * Returns coordinates of points's bounding rectangle (left, top, width, height)
       * @param {Array} points 4 points array
       * @return {Object} Object with left, top, width, height properties
       */
      makeBoundingBoxFromPoints: function(points) {
        var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
            minX = fabric.util.array.min(xPoints),
            maxX = fabric.util.array.max(xPoints),
            width = maxX - minX,
            yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
            minY = fabric.util.array.min(yPoints),
            maxY = fabric.util.array.max(yPoints),
            height = maxY - minY;

        return {
          left: minX,
          top: minY,
          width: width,
          height: height
        };
      },

      /**
       * Invert transformation t
       * @static
       * @memberOf fabric.util
       * @param {Array} t The transform
       * @return {Array} The inverted transform
       */
      invertTransform: function(t) {
        var a = 1 / (t[0] * t[3] - t[1] * t[2]),
            r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
            o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
        r[4] = -o.x;
        r[5] = -o.y;
        return r;
      },

      /**
       * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
       * @static
       * @memberOf fabric.util
       * @param {Number|String} number number to operate on
       * @param {Number} fractionDigits number of fraction digits to "leave"
       * @return {Number}
       */
      toFixed: function(number, fractionDigits) {
        return parseFloat(Number(number).toFixed(fractionDigits));
      },

      /**
       * Converts from attribute value to pixel value if applicable.
       * Returns converted pixels or original value not converted.
       * @param {Number|String} value number to operate on
       * @param {Number} fontSize
       * @return {Number|String}
       */
      parseUnit: function(value, fontSize) {
        var unit = /\D{0,2}$/.exec(value),
            number = parseFloat(value);
        if (!fontSize) {
          fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
        }
        switch (unit[0]) {
          case 'mm':
            return number * fabric.DPI / 25.4;

          case 'cm':
            return number * fabric.DPI / 2.54;

          case 'in':
            return number * fabric.DPI;

          case 'pt':
            return number * fabric.DPI / 72; // or * 4 / 3

          case 'pc':
            return number * fabric.DPI / 72 * 12; // or * 16

          case 'em':
            return number * fontSize;

          default:
            return number;
        }
      },

      /**
       * Function which always returns `false`.
       * @static
       * @memberOf fabric.util
       * @return {Boolean}
       */
      falseFunction: function() {
        return false;
      },

      /**
       * Returns klass "Class" object of given namespace
       * @memberOf fabric.util
       * @param {String} type Type of object (eg. 'circle')
       * @param {String} namespace Namespace to get klass "Class" object from
       * @return {Object} klass "Class"
       */
      getKlass: function(type, namespace) {
        // capitalize first letter only
        type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
        return fabric.util.resolveNamespace(namespace)[type];
      },

      /**
       * Returns array of attributes for given svg that fabric parses
       * @memberOf fabric.util
       * @param {String} type Type of svg element (eg. 'circle')
       * @return {Array} string names of supported attributes
       */
      getSvgAttributes: function(type) {
        var attributes = [
          'instantiated_by_use',
          'style',
          'id',
          'class'
        ];
        switch (type) {
          case 'linearGradient':
            attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
            break;
          case 'radialGradient':
            attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
            break;
          case 'stop':
            attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
            break;
        }
        return attributes;
      },

      /**
       * Returns object of given namespace
       * @memberOf fabric.util
       * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
       * @return {Object} Object for given namespace (default fabric)
       */
      resolveNamespace: function(namespace) {
        if (!namespace) {
          return fabric;
        }

        var parts = namespace.split('.'),
            len = parts.length, i,
            obj = global || fabric.window;

        for (i = 0; i < len; ++i) {
          obj = obj[parts[i]];
        }

        return obj;
      },

      /**
       * Loads image element from given url and passes it to a callback
       * @memberOf fabric.util
       * @param {String} url URL representing an image
       * @param {Function} callback Callback; invoked with loaded image
       * @param {*} [context] Context to invoke callback in
       * @param {Object} [crossOrigin] crossOrigin value to set image element to
       */
      loadImage: function(url, callback, context, crossOrigin) {
        if (!url) {
          callback && callback.call(context, url);
          return;
        }

        var img = fabric.util.createImage();

        /** @ignore */
        var onLoadCallback = function () {
          callback && callback.call(context, img);
          img = img.onload = img.onerror = null;
        };

        img.onload = onLoadCallback;
        /** @ignore */
        img.onerror = function() {
          fabric.log('Error loading ' + img.src);
          callback && callback.call(context, null, true);
          img = img.onload = img.onerror = null;
        };

        // data-urls appear to be buggy with crossOrigin
        // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
        // see https://code.google.com/p/chromium/issues/detail?id=315152
        //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
        if (url.indexOf('data') !== 0 && crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        // IE10 / IE11-Fix: SVG contents from data: URI
        // will only be available if the IMG is present
        // in the DOM (and visible)
        if (url.substring(0,14) === 'data:image/svg') {
          img.onload = null;
          fabric.util.loadImageInDom(img, onLoadCallback);
        }

        img.src = url;
      },

      /**
       * Attaches SVG image with data: URL to the dom
       * @memberOf fabric.util
       * @param {Object} img Image object with data:image/svg src
       * @param {Function} callback Callback; invoked with loaded image
       * @return {Object} DOM element (div containing the SVG image)
       */
      loadImageInDom: function(img, onLoadCallback) {
        var div = fabric.document.createElement('div');
        div.style.width = div.style.height = '1px';
        div.style.left = div.style.top = '-100%';
        div.style.position = 'absolute';
        div.appendChild(img);
        fabric.document.querySelector('body').appendChild(div);
        /**
         * Wrap in function to:
         *   1. Call existing callback
         *   2. Cleanup DOM
         */
        img.onload = function () {
          onLoadCallback();
          div.parentNode.removeChild(div);
          div = null;
        };
      },

      /**
       * Creates corresponding fabric instances from their object representations
       * @static
       * @memberOf fabric.util
       * @param {Array} objects Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * @param {String} namespace Namespace to get klass "Class" object from
       * @param {Function} reviver Method for further parsing of object elements,
       * called after each fabric object created.
       */
      enlivenObjects: function(objects, callback, namespace, reviver) {
        objects = objects || [];

        function onLoaded() {
          if (++numLoadedObjects === numTotalObjects) {
            callback && callback(enlivenedObjects);
          }
        }

        var enlivenedObjects = [],
            numLoadedObjects = 0,
            numTotalObjects = objects.length;

        if (!numTotalObjects) {
          callback && callback(enlivenedObjects);
          return;
        }

        objects.forEach(function (o, index) {
          // if sparse array
          if (!o || !o.type) {
            onLoaded();
            return;
          }
          var klass = fabric.util.getKlass(o.type, namespace);
          klass.fromObject(o, function (obj, error) {
            error || (enlivenedObjects[index] = obj);
            reviver && reviver(o, obj, error);
            onLoaded();
          });
        });
      },

      /**
       * Create and wait for loading of patterns
       * @static
       * @memberOf fabric.util
       * @param {Array} patterns Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * called after each fabric object created.
       */
      enlivenPatterns: function(patterns, callback) {
        patterns = patterns || [];

        function onLoaded() {
          if (++numLoadedPatterns === numPatterns) {
            callback && callback(enlivenedPatterns);
          }
        }

        var enlivenedPatterns = [],
            numLoadedPatterns = 0,
            numPatterns = patterns.length;

        if (!numPatterns) {
          callback && callback(enlivenedPatterns);
          return;
        }

        patterns.forEach(function (p, index) {
          if (p && p.source) {
            new fabric.Pattern(p, function(pattern) {
              enlivenedPatterns[index] = pattern;
              onLoaded();
            });
          }
          else {
            enlivenedPatterns[index] = p;
            onLoaded();
          }
        });
      },

      /**
       * Groups SVG elements (usually those retrieved from SVG document)
       * @static
       * @memberOf fabric.util
       * @param {Array} elements SVG elements to group
       * @param {Object} [options] Options object
       * @param {String} path Value to set sourcePath to
       * @return {fabric.Object|fabric.Group}
       */
      groupSVGElements: function(elements, options, path) {
        var object;
        if (elements.length === 1) {
          return elements[0];
        }
        if (options) {
          if (options.width && options.height) {
            options.centerPoint = {
              x: options.width / 2,
              y: options.height / 2
            };
          }
          else {
            delete options.width;
            delete options.height;
          }
        }
        object = new fabric.Group(elements, options);
        if (typeof path !== 'undefined') {
          object.sourcePath = path;
        }
        return object;
      },

      /**
       * Populates an object with properties of another object
       * @static
       * @memberOf fabric.util
       * @param {Object} source Source object
       * @param {Object} destination Destination object
       * @return {Array} properties Properties names to include
       */
      populateWithProperties: function(source, destination, properties) {
        if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
          for (var i = 0, len = properties.length; i < len; i++) {
            if (properties[i] in source) {
              destination[properties[i]] = source[properties[i]];
            }
          }
        }
      },

      /**
       * Draws a dashed line between two points
       *
       * This method is used to draw dashed line around selection area.
       * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
       *
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x  start x coordinate
       * @param {Number} y start y coordinate
       * @param {Number} x2 end x coordinate
       * @param {Number} y2 end y coordinate
       * @param {Array} da dash array pattern
       */
      drawDashedLine: function(ctx, x, y, x2, y2, da) {
        var dx = x2 - x,
            dy = y2 - y,
            len = sqrt(dx * dx + dy * dy),
            rot = atan2(dy, dx),
            dc = da.length,
            di = 0,
            draw = true;

        ctx.save();
        ctx.translate(x, y);
        ctx.moveTo(0, 0);
        ctx.rotate(rot);

        x = 0;
        while (len > x) {
          x += da[di++ % dc];
          if (x > len) {
            x = len;
          }
          ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
          draw = !draw;
        }

        ctx.restore();
      },

      /**
       * Creates canvas element
       * @static
       * @memberOf fabric.util
       * @return {CanvasElement} initialized canvas element
       */
      createCanvasElement: function() {
        return fabric.document.createElement('canvas');
      },

      /**
       * Creates image element (works on client and node)
       * @static
       * @memberOf fabric.util
       * @return {HTMLImageElement} HTML image element
       */
      createImage: function() {
        return fabric.document.createElement('img');
      },

      /**
       * @static
       * @memberOf fabric.util
       * @deprecated since 2.0.0
       * @param {fabric.Object} receiver Object implementing `clipTo` method
       * @param {CanvasRenderingContext2D} ctx Context to clip
       */
      clipContext: function(receiver, ctx) {
        ctx.save();
        ctx.beginPath();
        receiver.clipTo(ctx);
        ctx.clip();
      },

      /**
       * Multiply matrix A by matrix B to nest transformations
       * @static
       * @memberOf fabric.util
       * @param  {Array} a First transformMatrix
       * @param  {Array} b Second transformMatrix
       * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
       * @return {Array} The product of the two transform matrices
       */
      multiplyTransformMatrices: function(a, b, is2x2) {
        // Matrix multiply a * b
        return [
          a[0] * b[0] + a[2] * b[1],
          a[1] * b[0] + a[3] * b[1],
          a[0] * b[2] + a[2] * b[3],
          a[1] * b[2] + a[3] * b[3],
          is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
          is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
        ];
      },

      /**
       * Decomposes standard 2x2 matrix into transform componentes
       * @static
       * @memberOf fabric.util
       * @param  {Array} a transformMatrix
       * @return {Object} Components of transform
       */
      qrDecompose: function(a) {
        var angle = atan2(a[1], a[0]),
            denom = pow(a[0], 2) + pow(a[1], 2),
            scaleX = sqrt(denom),
            scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
            skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
        return {
          angle: angle  / PiBy180,
          scaleX: scaleX,
          scaleY: scaleY,
          skewX: skewX / PiBy180,
          skewY: 0,
          translateX: a[4],
          translateY: a[5]
        };
      },

      customTransformMatrix: function(scaleX, scaleY, skewX) {
        var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],
            scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];
        return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);
      },

      resetObjectTransform: function (target) {
        target.scaleX = 1;
        target.scaleY = 1;
        target.skewX = 0;
        target.skewY = 0;
        target.flipX = false;
        target.flipY = false;
        target.rotate(0);
      },

      /**
       * Returns string representation of function body
       * @param {Function} fn Function to get body of
       * @return {String} Function body
       */
      getFunctionBody: function(fn) {
        return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
      },

      /**
       * Returns true if context has transparent pixel
       * at specified location (taking tolerance into account)
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x x coordinate
       * @param {Number} y y coordinate
       * @param {Number} tolerance Tolerance
       */
      isTransparent: function(ctx, x, y, tolerance) {

        // If tolerance is > 0 adjust start coords to take into account.
        // If moves off Canvas fix to 0
        if (tolerance > 0) {
          if (x > tolerance) {
            x -= tolerance;
          }
          else {
            x = 0;
          }
          if (y > tolerance) {
            y -= tolerance;
          }
          else {
            y = 0;
          }
        }

        var _isTransparent = true, i, temp,
            imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
            l = imageData.data.length;

        // Split image data - for tolerance > 1, pixelDataSize = 4;
        for (i = 3; i < l; i += 4) {
          temp = imageData.data[i];
          _isTransparent = temp <= 0;
          if (_isTransparent === false) {
            break; // Stop if colour found
          }
        }

        imageData = null;

        return _isTransparent;
      },

      /**
       * Parse preserveAspectRatio attribute from element
       * @param {string} attribute to be parsed
       * @return {Object} an object containing align and meetOrSlice attribute
       */
      parsePreserveAspectRatioAttribute: function(attribute) {
        var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
            aspectRatioAttrs = attribute.split(' '), align;

        if (aspectRatioAttrs && aspectRatioAttrs.length) {
          meetOrSlice = aspectRatioAttrs.pop();
          if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
            align = meetOrSlice;
            meetOrSlice = 'meet';
          }
          else if (aspectRatioAttrs.length) {
            align = aspectRatioAttrs.pop();
          }
        }
        //divide align in alignX and alignY
        alignX = align !== 'none' ? align.slice(1, 4) : 'none';
        alignY = align !== 'none' ? align.slice(5, 8) : 'none';
        return {
          meetOrSlice: meetOrSlice,
          alignX: alignX,
          alignY: alignY
        };
      },

      /**
       * Clear char widths cache for the given font family or all the cache if no
       * fontFamily is specified.
       * Use it if you know you are loading fonts in a lazy way and you are not waiting
       * for custom fonts to load properly when adding text objects to the canvas.
       * If a text object is added when its own font is not loaded yet, you will get wrong
       * measurement and so wrong bounding boxes.
       * After the font cache is cleared, either change the textObject text content or call
       * initDimensions() to trigger a recalculation
       * @memberOf fabric.util
       * @param {String} [fontFamily] font family to clear
       */
      clearFabricFontCache: function(fontFamily) {
        fontFamily = (fontFamily || '').toLowerCase();
        if (!fontFamily) {
          fabric.charWidthsCache = { };
        }
        else if (fabric.charWidthsCache[fontFamily]) {
          delete fabric.charWidthsCache[fontFamily];
        }
      },

      /**
       * Given current aspect ratio, determines the max width and height that can
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Number} ar aspect ratio
       * @param {Number} maximumArea Maximum area you want to achieve
       * @return {Object.x} Limited dimensions by X
       * @return {Object.y} Limited dimensions by Y
       */
      limitDimsByArea: function(ar, maximumArea) {
        var roughWidth = Math.sqrt(maximumArea * ar),
            perfLimitSizeY = Math.floor(maximumArea / roughWidth);
        return { x: Math.floor(roughWidth), y: perfLimitSizeY };
      },

      capValue: function(min, value, max) {
        return Math.max(min, Math.min(value, max));
      },

      findScaleToFit: function(source, destination) {
        return Math.min(destination.width / source.width, destination.height / source.height);
      },

      findScaleToCover: function(source, destination) {
        return Math.max(destination.width / source.width, destination.height / source.height);
      }
    };
  })(exports);


  (function() {

    var arcToSegmentsCache = { },
        segmentToBezierCache = { },
        boundsOfCurveCache = { },
        _join = Array.prototype.join;

    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
     * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
     * http://mozilla.org/MPL/2.0/
     */
    function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
      var argsString = _join.call(arguments);
      if (arcToSegmentsCache[argsString]) {
        return arcToSegmentsCache[argsString];
      }

      var PI = Math.PI, th = rotateX * PI / 180,
          sinTh = fabric.util.sin(th),
          cosTh = fabric.util.cos(th),
          fromX = 0, fromY = 0;

      rx = Math.abs(rx);
      ry = Math.abs(ry);

      var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
          py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
          rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
          pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
          root = 0;

      if (pl < 0) {
        var s = Math.sqrt(1 - pl / (rx2 * ry2));
        rx *= s;
        ry *= s;
      }
      else {
        root = (large === sweep ? -1.0 : 1.0) *
                Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
      }

      var cx = root * rx * py / ry,
          cy = -root * ry * px / rx,
          cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
          cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
          mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
          dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

      if (sweep === 0 && dtheta > 0) {
        dtheta -= 2 * PI;
      }
      else if (sweep === 1 && dtheta < 0) {
        dtheta += 2 * PI;
      }

      // Convert into cubic bezier segments <= 90deg
      var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
          result = [], mDelta = dtheta / segments,
          mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
          th3 = mTheta + mDelta;

      for (var i = 0; i < segments; i++) {
        result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
        fromX = result[i][4];
        fromY = result[i][5];
        mTheta = th3;
        th3 += mDelta;
      }
      arcToSegmentsCache[argsString] = result;
      return result;
    }

    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
      var argsString2 = _join.call(arguments);
      if (segmentToBezierCache[argsString2]) {
        return segmentToBezierCache[argsString2];
      }

      var costh2 = fabric.util.cos(th2),
          sinth2 = fabric.util.sin(th2),
          costh3 = fabric.util.cos(th3),
          sinth3 = fabric.util.sin(th3),
          toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
          toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
          cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
          cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
          cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
          cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

      segmentToBezierCache[argsString2] = [
        cp1X, cp1Y,
        cp2X, cp2Y,
        toX, toY
      ];
      return segmentToBezierCache[argsString2];
    }

    /*
     * Private
     */
    function calcVectorAngle(ux, uy, vx, vy) {
      var ta = Math.atan2(uy, ux),
          tb = Math.atan2(vy, vx);
      if (tb >= ta) {
        return tb - ta;
      }
      else {
        return 2 * Math.PI - (ta - tb);
      }
    }

    /**
     * Draws arc
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} fx
     * @param {Number} fy
     * @param {Array} coords
     */
    fabric.util.drawArc = function(ctx, fx, fy, coords) {
      var rx = coords[0],
          ry = coords[1],
          rot = coords[2],
          large = coords[3],
          sweep = coords[4],
          tx = coords[5],
          ty = coords[6],
          segs = [[], [], [], []],
          segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

      for (var i = 0, len = segsNorm.length; i < len; i++) {
        segs[i][0] = segsNorm[i][0] + fx;
        segs[i][1] = segsNorm[i][1] + fy;
        segs[i][2] = segsNorm[i][2] + fx;
        segs[i][3] = segsNorm[i][3] + fy;
        segs[i][4] = segsNorm[i][4] + fx;
        segs[i][5] = segsNorm[i][5] + fy;
        ctx.bezierCurveTo.apply(ctx, segs[i]);
      }
    };

    /**
     * Calculate bounding box of a elliptic-arc
     * @param {Number} fx start point of arc
     * @param {Number} fy
     * @param {Number} rx horizontal radius
     * @param {Number} ry vertical radius
     * @param {Number} rot angle of horizontal axe
     * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
     * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
     * @param {Number} tx end point of arc
     * @param {Number} ty
     */
    fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

      var fromX = 0, fromY = 0, bound, bounds = [],
          segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

      for (var i = 0, len = segs.length; i < len; i++) {
        bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
        bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
        bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
        fromX = segs[i][4];
        fromY = segs[i][5];
      }
      return bounds;
    };

    /**
     * Calculate bounding box of a beziercurve
     * @param {Number} x0 starting point
     * @param {Number} y0
     * @param {Number} x1 first control point
     * @param {Number} y1
     * @param {Number} x2 secondo control point
     * @param {Number} y2
     * @param {Number} x3 end of beizer
     * @param {Number} y3
     */
    // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
      var argsString = _join.call(arguments);
      if (boundsOfCurveCache[argsString]) {
        return boundsOfCurveCache[argsString];
      }

      var sqrt = Math.sqrt,
          min = Math.min, max = Math.max,
          abs = Math.abs, tvalues = [],
          bounds = [[], []],
          a, b, c, t, t1, t2, b2ac, sqrtb2ac;

      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;

      for (var i = 0; i < 2; ++i) {
        if (i > 0) {
          b = 6 * y0 - 12 * y1 + 6 * y2;
          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
          c = 3 * y1 - 3 * y0;
        }

        if (abs(a) < 1e-12) {
          if (abs(b) < 1e-12) {
            continue;
          }
          t = -c / b;
          if (0 < t && t < 1) {
            tvalues.push(t);
          }
          continue;
        }
        b2ac = b * b - 4 * c * a;
        if (b2ac < 0) {
          continue;
        }
        sqrtb2ac = sqrt(b2ac);
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) {
          tvalues.push(t1);
        }
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) {
          tvalues.push(t2);
        }
      }

      var x, y, j = tvalues.length, jlen = j, mt;
      while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
        bounds[0][j] = x;

        y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
        bounds[1][j] = y;
      }

      bounds[0][jlen] = x0;
      bounds[1][jlen] = y0;
      bounds[0][jlen + 1] = x3;
      bounds[1][jlen + 1] = y3;
      var result = [
        {
          x: min.apply(null, bounds[0]),
          y: min.apply(null, bounds[1])
        },
        {
          x: max.apply(null, bounds[0]),
          y: max.apply(null, bounds[1])
        }
      ];
      boundsOfCurveCache[argsString] = result;
      return result;
    }

    fabric.util.getBoundsOfCurve = getBoundsOfCurve;

  })();


  (function() {

    var slice = Array.prototype.slice;

    /**
     * Invokes method on all items in a given array
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} method Name of a method to invoke
     * @return {Array}
     */
    function invoke(array, method) {
      var args = slice.call(arguments, 2), result = [];
      for (var i = 0, len = array.length; i < len; i++) {
        result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
      }
      return result;
    }

    /**
     * Finds maximum value in array (not necessarily "first" one)
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} byProperty
     * @return {*}
     */
    function max(array, byProperty) {
      return find(array, byProperty, function(value1, value2) {
        return value1 >= value2;
      });
    }

    /**
     * Finds minimum value in array (not necessarily "first" one)
     * @memberOf fabric.util.array
     * @param {Array} array Array to iterate over
     * @param {String} byProperty
     * @return {*}
     */
    function min(array, byProperty) {
      return find(array, byProperty, function(value1, value2) {
        return value1 < value2;
      });
    }

    /**
     * @private
     */
    function fill(array, value) {
      var k = array.length;
      while (k--) {
        array[k] = value;
      }
      return array;
    }

    /**
     * @private
     */
    function find(array, byProperty, condition) {
      if (!array || array.length === 0) {
        return;
      }

      var i = array.length - 1,
          result = byProperty ? array[i][byProperty] : array[i];
      if (byProperty) {
        while (i--) {
          if (condition(array[i][byProperty], result)) {
            result = array[i][byProperty];
          }
        }
      }
      else {
        while (i--) {
          if (condition(array[i], result)) {
            result = array[i];
          }
        }
      }
      return result;
    }

    /**
     * @namespace fabric.util.array
     */
    fabric.util.array = {
      fill: fill,
      invoke: invoke,
      min: min,
      max: max
    };

  })();


  (function() {
    /**
     * Copies all enumerable properties of one js object to another
     * Does not clone or extend fabric.Object subclasses.
     * @memberOf fabric.util.object
     * @param {Object} destination Where to copy to
     * @param {Object} source Where to copy from
     * @return {Object}
     */

    function extend(destination, source, deep) {
      // JScript DontEnum bug is not taken care of
      // the deep clone is for internal use, is not meant to avoid
      // javascript traps or cloning html element or self referenced objects.
      if (deep) {
        if (!fabric.isLikelyNode && source instanceof Element) {
          // avoid cloning deep images, canvases,
          destination = source;
        }
        else if (source instanceof Array) {
          destination = [];
          for (var i = 0, len = source.length; i < len; i++) {
            destination[i] = extend({ }, source[i], deep);
          }
        }
        else if (source && typeof source === 'object') {
          for (var property in source) {
            if (source.hasOwnProperty(property)) {
              destination[property] = extend({ }, source[property], deep);
            }
          }
        }
        else {
          // this sounds odd for an extend but is ok for recursive use
          destination = source;
        }
      }
      else {
        for (var property in source) {
          destination[property] = source[property];
        }
      }
      return destination;
    }

    /**
     * Creates an empty object and copies all enumerable properties of another object to it
     * @memberOf fabric.util.object
     * TODO: this function return an empty object if you try to clone null
     * @param {Object} object Object to clone
     * @return {Object}
     */
    function clone(object, deep) {
      return extend({ }, object, deep);
    }

    /** @namespace fabric.util.object */
    fabric.util.object = {
      extend: extend,
      clone: clone
    };
    fabric.util.object.extend(fabric.util, fabric.Observable);
  })();


  (function() {

    /**
     * Camelizes a string
     * @memberOf fabric.util.string
     * @param {String} string String to camelize
     * @return {String} Camelized version of a string
     */
    function camelize(string) {
      return string.replace(/-+(.)?/g, function(match, character) {
        return character ? character.toUpperCase() : '';
      });
    }

    /**
     * Capitalizes a string
     * @memberOf fabric.util.string
     * @param {String} string String to capitalize
     * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
     * and other letters stay untouched, if false first letter is capitalized
     * and other letters are converted to lowercase.
     * @return {String} Capitalized version of a string
     */
    function capitalize(string, firstLetterOnly) {
      return string.charAt(0).toUpperCase() +
        (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
    }

    /**
     * Escapes XML in a string
     * @memberOf fabric.util.string
     * @param {String} string String to escape
     * @return {String} Escaped version of a string
     */
    function escapeXml(string) {
      return string.replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    /**
     * Divide a string in the user perceived single units
     * @memberOf fabric.util.string
     * @param {String} textstring String to escape
     * @return {Array} array containing the graphemes
     */
    function graphemeSplit(textstring) {
      var i = 0, chr, graphemes = [];
      for (i = 0, chr; i < textstring.length; i++) {
        if ((chr = getWholeChar(textstring, i)) === false) {
          continue;
        }
        graphemes.push(chr);
      }
      return graphemes;
    }

    // taken from mdn in the charAt doc page.
    function getWholeChar(str, i) {
      var code = str.charCodeAt(i);

      if (isNaN(code)) {
        return ''; // Position not found
      }
      if (code < 0xD800 || code > 0xDFFF) {
        return str.charAt(i);
      }

      // High surrogate (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 <= code && code <= 0xDBFF) {
        if (str.length <= (i + 1)) {
          throw 'High surrogate without following low surrogate';
        }
        var next = str.charCodeAt(i + 1);
        if (0xDC00 > next || next > 0xDFFF) {
          throw 'High surrogate without following low surrogate';
        }
        return str.charAt(i) + str.charAt(i + 1);
      }
      // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
      if (i === 0) {
        throw 'Low surrogate without preceding high surrogate';
      }
      var prev = str.charCodeAt(i - 1);

      // (could change last hex to 0xDB7F to treat high private
      // surrogates as single characters)
      if (0xD800 > prev || prev > 0xDBFF) {
        throw 'Low surrogate without preceding high surrogate';
      }
      // We can pass over low surrogates now as the second component
      // in a pair which we have already processed
      return false;
    }


    /**
     * String utilities
     * @namespace fabric.util.string
     */
    fabric.util.string = {
      camelize: camelize,
      capitalize: capitalize,
      escapeXml: escapeXml,
      graphemeSplit: graphemeSplit
    };
  })();


  (function() {

    var slice = Array.prototype.slice, emptyFunction = function() { },

        IS_DONTENUM_BUGGY = (function() {
          return true;
        })(),

        /** @ignore */
        addMethods = function(klass, source, parent) {
          for (var property in source) {

            if (property in klass.prototype &&
                typeof klass.prototype[property] === 'function' &&
                (source[property] + '').indexOf('callSuper') > -1) {

              klass.prototype[property] = (function(property) {
                return function() {

                  var superclass = this.constructor.superclass;
                  this.constructor.superclass = parent;
                  var returnValue = source[property].apply(this, arguments);
                  this.constructor.superclass = superclass;

                  if (property !== 'initialize') {
                    return returnValue;
                  }
                };
              })(property);
            }
            else {
              klass.prototype[property] = source[property];
            }

            if (IS_DONTENUM_BUGGY) {
              if (source.toString !== Object.prototype.toString) {
                klass.prototype.toString = source.toString;
              }
              if (source.valueOf !== Object.prototype.valueOf) {
                klass.prototype.valueOf = source.valueOf;
              }
            }
          }
        };

    function Subclass() { }

    function callSuper(methodName) {
      var parentMethod = null,
          _this = this;

      // climb prototype chain to find method not equal to callee's method
      while (_this.constructor.superclass) {
        var superClassMethod = _this.constructor.superclass.prototype[methodName];
        if (_this[methodName] !== superClassMethod) {
          parentMethod = superClassMethod;
          break;
        }
        // eslint-disable-next-line
        _this = _this.constructor.superclass.prototype;
      }

      if (!parentMethod) {
        return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
      }

      return (arguments.length > 1)
        ? parentMethod.apply(this, slice.call(arguments, 1))
        : parentMethod.call(this);
    }

    /**
     * Helper for creation of "classes".
     * @memberOf fabric.util
     * @param {Function} [parent] optional "Class" to inherit from
     * @param {Object} [properties] Properties shared by all instances of this class
     *                  (be careful modifying objects defined here as this would affect all instances)
     */
    function createClass() {
      var parent = null,
          properties = slice.call(arguments, 0);

      if (typeof properties[0] === 'function') {
        parent = properties.shift();
      }
      function klass() {
        this.initialize.apply(this, arguments);
      }

      klass.superclass = parent;
      klass.subclasses = [];

      if (parent) {
        Subclass.prototype = parent.prototype;
        klass.prototype = new Subclass();
        parent.subclasses.push(klass);
      }
      for (var i = 0, length = properties.length; i < length; i++) {
        addMethods(klass, properties[i], parent);
      }
      if (!klass.prototype.initialize) {
        klass.prototype.initialize = emptyFunction;
      }
      klass.prototype.constructor = klass;
      klass.prototype.callSuper = callSuper;
      return klass;
    }

    fabric.util.createClass = createClass;
  })();


  (function () {

    var unknown = 'unknown';

    /* EVENT HANDLING */

    function areHostMethods(object) {
      var methodNames = Array.prototype.slice.call(arguments, 1),
          t, i, len = methodNames.length;
      for (i = 0; i < len; i++) {
        t = typeof object[methodNames[i]];
        if (!(/^(?:function|object|unknown)$/).test(t)) {
          return false;
        }
      }
      return true;
    }

    /** @ignore */
    var getElement,
        setElement,
        getUniqueId = (function () {
          var uid = 0;
          return function (element) {
            return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
          };
        })();

    (function () {
      var elements = { };
      /** @ignore */
      getElement = function (uid) {
        return elements[uid];
      };
      /** @ignore */
      setElement = function (uid, element) {
        elements[uid] = element;
      };
    })();

    function createListener(uid, handler) {
      return {
        handler: handler,
        wrappedHandler: createWrappedHandler(uid, handler)
      };
    }

    function createWrappedHandler(uid, handler) {
      return function (e) {
        handler.call(getElement(uid), e || fabric.window.event);
      };
    }

    function createDispatcher(uid, eventName) {
      return function (e) {
        if (handlers[uid] && handlers[uid][eventName]) {
          var handlersForEvent = handlers[uid][eventName];
          for (var i = 0, len = handlersForEvent.length; i < len; i++) {
            handlersForEvent[i].call(this, e || fabric.window.event);
          }
        }
      };
    }

    var shouldUseAddListenerRemoveListener = (
          areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
          areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),

        shouldUseAttachEventDetachEvent = (
          areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
          areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),

        // IE branch
        listeners = { },

        // DOM L0 branch
        handlers = { },

        addListener, removeListener;

    if (shouldUseAddListenerRemoveListener) {
      /** @ignore */
      addListener = function (element, eventName, handler, options) {
        // since ie10 or ie9 can use addEventListener but they do not support options, i need to check
        element && element.addEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
      };
      /** @ignore */
      removeListener = function (element, eventName, handler, options) {
        element && element.removeEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
      };
    }

    else if (shouldUseAttachEventDetachEvent) {
      /** @ignore */
      addListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element);
        setElement(uid, element);
        if (!listeners[uid]) {
          listeners[uid] = { };
        }
        if (!listeners[uid][eventName]) {
          listeners[uid][eventName] = [];

        }
        var listener = createListener(uid, handler);
        listeners[uid][eventName].push(listener);
        element.attachEvent('on' + eventName, listener.wrappedHandler);
      };
      /** @ignore */
      removeListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element), listener;
        if (listeners[uid] && listeners[uid][eventName]) {
          for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
            listener = listeners[uid][eventName][i];
            if (listener && listener.handler === handler) {
              element.detachEvent('on' + eventName, listener.wrappedHandler);
              listeners[uid][eventName][i] = null;
            }
          }
        }
      };
    }
    else {
      /** @ignore */
      addListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element);
        if (!handlers[uid]) {
          handlers[uid] = { };
        }
        if (!handlers[uid][eventName]) {
          handlers[uid][eventName] = [];
          var existingHandler = element['on' + eventName];
          if (existingHandler) {
            handlers[uid][eventName].push(existingHandler);
          }
          element['on' + eventName] = createDispatcher(uid, eventName);
        }
        handlers[uid][eventName].push(handler);
      };
      /** @ignore */
      removeListener = function (element, eventName, handler) {
        if (!element) {
          return;
        }
        var uid = getUniqueId(element);
        if (handlers[uid] && handlers[uid][eventName]) {
          var handlersForEvent = handlers[uid][eventName];
          for (var i = 0, len = handlersForEvent.length; i < len; i++) {
            if (handlersForEvent[i] === handler) {
              handlersForEvent.splice(i, 1);
            }
          }
        }
      };
    }

    /**
     * Adds an event listener to an element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {String} eventName
     * @param {Function} handler
     */
    fabric.util.addListener = addListener;

    /**
     * Removes an event listener from an element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {String} eventName
     * @param {Function} handler
     */
    fabric.util.removeListener = removeListener;

    /**
     * Cross-browser wrapper for getting event's coordinates
     * @memberOf fabric.util
     * @param {Event} event Event object
     */
    function getPointer(event) {
      event || (event = fabric.window.event);

      var element = event.target ||
                    (typeof event.srcElement !== unknown ? event.srcElement : null),

          scroll = fabric.util.getScrollLeftTop(element);
      return {
        x: pointerX(event) + scroll.left,
        y: pointerY(event) + scroll.top
      };
    }

    var pointerX = function(event) {
          return event.clientX;
        },

        pointerY = function(event) {
          return event.clientY;
        };

    function _getPointer(event, pageProp, clientProp) {
      var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
      var pointer, eventTouchProp = event[touchProp];

      if (eventTouchProp && eventTouchProp[0]) {
        pointer = eventTouchProp[0][clientProp];
      }

      if (typeof pointer === 'undefined') {
        pointer = event[clientProp];
      }

      return pointer;
    }

    if (fabric.isTouchSupported) {
      pointerX = function(event) {
        return _getPointer(event, 'pageX', 'clientX');
      };
      pointerY = function(event) {
        return _getPointer(event, 'pageY', 'clientY');
      };
    }

    fabric.util.getPointer = getPointer;

  })();


  (function () {

    /**
     * Cross-browser wrapper for setting element's style
     * @memberOf fabric.util
     * @param {HTMLElement} element
     * @param {Object} styles
     * @return {HTMLElement} Element that was passed as a first argument
     */
    function setStyle(element, styles) {
      var elementStyle = element.style;
      if (!elementStyle) {
        return element;
      }
      if (typeof styles === 'string') {
        element.style.cssText += ';' + styles;
        return styles.indexOf('opacity') > -1
          ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
          : element;
      }
      for (var property in styles) {
        if (property === 'opacity') {
          setOpacity(element, styles[property]);
        }
        else {
          var normalizedProperty = (property === 'float' || property === 'cssFloat')
            ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
            : property;
          elementStyle[normalizedProperty] = styles[property];
        }
      }
      return element;
    }

    var parseEl = fabric.document.createElement('div'),
        supportsOpacity = typeof parseEl.style.opacity === 'string',
        supportsFilters = typeof parseEl.style.filter === 'string',
        reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

        /** @ignore */
        setOpacity = function (element) { return element; };

    if (supportsOpacity) {
      /** @ignore */
      setOpacity = function(element, value) {
        element.style.opacity = value;
        return element;
      };
    }
    else if (supportsFilters) {
      /** @ignore */
      setOpacity = function(element, value) {
        var es = element.style;
        if (element.currentStyle && !element.currentStyle.hasLayout) {
          es.zoom = 1;
        }
        if (reOpacity.test(es.filter)) {
          value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
          es.filter = es.filter.replace(reOpacity, value);
        }
        else {
          es.filter += ' alpha(opacity=' + (value * 100) + ')';
        }
        return element;
      };
    }

    fabric.util.setStyle = setStyle;

  })();


  (function() {

    var _slice = Array.prototype.slice;

    /**
     * Takes id and returns an element with that id (if one exists in a document)
     * @memberOf fabric.util
     * @param {String|HTMLElement} id
     * @return {HTMLElement|null}
     */
    function getById(id) {
      return typeof id === 'string' ? fabric.document.getElementById(id) : id;
    }

    var sliceCanConvertNodelists,
        /**
         * Converts an array-like object (e.g. arguments or NodeList) to an array
         * @memberOf fabric.util
         * @param {Object} arrayLike
         * @return {Array}
         */
        toArray = function(arrayLike) {
          return _slice.call(arrayLike, 0);
        };

    try {
      sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
    }
    catch (err) { }

    if (!sliceCanConvertNodelists) {
      toArray = function(arrayLike) {
        var arr = new Array(arrayLike.length), i = arrayLike.length;
        while (i--) {
          arr[i] = arrayLike[i];
        }
        return arr;
      };
    }

    /**
     * Creates specified element with specified attributes
     * @memberOf fabric.util
     * @param {String} tagName Type of an element to create
     * @param {Object} [attributes] Attributes to set on an element
     * @return {HTMLElement} Newly created element
     */
    function makeElement(tagName, attributes) {
      var el = fabric.document.createElement(tagName);
      for (var prop in attributes) {
        if (prop === 'class') {
          el.className = attributes[prop];
        }
        else if (prop === 'for') {
          el.htmlFor = attributes[prop];
        }
        else {
          el.setAttribute(prop, attributes[prop]);
        }
      }
      return el;
    }

    /**
     * Adds class to an element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to add class to
     * @param {String} className Class to add to an element
     */
    function addClass(element, className) {
      if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
        element.className += (element.className ? ' ' : '') + className;
      }
    }

    /**
     * Wraps element with another element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to wrap
     * @param {HTMLElement|String} wrapper Element to wrap with
     * @param {Object} [attributes] Attributes to set on a wrapper
     * @return {HTMLElement} wrapper
     */
    function wrapElement(element, wrapper, attributes) {
      if (typeof wrapper === 'string') {
        wrapper = makeElement(wrapper, attributes);
      }
      if (element.parentNode) {
        element.parentNode.replaceChild(wrapper, element);
      }
      wrapper.appendChild(element);
      return wrapper;
    }

    /**
     * Returns element scroll offsets
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to operate on
     * @return {Object} Object with left/top values
     */
    function getScrollLeftTop(element) {

      var left = 0,
          top = 0,
          docElement = fabric.document.documentElement,
          body = fabric.document.body || {
            scrollLeft: 0, scrollTop: 0
          };

      // While loop checks (and then sets element to) .parentNode OR .host
      //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
      //  but the .parentNode of a root ShadowDOM node will always be null, instead
      //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
      while (element && (element.parentNode || element.host)) {

        // Set element to element parent, or 'host' in case of ShadowDOM
        element = element.parentNode || element.host;

        if (element === fabric.document) {
          left = body.scrollLeft || docElement.scrollLeft || 0;
          top = body.scrollTop ||  docElement.scrollTop || 0;
        }
        else {
          left += element.scrollLeft || 0;
          top += element.scrollTop || 0;
        }

        if (element.nodeType === 1 && element.style.position === 'fixed') {
          break;
        }
      }

      return { left: left, top: top };
    }

    /**
     * Returns offset for a given element
     * @function
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to get offset for
     * @return {Object} Object with "left" and "top" properties
     */
    function getElementOffset(element) {
      var docElem,
          doc = element && element.ownerDocument,
          box = { left: 0, top: 0 },
          offset = { left: 0, top: 0 },
          scrollLeftTop,
          offsetAttributes = {
            borderLeftWidth: 'left',
            borderTopWidth:  'top',
            paddingLeft:     'left',
            paddingTop:      'top'
          };

      if (!doc) {
        return offset;
      }

      for (var attr in offsetAttributes) {
        offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
      }

      docElem = doc.documentElement;
      if ( typeof element.getBoundingClientRect !== 'undefined' ) {
        box = element.getBoundingClientRect();
      }

      scrollLeftTop = getScrollLeftTop(element);

      return {
        left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
        top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
      };
    }

    /**
     * Returns style attribute value of a given element
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to get style attribute for
     * @param {String} attr Style attribute to get for element
     * @return {String} Style attribute value of the given element.
     */
    var getElementStyle;
    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
      getElementStyle = function(element, attr) {
        var style = fabric.document.defaultView.getComputedStyle(element, null);
        return style ? style[attr] : undefined;
      };
    }
    else {
      getElementStyle = function(element, attr) {
        var value = element.style[attr];
        if (!value && element.currentStyle) {
          value = element.currentStyle[attr];
        }
        return value;
      };
    }

    (function () {
      var style = fabric.document.documentElement.style,
          selectProp = 'userSelect' in style
            ? 'userSelect'
            : 'MozUserSelect' in style
              ? 'MozUserSelect'
              : 'WebkitUserSelect' in style
                ? 'WebkitUserSelect'
                : 'KhtmlUserSelect' in style
                  ? 'KhtmlUserSelect'
                  : '';

      /**
       * Makes element unselectable
       * @memberOf fabric.util
       * @param {HTMLElement} element Element to make unselectable
       * @return {HTMLElement} Element that was passed in
       */
      function makeElementUnselectable(element) {
        if (typeof element.onselectstart !== 'undefined') {
          element.onselectstart = fabric.util.falseFunction;
        }
        if (selectProp) {
          element.style[selectProp] = 'none';
        }
        else if (typeof element.unselectable === 'string') {
          element.unselectable = 'on';
        }
        return element;
      }

      /**
       * Makes element selectable
       * @memberOf fabric.util
       * @param {HTMLElement} element Element to make selectable
       * @return {HTMLElement} Element that was passed in
       */
      function makeElementSelectable(element) {
        if (typeof element.onselectstart !== 'undefined') {
          element.onselectstart = null;
        }
        if (selectProp) {
          element.style[selectProp] = '';
        }
        else if (typeof element.unselectable === 'string') {
          element.unselectable = '';
        }
        return element;
      }

      fabric.util.makeElementUnselectable = makeElementUnselectable;
      fabric.util.makeElementSelectable = makeElementSelectable;
    })();

    (function() {

      /**
       * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
       * @memberOf fabric.util
       * @param {String} url URL of a script to load
       * @param {Function} callback Callback to execute when script is finished loading
       */
      function getScript(url, callback) {
        var headEl = fabric.document.getElementsByTagName('head')[0],
            scriptEl = fabric.document.createElement('script'),
            loading = true;

        /** @ignore */
        scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
          if (loading) {
            if (typeof this.readyState === 'string' &&
                this.readyState !== 'loaded' &&
                this.readyState !== 'complete') {
              return;
            }
            loading = false;
            callback(e || fabric.window.event);
            scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
          }
        };
        scriptEl.src = url;
        headEl.appendChild(scriptEl);
        // causes issue in Opera
        // headEl.removeChild(scriptEl);
      }

      fabric.util.getScript = getScript;
    })();

    function getNodeCanvas(element) {
      var impl = fabric.jsdomImplForWrapper(element);
      return impl._canvas || impl._image;
    }
    fabric.util.getById = getById;
    fabric.util.toArray = toArray;
    fabric.util.makeElement = makeElement;
    fabric.util.addClass = addClass;
    fabric.util.wrapElement = wrapElement;
    fabric.util.getScrollLeftTop = getScrollLeftTop;
    fabric.util.getElementOffset = getElementOffset;
    fabric.util.getElementStyle = getElementStyle;
    fabric.util.getNodeCanvas = getNodeCanvas;

  })();


  (function() {

    function addParamToUrl(url, param) {
      return url + (/\?/.test(url) ? '&' : '?') + param;
    }

    var makeXHR = (function() {
      var factories = [
        function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
        function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
        function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },
        function() { return new XMLHttpRequest(); }
      ];
      for (var i = factories.length; i--; ) {
        try {
          var req = factories[i]();
          if (req) {
            return factories[i];
          }
        }
        catch (err) { }
      }
    })();

    function emptyFn() { }

    /**
     * Cross-browser abstraction for sending XMLHttpRequest
     * @memberOf fabric.util
     * @param {String} url URL to send XMLHttpRequest to
     * @param {Object} [options] Options object
     * @param {String} [options.method="GET"]
     * @param {String} [options.parameters] parameters to append to url in GET or in body
     * @param {String} [options.body] body to send with POST or PUT request
     * @param {Function} options.onComplete Callback to invoke when request is completed
     * @return {XMLHttpRequest} request
     */
    function request(url, options) {

      options || (options = { });

      var method = options.method ? options.method.toUpperCase() : 'GET',
          onComplete = options.onComplete || function() { },
          xhr = makeXHR(),
          body = options.body || options.parameters;

      /** @ignore */
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          onComplete(xhr);
          xhr.onreadystatechange = emptyFn;
        }
      };

      if (method === 'GET') {
        body = null;
        if (typeof options.parameters === 'string') {
          url = addParamToUrl(url, options.parameters);
        }
      }

      xhr.open(method, url, true);

      if (method === 'POST' || method === 'PUT') {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      }

      xhr.send(body);
      return xhr;
    }

    fabric.util.request = request;
  })();


  /**
   * Wrapper around `console.log` (when available)
   * @param {*} [values] Values to log
   */
  fabric.log = function() { };

  /**
   * Wrapper around `console.warn` (when available)
   * @param {*} [values] Values to log as a warning
   */
  fabric.warn = function() { };

  /* eslint-disable */
  if (typeof console !== 'undefined') {

    ['log', 'warn'].forEach(function(methodName) {

      if (typeof console[methodName] !== 'undefined' &&
          typeof console[methodName].apply === 'function') {

        fabric[methodName] = function() {
          return console[methodName].apply(console, arguments);
        };
      }
    });
  }
  /* eslint-enable */


  (function() {

    function noop() {
      return false;
    }

    /**
     * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
     * @memberOf fabric.util
     * @param {Object} [options] Animation options
     * @param {Function} [options.onChange] Callback; invoked on every value change
     * @param {Function} [options.onComplete] Callback; invoked when value change is completed
     * @param {Number} [options.startValue=0] Starting value
     * @param {Number} [options.endValue=100] Ending value
     * @param {Number} [options.byValue=100] Value to modify the property by
     * @param {Function} [options.easing] Easing function
     * @param {Number} [options.duration=500] Duration of change (in ms)
     */
    function animate(options) {

      requestAnimFrame(function(timestamp) {
        options || (options = { });

        var start = timestamp || +new Date(),
            duration = options.duration || 500,
            finish = start + duration, time,
            onChange = options.onChange || noop,
            abort = options.abort || noop,
            onComplete = options.onComplete || noop,
            easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
            startValue = 'startValue' in options ? options.startValue : 0,
            endValue = 'endValue' in options ? options.endValue : 100,
            byValue = options.byValue || endValue - startValue;

        options.onStart && options.onStart();

        (function tick(ticktime) {
          if (abort()) {
            onComplete(endValue, 1, 1);
            return;
          }
          time = ticktime || +new Date();
          var currentTime = time > finish ? duration : (time - start),
              timePerc = currentTime / duration,
              current = easing(currentTime, startValue, byValue, duration),
              valuePerc = Math.abs((current - startValue) / byValue);
          onChange(current, valuePerc, timePerc);
          if (time > finish) {
            options.onComplete && options.onComplete();
            return;
          }
          requestAnimFrame(tick);
        })(start);
      });

    }

    var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                            fabric.window.webkitRequestAnimationFrame ||
                            fabric.window.mozRequestAnimationFrame    ||
                            fabric.window.oRequestAnimationFrame      ||
                            fabric.window.msRequestAnimationFrame     ||
                            function(callback) {
                              return fabric.window.setTimeout(callback, 1000 / 60);
                            };

    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

    /**
     * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
     * @memberOf fabric.util
     * @param {Function} callback Callback to invoke
     * @param {DOMElement} element optional Element to associate with animation
     */
    function requestAnimFrame() {
      return _requestAnimFrame.apply(fabric.window, arguments);
    }

    function cancelAnimFrame() {
      return _cancelAnimFrame.apply(fabric.window, arguments);
    }

    fabric.util.animate = animate;
    fabric.util.requestAnimFrame = requestAnimFrame;
    fabric.util.cancelAnimFrame = cancelAnimFrame;
  })();


  (function() {
    // Calculate an in-between color. Returns a "rgba()" string.
    // Credit: Edwin Martin <edwin@bitstorm.org>
    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
    function calculateColor(begin, end, pos) {
      var color = 'rgba('
          + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
          + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
          + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

      color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
      color += ')';
      return color;
    }

    /**
     * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
     * @memberOf fabric.util
     * @param {String} fromColor The starting color in hex or rgb(a) format.
     * @param {String} toColor The starting color in hex or rgb(a) format.
     * @param {Number} [duration] Duration of change (in ms).
     * @param {Object} [options] Animation options
     * @param {Function} [options.onChange] Callback; invoked on every value change
     * @param {Function} [options.onComplete] Callback; invoked when value change is completed
     * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
     */
    function animateColor(fromColor, toColor, duration, options) {
      var startColor = new fabric.Color(fromColor).getSource(),
          endColor = new fabric.Color(toColor).getSource();

      options = options || {};

      fabric.util.animate(fabric.util.object.extend(options, {
        duration: duration || 500,
        startValue: startColor,
        endValue: endColor,
        byValue: endColor,
        easing: function (currentTime, startValue, byValue, duration) {
          var posValue = options.colorEasing
            ? options.colorEasing(currentTime, duration)
            : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
          return calculateColor(startValue, byValue, posValue);
        }
      }));
    }

    fabric.util.animateColor = animateColor;

  })();


  (function() {

    function normalize(a, c, p, s) {
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        //handle the 0/0 case:
        if (c === 0 && a === 0) {
          s = p / (2 * Math.PI) * Math.asin(1);
        }
        else {
          s = p / (2 * Math.PI) * Math.asin(c / a);
        }
      }
      return { a: a, c: c, p: p, s: s };
    }

    function elastic(opts, t, d) {
      return opts.a *
        Math.pow(2, 10 * (t -= 1)) *
        Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
    }

    /**
     * Cubic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutCubic(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    }

    /**
     * Cubic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutCubic(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t + 2) + b;
    }

    /**
     * Quartic easing in
     * @memberOf fabric.util.ease
     */
    function easeInQuart(t, b, c, d) {
      return c * (t /= d) * t * t * t + b;
    }

    /**
     * Quartic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutQuart(t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    }

    /**
     * Quartic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutQuart(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t * t + b;
      }
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    }

    /**
     * Quintic easing in
     * @memberOf fabric.util.ease
     */
    function easeInQuint(t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    }

    /**
     * Quintic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutQuint(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }

    /**
     * Quintic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutQuint(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    }

    /**
     * Sinusoidal easing in
     * @memberOf fabric.util.ease
     */
    function easeInSine(t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    }

    /**
     * Sinusoidal easing out
     * @memberOf fabric.util.ease
     */
    function easeOutSine(t, b, c, d) {
      return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }

    /**
     * Sinusoidal easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutSine(t, b, c, d) {
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    }

    /**
     * Exponential easing in
     * @memberOf fabric.util.ease
     */
    function easeInExpo(t, b, c, d) {
      return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    }

    /**
     * Exponential easing out
     * @memberOf fabric.util.ease
     */
    function easeOutExpo(t, b, c, d) {
      return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }

    /**
     * Exponential easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutExpo(t, b, c, d) {
      if (t === 0) {
        return b;
      }
      if (t === d) {
        return b + c;
      }
      t /= d / 2;
      if (t < 1) {
        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
      }
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    }

    /**
     * Circular easing in
     * @memberOf fabric.util.ease
     */
    function easeInCirc(t, b, c, d) {
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    }

    /**
     * Circular easing out
     * @memberOf fabric.util.ease
     */
    function easeOutCirc(t, b, c, d) {
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    }

    /**
     * Circular easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutCirc(t, b, c, d) {
      t /= d / 2;
      if (t < 1) {
        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
      }
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }

    /**
     * Elastic easing in
     * @memberOf fabric.util.ease
     */
    function easeInElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d;
      if (t === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      var opts = normalize(a, c, p, s);
      return -elastic(opts, t, d) + b;
    }

    /**
     * Elastic easing out
     * @memberOf fabric.util.ease
     */
    function easeOutElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d;
      if (t === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      var opts = normalize(a, c, p, s);
      return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
    }

    /**
     * Elastic easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutElastic(t, b, c, d) {
      var s = 1.70158, p = 0, a = c;
      if (t === 0) {
        return b;
      }
      t /= d / 2;
      if (t === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      var opts = normalize(a, c, p, s);
      if (t < 1) {
        return -0.5 * elastic(opts, t, d) + b;
      }
      return opts.a * Math.pow(2, -10 * (t -= 1)) *
        Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
    }

    /**
     * Backwards easing in
     * @memberOf fabric.util.ease
     */
    function easeInBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    }

    /**
     * Backwards easing out
     * @memberOf fabric.util.ease
     */
    function easeOutBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    }

    /**
     * Backwards easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutBack(t, b, c, d, s) {
      if (s === undefined) {
        s = 1.70158;
      }
      t /= d / 2;
      if (t < 1) {
        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    }

    /**
     * Bouncing easing in
     * @memberOf fabric.util.ease
     */
    function easeInBounce(t, b, c, d) {
      return c - easeOutBounce (d - t, 0, c, d) + b;
    }

    /**
     * Bouncing easing out
     * @memberOf fabric.util.ease
     */
    function easeOutBounce(t, b, c, d) {
      if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
      }
      else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
      }
      else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
      }
      else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
      }
    }

    /**
     * Bouncing easing in and out
     * @memberOf fabric.util.ease
     */
    function easeInOutBounce(t, b, c, d) {
      if (t < d / 2) {
        return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
      }
      return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }

    /**
     * Easing functions
     * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
     * @namespace fabric.util.ease
     */
    fabric.util.ease = {

      /**
       * Quadratic easing in
       * @memberOf fabric.util.ease
       */
      easeInQuad: function(t, b, c, d) {
        return c * (t /= d) * t + b;
      },

      /**
       * Quadratic easing out
       * @memberOf fabric.util.ease
       */
      easeOutQuad: function(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },

      /**
       * Quadratic easing in and out
       * @memberOf fabric.util.ease
       */
      easeInOutQuad: function(t, b, c, d) {
        t /= (d / 2);
        if (t < 1) {
          return c / 2 * t * t + b;
        }
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
      },

      /**
       * Cubic easing in
       * @memberOf fabric.util.ease
       */
      easeInCubic: function(t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },

      easeOutCubic: easeOutCubic,
      easeInOutCubic: easeInOutCubic,
      easeInQuart: easeInQuart,
      easeOutQuart: easeOutQuart,
      easeInOutQuart: easeInOutQuart,
      easeInQuint: easeInQuint,
      easeOutQuint: easeOutQuint,
      easeInOutQuint: easeInOutQuint,
      easeInSine: easeInSine,
      easeOutSine: easeOutSine,
      easeInOutSine: easeInOutSine,
      easeInExpo: easeInExpo,
      easeOutExpo: easeOutExpo,
      easeInOutExpo: easeInOutExpo,
      easeInCirc: easeInCirc,
      easeOutCirc: easeOutCirc,
      easeInOutCirc: easeInOutCirc,
      easeInElastic: easeInElastic,
      easeOutElastic: easeOutElastic,
      easeInOutElastic: easeInOutElastic,
      easeInBack: easeInBack,
      easeOutBack: easeOutBack,
      easeInOutBack: easeInOutBack,
      easeInBounce: easeInBounce,
      easeOutBounce: easeOutBounce,
      easeInOutBounce: easeInOutBounce
    };

  })();


  (function(global) {

    /**
     * @name fabric
     * @namespace
     */

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        toFixed = fabric.util.toFixed,
        parseUnit = fabric.util.parseUnit,
        multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

        svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
          'image', 'text', 'linearGradient', 'radialGradient', 'stop'],
        svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
        svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
        svgValidParents = ['symbol', 'g', 'a', 'svg'],

        attributesMap = {
          cx:                   'left',
          x:                    'left',
          r:                    'radius',
          cy:                   'top',
          y:                    'top',
          display:              'visible',
          visibility:           'visible',
          transform:            'transformMatrix',
          'fill-opacity':       'fillOpacity',
          'fill-rule':          'fillRule',
          'font-family':        'fontFamily',
          'font-size':          'fontSize',
          'font-style':         'fontStyle',
          'font-weight':        'fontWeight',
          'letter-spacing':     'charSpacing',
          'paint-order':        'paintFirst',
          'stroke-dasharray':   'strokeDashArray',
          'stroke-linecap':     'strokeLineCap',
          'stroke-linejoin':    'strokeLineJoin',
          'stroke-miterlimit':  'strokeMiterLimit',
          'stroke-opacity':     'strokeOpacity',
          'stroke-width':       'strokeWidth',
          'text-decoration':    'textDecoration',
          'text-anchor':        'textAnchor',
          opacity:              'opacity'
        },

        colorAttributes = {
          stroke: 'strokeOpacity',
          fill:   'fillOpacity'
        };

    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

    fabric.cssRules = { };
    fabric.gradientDefs = { };

    function normalizeAttr(attr) {
      // transform attribute names
      if (attr in attributesMap) {
        return attributesMap[attr];
      }
      return attr;
    }

    function normalizeValue(attr, value, parentAttributes, fontSize) {
      var isArray = Object.prototype.toString.call(value) === '[object Array]',
          parsed;

      if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
        value = '';
      }
      else if (attr === 'strokeDashArray') {
        if (value === 'none') {
          value = null;
        }
        else {
          value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
            return parseFloat(n);
          });
        }
      }
      else if (attr === 'transformMatrix') {
        if (parentAttributes && parentAttributes.transformMatrix) {
          value = multiplyTransformMatrices(
            parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
        }
        else {
          value = fabric.parseTransformAttribute(value);
        }
      }
      else if (attr === 'visible') {
        value = value !== 'none' && value !== 'hidden';
        // display=none on parent element always takes precedence over child element
        if (parentAttributes && parentAttributes.visible === false) {
          value = false;
        }
      }
      else if (attr === 'opacity') {
        value = parseFloat(value);
        if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
          value *= parentAttributes.opacity;
        }
      }
      else if (attr === 'textAnchor' /* text-anchor */) {
        value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
      }
      else if (attr === 'charSpacing') {
        // parseUnit returns px and we convert it to em
        parsed = parseUnit(value, fontSize) / fontSize * 1000;
      }
      else if (attr === 'paintFirst') {
        var fillIndex = value.indexOf('fill');
        var strokeIndex = value.indexOf('stroke');
        var value = 'fill';
        if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
          value = 'stroke';
        }
        else if (fillIndex === -1 && strokeIndex > -1) {
          value = 'stroke';
        }
      }
      else {
        parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
      }

      return (!isArray && isNaN(parsed) ? value : parsed);
    }

    /**
      * @private
      */
    function getSvgRegex(arr) {
      return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
    }

    /**
     * @private
     * @param {Object} attributes Array of attributes to parse
     */
    function _setStrokeFillOpacity(attributes) {
      for (var attr in colorAttributes) {

        if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
          continue;
        }

        if (typeof attributes[attr] === 'undefined') {
          if (!fabric.Object.prototype[attr]) {
            continue;
          }
          attributes[attr] = fabric.Object.prototype[attr];
        }

        if (attributes[attr].indexOf('url(') === 0) {
          continue;
        }

        var color = new fabric.Color(attributes[attr]);
        attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
      }
      return attributes;
    }

    /**
     * @private
     */
    function _getMultipleNodes(doc, nodeNames) {
      var nodeName, nodeArray = [], nodeList, i, len;
      for (i = 0, len = nodeNames.length; i < len; i++) {
        nodeName = nodeNames[i];
        nodeList = doc.getElementsByTagName(nodeName);
        nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
      }
      return nodeArray;
    }

    /**
     * Parses "transform" attribute, returning an array of values
     * @static
     * @function
     * @memberOf fabric
     * @param {String} attributeValue String containing attribute value
     * @return {Array} Array of 6 elements representing transformation matrix
     */
    fabric.parseTransformAttribute = (function() {
      function rotateMatrix(matrix, args) {
        var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
            x = 0, y = 0;
        if (args.length === 3) {
          x = args[1];
          y = args[2];
        }

        matrix[0] = cos;
        matrix[1] = sin;
        matrix[2] = -sin;
        matrix[3] = cos;
        matrix[4] = x - (cos * x - sin * y);
        matrix[5] = y - (sin * x + cos * y);
      }

      function scaleMatrix(matrix, args) {
        var multiplierX = args[0],
            multiplierY = (args.length === 2) ? args[1] : args[0];

        matrix[0] = multiplierX;
        matrix[3] = multiplierY;
      }

      function skewMatrix(matrix, args, pos) {
        matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
      }

      function translateMatrix(matrix, args) {
        matrix[4] = args[0];
        if (args.length === 2) {
          matrix[5] = args[1];
        }
      }

      // identity matrix
      var iMatrix = [
            1, // a
            0, // b
            0, // c
            1, // d
            0, // e
            0  // f
          ],

          // == begin transform regexp
          number = fabric.reNum,

          commaWsp = '(?:\\s+,?\\s*|,\\s*)',

          skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

          skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

          rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + ')' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                      commaWsp + '(' + number + '))?\\s*\\))',

          matrix = '(?:(matrix)\\s*\\(\\s*' +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' + commaWsp +
                    '(' + number + ')' +
                    '\\s*\\))',

          transform = '(?:' +
                      matrix + '|' +
                      translate + '|' +
                      scale + '|' +
                      rotate + '|' +
                      skewX + '|' +
                      skewY +
                      ')',

          transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

          transformList = '^\\s*(?:' + transforms + '?)\\s*$',

          // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
          reTransformList = new RegExp(transformList),
          // == end transform regexp

          reTransform = new RegExp(transform, 'g');

      return function(attributeValue) {

        // start with identity matrix
        var matrix = iMatrix.concat(),
            matrices = [];

        // return if no argument was given or
        // an argument does not match transform attribute regexp
        if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
          return matrix;
        }

        attributeValue.replace(reTransform, function(match) {

          var m = new RegExp(transform).exec(match).filter(function (match) {
                // match !== '' && match != null
                return (!!match);
              }),
              operation = m[1],
              args = m.slice(2).map(parseFloat);

          switch (operation) {
            case 'translate':
              translateMatrix(matrix, args);
              break;
            case 'rotate':
              args[0] = fabric.util.degreesToRadians(args[0]);
              rotateMatrix(matrix, args);
              break;
            case 'scale':
              scaleMatrix(matrix, args);
              break;
            case 'skewX':
              skewMatrix(matrix, args, 2);
              break;
            case 'skewY':
              skewMatrix(matrix, args, 1);
              break;
            case 'matrix':
              matrix = args;
              break;
          }

          // snapshot current matrix into matrices array
          matrices.push(matrix.concat());
          // reset
          matrix = iMatrix.concat();
        });

        var combinedMatrix = matrices[0];
        while (matrices.length > 1) {
          matrices.shift();
          combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
        }
        return combinedMatrix;
      };
    })();

    /**
     * @private
     */
    function parseStyleString(style, oStyle) {
      var attr, value;
      style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
        var pair = chunk.split(':');

        attr = pair[0].trim().toLowerCase();
        value =  pair[1].trim();

        oStyle[attr] = value;
      });
    }

    /**
     * @private
     */
    function parseStyleObject(style, oStyle) {
      var attr, value;
      for (var prop in style) {
        if (typeof style[prop] === 'undefined') {
          continue;
        }

        attr = prop.toLowerCase();
        value = style[prop];

        oStyle[attr] = value;
      }
    }

    /**
     * @private
     */
    function getGlobalStylesForElement(element, svgUid) {
      var styles = { };
      for (var rule in fabric.cssRules[svgUid]) {
        if (elementMatchesRule(element, rule.split(' '))) {
          for (var property in fabric.cssRules[svgUid][rule]) {
            styles[property] = fabric.cssRules[svgUid][rule][property];
          }
        }
      }
      return styles;
    }

    /**
     * @private
     */
    function elementMatchesRule(element, selectors) {
      var firstMatching, parentMatching = true;
      //start from rightmost selector.
      firstMatching = selectorMatches(element, selectors.pop());
      if (firstMatching && selectors.length) {
        parentMatching = doesSomeParentMatch(element, selectors);
      }
      return firstMatching && parentMatching && (selectors.length === 0);
    }

    function doesSomeParentMatch(element, selectors) {
      var selector, parentMatching = true;
      while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
        if (parentMatching) {
          selector = selectors.pop();
        }
        element = element.parentNode;
        parentMatching = selectorMatches(element, selector);
      }
      return selectors.length === 0;
    }

    /**
     * @private
     */
    function selectorMatches(element, selector) {
      var nodeName = element.nodeName,
          classNames = element.getAttribute('class'),
          id = element.getAttribute('id'), matcher, i;
      // i check if a selector matches slicing away part from it.
      // if i get empty string i should match
      matcher = new RegExp('^' + nodeName, 'i');
      selector = selector.replace(matcher, '');
      if (id && selector.length) {
        matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
      if (classNames && selector.length) {
        classNames = classNames.split(' ');
        for (i = classNames.length; i--;) {
          matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
          selector = selector.replace(matcher, '');
        }
      }
      return selector.length === 0;
    }

    /**
     * @private
     * to support IE8 missing getElementById on SVGdocument
     */
    function elementById(doc, id) {
      var el;
      doc.getElementById && (el = doc.getElementById(id));
      if (el) {
        return el;
      }
      var node, i, len, nodelist = doc.getElementsByTagName('*');
      for (i = 0, len = nodelist.length; i < len; i++) {
        node = nodelist[i];
        if (id === node.getAttribute('id')) {
          return node;
        }
      }
    }

    /**
     * @private
     */
    function parseUseDirectives(doc) {
      var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;

      while (nodelist.length && i < nodelist.length) {
        var el = nodelist[i],
            xlink = el.getAttribute('xlink:href').substr(1),
            x = el.getAttribute('x') || 0,
            y = el.getAttribute('y') || 0,
            el2 = elementById(doc, xlink).cloneNode(true),
            currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
            parentNode, oldLength = nodelist.length, attr, j, attrs, len;

        applyViewboxTransform(el2);
        if (/^svg$/i.test(el2.nodeName)) {
          var el3 = el2.ownerDocument.createElement('g');
          for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
            attr = attrs.item(j);
            el3.setAttribute(attr.nodeName, attr.nodeValue);
          }
          // el2.firstChild != null
          while (el2.firstChild) {
            el3.appendChild(el2.firstChild);
          }
          el2 = el3;
        }

        for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
            continue;
          }

          if (attr.nodeName === 'transform') {
            currentTrans = attr.nodeValue + ' ' + currentTrans;
          }
          else {
            el2.setAttribute(attr.nodeName, attr.nodeValue);
          }
        }

        el2.setAttribute('transform', currentTrans);
        el2.setAttribute('instantiated_by_use', '1');
        el2.removeAttribute('id');
        parentNode = el.parentNode;
        parentNode.replaceChild(el2, el);
        // some browsers do not shorten nodelist after replaceChild (IE8)
        if (nodelist.length === oldLength) {
          i++;
        }
      }
    }

    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
    // matches, e.g.: +14.56e-12, etc.
    var reViewBoxAttrValue = new RegExp(
      '^' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*,?' +
      '\\s*(' + fabric.reNum + '+)\\s*' +
      '$'
    );

    /**
     * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
     */
    function applyViewboxTransform(element) {

      var viewBoxAttr = element.getAttribute('viewBox'),
          scaleX = 1,
          scaleY = 1,
          minX = 0,
          minY = 0,
          viewBoxWidth, viewBoxHeight, matrix, el,
          widthAttr = element.getAttribute('width'),
          heightAttr = element.getAttribute('height'),
          x = element.getAttribute('x') || 0,
          y = element.getAttribute('y') || 0,
          preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
          missingViewBox = (!viewBoxAttr || !fabric.svgViewBoxElementsRegEx.test(element.nodeName)
                             || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
          missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
          toBeParsed = missingViewBox && missingDimAttr,
          parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

      parsedDim.width = 0;
      parsedDim.height = 0;
      parsedDim.toBeParsed = toBeParsed;

      if (toBeParsed) {
        return parsedDim;
      }

      if (missingViewBox) {
        parsedDim.width = parseUnit(widthAttr);
        parsedDim.height = parseUnit(heightAttr);
        return parsedDim;
      }

      minX = -parseFloat(viewBoxAttr[1]);
      minY = -parseFloat(viewBoxAttr[2]);
      viewBoxWidth = parseFloat(viewBoxAttr[3]);
      viewBoxHeight = parseFloat(viewBoxAttr[4]);

      if (!missingDimAttr) {
        parsedDim.width = parseUnit(widthAttr);
        parsedDim.height = parseUnit(heightAttr);
        scaleX = parsedDim.width / viewBoxWidth;
        scaleY = parsedDim.height / viewBoxHeight;
      }
      else {
        parsedDim.width = viewBoxWidth;
        parsedDim.height = viewBoxHeight;
      }

      // default is to preserve aspect ratio
      preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
      if (preserveAspectRatio.alignX !== 'none') {
        //translate all container for the effect of Mid, Min, Max
        if (preserveAspectRatio.meetOrSlice === 'meet') {
          scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
          // calculate additional translation to move the viewbox
        }
        if (preserveAspectRatio.meetOrSlice === 'slice') {
          scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
          // calculate additional translation to move the viewbox
        }
        widthDiff = parsedDim.width - viewBoxWidth * scaleX;
        heightDiff = parsedDim.height - viewBoxHeight * scaleX;
        if (preserveAspectRatio.alignX === 'Mid') {
          widthDiff /= 2;
        }
        if (preserveAspectRatio.alignY === 'Mid') {
          heightDiff /= 2;
        }
        if (preserveAspectRatio.alignX === 'Min') {
          widthDiff = 0;
        }
        if (preserveAspectRatio.alignY === 'Min') {
          heightDiff = 0;
        }
      }

      if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
        return parsedDim;
      }

      if (x || y) {
        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
      }

      matrix = translateMatrix + ' matrix(' + scaleX +
                    ' 0' +
                    ' 0 ' +
                    scaleY + ' ' +
                    (minX * scaleX + widthDiff) + ' ' +
                    (minY * scaleY + heightDiff) + ') ';

      if (element.nodeName === 'svg') {
        el = element.ownerDocument.createElement('g');
        // element.firstChild != null
        while (element.firstChild) {
          el.appendChild(element.firstChild);
        }
        element.appendChild(el);
      }
      else {
        el = element;
        matrix = el.getAttribute('transform') + matrix;
      }

      el.setAttribute('transform', matrix);
      return parsedDim;
    }

    function hasAncestorWithNodeName(element, nodeName) {
      while (element && (element = element.parentNode)) {
        if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
          && !element.getAttribute('instantiated_by_use')) {
          return true;
        }
      }
      return false;
    }

    /**
     * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @param {Function} callback Callback to call when parsing is finished;
     * It's being passed an array of elements (parsed from a document).
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [parsingOptions] options for parsing document
     * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
     */
    fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
      if (!doc) {
        return;
      }

      parseUseDirectives(doc);

      var svgUid =  fabric.Object.__uid++, i, len,
          options = applyViewboxTransform(doc),
          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
      options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
      options.svgUid = svgUid;

      if (descendants.length === 0 && fabric.isLikelyNode) {
        // we're likely in node, where "o3-xml" library fails to gEBTN("*")
        // https://github.com/ajaxorg/node-o3-xml/issues/21
        descendants = doc.selectNodes('//*[name(.)!="svg"]');
        var arr = [];
        for (i = 0, len = descendants.length; i < len; i++) {
          arr[i] = descendants[i];
        }
        descendants = arr;
      }

      var elements = descendants.filter(function(el) {
        applyViewboxTransform(el);
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
              !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
      });

      if (!elements || (elements && !elements.length)) {
        callback && callback([], {});
        return;
      }

      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
      // Precedence of rules:   style > class > attribute
      fabric.parseElements(elements, function(instances, elements) {
        if (callback) {
          callback(instances, options, elements, descendants);
        }
      }, clone(options), reviver, parsingOptions);
    };

    var reFontDeclaration = new RegExp(
      '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
      '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
        fabric.reNum +
      '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

    extend(fabric, {
      /**
       * Parses a short font declaration, building adding its properties to a style object
       * @static
       * @function
       * @memberOf fabric
       * @param {String} value font declaration
       * @param {Object} oStyle definition
       */
      parseFontDeclaration: function(value, oStyle) {
        var match = value.match(reFontDeclaration);

        if (!match) {
          return;
        }
        var fontStyle = match[1],
            // font variant is not used
            // fontVariant = match[2],
            fontWeight = match[3],
            fontSize = match[4],
            lineHeight = match[5],
            fontFamily = match[6];

        if (fontStyle) {
          oStyle.fontStyle = fontStyle;
        }
        if (fontWeight) {
          oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
        }
        if (fontSize) {
          oStyle.fontSize = parseUnit(fontSize);
        }
        if (fontFamily) {
          oStyle.fontFamily = fontFamily;
        }
        if (lineHeight) {
          oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
        }
      },

      /**
       * Parses an SVG document, returning all of the gradient declarations found in it
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
       */
      getGradientDefs: function(doc) {
        var tagArray = [
              'linearGradient',
              'radialGradient',
              'svg:linearGradient',
              'svg:radialGradient'],
            elList = _getMultipleNodes(doc, tagArray),
            el, j = 0, id, xlink,
            gradientDefs = { }, idsToXlinkMap = { };
        j = elList.length;

        while (j--) {
          el = elList[j];
          xlink = el.getAttribute('xlink:href');
          id = el.getAttribute('id');
          if (xlink) {
            idsToXlinkMap[id] = xlink.substr(1);
          }
          gradientDefs[id] = el;
        }

        for (id in idsToXlinkMap) {
          var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
          el = gradientDefs[id];
          while (el2.firstChild) {
            el.appendChild(el2.firstChild);
          }
        }
        return gradientDefs;
      },

      /**
       * Returns an object of attributes' name/value, given element and an array of attribute names;
       * Parses parent "g" nodes recursively upwards.
       * @static
       * @memberOf fabric
       * @param {DOMElement} element Element to parse
       * @param {Array} attributes Array of attributes to parse
       * @return {Object} object containing parsed attributes' names/values
       */
      parseAttributes: function(element, attributes, svgUid) {

        if (!element) {
          return;
        }

        var value,
            parentAttributes = { },
            fontSize;

        if (typeof svgUid === 'undefined') {
          svgUid = element.getAttribute('svgUid');
        }
        // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
        if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
          parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
        }
        fontSize = (parentAttributes && parentAttributes.fontSize ) ||
                   element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;

        var ownAttributes = attributes.reduce(function(memo, attr) {
          value = element.getAttribute(attr);
          if (value) { // eslint-disable-line
            memo[attr] = value;
          }
          return memo;
        }, { });
        // add values parsed from style, which take precedence over attributes
        // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
        ownAttributes = extend(ownAttributes,
          extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));

        var normalizedAttr, normalizedValue, normalizedStyle = {};
        for (var attr in ownAttributes) {
          normalizedAttr = normalizeAttr(attr);
          normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
          normalizedStyle[normalizedAttr] = normalizedValue;
        }
        if (normalizedStyle && normalizedStyle.font) {
          fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
        }
        var mergedAttrs = extend(parentAttributes, normalizedStyle);
        return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
      },

      /**
       * Transforms an array of svg elements to corresponding fabric.* instances
       * @static
       * @memberOf fabric
       * @param {Array} elements Array of elements to parse
       * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
       * @param {Object} [options] Options object
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       */
      parseElements: function(elements, callback, options, reviver, parsingOptions) {
        new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
      },

      /**
       * Parses "style" attribute, retuning an object with values
       * @static
       * @memberOf fabric
       * @param {SVGElement} element Element to parse
       * @return {Object} Objects with values parsed from style attribute of an element
       */
      parseStyleAttribute: function(element) {
        var oStyle = { },
            style = element.getAttribute('style');

        if (!style) {
          return oStyle;
        }

        if (typeof style === 'string') {
          parseStyleString(style, oStyle);
        }
        else {
          parseStyleObject(style, oStyle);
        }

        return oStyle;
      },

      /**
       * Parses "points" attribute, returning an array of values
       * @static
       * @memberOf fabric
       * @param {String} points points attribute string
       * @return {Array} array of points
       */
      parsePointsAttribute: function(points) {

        // points attribute is required and must not be empty
        if (!points) {
          return null;
        }

        // replace commas with whitespace and remove bookending whitespace
        points = points.replace(/,/g, ' ').trim();

        points = points.split(/\s+/);
        var parsedPoints = [], i, len;

        for (i = 0, len = points.length; i < len; i += 2) {
          parsedPoints.push({
            x: parseFloat(points[i]),
            y: parseFloat(points[i + 1])
          });
        }

        // odd number of points is an error
        // if (parsedPoints.length % 2 !== 0) {
        //   return null;
        // }

        return parsedPoints;
      },

      /**
       * Returns CSS rules for a given SVG document
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} CSS rules of this document
       */
      getCSSRules: function(doc) {
        var styles = doc.getElementsByTagName('style'), i, len,
            allRules = { }, rules;

        // very crude parsing of style contents
        for (i = 0, len = styles.length; i < len; i++) {
          // IE9 doesn't support textContent, but provides text instead.
          var styleContents = styles[i].textContent || styles[i].text;

          // remove comments
          styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
          if (styleContents.trim() === '') {
            continue;
          }
          rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
          rules = rules.map(function(rule) { return rule.trim(); });
          // eslint-disable-next-line no-loop-func
          rules.forEach(function(rule) {

            var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
                ruleObj = { }, declaration = match[2].trim(),
                propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

            for (i = 0, len = propertyValuePairs.length; i < len; i++) {
              var pair = propertyValuePairs[i].split(/\s*:\s*/),
                  property = pair[0],
                  value = pair[1];
              ruleObj[property] = value;
            }
            rule = match[1];
            rule.split(',').forEach(function(_rule) {
              _rule = _rule.replace(/^svg/i, '').trim();
              if (_rule === '') {
                return;
              }
              if (allRules[_rule]) {
                fabric.util.object.extend(allRules[_rule], ruleObj);
              }
              else {
                allRules[_rule] = fabric.util.object.clone(ruleObj);
              }
            });
          });
        }
        return allRules;
      },

      /**
       * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
       * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
       * @memberOf fabric
       * @param {String} url
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromURL: function(url, callback, reviver, options) {

        url = url.replace(/^\n\s*/, '').trim();
        new fabric.util.request(url, {
          method: 'get',
          onComplete: onComplete
        });

        function onComplete(r) {

          var xml = r.responseXML;
          if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
            xml = new ActiveXObject('Microsoft.XMLDOM');
            xml.async = 'false';
            //IE chokes on DOCTYPE
            xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
          }
          if (!xml || !xml.documentElement) {
            callback && callback(null);
          }

          fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
            callback && callback(results, _options, elements, allElements);
          }, reviver, options);
        }
      },

      /**
       * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
       * @memberOf fabric
       * @param {String} string
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromString: function(string, callback, reviver, options) {
        string = string.trim();
        var doc;
        if (typeof DOMParser !== 'undefined') {
          var parser = new DOMParser();
          if (parser && parser.parseFromString) {
            doc = parser.parseFromString(string, 'text/xml');
          }
        }
        else if (fabric.window.ActiveXObject) {
          doc = new ActiveXObject('Microsoft.XMLDOM');
          doc.async = 'false';
          // IE chokes on DOCTYPE
          doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
        }

        fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
          callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    });

  })(exports);


  fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions) {
    this.elements = elements;
    this.callback = callback;
    this.options = options;
    this.reviver = reviver;
    this.svgUid = (options && options.svgUid) || 0;
    this.parsingOptions = parsingOptions;
    this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
  };

  fabric.ElementsParser.prototype.parse = function() {
    this.instances = new Array(this.elements.length);
    this.numElements = this.elements.length;

    this.createObjects();
  };

  fabric.ElementsParser.prototype.createObjects = function() {
    for (var i = 0, len = this.elements.length; i < len; i++) {
      this.elements[i].setAttribute('svgUid', this.svgUid);
      (function(_obj, i) {
        setTimeout(function() {
          _obj.createObject(_obj.elements[i], i);
        }, 0);
      })(this, i);
    }
  };

  fabric.ElementsParser.prototype.createObject = function(el, index) {
    var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
    if (klass && klass.fromElement) {
      try {
        this._createObject(klass, el, index);
      }
      catch (err) {
        fabric.log(err);
      }
    }
    else {
      this.checkIfDone();
    }
  };

  fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
    klass.fromElement(el, this.createCallback(index, el), this.options);
  };

  fabric.ElementsParser.prototype.createCallback = function(index, el) {
    var _this = this;
    return function(obj) {
      var _options;
      _this.resolveGradient(obj, 'fill');
      _this.resolveGradient(obj, 'stroke');
      if (obj instanceof fabric.Image) {
        _options = obj.parsePreserveAspectRatioAttribute(el);
      }
      obj._removeTransformMatrix(_options);
      _this.reviver && _this.reviver(el, obj);
      _this.instances[index] = obj;
      _this.checkIfDone();
    };
  };

  fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {

    var instanceFillValue = obj[property];
    if (!(/^url\(/).test(instanceFillValue)) {
      return;
    }
    var gradientId = this.regexUrl.exec(instanceFillValue)[1];
    this.regexUrl.lastIndex = 0;
    if (fabric.gradientDefs[this.svgUid][gradientId]) {
      obj.set(property,
        fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));
    }
  };

  fabric.ElementsParser.prototype.checkIfDone = function() {
    if (--this.numElements === 0) {
      this.instances = this.instances.filter(function(el) {
        // eslint-disable-next-line no-eq-null, eqeqeq
        return el != null;
      });
      this.callback(this.instances, this.elements);
    }
  };


  (function(global) {

    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Point) {
      fabric.warn('fabric.Point is already defined');
      return;
    }

    fabric.Point = Point;

    /**
     * Point class
     * @class fabric.Point
     * @memberOf fabric
     * @constructor
     * @param {Number} x
     * @param {Number} y
     * @return {fabric.Point} thisArg
     */
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype = /** @lends fabric.Point.prototype */ {

      type: 'point',

      constructor: Point,

      /**
       * Adds another point to this one and returns another one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point instance with added values
       */
      add: function (that) {
        return new Point(this.x + that.x, this.y + that.y);
      },

      /**
       * Adds another point to this one
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      addEquals: function (that) {
        this.x += that.x;
        this.y += that.y;
        return this;
      },

      /**
       * Adds value to this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point} new Point with added value
       */
      scalarAdd: function (scalar) {
        return new Point(this.x + scalar, this.y + scalar);
      },

      /**
       * Adds value to this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarAddEquals: function (scalar) {
        this.x += scalar;
        this.y += scalar;
        return this;
      },

      /**
       * Subtracts another point from this point and returns a new one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point object with subtracted values
       */
      subtract: function (that) {
        return new Point(this.x - that.x, this.y - that.y);
      },

      /**
       * Subtracts another point from this point
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      subtractEquals: function (that) {
        this.x -= that.x;
        this.y -= that.y;
        return this;
      },

      /**
       * Subtracts value from this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      scalarSubtract: function (scalar) {
        return new Point(this.x - scalar, this.y - scalar);
      },

      /**
       * Subtracts value from this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarSubtractEquals: function (scalar) {
        this.x -= scalar;
        this.y -= scalar;
        return this;
      },

      /**
       * Multiplies this point by a value and returns a new one
       * TODO: rename in scalarMultiply in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      multiply: function (scalar) {
        return new Point(this.x * scalar, this.y * scalar);
      },

      /**
       * Multiplies this point by a value
       * TODO: rename in scalarMultiplyEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      multiplyEquals: function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      },

      /**
       * Divides this point by a value and returns a new one
       * TODO: rename in scalarDivide in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      divide: function (scalar) {
        return new Point(this.x / scalar, this.y / scalar);
      },

      /**
       * Divides this point by a value
       * TODO: rename in scalarDivideEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      divideEquals: function (scalar) {
        this.x /= scalar;
        this.y /= scalar;
        return this;
      },

      /**
       * Returns true if this point is equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      eq: function (that) {
        return (this.x === that.x && this.y === that.y);
      },

      /**
       * Returns true if this point is less than another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lt: function (that) {
        return (this.x < that.x && this.y < that.y);
      },

      /**
       * Returns true if this point is less than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lte: function (that) {
        return (this.x <= that.x && this.y <= that.y);
      },

      /**

       * Returns true if this point is greater another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gt: function (that) {
        return (this.x > that.x && this.y > that.y);
      },

      /**
       * Returns true if this point is greater than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gte: function (that) {
        return (this.x >= that.x && this.y >= that.y);
      },

      /**
       * Returns new point which is the result of linear interpolation with this one and another one
       * @param {fabric.Point} that
       * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
       * @return {fabric.Point}
       */
      lerp: function (that, t) {
        if (typeof t === 'undefined') {
          t = 0.5;
        }
        t = Math.max(Math.min(1, t), 0);
        return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
      },

      /**
       * Returns distance from this point and another one
       * @param {fabric.Point} that
       * @return {Number}
       */
      distanceFrom: function (that) {
        var dx = this.x - that.x,
            dy = this.y - that.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      /**
       * Returns the point between this point and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      midPointFrom: function (that) {
        return this.lerp(that);
      },

      /**
       * Returns a new point which is the min of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      min: function (that) {
        return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
      },

      /**
       * Returns a new point which is the max of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      max: function (that) {
        return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
      },

      /**
       * Returns string representation of this point
       * @return {String}
       */
      toString: function () {
        return this.x + ',' + this.y;
      },

      /**
       * Sets x/y of this point
       * @param {Number} x
       * @param {Number} y
       * @chainable
       */
      setXY: function (x, y) {
        this.x = x;
        this.y = y;
        return this;
      },

      /**
       * Sets x of this point
       * @param {Number} x
       * @chainable
       */
      setX: function (x) {
        this.x = x;
        return this;
      },

      /**
       * Sets y of this point
       * @param {Number} y
       * @chainable
       */
      setY: function (y) {
        this.y = y;
        return this;
      },

      /**
       * Sets x/y of this point from another point
       * @param {fabric.Point} that
       * @chainable
       */
      setFromPoint: function (that) {
        this.x = that.x;
        this.y = that.y;
        return this;
      },

      /**
       * Swaps x/y of this point and another point
       * @param {fabric.Point} that
       */
      swap: function (that) {
        var x = this.x,
            y = this.y;
        this.x = that.x;
        this.y = that.y;
        that.x = x;
        that.y = y;
      },

      /**
       * return a cloned instance of the point
       * @return {fabric.Point}
       */
      clone: function () {
        return new Point(this.x, this.y);
      }
    };

  })(exports);


  (function(global) {

    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Intersection) {
      fabric.warn('fabric.Intersection is already defined');
      return;
    }

    /**
     * Intersection class
     * @class fabric.Intersection
     * @memberOf fabric
     * @constructor
     */
    function Intersection(status) {
      this.status = status;
      this.points = [];
    }

    fabric.Intersection = Intersection;

    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

      constructor: Intersection,

      /**
       * Appends a point to intersection
       * @param {fabric.Point} point
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoint: function (point) {
        this.points.push(point);
        return this;
      },

      /**
       * Appends points to intersection
       * @param {Array} points
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoints: function (points) {
        this.points = this.points.concat(points);
        return this;
      }
    };

    /**
     * Checks if one line intersects another
     * TODO: rename in intersectSegmentSegment
     * @static
     * @param {fabric.Point} a1
     * @param {fabric.Point} a2
     * @param {fabric.Point} b1
     * @param {fabric.Point} b2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
      var result,
          uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
          ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
          uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (uB !== 0) {
        var ua = uaT / uB,
            ub = ubT / uB;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
          result = new Intersection('Intersection');
          result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
        }
        else {
          result = new Intersection();
        }
      }
      else {
        if (uaT === 0 || ubT === 0) {
          result = new Intersection('Coincident');
        }
        else {
          result = new Intersection('Parallel');
        }
      }
      return result;
    };

    /**
     * Checks if line intersects polygon
     * TODO: rename in intersectSegmentPolygon
     * fix detection of coincident
     * @static
     * @param {fabric.Point} a1
     * @param {fabric.Point} a2
     * @param {Array} points
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
      var result = new Intersection(),
          length = points.length,
          b1, b2, inter, i;

      for (i = 0; i < length; i++) {
        b1 = points[i];
        b2 = points[(i + 1) % length];
        inter = Intersection.intersectLineLine(a1, a2, b1, b2);

        result.appendPoints(inter.points);
      }
      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

    /**
     * Checks if polygon intersects another polygon
     * @static
     * @param {Array} points1
     * @param {Array} points2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
      var result = new Intersection(),
          length = points1.length, i;

      for (i = 0; i < length; i++) {
        var a1 = points1[i],
            a2 = points1[(i + 1) % length],
            inter = Intersection.intersectLinePolygon(a1, a2, points2);

        result.appendPoints(inter.points);
      }
      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

    /**
     * Checks if polygon intersects rectangle
     * @static
     * @param {Array} points
     * @param {fabric.Point} r1
     * @param {fabric.Point} r2
     * @return {fabric.Intersection}
     */
    fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
      var min = r1.min(r2),
          max = r1.max(r2),
          topRight = new fabric.Point(max.x, min.y),
          bottomLeft = new fabric.Point(min.x, max.y),
          inter1 = Intersection.intersectLinePolygon(min, topRight, points),
          inter2 = Intersection.intersectLinePolygon(topRight, max, points),
          inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
          inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
          result = new Intersection();

      result.appendPoints(inter1.points);
      result.appendPoints(inter2.points);
      result.appendPoints(inter3.points);
      result.appendPoints(inter4.points);

      if (result.points.length > 0) {
        result.status = 'Intersection';
      }
      return result;
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Color) {
      fabric.warn('fabric.Color is already defined.');
      return;
    }

    /**
     * Color class
     * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
     * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
     *
     * @class fabric.Color
     * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
     * @return {fabric.Color} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
     */
    function Color(color) {
      if (!color) {
        this.setSource([0, 0, 0, 1]);
      }
      else {
        this._tryParsingColor(color);
      }
    }

    fabric.Color = Color;

    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

      /**
       * @private
       * @param {String|Array} color Color value to parse
       */
      _tryParsingColor: function(color) {
        var source;

        if (color in Color.colorNameMap) {
          color = Color.colorNameMap[color];
        }

        if (color === 'transparent') {
          source = [255, 255, 255, 0];
        }

        if (!source) {
          source = Color.sourceFromHex(color);
        }
        if (!source) {
          source = Color.sourceFromRgb(color);
        }
        if (!source) {
          source = Color.sourceFromHsl(color);
        }
        if (!source) {
          //if color is not recognize let's make black as canvas does
          source = [0, 0, 0, 1];
        }
        if (source) {
          this.setSource(source);
        }
      },

      /**
       * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
       * @private
       * @param {Number} r Red color value
       * @param {Number} g Green color value
       * @param {Number} b Blue color value
       * @return {Array} Hsl color
       */
      _rgbToHsl: function(r, g, b) {
        r /= 255; g /= 255; b /= 255;

        var h, s, l,
            max = fabric.util.array.max([r, g, b]),
            min = fabric.util.array.min([r, g, b]);

        l = (max + min) / 2;

        if (max === min) {
          h = s = 0; // achromatic
        }
        else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }

        return [
          Math.round(h * 360),
          Math.round(s * 100),
          Math.round(l * 100)
        ];
      },

      /**
       * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @return {Array}
       */
      getSource: function() {
        return this._source;
      },

      /**
       * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @param {Array} source
       */
      setSource: function(source) {
        this._source = source;
      },

      /**
       * Returns color representation in RGB format
       * @return {String} ex: rgb(0-255,0-255,0-255)
       */
      toRgb: function() {
        var source = this.getSource();
        return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
      },

      /**
       * Returns color representation in RGBA format
       * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
       */
      toRgba: function() {
        var source = this.getSource();
        return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
      },

      /**
       * Returns color representation in HSL format
       * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
       */
      toHsl: function() {
        var source = this.getSource(),
            hsl = this._rgbToHsl(source[0], source[1], source[2]);

        return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
      },

      /**
       * Returns color representation in HSLA format
       * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
       */
      toHsla: function() {
        var source = this.getSource(),
            hsl = this._rgbToHsl(source[0], source[1], source[2]);

        return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
      },

      /**
       * Returns color representation in HEX format
       * @return {String} ex: FF5555
       */
      toHex: function() {
        var source = this.getSource(), r, g, b;

        r = source[0].toString(16);
        r = (r.length === 1) ? ('0' + r) : r;

        g = source[1].toString(16);
        g = (g.length === 1) ? ('0' + g) : g;

        b = source[2].toString(16);
        b = (b.length === 1) ? ('0' + b) : b;

        return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
      },

      /**
       * Returns color representation in HEXA format
       * @return {String} ex: FF5555CC
       */
      toHexa: function() {
        var source = this.getSource(), a;

        a = Math.round(source[3] * 255);
        a = a.toString(16);
        a = (a.length === 1) ? ('0' + a) : a;

        return this.toHex() + a.toUpperCase();
      },

      /**
       * Gets value of alpha channel for this color
       * @return {Number} 0-1
       */
      getAlpha: function() {
        return this.getSource()[3];
      },

      /**
       * Sets value of alpha channel for this color
       * @param {Number} alpha Alpha value 0-1
       * @return {fabric.Color} thisArg
       */
      setAlpha: function(alpha) {
        var source = this.getSource();
        source[3] = alpha;
        this.setSource(source);
        return this;
      },

      /**
       * Transforms color to its grayscale representation
       * @return {fabric.Color} thisArg
       */
      toGrayscale: function() {
        var source = this.getSource(),
            average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
            currentAlpha = source[3];
        this.setSource([average, average, average, currentAlpha]);
        return this;
      },

      /**
       * Transforms color to its black and white representation
       * @param {Number} threshold
       * @return {fabric.Color} thisArg
       */
      toBlackWhite: function(threshold) {
        var source = this.getSource(),
            average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
            currentAlpha = source[3];

        threshold = threshold || 127;

        average = (Number(average) < Number(threshold)) ? 0 : 255;
        this.setSource([average, average, average, currentAlpha]);
        return this;
      },

      /**
       * Overlays color with another color
       * @param {String|fabric.Color} otherColor
       * @return {fabric.Color} thisArg
       */
      overlayWith: function(otherColor) {
        if (!(otherColor instanceof Color)) {
          otherColor = new Color(otherColor);
        }

        var result = [],
            alpha = this.getAlpha(),
            otherAlpha = 0.5,
            source = this.getSource(),
            otherSource = otherColor.getSource(), i;

        for (i = 0; i < 3; i++) {
          result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
        }

        result[3] = alpha;
        this.setSource(result);
        return this;
      }
    };

    /**
     * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
     * @static
     * @field
     * @memberOf fabric.Color
     */
    // eslint-disable-next-line max-len
    fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

    /**
     * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
     * @static
     * @field
     * @memberOf fabric.Color
     */
    fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

    /**
     * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
     * @static
     * @field
     * @memberOf fabric.Color
     */
    fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

    /**
     * Map of the 148 color names with HEX code
     * @static
     * @field
     * @memberOf fabric.Color
     * @see: https://www.w3.org/TR/css3-color/#svg-color
     */
    fabric.Color.colorNameMap = {
      aliceblue:            '#F0F8FF',
      antiquewhite:         '#FAEBD7',
      aqua:                 '#00FFFF',
      aquamarine:           '#7FFFD4',
      azure:                '#F0FFFF',
      beige:                '#F5F5DC',
      bisque:               '#FFE4C4',
      black:                '#000000',
      blanchedalmond:       '#FFEBCD',
      blue:                 '#0000FF',
      blueviolet:           '#8A2BE2',
      brown:                '#A52A2A',
      burlywood:            '#DEB887',
      cadetblue:            '#5F9EA0',
      chartreuse:           '#7FFF00',
      chocolate:            '#D2691E',
      coral:                '#FF7F50',
      cornflowerblue:       '#6495ED',
      cornsilk:             '#FFF8DC',
      crimson:              '#DC143C',
      cyan:                 '#00FFFF',
      darkblue:             '#00008B',
      darkcyan:             '#008B8B',
      darkgoldenrod:        '#B8860B',
      darkgray:             '#A9A9A9',
      darkgrey:             '#A9A9A9',
      darkgreen:            '#006400',
      darkkhaki:            '#BDB76B',
      darkmagenta:          '#8B008B',
      darkolivegreen:       '#556B2F',
      darkorange:           '#FF8C00',
      darkorchid:           '#9932CC',
      darkred:              '#8B0000',
      darksalmon:           '#E9967A',
      darkseagreen:         '#8FBC8F',
      darkslateblue:        '#483D8B',
      darkslategray:        '#2F4F4F',
      darkslategrey:        '#2F4F4F',
      darkturquoise:        '#00CED1',
      darkviolet:           '#9400D3',
      deeppink:             '#FF1493',
      deepskyblue:          '#00BFFF',
      dimgray:              '#696969',
      dimgrey:              '#696969',
      dodgerblue:           '#1E90FF',
      firebrick:            '#B22222',
      floralwhite:          '#FFFAF0',
      forestgreen:          '#228B22',
      fuchsia:              '#FF00FF',
      gainsboro:            '#DCDCDC',
      ghostwhite:           '#F8F8FF',
      gold:                 '#FFD700',
      goldenrod:            '#DAA520',
      gray:                 '#808080',
      grey:                 '#808080',
      green:                '#008000',
      greenyellow:          '#ADFF2F',
      honeydew:             '#F0FFF0',
      hotpink:              '#FF69B4',
      indianred:            '#CD5C5C',
      indigo:               '#4B0082',
      ivory:                '#FFFFF0',
      khaki:                '#F0E68C',
      lavender:             '#E6E6FA',
      lavenderblush:        '#FFF0F5',
      lawngreen:            '#7CFC00',
      lemonchiffon:         '#FFFACD',
      lightblue:            '#ADD8E6',
      lightcoral:           '#F08080',
      lightcyan:            '#E0FFFF',
      lightgoldenrodyellow: '#FAFAD2',
      lightgray:            '#D3D3D3',
      lightgrey:            '#D3D3D3',
      lightgreen:           '#90EE90',
      lightpink:            '#FFB6C1',
      lightsalmon:          '#FFA07A',
      lightseagreen:        '#20B2AA',
      lightskyblue:         '#87CEFA',
      lightslategray:       '#778899',
      lightslategrey:       '#778899',
      lightsteelblue:       '#B0C4DE',
      lightyellow:          '#FFFFE0',
      lime:                 '#00FF00',
      limegreen:            '#32CD32',
      linen:                '#FAF0E6',
      magenta:              '#FF00FF',
      maroon:               '#800000',
      mediumaquamarine:     '#66CDAA',
      mediumblue:           '#0000CD',
      mediumorchid:         '#BA55D3',
      mediumpurple:         '#9370DB',
      mediumseagreen:       '#3CB371',
      mediumslateblue:      '#7B68EE',
      mediumspringgreen:    '#00FA9A',
      mediumturquoise:      '#48D1CC',
      mediumvioletred:      '#C71585',
      midnightblue:         '#191970',
      mintcream:            '#F5FFFA',
      mistyrose:            '#FFE4E1',
      moccasin:             '#FFE4B5',
      navajowhite:          '#FFDEAD',
      navy:                 '#000080',
      oldlace:              '#FDF5E6',
      olive:                '#808000',
      olivedrab:            '#6B8E23',
      orange:               '#FFA500',
      orangered:            '#FF4500',
      orchid:               '#DA70D6',
      palegoldenrod:        '#EEE8AA',
      palegreen:            '#98FB98',
      paleturquoise:        '#AFEEEE',
      palevioletred:        '#DB7093',
      papayawhip:           '#FFEFD5',
      peachpuff:            '#FFDAB9',
      peru:                 '#CD853F',
      pink:                 '#FFC0CB',
      plum:                 '#DDA0DD',
      powderblue:           '#B0E0E6',
      purple:               '#800080',
      rebeccapurple:        '#663399',
      red:                  '#FF0000',
      rosybrown:            '#BC8F8F',
      royalblue:            '#4169E1',
      saddlebrown:          '#8B4513',
      salmon:               '#FA8072',
      sandybrown:           '#F4A460',
      seagreen:             '#2E8B57',
      seashell:             '#FFF5EE',
      sienna:               '#A0522D',
      silver:               '#C0C0C0',
      skyblue:              '#87CEEB',
      slateblue:            '#6A5ACD',
      slategray:            '#708090',
      slategrey:            '#708090',
      snow:                 '#FFFAFA',
      springgreen:          '#00FF7F',
      steelblue:            '#4682B4',
      tan:                  '#D2B48C',
      teal:                 '#008080',
      thistle:              '#D8BFD8',
      tomato:               '#FF6347',
      turquoise:            '#40E0D0',
      violet:               '#EE82EE',
      wheat:                '#F5DEB3',
      white:                '#FFFFFF',
      whitesmoke:           '#F5F5F5',
      yellow:               '#FFFF00',
      yellowgreen:          '#9ACD32'
    };

    /**
     * @private
     * @param {Number} p
     * @param {Number} q
     * @param {Number} t
     * @return {Number}
     */
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }

    /**
     * Returns new color object, when given a color in RGB format
     * @memberOf fabric.Color
     * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
     * @return {fabric.Color}
     */
    fabric.Color.fromRgb = function(color) {
      return Color.fromSource(Color.sourceFromRgb(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
     * @memberOf fabric.Color
     * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
     * @return {Array} source
     */
    fabric.Color.sourceFromRgb = function(color) {
      var match = color.match(Color.reRGBa);
      if (match) {
        var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
            g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
            b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

        return [
          parseInt(r, 10),
          parseInt(g, 10),
          parseInt(b, 10),
          match[4] ? parseFloat(match[4]) : 1
        ];
      }
    };

    /**
     * Returns new color object, when given a color in RGBA format
     * @static
     * @function
     * @memberOf fabric.Color
     * @param {String} color
     * @return {fabric.Color}
     */
    fabric.Color.fromRgba = Color.fromRgb;

    /**
     * Returns new color object, when given a color in HSL format
     * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
     * @memberOf fabric.Color
     * @return {fabric.Color}
     */
    fabric.Color.fromHsl = function(color) {
      return Color.fromSource(Color.sourceFromHsl(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @memberOf fabric.Color
     * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
     * @return {Array} source
     * @see http://http://www.w3.org/TR/css3-color/#hsl-color
     */
    fabric.Color.sourceFromHsl = function(color) {
      var match = color.match(Color.reHSLa);
      if (!match) {
        return;
      }

      var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
          s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
          l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
          r, g, b;

      if (s === 0) {
        r = g = b = l;
      }
      else {
        var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            p = l * 2 - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        match[4] ? parseFloat(match[4]) : 1
      ];
    };

    /**
     * Returns new color object, when given a color in HSLA format
     * @static
     * @function
     * @memberOf fabric.Color
     * @param {String} color
     * @return {fabric.Color}
     */
    fabric.Color.fromHsla = Color.fromHsl;

    /**
     * Returns new color object, when given a color in HEX format
     * @static
     * @memberOf fabric.Color
     * @param {String} color Color value ex: FF5555
     * @return {fabric.Color}
     */
    fabric.Color.fromHex = function(color) {
      return Color.fromSource(Color.sourceFromHex(color));
    };

    /**
     * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
     * @static
     * @memberOf fabric.Color
     * @param {String} color ex: FF5555 or FF5544CC (RGBa)
     * @return {Array} source
     */
    fabric.Color.sourceFromHex = function(color) {
      if (color.match(Color.reHex)) {
        var value = color.slice(color.indexOf('#') + 1),
            isShortNotation = (value.length === 3 || value.length === 4),
            isRGBa = (value.length === 8 || value.length === 4),
            r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
            g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
            b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
            a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

        return [
          parseInt(r, 16),
          parseInt(g, 16),
          parseInt(b, 16),
          parseFloat((parseInt(a, 16) / 255).toFixed(2))
        ];
      }
    };

    /**
     * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
     * @static
     * @memberOf fabric.Color
     * @param {Array} source
     * @return {fabric.Color}
     */
    fabric.Color.fromSource = function(source) {
      var oColor = new Color();
      oColor.setSource(source);
      return oColor;
    };

  })(exports);


  (function() {

    /* _FROM_SVG_START_ */
    function getColorStop(el) {
      var style = el.getAttribute('style'),
          offset = el.getAttribute('offset') || 0,
          color, colorAlpha, opacity, i;

      // convert percents to absolute values
      offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
      offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
      if (style) {
        var keyValuePairs = style.split(/\s*;\s*/);

        if (keyValuePairs[keyValuePairs.length - 1] === '') {
          keyValuePairs.pop();
        }

        for (i = keyValuePairs.length; i--; ) {

          var split = keyValuePairs[i].split(/\s*:\s*/),
              key = split[0].trim(),
              value = split[1].trim();

          if (key === 'stop-color') {
            color = value;
          }
          else if (key === 'stop-opacity') {
            opacity = value;
          }
        }
      }

      if (!color) {
        color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
      }
      if (!opacity) {
        opacity = el.getAttribute('stop-opacity');
      }

      color = new fabric.Color(color);
      colorAlpha = color.getAlpha();
      opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
      opacity *= colorAlpha;

      return {
        offset: offset,
        color: color.toRgb(),
        opacity: opacity
      };
    }

    function getLinearCoords(el) {
      return {
        x1: el.getAttribute('x1') || 0,
        y1: el.getAttribute('y1') || 0,
        x2: el.getAttribute('x2') || '100%',
        y2: el.getAttribute('y2') || 0
      };
    }

    function getRadialCoords(el) {
      return {
        x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
        y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
        r1: 0,
        x2: el.getAttribute('cx') || '50%',
        y2: el.getAttribute('cy') || '50%',
        r2: el.getAttribute('r') || '50%'
      };
    }
    /* _FROM_SVG_END_ */

    var clone = fabric.util.object.clone;

    /**
     * Gradient class
     * @class fabric.Gradient
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
     * @see {@link fabric.Gradient#initialize} for constructor definition
     */
    fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

      /**
       * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
       * @type Number
       * @default 0
       */
      offsetX: 0,

      /**
       * Vertical offset for aligning gradients coming from SVG when outside pathgroups
       * @type Number
       * @default 0
       */
      offsetY: 0,

      /**
       * Constructor
       * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
       * @return {fabric.Gradient} thisArg
       */
      initialize: function(options) {
        options || (options = { });

        var coords = { };

        this.id = fabric.Object.__uid++;
        this.type = options.type || 'linear';

        coords = {
          x1: options.coords.x1 || 0,
          y1: options.coords.y1 || 0,
          x2: options.coords.x2 || 0,
          y2: options.coords.y2 || 0
        };

        if (this.type === 'radial') {
          coords.r1 = options.coords.r1 || 0;
          coords.r2 = options.coords.r2 || 0;
        }
        this.coords = coords;
        this.colorStops = options.colorStops.slice();
        if (options.gradientTransform) {
          this.gradientTransform = options.gradientTransform;
        }
        this.offsetX = options.offsetX || this.offsetX;
        this.offsetY = options.offsetY || this.offsetY;
      },

      /**
       * Adds another colorStop
       * @param {Object} colorStop Object with offset and color
       * @return {fabric.Gradient} thisArg
       */
      addColorStop: function(colorStops) {
        for (var position in colorStops) {
          var color = new fabric.Color(colorStops[position]);
          this.colorStops.push({
            offset: parseFloat(position),
            color: color.toRgb(),
            opacity: color.getAlpha()
          });
        }
        return this;
      },

      /**
       * Returns object representation of a gradient
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object}
       */
      toObject: function(propertiesToInclude) {
        var object = {
          type: this.type,
          coords: this.coords,
          colorStops: this.colorStops,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
        };
        fabric.util.populateWithProperties(this, object, propertiesToInclude);

        return object;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an gradient
       * @param {Object} object Object to create a gradient for
       * @return {String} SVG representation of an gradient (linear/radial)
       */
      toSVG: function(object) {
        var coords = clone(this.coords, true), i, len,
            markup, commonAttributes, colorStops = clone(this.colorStops, true),
            needsSwap = coords.r1 > coords.r2,
            offsetX = object.width / 2, offsetY = object.height / 2;
        // colorStops must be sorted ascending
        colorStops.sort(function(a, b) {
          return a.offset - b.offset;
        });
        if (object.type === 'path') {
          offsetX -= object.pathOffset.x;
          offsetY -= object.pathOffset.y;
        }

        commonAttributes = 'id="SVGID_' + this.id +
                       '" gradientUnits="userSpaceOnUse"';
        if (this.gradientTransform) {
          commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
        }
        if (this.type === 'linear') {
          markup = [
            '<linearGradient ',
            commonAttributes,
            ' x1="', coords.x1,
            '" y1="', coords.y1,
            '" x2="', coords.x2,
            '" y2="', coords.y2,
            '">\n'
          ];
        }
        else if (this.type === 'radial') {
          // svg radial gradient has just 1 radius. the biggest.
          markup = [
            '<radialGradient ',
            commonAttributes,
            ' cx="', needsSwap ? coords.x1 : coords.x2,
            '" cy="', needsSwap ? coords.y1 : coords.y2,
            '" r="', needsSwap ? coords.r1 : coords.r2,
            '" fx="', needsSwap ? coords.x2 : coords.x1,
            '" fy="', needsSwap ? coords.y2 : coords.y1,
            '">\n'
          ];
        }

        if (this.type === 'radial') {
          if (needsSwap) {
            // svg goes from internal to external radius. if radius are inverted, swap color stops.
            colorStops = colorStops.concat();
            colorStops.reverse();
            for (i = 0, len = colorStops.length; i < len; i++) {
              colorStops[i].offset = 1 - colorStops[i].offset;
            }
          }
          var minRadius = Math.min(coords.r1, coords.r2);
          if (minRadius > 0) {
            // i have to shift all colorStops and add new one in 0.
            var maxRadius = Math.max(coords.r1, coords.r2),
                percentageShift = minRadius / maxRadius;
            for (i = 0, len = colorStops.length; i < len; i++) {
              colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
            }
          }
        }

        for (i = 0, len = colorStops.length; i < len; i++) {
          var colorStop = colorStops[i];
          markup.push(
            '<stop ',
            'offset="', (colorStop.offset * 100) + '%',
            '" style="stop-color:', colorStop.color,
            (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
            '"/>\n'
          );
        }

        markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

        return markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns an instance of CanvasGradient
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @return {CanvasGradient}
       */
      toLive: function(ctx) {
        var gradient, coords = fabric.util.object.clone(this.coords), i, len;

        if (!this.type) {
          return;
        }

        if (this.type === 'linear') {
          gradient = ctx.createLinearGradient(
            coords.x1, coords.y1, coords.x2, coords.y2);
        }
        else if (this.type === 'radial') {
          gradient = ctx.createRadialGradient(
            coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
        }

        for (i = 0, len = this.colorStops.length; i < len; i++) {
          var color = this.colorStops[i].color,
              opacity = this.colorStops[i].opacity,
              offset = this.colorStops[i].offset;

          if (typeof opacity !== 'undefined') {
            color = new fabric.Color(color).setAlpha(opacity).toRgba();
          }
          gradient.addColorStop(offset, color);
        }

        return gradient;
      }
    });

    fabric.util.object.extend(fabric.Gradient, {

      /* _FROM_SVG_START_ */
      /**
       * Returns {@link fabric.Gradient} instance from an SVG element
       * @static
       * @memberOf fabric.Gradient
       * @param {SVGGradientElement} el SVG gradient element
       * @param {fabric.Object} instance
       * @return {fabric.Gradient} Gradient instance
       * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
       * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
       */
      fromElement: function(el, instance) {
        /**
         *  @example:
         *
         *  <linearGradient id="linearGrad1">
         *    <stop offset="0%" stop-color="white"/>
         *    <stop offset="100%" stop-color="black"/>
         *  </linearGradient>
         *
         *  OR
         *
         *  <linearGradient id="linearGrad2">
         *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
         *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
         *  </linearGradient>
         *
         *  OR
         *
         *  <radialGradient id="radialGrad1">
         *    <stop offset="0%" stop-color="white" stop-opacity="1" />
         *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
         *    <stop offset="100%" stop-color="white" stop-opacity="1" />
         *  </radialGradient>
         *
         *  OR
         *
         *  <radialGradient id="radialGrad2">
         *    <stop offset="0" stop-color="rgb(255,255,255)" />
         *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
         *    <stop offset="1" stop-color="rgb(255,255,255)" />
         *  </radialGradient>
         *
         */

        var colorStopEls = el.getElementsByTagName('stop'),
            type,
            gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
            gradientTransform = el.getAttribute('gradientTransform'),
            colorStops = [],
            coords, ellipseMatrix, i;

        if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
          type = 'linear';
        }
        else {
          type = 'radial';
        }

        if (type === 'linear') {
          coords = getLinearCoords(el);
        }
        else if (type === 'radial') {
          coords = getRadialCoords(el);
        }

        for (i = colorStopEls.length; i--; ) {
          colorStops.push(getColorStop(colorStopEls[i]));
        }

        ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);

        var gradient = new fabric.Gradient({
          type: type,
          coords: coords,
          colorStops: colorStops,
          offsetX: -instance.left,
          offsetY: -instance.top
        });

        if (gradientTransform || ellipseMatrix !== '') {
          gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
        }

        return gradient;
      },
      /* _FROM_SVG_END_ */

      /**
       * Returns {@link fabric.Gradient} instance from its object representation
       * @static
       * @memberOf fabric.Gradient
       * @param {Object} obj
       * @param {Object} [options] Options object
       */
      forObject: function(obj, options) {
        options || (options = { });
        _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
        return new fabric.Gradient(options);
      }
    });

    /**
     * @private
     */
    function _convertPercentUnitsToValues(object, options, gradientUnits) {
      var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
      for (var prop in options) {
        if (options[prop] === 'Infinity') {
          options[prop] = 1;
        }
        else if (options[prop] === '-Infinity') {
          options[prop] = 0;
        }
        propValue = parseFloat(options[prop], 10);
        if (typeof options[prop] === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(options[prop])) {
          multFactor = 0.01;
        }
        else {
          multFactor = 1;
        }
        if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
          multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
          addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
        }
        else if (prop === 'y1' || prop === 'y2') {
          multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
          addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
        }
        options[prop] = propValue * multFactor + addFactor;
      }
      if (object.type === 'ellipse' &&
          options.r2 !== null &&
          gradientUnits === 'objectBoundingBox' &&
          object.rx !== object.ry) {

        var scaleFactor = object.ry / object.rx;
        ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
        if (options.y1) {
          options.y1 /= scaleFactor;
        }
        if (options.y2) {
          options.y2 /= scaleFactor;
        }
      }
      return ellipseMatrix;
    }
  })();


  (function() {

    var toFixed = fabric.util.toFixed;

    /**
     * Pattern class
     * @class fabric.Pattern
     * @see {@link http://fabricjs.com/patterns|Pattern demo}
     * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
     * @see {@link fabric.Pattern#initialize} for constructor definition
     */


    fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

      /**
       * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
       * @type String
       * @default
       */
      repeat: 'repeat',

      /**
       * Pattern horizontal offset from object's left/top corner
       * @type Number
       * @default
       */
      offsetX: 0,

      /**
       * Pattern vertical offset from object's left/top corner
       * @type Number
       * @default
       */
      offsetY: 0,

      /**
       * crossOrigin value (one of "", "anonymous", "use-credentials")
       * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
       * @type String
       * @default
       */
      crossOrigin: '',

      /**
       * transform matrix to change the pattern, imported from svgs.
       * @type Array
       * @default
       */
      patternTransform: null,

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @param {Function} [callback] function to invoke after callback init.
       * @return {fabric.Pattern} thisArg
       */
      initialize: function(options, callback) {
        options || (options = { });

        this.id = fabric.Object.__uid++;
        this.setOptions(options);
        if (!options.source || (options.source && typeof options.source !== 'string')) {
          callback && callback(this);
          return;
        }
        // function string
        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
          this.source = new Function(fabric.util.getFunctionBody(options.source));
          callback && callback(this);
        }
        else {
          // img src string
          var _this = this;
          this.source = fabric.util.createImage();
          fabric.util.loadImage(options.source, function(img) {
            _this.source = img;
            callback && callback(_this);
          }, null, this.crossOrigin);
        }
      },

      /**
       * Returns object representation of a pattern
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of a pattern instance
       */
      toObject: function(propertiesToInclude) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
            source, object;

        // callback
        if (typeof this.source === 'function') {
          source = String(this.source);
        }
        // <img> element
        else if (typeof this.source.src === 'string') {
          source = this.source.src;
        }
        // <canvas> element
        else if (typeof this.source === 'object' && this.source.toDataURL) {
          source = this.source.toDataURL();
        }

        object = {
          type: 'pattern',
          source: source,
          repeat: this.repeat,
          crossOrigin: this.crossOrigin,
          offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
          offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
          patternTransform: this.patternTransform ? this.patternTransform.concat() : null
        };
        fabric.util.populateWithProperties(this, object, propertiesToInclude);

        return object;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of a pattern
       * @param {fabric.Object} object
       * @return {String} SVG representation of a pattern
       */
      toSVG: function(object) {
        var patternSource = typeof this.source === 'function' ? this.source() : this.source,
            patternWidth = patternSource.width / object.width,
            patternHeight = patternSource.height / object.height,
            patternOffsetX = this.offsetX / object.width,
            patternOffsetY = this.offsetY / object.height,
            patternImgSrc = '';
        if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
          patternHeight = 1;
        }
        if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
          patternWidth = 1;
        }
        if (patternSource.src) {
          patternImgSrc = patternSource.src;
        }
        else if (patternSource.toDataURL) {
          patternImgSrc = patternSource.toDataURL();
        }

        return '<pattern id="SVGID_' + this.id +
                      '" x="' + patternOffsetX +
                      '" y="' + patternOffsetY +
                      '" width="' + patternWidth +
                      '" height="' + patternHeight + '">\n' +
                 '<image x="0" y="0"' +
                        ' width="' + patternSource.width +
                        '" height="' + patternSource.height +
                        '" xlink:href="' + patternImgSrc +
                 '"></image>\n' +
               '</pattern>\n';
      },
      /* _TO_SVG_END_ */

      setOptions: function(options) {
        for (var prop in options) {
          this[prop] = options[prop];
        }
      },

      /**
       * Returns an instance of CanvasPattern
       * @param {CanvasRenderingContext2D} ctx Context to create pattern
       * @return {CanvasPattern}
       */
      toLive: function(ctx) {
        var source = typeof this.source === 'function' ? this.source() : this.source;

        // if the image failed to load, return, and allow rest to continue loading
        if (!source) {
          return '';
        }

        // if an image
        if (typeof source.src !== 'undefined') {
          if (!source.complete) {
            return '';
          }
          if (source.naturalWidth === 0 || source.naturalHeight === 0) {
            return '';
          }
        }
        return ctx.createPattern(source, this.repeat);
      }
    });
  })();


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        toFixed = fabric.util.toFixed;

    if (fabric.Shadow) {
      fabric.warn('fabric.Shadow is already defined.');
      return;
    }

    /**
     * Shadow class
     * @class fabric.Shadow
     * @see {@link http://fabricjs.com/shadows|Shadow demo}
     * @see {@link fabric.Shadow#initialize} for constructor definition
     */
    fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

      /**
       * Shadow color
       * @type String
       * @default
       */
      color: 'rgb(0,0,0)',

      /**
       * Shadow blur
       * @type Number
       */
      blur: 0,

      /**
       * Shadow horizontal offset
       * @type Number
       * @default
       */
      offsetX: 0,

      /**
       * Shadow vertical offset
       * @type Number
       * @default
       */
      offsetY: 0,

      /**
       * Whether the shadow should affect stroke operations
       * @type Boolean
       * @default
       */
      affectStroke: false,

      /**
       * Indicates whether toObject should include default values
       * @type Boolean
       * @default
       */
      includeDefaultValues: true,

      /**
       * Constructor
       * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
       * @return {fabric.Shadow} thisArg
       */
      initialize: function(options) {

        if (typeof options === 'string') {
          options = this._parseShadow(options);
        }

        for (var prop in options) {
          this[prop] = options[prop];
        }

        this.id = fabric.Object.__uid++;
      },

      /**
       * @private
       * @param {String} shadow Shadow value to parse
       * @return {Object} Shadow object with color, offsetX, offsetY and blur
       */
      _parseShadow: function(shadow) {
        var shadowStr = shadow.trim(),
            offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
            color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

        return {
          color: color.trim(),
          offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
          offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
          blur: parseInt(offsetsAndBlur[3], 10) || 0
        };
      },

      /**
       * Returns a string representation of an instance
       * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
       * @return {String} Returns CSS3 text-shadow declaration
       */
      toString: function() {
        return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of a shadow
       * @param {fabric.Object} object
       * @return {String} SVG representation of a shadow
       */
      toSVG: function(object) {
        var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
            offset = fabric.util.rotateVector(
              { x: this.offsetX, y: this.offsetY },
              fabric.util.degreesToRadians(-object.angle)),
            BLUR_BOX = 20, color = new fabric.Color(this.color);

        if (object.width && object.height) {
          //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
          // we add some extra space to filter box to contain the blur ( 20 )
          fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
          fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        }
        if (object.flipX) {
          offset.x *= -1;
        }
        if (object.flipY) {
          offset.y *= -1;
        }

        return (
          '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
            'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
            '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
              toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
            '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
            '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
            '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
            '\t<feComposite in2="oBlur" operator="in" />\n' +
            '\t<feMerge>\n' +
              '\t\t<feMergeNode></feMergeNode>\n' +
              '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
            '\t</feMerge>\n' +
          '</filter>\n');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns object representation of a shadow
       * @return {Object} Object representation of a shadow instance
       */
      toObject: function() {
        if (this.includeDefaultValues) {
          return {
            color: this.color,
            blur: this.blur,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            affectStroke: this.affectStroke
          };
        }
        var obj = { }, proto = fabric.Shadow.prototype;

        ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {
          if (this[prop] !== proto[prop]) {
            obj[prop] = this[prop];
          }
        }, this);

        return obj;
      }
    });

    /**
     * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
     * @static
     * @field
     * @memberOf fabric.Shadow
     */
    // eslint-disable-next-line max-len
    fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

  })(exports);


  (function () {

    if (fabric.StaticCanvas) {
      fabric.warn('fabric.StaticCanvas is already defined.');
      return;
    }

    // aliases for faster resolution
    var extend = fabric.util.object.extend,
        getElementOffset = fabric.util.getElementOffset,
        removeFromArray = fabric.util.removeFromArray,
        toFixed = fabric.util.toFixed,
        transformPoint = fabric.util.transformPoint,
        invertTransform = fabric.util.invertTransform,

        CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

    /**
     * Static canvas class
     * @class fabric.StaticCanvas
     * @mixes fabric.Collection
     * @mixes fabric.Observable
     * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
     * @see {@link fabric.StaticCanvas#initialize} for constructor definition
     * @fires before:render
     * @fires after:render
     * @fires canvas:cleared
     * @fires object:added
     * @fires object:removed
     */
    fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

      /**
       * Constructor
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(el, options) {
        options || (options = { });
        this.renderAndResetBound = this.renderAndReset.bind(this);
        this.requestRenderAllBound = this.requestRenderAll.bind(this);
        this._initStatic(el, options);
      },

      /**
       * Background color of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
       * @type {(String|fabric.Pattern)}
       * @default
       */
      backgroundColor: '',

      /**
       * Background image of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
       * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
       * and "backgroundImageStretch" properties are deprecated since 1.3.9.
       * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
       * @type fabric.Image
       * @default
       */
      backgroundImage: null,

      /**
       * Overlay color of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
       * @since 1.3.9
       * @type {(String|fabric.Pattern)}
       * @default
       */
      overlayColor: '',

      /**
       * Overlay image of canvas instance.
       * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
       * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
       * and "overlayImageTop" properties are deprecated since 1.3.9.
       * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
       * @type fabric.Image
       * @default
       */
      overlayImage: null,

      /**
       * Indicates whether toObject/toDatalessObject should include default values
       * @type Boolean
       * @default
       */
      includeDefaultValues: true,

      /**
       * Indicates whether objects' state should be saved
       * @type Boolean
       * @default
       */
      stateful: false,

      /**
       * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
       * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
       * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
       * since the renders are quequed and executed one per frame.
       * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
       * Left default to true to do not break documentation and old app, fiddles.
       * @type Boolean
       * @default
       */
      renderOnAddRemove: true,

      /**
       * Function that determines clipping of entire canvas area
       * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
       * @deprecated since 2.0.0
       * @type Function
       * @default
       */
      clipTo: null,

      /**
       * Indicates whether object controls (borders/controls) are rendered above overlay image
       * @type Boolean
       * @default
       */
      controlsAboveOverlay: false,

      /**
       * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
       * @type Boolean
       * @default
       */
      allowTouchScrolling: false,

      /**
       * Indicates whether this canvas will use image smoothing, this is on by default in browsers
       * @type Boolean
       * @default
       */
      imageSmoothingEnabled: true,

      /**
       * The transformation (in the format of Canvas transform) which focuses the viewport
       * @type Array
       * @default
       */
      viewportTransform: fabric.iMatrix.concat(),

      /**
       * if set to false background image is not affected by viewport transform
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      backgroundVpt: true,

      /**
       * if set to false overlya image is not affected by viewport transform
       * @since 1.6.3
       * @type Boolean
       * @default
       */
      overlayVpt: true,

      /**
       * Callback; invoked right before object is about to be scaled/rotated
       * @deprecated since 2.3.0
       * Use before:transform event
       */
      onBeforeScaleRotate: function () {
        /* NOOP */
      },

      /**
       * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
       * @type Boolean
       * @default
       */
      enableRetinaScaling: true,

      /**
       * Describe canvas element extension over design
       * properties are tl,tr,bl,br.
       * if canvas is not zoomed/panned those points are the four corner of canvas
       * if canvas is viewportTransformed you those points indicate the extension
       * of canvas element in plain untrasformed coordinates
       * The coordinates get updated with @method calcViewportBoundaries.
       * @memberOf fabric.StaticCanvas.prototype
       */
      vptCoords: { },

      /**
       * Based on vptCoords and object.aCoords, skip rendering of objects that
       * are not included in current viewport.
       * May greatly help in applications with crowded canvas and use of zoom/pan
       * If One of the corner of the bounding box of the object is on the canvas
       * the objects get rendered.
       * @memberOf fabric.StaticCanvas.prototype
       * @type Boolean
       * @default
       */
      skipOffscreen: true,

      /**
       * @private
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       */
      _initStatic: function(el, options) {
        var cb = this.requestRenderAllBound;
        this._objects = [];
        this._createLowerCanvas(el);
        this._initOptions(options);
        this._setImageSmoothing();
        // only initialize retina scaling once
        if (!this.interactive) {
          this._initRetinaScaling();
        }

        if (options.overlayImage) {
          this.setOverlayImage(options.overlayImage, cb);
        }
        if (options.backgroundImage) {
          this.setBackgroundImage(options.backgroundImage, cb);
        }
        if (options.backgroundColor) {
          this.setBackgroundColor(options.backgroundColor, cb);
        }
        if (options.overlayColor) {
          this.setOverlayColor(options.overlayColor, cb);
        }
        this.calcOffset();
      },

      /**
       * @private
       */
      _isRetinaScaling: function() {
        return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
      },

      /**
       * @private
       * @return {Number} retinaScaling if applied, otherwise 1;
       */
      getRetinaScaling: function() {
        return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
      },

      /**
       * @private
       */
      _initRetinaScaling: function() {
        if (!this._isRetinaScaling()) {
          return;
        }
        this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
        this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);

        this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
      },

      /**
       * Calculates canvas element offset relative to the document
       * This method is also attached as "resize" event handler of window
       * @return {fabric.Canvas} instance
       * @chainable
       */
      calcOffset: function () {
        this._offset = getElementOffset(this.lowerCanvasEl);
        return this;
      },

      /**
       * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
       * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
       * @param {Function} callback callback to invoke when image is loaded and set as an overlay
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
       * @example <caption>Normal overlayImage with left/top = 0</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   // Needed to position overlayImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>overlayImage with different properties</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
       * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
       *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
       *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
       * });
       * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   width: canvas.width,
       *   height: canvas.height,
       *   // Needed to position overlayImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>overlayImage loaded from cross-origin</caption>
       * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top',
       *   crossOrigin: 'anonymous'
       * });
       */
      setOverlayImage: function (image, callback, options) {
        return this.__setBgOverlayImage('overlayImage', image, callback, options);
      },

      /**
       * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
       * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
       * @param {Function} callback Callback to invoke when image is loaded and set as background
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
       * @example <caption>Normal backgroundImage with left/top = 0</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   // Needed to position backgroundImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>backgroundImage with different properties</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
       * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
       *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
       *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
       * });
       * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   width: canvas.width,
       *   height: canvas.height,
       *   // Needed to position backgroundImage at 0/0
       *   originX: 'left',
       *   originY: 'top'
       * });
       * @example <caption>backgroundImage loaded from cross-origin</caption>
       * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
       *   opacity: 0.5,
       *   angle: 45,
       *   left: 400,
       *   top: 400,
       *   originX: 'left',
       *   originY: 'top',
       *   crossOrigin: 'anonymous'
       * });
       */
      setBackgroundImage: function (image, callback, options) {
        return this.__setBgOverlayImage('backgroundImage', image, callback, options);
      },

      /**
       * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
       * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
       * @param {Function} callback Callback to invoke when foreground color is set
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
       * @example <caption>Normal overlayColor - color value</caption>
       * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as overlayColor</caption>
       * canvas.setOverlayColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
       * }, canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
       * canvas.setOverlayColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat',
       *   offsetX: 200,
       *   offsetY: 100
       * }, canvas.renderAll.bind(canvas));
       */
      setOverlayColor: function(overlayColor, callback) {
        return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
      },

      /**
       * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
       * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
       * @param {Function} callback Callback to invoke when background color is set
       * @return {fabric.Canvas} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
       * @example <caption>Normal backgroundColor - color value</caption>
       * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as backgroundColor</caption>
       * canvas.setBackgroundColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
       * }, canvas.renderAll.bind(canvas));
       * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
       * canvas.setBackgroundColor({
       *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
       *   repeat: 'repeat',
       *   offsetX: 200,
       *   offsetY: 100
       * }, canvas.renderAll.bind(canvas));
       */
      setBackgroundColor: function(backgroundColor, callback) {
        return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
      },

      /**
       * @private
       * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
       */
      _setImageSmoothing: function() {
        var ctx = this.getContext();

        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
          || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
        ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
      },

      /**
       * @private
       * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
       * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
       * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
       * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
       * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
       */
      __setBgOverlayImage: function(property, image, callback, options) {
        if (typeof image === 'string') {
          fabric.util.loadImage(image, function(img) {
            img && (this[property] = new fabric.Image(img, options));
            callback && callback(img);
          }, this, options && options.crossOrigin);
        }
        else {
          options && image.setOptions(options);
          this[property] = image;
          callback && callback(image);
        }

        return this;
      },

      /**
       * @private
       * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
       * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
       * @param {(Object|String|null)} color Object with pattern information, color value or null
       * @param {Function} [callback] Callback is invoked when color is set
       */
      __setBgOverlayColor: function(property, color, callback) {
        this[property] = color;
        this._initGradient(color, property);
        this._initPattern(color, property, callback);
        return this;
      },

      /**
       * @private
       */
      _createCanvasElement: function() {
        var element = fabric.util.createCanvasElement();
        if (!element) {
          throw CANVAS_INIT_ERROR;
        }
        if (!element.style) {
          element.style = { };
        }
        if (typeof element.getContext === 'undefined') {
          throw CANVAS_INIT_ERROR;
        }
        return element;
      },

      /**
       * @private
       * @param {Object} [options] Options object
       */
      _initOptions: function (options) {
        this._setOptions(options);

        this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
        this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;

        if (!this.lowerCanvasEl.style) {
          return;
        }

        this.lowerCanvasEl.width = this.width;
        this.lowerCanvasEl.height = this.height;

        this.lowerCanvasEl.style.width = this.width + 'px';
        this.lowerCanvasEl.style.height = this.height + 'px';

        this.viewportTransform = this.viewportTransform.slice();
      },

      /**
       * Creates a bottom canvas
       * @private
       * @param {HTMLElement} [canvasEl]
       */
      _createLowerCanvas: function (canvasEl) {
        // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
        if (canvasEl && canvasEl.getContext) {
          this.lowerCanvasEl = canvasEl;
        }
        else {
          this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
        }

        fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

        if (this.interactive) {
          this._applyCanvasStyle(this.lowerCanvasEl);
        }

        this.contextContainer = this.lowerCanvasEl.getContext('2d');
      },

      /**
       * Returns canvas width (in px)
       * @return {Number}
       */
      getWidth: function () {
        return this.width;
      },

      /**
       * Returns canvas height (in px)
       * @return {Number}
       */
      getHeight: function () {
        return this.height;
      },

      /**
       * Sets width of this canvas instance
       * @param {Number|String} value                         Value to set width to
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setWidth: function (value, options) {
        return this.setDimensions({ width: value }, options);
      },

      /**
       * Sets height of this canvas instance
       * @param {Number|String} value                         Value to set height to
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setHeight: function (value, options) {
        return this.setDimensions({ height: value }, options);
      },

      /**
       * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
       * @param {Object}        dimensions                    Object with width/height properties
       * @param {Number|String} [dimensions.width]            Width of canvas element
       * @param {Number|String} [dimensions.height]           Height of canvas element
       * @param {Object}        [options]                     Options object
       * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
       * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      setDimensions: function (dimensions, options) {
        var cssValue;

        options = options || {};

        for (var prop in dimensions) {
          cssValue = dimensions[prop];

          if (!options.cssOnly) {
            this._setBackstoreDimension(prop, dimensions[prop]);
            cssValue += 'px';
            this.hasLostContext = true;
          }

          if (!options.backstoreOnly) {
            this._setCssDimension(prop, cssValue);
          }
        }
        if (this._isCurrentlyDrawing) {
          this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
        }
        this._initRetinaScaling();
        this._setImageSmoothing();
        this.calcOffset();

        if (!options.cssOnly) {
          this.requestRenderAll();
        }

        return this;
      },

      /**
       * Helper for setting width/height
       * @private
       * @param {String} prop property (width|height)
       * @param {Number} value value to set property to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      _setBackstoreDimension: function (prop, value) {
        this.lowerCanvasEl[prop] = value;

        if (this.upperCanvasEl) {
          this.upperCanvasEl[prop] = value;
        }

        if (this.cacheCanvasEl) {
          this.cacheCanvasEl[prop] = value;
        }

        this[prop] = value;

        return this;
      },

      /**
       * Helper for setting css width/height
       * @private
       * @param {String} prop property (width|height)
       * @param {String} value value to set property to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      _setCssDimension: function (prop, value) {
        this.lowerCanvasEl.style[prop] = value;

        if (this.upperCanvasEl) {
          this.upperCanvasEl.style[prop] = value;
        }

        if (this.wrapperEl) {
          this.wrapperEl.style[prop] = value;
        }

        return this;
      },

      /**
       * Returns canvas zoom level
       * @return {Number}
       */
      getZoom: function () {
        return this.viewportTransform[0];
      },

      /**
       * Sets viewport transform of this canvas instance
       * @param {Array} vpt the transform in the form of context.transform
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setViewportTransform: function (vpt) {
        var activeObject = this._activeObject, object, ignoreVpt = false, skipAbsolute = true, i, len;
        this.viewportTransform = vpt;
        for (i = 0, len = this._objects.length; i < len; i++) {
          object = this._objects[i];
          object.group || object.setCoords(ignoreVpt, skipAbsolute);
        }
        if (activeObject && activeObject.type === 'activeSelection') {
          activeObject.setCoords(ignoreVpt, skipAbsolute);
        }
        this.calcViewportBoundaries();
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Sets zoom level of this canvas instance, zoom centered around point
       * @param {fabric.Point} point to zoom with respect to
       * @param {Number} value to set zoom to, less than 1 zooms out
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      zoomToPoint: function (point, value) {
        // TODO: just change the scale, preserve other transformations
        var before = point, vpt = this.viewportTransform.slice(0);
        point = transformPoint(point, invertTransform(this.viewportTransform));
        vpt[0] = value;
        vpt[3] = value;
        var after = transformPoint(point, vpt);
        vpt[4] += before.x - after.x;
        vpt[5] += before.y - after.y;
        return this.setViewportTransform(vpt);
      },

      /**
       * Sets zoom level of this canvas instance
       * @param {Number} value to set zoom to, less than 1 zooms out
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      setZoom: function (value) {
        this.zoomToPoint(new fabric.Point(0, 0), value);
        return this;
      },

      /**
       * Pan viewport so as to place point at top left corner of canvas
       * @param {fabric.Point} point to move to
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      absolutePan: function (point) {
        var vpt = this.viewportTransform.slice(0);
        vpt[4] = -point.x;
        vpt[5] = -point.y;
        return this.setViewportTransform(vpt);
      },

      /**
       * Pans viewpoint relatively
       * @param {fabric.Point} point (position vector) to move by
       * @return {fabric.Canvas} instance
       * @chainable true
       */
      relativePan: function (point) {
        return this.absolutePan(new fabric.Point(
          -point.x - this.viewportTransform[4],
          -point.y - this.viewportTransform[5]
        ));
      },

      /**
       * Returns &lt;canvas> element corresponding to this instance
       * @return {HTMLCanvasElement}
       */
      getElement: function () {
        return this.lowerCanvasEl;
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was added
       */
      _onObjectAdded: function(obj) {
        this.stateful && obj.setupState();
        obj._set('canvas', this);
        obj.setCoords();
        this.fire('object:added', { target: obj });
        obj.fire('added');
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was removed
       */
      _onObjectRemoved: function(obj) {
        this.fire('object:removed', { target: obj });
        obj.fire('removed');
        delete obj.canvas;
      },

      /**
       * Clears specified context of canvas element
       * @param {CanvasRenderingContext2D} ctx Context to clear
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clearContext: function(ctx) {
        ctx.clearRect(0, 0, this.width, this.height);
        return this;
      },

      /**
       * Returns context of canvas where objects are drawn
       * @return {CanvasRenderingContext2D}
       */
      getContext: function () {
        return this.contextContainer;
      },

      /**
       * Clears all contexts (background, main, top) of an instance
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clear: function () {
        this._objects.length = 0;
        this.backgroundImage = null;
        this.overlayImage = null;
        this.backgroundColor = '';
        this.overlayColor = '';
        if (this._hasITextHandlers) {
          this.off('mouse:up', this._mouseUpITextHandler);
          this._iTextInstances = null;
          this._hasITextHandlers = false;
        }
        this.clearContext(this.contextContainer);
        this.fire('canvas:cleared');
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Renders the canvas
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAll: function () {
        var canvasToDrawOn = this.contextContainer;
        this.renderCanvas(canvasToDrawOn, this._objects);
        return this;
      },

      /**
       * Function created to be instance bound at initialization
       * used in requestAnimationFrame rendering
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAndReset: function() {
        this.isRendering = 0;
        this.renderAll();
      },

      /**
       * Append a renderAll request to next animation frame.
       * a boolean flag will avoid appending more.
       * @return {fabric.Canvas} instance
       * @chainable
       */
      requestRenderAll: function () {
        if (!this.isRendering) {
          this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
        }
        return this;
      },

      /**
       * Calculate the position of the 4 corner of canvas with current viewportTransform.
       * helps to determinate when an object is in the current rendering viewport using
       * object absolute coordinates ( aCoords )
       * @return {Object} points.tl
       * @chainable
       */
      calcViewportBoundaries: function() {
        var points = { }, width = this.width, height = this.height,
            iVpt = invertTransform(this.viewportTransform);
        points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
        points.br = transformPoint({ x: width, y: height }, iVpt);
        points.tr = new fabric.Point(points.br.x, points.tl.y);
        points.bl = new fabric.Point(points.tl.x, points.br.y);
        this.vptCoords = points;
        return points;
      },

      /**
       * Renders background, objects, overlay and controls.
       * @param {CanvasRenderingContext2D} ctx
       * @param {Array} objects to render
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderCanvas: function(ctx, objects) {
        var v = this.viewportTransform;
        if (this.isRendering) {
          fabric.util.cancelAnimFrame(this.isRendering);
          this.isRendering = 0;
        }
        this.calcViewportBoundaries();
        this.clearContext(ctx);
        this.fire('before:render');
        if (this.clipTo) {
          fabric.util.clipContext(this, ctx);
        }
        this._renderBackground(ctx);

        ctx.save();
        //apply viewport transform once for all rendering process
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        this._renderObjects(ctx, objects);
        ctx.restore();
        if (!this.controlsAboveOverlay && this.interactive) {
          this.drawControls(ctx);
        }
        if (this.clipTo) {
          ctx.restore();
        }
        this._renderOverlay(ctx);
        if (this.controlsAboveOverlay && this.interactive) {
          this.drawControls(ctx);
        }
        this.fire('after:render');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Array} objects to render
       */
      _renderObjects: function(ctx, objects) {
        var i, len;
        for (i = 0, len = objects.length; i < len; ++i) {
          objects[i] && objects[i].render(ctx);
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {string} property 'background' or 'overlay'
       */
      _renderBackgroundOrOverlay: function(ctx, property) {
        var object = this[property + 'Color'], v;
        if (object) {
          ctx.fillStyle = object.toLive
            ? object.toLive(ctx, this)
            : object;

          ctx.fillRect(
            object.offsetX || 0,
            object.offsetY || 0,
            this.width,
            this.height);
        }
        object = this[property + 'Image'];
        if (object) {
          if (this[property + 'Vpt']) {
            v = this.viewportTransform;
            ctx.save();
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
          }
          object.render(ctx);
          this[property + 'Vpt'] && ctx.restore();
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderBackground: function(ctx) {
        this._renderBackgroundOrOverlay(ctx, 'background');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderOverlay: function(ctx) {
        this._renderBackgroundOrOverlay(ctx, 'overlay');
      },

      /**
       * Returns coordinates of a center of canvas.
       * Returned value is an object with top and left properties
       * @return {Object} object with "top" and "left" number values
       */
      getCenter: function () {
        return {
          top: this.height / 2,
          left: this.width / 2
        };
      },

      /**
       * Centers object horizontally in the canvas
       * @param {fabric.Object} object Object to center horizontally
       * @return {fabric.Canvas} thisArg
       */
      centerObjectH: function (object) {
        return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
      },

      /**
       * Centers object vertically in the canvas
       * @param {fabric.Object} object Object to center vertically
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      centerObjectV: function (object) {
        return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
      },

      /**
       * Centers object vertically and horizontally in the canvas
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      centerObject: function(object) {
        var center = this.getCenter();

        return this._centerObject(object, new fabric.Point(center.left, center.top));
      },

      /**
       * Centers object vertically and horizontally in the viewport
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObject: function(object) {
        var vpCenter = this.getVpCenter();

        return this._centerObject(object, vpCenter);
      },

      /**
       * Centers object horizontally in the viewport, object.top is unchanged
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObjectH: function(object) {
        var vpCenter = this.getVpCenter();
        this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
        return this;
      },

      /**
       * Centers object Vertically in the viewport, object.top is unchanged
       * @param {fabric.Object} object Object to center vertically and horizontally
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      viewportCenterObjectV: function(object) {
        var vpCenter = this.getVpCenter();

        return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
      },

      /**
       * Calculate the point in canvas that correspond to the center of actual viewport.
       * @return {fabric.Point} vpCenter, viewport center
       * @chainable
       */
      getVpCenter: function() {
        var center = this.getCenter(),
            iVpt = invertTransform(this.viewportTransform);
        return transformPoint({ x: center.left, y: center.top }, iVpt);
      },

      /**
       * @private
       * @param {fabric.Object} object Object to center
       * @param {fabric.Point} center Center point
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      _centerObject: function(object, center) {
        object.setPositionByOrigin(center, 'center', 'center');
        object.setCoords();
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Returs dataless JSON representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {String} json string
       */
      toDatalessJSON: function (propertiesToInclude) {
        return this.toDatalessObject(propertiesToInclude);
      },

      /**
       * Returns object representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function (propertiesToInclude) {
        return this._toObjectMethod('toObject', propertiesToInclude);
      },

      /**
       * Returns dataless object representation of canvas
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function (propertiesToInclude) {
        return this._toObjectMethod('toDatalessObject', propertiesToInclude);
      },

      /**
       * @private
       */
      _toObjectMethod: function (methodName, propertiesToInclude) {

        var data = {
          version: fabric.version,
          objects: this._toObjects(methodName, propertiesToInclude)
        };

        extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

        fabric.util.populateWithProperties(this, data, propertiesToInclude);

        return data;
      },

      /**
       * @private
       */
      _toObjects: function(methodName, propertiesToInclude) {
        return this.getObjects().filter(function(object) {
          return !object.excludeFromExport;
        }).map(function(instance) {
          return this._toObject(instance, methodName, propertiesToInclude);
        }, this);
      },

      /**
       * @private
       */
      _toObject: function(instance, methodName, propertiesToInclude) {
        var originalValue;

        if (!this.includeDefaultValues) {
          originalValue = instance.includeDefaultValues;
          instance.includeDefaultValues = false;
        }

        var object = instance[methodName](propertiesToInclude);
        if (!this.includeDefaultValues) {
          instance.includeDefaultValues = originalValue;
        }
        return object;
      },

      /**
       * @private
       */
      __serializeBgOverlay: function(methodName, propertiesToInclude) {
        var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

        if (this.backgroundColor) {
          data.background = this.backgroundColor.toObject
            ? this.backgroundColor.toObject(propertiesToInclude)
            : this.backgroundColor;
        }

        if (this.overlayColor) {
          data.overlay = this.overlayColor.toObject
            ? this.overlayColor.toObject(propertiesToInclude)
            : this.overlayColor;
        }
        if (bgImage && !bgImage.excludeFromExport) {
          data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
        }
        if (overlay && !overlay.excludeFromExport) {
          data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
        }

        return data;
      },

      /* _TO_SVG_START_ */
      /**
       * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
       * a zoomed canvas will then produce zoomed SVG output.
       * @type Boolean
       * @default
       */
      svgViewportTransformation: true,

      /**
       * Returns SVG representation of canvas
       * @function
       * @param {Object} [options] Options object for SVG output
       * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
       * @param {Object} [options.viewBox] SVG viewbox object
       * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
       * @param {Number} [options.viewBox.y] y-coordinate of viewbox
       * @param {Number} [options.viewBox.width] Width of viewbox
       * @param {Number} [options.viewBox.height] Height of viewbox
       * @param {String} [options.encoding=UTF-8] Encoding of SVG output
       * @param {String} [options.width] desired width of svg with or without units
       * @param {String} [options.height] desired height of svg with or without units
       * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
       * @return {String} SVG string
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
       * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
       * @example <caption>Normal SVG output</caption>
       * var svg = canvas.toSVG();
       * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
       * var svg = canvas.toSVG({suppressPreamble: true});
       * @example <caption>SVG output with viewBox attribute</caption>
       * var svg = canvas.toSVG({
       *   viewBox: {
       *     x: 100,
       *     y: 100,
       *     width: 200,
       *     height: 300
       *   }
       * });
       * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
       * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
       * @example <caption>Modify SVG output with reviver function</caption>
       * var svg = canvas.toSVG(null, function(svg) {
       *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
       * });
       */
      toSVG: function(options, reviver) {
        options || (options = { });

        var markup = [];

        this._setSVGPreamble(markup, options);
        this._setSVGHeader(markup, options);

        this._setSVGBgOverlayColor(markup, 'backgroundColor');
        this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);

        this._setSVGObjects(markup, reviver);

        this._setSVGBgOverlayColor(markup, 'overlayColor');
        this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

        markup.push('</svg>');

        return markup.join('');
      },

      /**
       * @private
       */
      _setSVGPreamble: function(markup, options) {
        if (options.suppressPreamble) {
          return;
        }
        markup.push(
          '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
          '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
          '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
        );
      },

      /**
       * @private
       */
      _setSVGHeader: function(markup, options) {
        var width = options.width || this.width,
            height = options.height || this.height,
            vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

        if (options.viewBox) {
          viewBox = 'viewBox="' +
                  options.viewBox.x + ' ' +
                  options.viewBox.y + ' ' +
                  options.viewBox.width + ' ' +
                  options.viewBox.height + '" ';
        }
        else {
          if (this.svgViewportTransformation) {
            vpt = this.viewportTransform;
            viewBox = 'viewBox="' +
                    toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
          }
        }

        markup.push(
          '<svg ',
          'xmlns="http://www.w3.org/2000/svg" ',
          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
          'version="1.1" ',
          'width="', width, '" ',
          'height="', height, '" ',
          viewBox,
          'xml:space="preserve">\n',
          '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
          '<defs>\n',
          this.createSVGFontFacesMarkup(),
          this.createSVGRefElementsMarkup(),
          '</defs>\n'
        );
      },

      /**
       * Creates markup containing SVG referenced elements like patterns, gradients etc.
       * @return {String}
       */
      createSVGRefElementsMarkup: function() {
        var _this = this,
            markup = ['backgroundColor', 'overlayColor'].map(function(prop) {
              var fill = _this[prop];
              if (fill && fill.toLive) {
                return fill.toSVG(_this, false);
              }
            });
        return markup.join('');
      },

      /**
       * Creates markup containing SVG font faces,
       * font URLs for font faces must be collected by developers
       * and are not extracted from the DOM by fabricjs
       * @param {Array} objects Array of fabric objects
       * @return {String}
       */
      createSVGFontFacesMarkup: function() {
        var markup = '', fontList = { }, obj, fontFamily,
            style, row, rowIndex, _char, charIndex, i, len,
            fontPaths = fabric.fontPaths, objects = this.getObjects();

        for (i = 0, len = objects.length; i < len; i++) {
          obj = objects[i];
          fontFamily = obj.fontFamily;
          if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
            continue;
          }
          fontList[fontFamily] = true;
          if (!obj.styles) {
            continue;
          }
          style = obj.styles;
          for (rowIndex in style) {
            row = style[rowIndex];
            for (charIndex in row) {
              _char = row[charIndex];
              fontFamily = _char.fontFamily;
              if (!fontList[fontFamily] && fontPaths[fontFamily]) {
                fontList[fontFamily] = true;
              }
            }
          }
        }

        for (var j in fontList) {
          markup += [
            '\t\t@font-face {\n',
            '\t\t\tfont-family: \'', j, '\';\n',
            '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
            '\t\t}\n'
          ].join('');
        }

        if (markup) {
          markup = [
            '\t<style type="text/css">',
            '<![CDATA[\n',
            markup,
            ']]>',
            '</style>\n'
          ].join('');
        }

        return markup;
      },

      /**
       * @private
       */
      _setSVGObjects: function(markup, reviver) {
        var instance, i, len, objects = this.getObjects();
        for (i = 0, len = objects.length; i < len; i++) {
          instance = objects[i];
          if (instance.excludeFromExport) {
            continue;
          }
          this._setSVGObject(markup, instance, reviver);
        }
      },

      /**
       * @private
       */
      _setSVGObject: function(markup, instance, reviver) {
        markup.push(instance.toSVG(reviver));
      },

      /**
       * @private
       */
      _setSVGBgOverlayImage: function(markup, property, reviver) {
        if (this[property] && this[property].toSVG) {
          markup.push(this[property].toSVG(reviver));
        }
      },

      /**
       * @private
       */
      _setSVGBgOverlayColor: function(markup, property) {
        var filler = this[property], vpt = this.viewportTransform, finalWidth = this.width / vpt[0],
            finalHeight = this.height / vpt[3];
        if (!filler) {
          return;
        }
        if (filler.toLive) {
          var repeat = filler.repeat;
          markup.push(
            '<rect transform="translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
            ' x="', filler.offsetX - finalWidth / 2, '" y="', filler.offsetY - finalHeight / 2, '" ',
            'width="',
            (repeat === 'repeat-y' || repeat === 'no-repeat'
              ? filler.source.width
              : finalWidth ),
            '" height="',
            (repeat === 'repeat-x' || repeat === 'no-repeat'
              ? filler.source.height
              : finalHeight),
            '" fill="url(#SVGID_' + filler.id + ')"',
            '></rect>\n'
          );
        }
        else {
          markup.push(
            '<rect x="0" y="0" width="100%" height="100%" ',
            'fill="', this[property], '"',
            '></rect>\n'
          );
        }
      },
      /* _TO_SVG_END_ */

      /**
       * Moves an object or the objects of a multiple selection
       * to the bottom of the stack of drawn objects
       * @param {fabric.Object} object Object to send to back
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      sendToBack: function (object) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, objs;
        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = objs.length; i--;) {
            obj = objs[i];
            removeFromArray(this._objects, obj);
            this._objects.unshift(obj);
          }
        }
        else {
          removeFromArray(this._objects, object);
          this._objects.unshift(object);
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Moves an object or the objects of a multiple selection
       * to the top of the stack of drawn objects
       * @param {fabric.Object} object Object to send
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      bringToFront: function (object) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, objs;
        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = 0; i < objs.length; i++) {
            obj = objs[i];
            removeFromArray(this._objects, obj);
            this._objects.push(obj);
          }
        }
        else {
          removeFromArray(this._objects, object);
          this._objects.push(object);
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * Moves an object or a selection down in stack of drawn objects
       * An optional paramter, intersecting allowes to move the object in behind
       * the first intersecting object. Where intersection is calculated with
       * bounding box. If no intersection is found, there will not be change in the
       * stack.
       * @param {fabric.Object} object Object to send
       * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      sendBackwards: function (object, intersecting) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, idx, newIdx, objs, objsMoved = 0;

        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = 0; i < objs.length; i++) {
            obj = objs[i];
            idx = this._objects.indexOf(obj);
            if (idx > 0 + objsMoved) {
              newIdx = idx - 1;
              removeFromArray(this._objects, obj);
              this._objects.splice(newIdx, 0, obj);
            }
            objsMoved++;
          }
        }
        else {
          idx = this._objects.indexOf(object);
          if (idx !== 0) {
            // if object is not on the bottom of stack
            newIdx = this._findNewLowerIndex(object, idx, intersecting);
            removeFromArray(this._objects, object);
            this._objects.splice(newIdx, 0, object);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * @private
       */
      _findNewLowerIndex: function(object, idx, intersecting) {
        var newIdx, i;

        if (intersecting) {
          newIdx = idx;

          // traverse down the stack looking for the nearest intersecting object
          for (i = idx - 1; i >= 0; --i) {

            var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                                 object.isContainedWithinObject(this._objects[i]) ||
                                 this._objects[i].isContainedWithinObject(object);

            if (isIntersecting) {
              newIdx = i;
              break;
            }
          }
        }
        else {
          newIdx = idx - 1;
        }

        return newIdx;
      },

      /**
       * Moves an object or a selection up in stack of drawn objects
       * An optional paramter, intersecting allowes to move the object in front
       * of the first intersecting object. Where intersection is calculated with
       * bounding box. If no intersection is found, there will not be change in the
       * stack.
       * @param {fabric.Object} object Object to send
       * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      bringForward: function (object, intersecting) {
        if (!object) {
          return this;
        }
        var activeSelection = this._activeObject,
            i, obj, idx, newIdx, objs, objsMoved = 0;

        if (object === activeSelection && object.type === 'activeSelection') {
          objs = activeSelection._objects;
          for (i = objs.length; i--;) {
            obj = objs[i];
            idx = this._objects.indexOf(obj);
            if (idx < this._objects.length - 1 - objsMoved) {
              newIdx = idx + 1;
              removeFromArray(this._objects, obj);
              this._objects.splice(newIdx, 0, obj);
            }
            objsMoved++;
          }
        }
        else {
          idx = this._objects.indexOf(object);
          if (idx !== this._objects.length - 1) {
            // if object is not on top of stack (last item in an array)
            newIdx = this._findNewUpperIndex(object, idx, intersecting);
            removeFromArray(this._objects, object);
            this._objects.splice(newIdx, 0, object);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },

      /**
       * @private
       */
      _findNewUpperIndex: function(object, idx, intersecting) {
        var newIdx, i, len;

        if (intersecting) {
          newIdx = idx;

          // traverse up the stack looking for the nearest intersecting object
          for (i = idx + 1, len = this._objects.length; i < len; ++i) {

            var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                                 object.isContainedWithinObject(this._objects[i]) ||
                                 this._objects[i].isContainedWithinObject(object);

            if (isIntersecting) {
              newIdx = i;
              break;
            }
          }
        }
        else {
          newIdx = idx + 1;
        }

        return newIdx;
      },

      /**
       * Moves an object to specified level in stack of drawn objects
       * @param {fabric.Object} object Object to send
       * @param {Number} index Position to move to
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      moveTo: function (object, index) {
        removeFromArray(this._objects, object);
        this._objects.splice(index, 0, object);
        return this.renderOnAddRemove && this.requestRenderAll();
      },

      /**
       * Clears a canvas element and dispose objects
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      dispose: function () {
        // cancel eventually ongoing renders
        if (this.isRendering) {
          fabric.util.cancelAnimFrame(this.isRendering);
          this.isRendering = 0;
        }
        this.forEachObject(function(object) {
          object.dispose && object.dispose();
        });
        this._objects = [];
        this.backgroundImage = null;
        this.overlayImage = null;
        this._iTextInstances = null;
        this.lowerCanvasEl = null;
        this.contextContainer = null;
        return this;
      },

      /**
       * Returns a string representation of an instance
       * @return {String} string representation of an instance
       */
      toString: function () {
        return '#<fabric.Canvas (' + this.complexity() + '): ' +
                 '{ objects: ' + this.getObjects().length + ' }>';
      }
    });

    extend(fabric.StaticCanvas.prototype, fabric.Observable);
    extend(fabric.StaticCanvas.prototype, fabric.Collection);
    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

      /**
       * @static
       * @type String
       * @default
       */
      EMPTY_JSON: '{"objects": [], "background": "white"}',

      /**
       * Provides a way to check support of some of the canvas methods
       * (either those of HTMLCanvasElement itself, or rendering context)
       *
       * @param {String} methodName Method to check support for;
       *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
       * @return {Boolean | null} `true` if method is supported (or at least exists),
       *                          `null` if canvas element or context can not be initialized
       */
      supports: function (methodName) {
        var el = fabric.util.createCanvasElement();

        if (!el || !el.getContext) {
          return null;
        }

        var ctx = el.getContext('2d');
        if (!ctx) {
          return null;
        }

        switch (methodName) {

          case 'getImageData':
            return typeof ctx.getImageData !== 'undefined';

          case 'setLineDash':
            return typeof ctx.setLineDash !== 'undefined';

          case 'toDataURL':
            return typeof el.toDataURL !== 'undefined';

          case 'toDataURLWithQuality':
            try {
              el.toDataURL('image/jpeg', 0);
              return true;
            }
            catch (e) { }
            return false;

          default:
            return null;
        }
      }
    });

    /**
     * Returns JSON representation of canvas
     * @function
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} JSON string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
     * @example <caption>JSON without additional properties</caption>
     * var json = canvas.toJSON();
     * @example <caption>JSON with additional properties included</caption>
     * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
     * @example <caption>JSON without default values</caption>
     * canvas.includeDefaultValues = false;
     * var json = canvas.toJSON();
     */
    fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

    if (fabric.isLikelyNode) {
      fabric.StaticCanvas.prototype.createPNGStream = function() {
        var impl = fabric.util.getNodeCanvas(this.lowerCanvasEl);
        return impl && impl.createPNGStream();
      };
      fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
        var impl = fabric.util.getNodeCanvas(this.lowerCanvasEl);
        return impl && impl.createJPEGStream(opts);
      };
    }
  })();


  /**
   * BaseBrush class
   * @class fabric.BaseBrush
   * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
   */
  fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

    /**
     * Color of a brush
     * @type String
     * @default
     */
    color: 'rgb(0, 0, 0)',

    /**
     * Width of a brush, has to be a Number, no string literals
     * @type Number
     * @default
     */
    width: 1,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
     * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
     * @type fabric.Shadow
     * @default
     */
    shadow: null,

    /**
     * Line endings style of a brush (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap: 'round',

    /**
     * Corner style of a brush (one of "bevel", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin: 'round',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
     * @type Number
     * @default
     */
    strokeMiterLimit:         10,

    /**
     * Stroke Dash Array.
     * @type Array
     * @default
     */
    strokeDashArray: null,

    /**
     * Sets shadow of an object
     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setShadow: function(options) {
      this.shadow = new fabric.Shadow(options);
      return this;
    },

    /**
     * Sets brush styles
     * @private
     */
    _setBrushStyles: function() {
      var ctx = this.canvas.contextTop;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.width;
      ctx.lineCap = this.strokeLineCap;
      ctx.miterLimit = this.strokeMiterLimit;
      ctx.lineJoin = this.strokeLineJoin;
      if (fabric.StaticCanvas.supports('setLineDash')) {
        ctx.setLineDash(this.strokeDashArray || []);
      }
    },

    /**
     * Sets the transformation on given context
     * @param {RenderingContext2d} ctx context to render on
     * @private
     */
    _saveAndTransform: function(ctx) {
      var v = this.canvas.viewportTransform;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
    },

    /**
     * Sets brush shadow styles
     * @private
     */
    _setShadow: function() {
      if (!this.shadow) {
        return;
      }

      var ctx = this.canvas.contextTop,
          zoom = this.canvas.getZoom();

      ctx.shadowColor = this.shadow.color;
      ctx.shadowBlur = this.shadow.blur * zoom;
      ctx.shadowOffsetX = this.shadow.offsetX * zoom;
      ctx.shadowOffsetY = this.shadow.offsetY * zoom;
    },

    /**
     * Removes brush shadow styles
     * @private
     */
    _resetShadow: function() {
      var ctx = this.canvas.contextTop;

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    }
  });


  (function() {

    /**
     * PencilBrush class
     * @class fabric.PencilBrush
     * @extends fabric.BaseBrush
     */
    fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

      /**
       * Constructor
       * @param {fabric.Canvas} canvas
       * @return {fabric.PencilBrush} Instance of a pencil brush
       */
      initialize: function(canvas) {
        this.canvas = canvas;
        this._points = [];
      },

      /**
       * Invoked inside on mouse down and mouse move
       * @param {Object} pointer
       */
      _drawSegment: function (ctx, p1, p2) {
        var midPoint = p1.midPointFrom(p2);
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        return midPoint;
      },

      /**
       * Inovoked on mouse down
       * @param {Object} pointer
       */
      onMouseDown: function(pointer) {
        this._prepareForDrawing(pointer);
        // capture coordinates immediately
        // this allows to draw dots (when movement never occurs)
        this._captureDrawingPath(pointer);
        this._render();
      },

      /**
       * Inovoked on mouse move
       * @param {Object} pointer
       */
      onMouseMove: function(pointer) {
        if (this._captureDrawingPath(pointer) && this._points.length > 1) {
          if (this.needsFullRender) {
            // redraw curve
            // clear top canvas
            this.canvas.clearContext(this.canvas.contextTop);
            this._render();
          }
          else {
            var points = this._points, length = points.length, ctx = this.canvas.contextTop;
            // draw the curve update
            this._saveAndTransform(ctx);
            if (this.oldEnd) {
              ctx.beginPath();
              ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
            }
            this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
            ctx.stroke();
            ctx.restore();
          }
        }
      },

      /**
       * Invoked on mouse up
       */
      onMouseUp: function() {
        this.oldEnd = undefined;
        this._finalizeAndAddPath();
      },

      /**
       * @private
       * @param {Object} pointer Actual mouse position related to the canvas.
       */
      _prepareForDrawing: function(pointer) {

        var p = new fabric.Point(pointer.x, pointer.y);

        this._reset();
        this._addPoint(p);
        this.canvas.contextTop.moveTo(p.x, p.y);
      },

      /**
       * @private
       * @param {fabric.Point} point Point to be added to points array
       */
      _addPoint: function(point) {
        if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
          return false;
        }
        this._points.push(point);
        return true;
      },

      /**
       * Clear points array and set contextTop canvas style.
       * @private
       */
      _reset: function() {
        this._points.length = 0;
        this._setBrushStyles();
        var color = new fabric.Color(this.color);
        this.needsFullRender = (color.getAlpha() < 1);
        this._setShadow();
      },

      /**
       * @private
       * @param {Object} pointer Actual mouse position related to the canvas.
       */
      _captureDrawingPath: function(pointer) {
        var pointerPoint = new fabric.Point(pointer.x, pointer.y);
        return this._addPoint(pointerPoint);
      },

      /**
       * Draw a smooth path on the topCanvas using quadraticCurveTo
       * @private
       */
      _render: function() {
        var ctx  = this.canvas.contextTop, i, len,
            p1 = this._points[0],
            p2 = this._points[1];

        this._saveAndTransform(ctx);
        ctx.beginPath();
        //if we only have 2 points in the path and they are the same
        //it means that the user only clicked the canvas without moving the mouse
        //then we should be drawing a dot. A path isn't drawn between two identical dots
        //that's why we set them apart a bit
        if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
          var width = this.width / 1000;
          p1 = new fabric.Point(p1.x, p1.y);
          p2 = new fabric.Point(p2.x, p2.y);
          p1.x -= width;
          p2.x += width;
        }
        ctx.moveTo(p1.x, p1.y);

        for (i = 1, len = this._points.length; i < len; i++) {
          // we pick the point between pi + 1 & pi + 2 as the
          // end point and p1 as our control point.
          this._drawSegment(ctx, p1, p2);
          p1 = this._points[i];
          p2 = this._points[i + 1];
        }
        // Draw last line as a straight line while
        // we wait for the next point to be able to calculate
        // the bezier control point
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
        ctx.restore();
      },

      /**
       * Converts points to SVG path
       * @param {Array} points Array of points
       * @return {String} SVG path
       */
      convertPointsToSVGPath: function(points) {
        var path = [], i, width = this.width / 1000,
            p1 = new fabric.Point(points[0].x, points[0].y),
            p2 = new fabric.Point(points[1].x, points[1].y),
            len = points.length, multSignX = 1, multSignY = 1, manyPoints = len > 2;

        if (manyPoints) {
          multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
          multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
        }
        path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');
        for (i = 1; i < len; i++) {
          if (!p1.eq(p2)) {
            var midPoint = p1.midPointFrom(p2);
            // p1 is our bezier control point
            // midpoint is our endpoint
            // start point is p(i-1) value.
            path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
          }
          p1 = points[i];
          if ((i + 1) < points.length) {
            p2 = points[i + 1];
          }
        }
        if (manyPoints) {
          multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
          multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
        }
        path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);
        return path;
      },

      /**
       * Creates fabric.Path object to add on canvas
       * @param {String} pathData Path data
       * @return {fabric.Path} Path to add on canvas
       */
      createPath: function(pathData) {
        var path = new fabric.Path(pathData, {
          fill: null,
          stroke: this.color,
          strokeWidth: this.width,
          strokeLineCap: this.strokeLineCap,
          strokeMiterLimit: this.strokeMiterLimit,
          strokeLineJoin: this.strokeLineJoin,
          strokeDashArray: this.strokeDashArray,
        });
        var position = new fabric.Point(path.left + path.width / 2, path.top + path.height / 2);
        position = path.translateToGivenOrigin(position, 'center', 'center', path.originX, path.originY);
        path.top = position.y;
        path.left = position.x;
        if (this.shadow) {
          this.shadow.affectStroke = true;
          path.setShadow(this.shadow);
        }

        return path;
      },

      /**
       * On mouseup after drawing the path on contextTop canvas
       * we use the points captured to create an new fabric path object
       * and add it to the fabric canvas.
       */
      _finalizeAndAddPath: function() {
        var ctx = this.canvas.contextTop;
        ctx.closePath();

        var pathData = this.convertPointsToSVGPath(this._points).join('');
        if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
          // do not create 0 width/height paths, as they are
          // rendered inconsistently across browsers
          // Firefox 4, for example, renders a dot,
          // whereas Chrome 10 renders nothing
          this.canvas.requestRenderAll();
          return;
        }

        var path = this.createPath(pathData);
        this.canvas.clearContext(this.canvas.contextTop);
        this.canvas.add(path);
        this.canvas.renderAll();
        path.setCoords();
        this._resetShadow();


        // fire event 'path' created
        this.canvas.fire('path:created', { path: path });
      }
    });
  })();


  /**
   * CircleBrush class
   * @class fabric.CircleBrush
   */
  fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

    /**
     * Width of a brush
     * @type Number
     * @default
     */
    width: 10,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.CircleBrush} Instance of a circle brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this.points = [];
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    drawDot: function(pointer) {
      var point = this.addPoint(pointer),
          ctx = this.canvas.contextTop;
      this._saveAndTransform(ctx);
      ctx.fillStyle = point.fill;
      ctx.beginPath();
      ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    },

    /**
     * Invoked on mouse down
     */
    onMouseDown: function(pointer) {
      this.points.length = 0;
      this.canvas.clearContext(this.canvas.contextTop);
      this._setShadow();
      this.drawDot(pointer);
    },

    /**
     * Render the full state of the brush
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          points = this.points, point;
      this._saveAndTransform(ctx);
      for (i = 0, len = points.length; i < len; i++) {
        point = points[i];
        ctx.fillStyle = point.fill;
        ctx.beginPath();
        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      this.drawDot(pointer);
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
      this.canvas.renderOnAddRemove = false;

      var circles = [];

      for (i = 0, len = this.points.length; i < len; i++) {
        var point = this.points[i],
            circle = new fabric.Circle({
              radius: point.radius,
              left: point.x,
              top: point.y,
              originX: 'center',
              originY: 'center',
              fill: point.fill
            });

        this.shadow && circle.setShadow(this.shadow);

        circles.push(circle);
      }
      var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });
      group.canvas = this.canvas;

      this.canvas.add(group);
      this.canvas.fire('path:created', { path: group });

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
      this.canvas.requestRenderAll();
    },

    /**
     * @param {Object} pointer
     * @return {fabric.Point} Just added pointer point
     */
    addPoint: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y),

          circleRadius = fabric.util.getRandomInt(
            Math.max(0, this.width - 20), this.width + 20) / 2,

          circleColor = new fabric.Color(this.color)
            .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
            .toRgba();

      pointerPoint.radius = circleRadius;
      pointerPoint.fill = circleColor;

      this.points.push(pointerPoint);

      return pointerPoint;
    }
  });


  /**
   * SprayBrush class
   * @class fabric.SprayBrush
   */
  fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

    /**
     * Width of a spray
     * @type Number
     * @default
     */
    width:              10,

    /**
     * Density of a spray (number of dots per chunk)
     * @type Number
     * @default
     */
    density:            20,

    /**
     * Width of spray dots
     * @type Number
     * @default
     */
    dotWidth:           1,

    /**
     * Width variance of spray dots
     * @type Number
     * @default
     */
    dotWidthVariance:   1,

    /**
     * Whether opacity of a dot should be random
     * @type Boolean
     * @default
     */
    randomOpacity:        false,

    /**
     * Whether overlapping dots (rectangles) should be removed (for performance reasons)
     * @type Boolean
     * @default
     */
    optimizeOverlapping:  true,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.SprayBrush} Instance of a spray brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this.sprayChunks = [];
    },

    /**
     * Invoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer) {
      this.sprayChunks.length = 0;
      this.canvas.clearContext(this.canvas.contextTop);
      this._setShadow();

      this.addSprayChunk(pointer);
      this.render(this.sprayChunkPoints);
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      this.addSprayChunk(pointer);
      this.render(this.sprayChunkPoints);
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
      this.canvas.renderOnAddRemove = false;

      var rects = [];

      for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
        var sprayChunk = this.sprayChunks[i];

        for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

          var rect = new fabric.Rect({
            width: sprayChunk[j].width,
            height: sprayChunk[j].width,
            left: sprayChunk[j].x + 1,
            top: sprayChunk[j].y + 1,
            originX: 'center',
            originY: 'center',
            fill: this.color
          });
          rects.push(rect);
        }
      }

      if (this.optimizeOverlapping) {
        rects = this._getOptimizedRects(rects);
      }

      var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });
      this.shadow && group.setShadow(this.shadow);
      this.canvas.add(group);
      this.canvas.fire('path:created', { path: group });

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
      this.canvas.requestRenderAll();
    },

    /**
     * @private
     * @param {Array} rects
     */
    _getOptimizedRects: function(rects) {

      // avoid creating duplicate rects at the same coordinates
      var uniqueRects = { }, key, i, len;

      for (i = 0, len = rects.length; i < len; i++) {
        key = rects[i].left + '' + rects[i].top;
        if (!uniqueRects[key]) {
          uniqueRects[key] = rects[i];
        }
      }
      var uniqueRectsArray = [];
      for (key in uniqueRects) {
        uniqueRectsArray.push(uniqueRects[key]);
      }

      return uniqueRectsArray;
    },

    /**
     * Render new chunk of spray brush
     */
    render: function(sprayChunk) {
      var ctx = this.canvas.contextTop, i, len;
      ctx.fillStyle = this.color;

      this._saveAndTransform(ctx);

      for (i = 0, len = sprayChunk.length; i < len; i++) {
        var point = sprayChunk[i];
        if (typeof point.opacity !== 'undefined') {
          ctx.globalAlpha = point.opacity;
        }
        ctx.fillRect(point.x, point.y, point.width, point.width);
      }
      ctx.restore();
    },

    /**
     * Render all spray chunks
     */
    _render: function() {
      var ctx = this.canvas.contextTop, i, ilen;
      ctx.fillStyle = this.color;

      this._saveAndTransform(ctx);

      for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
        this.render(this.sprayChunks[i]);
      }
      ctx.restore();
    },

    /**
     * @param {Object} pointer
     */
    addSprayChunk: function(pointer) {
      this.sprayChunkPoints = [];

      var x, y, width, radius = this.width / 2, i;

      for (i = 0; i < this.density; i++) {

        x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
        y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

        if (this.dotWidthVariance) {
          width = fabric.util.getRandomInt(
            // bottom clamp width to 1
            Math.max(1, this.dotWidth - this.dotWidthVariance),
            this.dotWidth + this.dotWidthVariance);
        }
        else {
          width = this.dotWidth;
        }

        var point = new fabric.Point(x, y);
        point.width = width;

        if (this.randomOpacity) {
          point.opacity = fabric.util.getRandomInt(0, 100) / 100;
        }

        this.sprayChunkPoints.push(point);
      }

      this.sprayChunks.push(this.sprayChunkPoints);
    }
  });


  /**
   * PatternBrush class
   * @class fabric.PatternBrush
   * @extends fabric.BaseBrush
   */
  fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

    getPatternSrc: function() {

      var dotWidth = 20,
          dotDistance = 5,
          patternCanvas = fabric.document.createElement('canvas'),
          patternCtx = patternCanvas.getContext('2d');

      patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

      patternCtx.fillStyle = this.color;
      patternCtx.beginPath();
      patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
      patternCtx.closePath();
      patternCtx.fill();

      return patternCanvas;
    },

    getPatternSrcFunction: function() {
      return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
    },

    /**
     * Creates "pattern" instance property
     */
    getPattern: function() {
      return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
    },

    /**
     * Sets brush styles
     */
    _setBrushStyles: function() {
      this.callSuper('_setBrushStyles');
      this.canvas.contextTop.strokeStyle = this.getPattern();
    },

    /**
     * Creates path
     */
    createPath: function(pathData) {
      var path = this.callSuper('createPath', pathData),
          topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

      path.stroke = new fabric.Pattern({
        source: this.source || this.getPatternSrcFunction(),
        offsetX: -topLeft.x,
        offsetY: -topLeft.y
      });
      return path;
    }
  });


  (function() {

    var getPointer = fabric.util.getPointer,
        degreesToRadians = fabric.util.degreesToRadians,
        radiansToDegrees = fabric.util.radiansToDegrees,
        atan2 = Math.atan2,
        abs = Math.abs,
        supportLineDash = fabric.StaticCanvas.supports('setLineDash'),

        STROKE_OFFSET = 0.5;

    /**
     * Canvas class
     * @class fabric.Canvas
     * @extends fabric.StaticCanvas
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
     * @see {@link fabric.Canvas#initialize} for constructor definition
     *
     * @fires object:modified
     * @fires object:rotated
     * @fires object:scaled
     * @fires object:moved
     * @fires object:skewed
     * @fires object:rotating
     * @fires object:scaling
     * @fires object:moving
     * @fires object:skewing
     * @fires object:selected this event is deprecated. use selection:created
     *
     * @fires before:transform
     * @fires before:selection:cleared
     * @fires selection:cleared
     * @fires selection:updated
     * @fires selection:created
     *
     * @fires path:created
     * @fires mouse:down
     * @fires mouse:move
     * @fires mouse:up
     * @fires mouse:down:before
     * @fires mouse:move:before
     * @fires mouse:up:before
     * @fires mouse:over
     * @fires mouse:out
     * @fires mouse:dblclick
     *
     * @fires dragover
     * @fires dragenter
     * @fires dragleave
     * @fires drop
     *
     */
    fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

      /**
       * Constructor
       * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(el, options) {
        options || (options = { });
        this.renderAndResetBound = this.renderAndReset.bind(this);
        this._initStatic(el, options);
        this._initInteractive();
        this._createCacheCanvas();
      },

      /**
       * When true, objects can be transformed by one side (unproportionally)
       * @type Boolean
       * @default
       */
      uniScaleTransform:      false,

      /**
       * Indicates which key enable unproportional scaling
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      uniScaleKey:           'shiftKey',

      /**
       * When true, objects use center point as the origin of scale transformation.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredScaling:        false,

      /**
       * When true, objects use center point as the origin of rotate transformation.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredRotation:       false,

      /**
       * Indicates which key enable centered Transform
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      centeredKey:           'altKey',

      /**
       * Indicates which key enable alternate action on corner
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled feature disabled.
       * @since 1.6.2
       * @type String
       * @default
       */
      altActionKey:           'shiftKey',

      /**
       * Indicates that canvas is interactive. This property should not be changed.
       * @type Boolean
       * @default
       */
      interactive:            true,

      /**
       * Indicates whether group selection should be enabled
       * @type Boolean
       * @default
       */
      selection:              true,

      /**
       * Indicates which key or keys enable multiple click selection
       * Pass value as a string or array of strings
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * If `null` or empty or containing any other string that is not a modifier key
       * feature is disabled.
       * @since 1.6.2
       * @type String|Array
       * @default
       */
      selectionKey:           'shiftKey',

      /**
       * Indicates which key enable alternative selection
       * in case of target overlapping with active object
       * values: 'altKey', 'shiftKey', 'ctrlKey'.
       * For a series of reason that come from the general expectations on how
       * things should work, this feature works only for preserveObjectStacking true.
       * If `null` or 'none' or any other string that is not a modifier key
       * feature is disabled.
       * @since 1.6.5
       * @type null|String
       * @default
       */
      altSelectionKey:           null,

      /**
       * Color of selection
       * @type String
       * @default
       */
      selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

      /**
       * Default dash array pattern
       * If not empty the selection border is dashed
       * @type Array
       */
      selectionDashArray:     [],

      /**
       * Color of the border of selection (usually slightly darker than color of selection itself)
       * @type String
       * @default
       */
      selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

      /**
       * Width of a line used in object/group selection
       * @type Number
       * @default
       */
      selectionLineWidth:     1,

      /**
       * Select only shapes that are fully contained in the dragged selection rectangle.
       * @type Boolean
       * @default
       */
      selectionFullyContained: false,

      /**
       * Default cursor value used when hovering over an object on canvas
       * @type String
       * @default
       */
      hoverCursor:            'move',

      /**
       * Default cursor value used when moving an object on canvas
       * @type String
       * @default
       */
      moveCursor:             'move',

      /**
       * Default cursor value used for the entire canvas
       * @type String
       * @default
       */
      defaultCursor:          'default',

      /**
       * Cursor value used during free drawing
       * @type String
       * @default
       */
      freeDrawingCursor:      'crosshair',

      /**
       * Cursor value used for rotation point
       * @type String
       * @default
       */
      rotationCursor:         'crosshair',

      /**
       * Cursor value used for disabled elements ( corners with disabled action )
       * @type String
       * @since 2.0.0
       * @default
       */
      notAllowedCursor:         'not-allowed',

      /**
       * Default element class that's given to wrapper (div) element of canvas
       * @type String
       * @default
       */
      containerClass:         'canvas-container',

      /**
       * When true, object detection happens on per-pixel basis rather than on per-bounding-box
       * @type Boolean
       * @default
       */
      perPixelTargetFind:     false,

      /**
       * Number of pixels around target pixel to tolerate (consider active) during object detection
       * @type Number
       * @default
       */
      targetFindTolerance:    0,

      /**
       * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
       * @type Boolean
       * @default
       */
      skipTargetFind:         false,

      /**
       * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
       * After mousedown, mousemove creates a shape,
       * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
       * @type Boolean
       * @default
       */
      isDrawingMode:          false,

      /**
       * Indicates whether objects should remain in current stack position when selected.
       * When false objects are brought to top and rendered as part of the selection group
       * @type Boolean
       * @default
       */
      preserveObjectStacking: false,

      /**
       * Indicates the angle that an object will lock to while rotating.
       * @type Number
       * @since 1.6.7
       * @default
       */
      snapAngle: 0,

      /**
       * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
       * When `null`, the snapThreshold will default to the snapAngle.
       * @type null|Number
       * @since 1.6.7
       * @default
       */
      snapThreshold: null,

      /**
       * Indicates if the right click on canvas can output the context menu or not
       * @type Boolean
       * @since 1.6.5
       * @default
       */
      stopContextMenu: false,

      /**
       * Indicates if the canvas can fire right click events
       * @type Boolean
       * @since 1.6.5
       * @default
       */
      fireRightClick: false,

      /**
       * Indicates if the canvas can fire middle click events
       * @type Boolean
       * @since 1.7.8
       * @default
       */
      fireMiddleClick: false,

      /**
       * @private
       */
      _initInteractive: function() {
        this._currentTransform = null;
        this._groupSelector = null;
        this._initWrapperElement();
        this._createUpperCanvas();
        this._initEventListeners();

        this._initRetinaScaling();

        this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

        this.calcOffset();
      },

      /**
       * Divides objects in two groups, one to render immediately
       * and one to render as activeGroup.
       * @return {Array} objects to render immediately and pushes the other in the activeGroup.
       */
      _chooseObjectsToRender: function() {
        var activeObjects = this.getActiveObjects(),
            object, objsToRender, activeGroupObjects;

        if (activeObjects.length > 0 && !this.preserveObjectStacking) {
          objsToRender = [];
          activeGroupObjects = [];
          for (var i = 0, length = this._objects.length; i < length; i++) {
            object = this._objects[i];
            if (activeObjects.indexOf(object) === -1 ) {
              objsToRender.push(object);
            }
            else {
              activeGroupObjects.push(object);
            }
          }
          if (activeObjects.length > 1) {
            this._activeObject._objects = activeGroupObjects;
          }
          objsToRender.push.apply(objsToRender, activeGroupObjects);
        }
        else {
          objsToRender = this._objects;
        }
        return objsToRender;
      },

      /**
       * Renders both the top canvas and the secondary container canvas.
       * @return {fabric.Canvas} instance
       * @chainable
       */
      renderAll: function () {
        if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
          this.clearContext(this.contextTop);
          this.contextTopDirty = false;
        }
        if (this.hasLostContext) {
          this.renderTopLayer(this.contextTop);
        }
        var canvasToDrawOn = this.contextContainer;
        this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
        return this;
      },

      renderTopLayer: function(ctx) {
        if (this.isDrawingMode && this._isCurrentlyDrawing) {
          this.freeDrawingBrush && this.freeDrawingBrush._render();
        }
        // we render the top context - last object
        if (this.selection && this._groupSelector) {
          this._drawSelection(ctx);
        }
      },

      /**
       * Method to render only the top canvas.
       * Also used to render the group selection box.
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      renderTop: function () {
        var ctx = this.contextTop;
        this.clearContext(ctx);
        this.renderTopLayer(ctx);
        this.fire('after:render');
        this.contextTopDirty = true;
        return this;
      },

      /**
       * Resets the current transform to its original values and chooses the type of resizing based on the event
       * @private
       */
      _resetCurrentTransform: function() {
        var t = this._currentTransform;

        t.target.set({
          scaleX: t.original.scaleX,
          scaleY: t.original.scaleY,
          skewX: t.original.skewX,
          skewY: t.original.skewY,
          left: t.original.left,
          top: t.original.top
        });

        if (this._shouldCenterTransform(t.target)) {
          if (t.originX !== 'center') {
            if (t.originX === 'right') {
              t.mouseXSign = -1;
            }
            else {
              t.mouseXSign = 1;
            }
          }
          if (t.originY !== 'center') {
            if (t.originY === 'bottom') {
              t.mouseYSign = -1;
            }
            else {
              t.mouseYSign = 1;
            }
          }

          t.originX = 'center';
          t.originY = 'center';
        }
        else {
          t.originX = t.original.originX;
          t.originY = t.original.originY;
        }
      },

      /**
       * Checks if point is contained within an area of given object
       * @param {Event} e Event object
       * @param {fabric.Object} target Object to test against
       * @param {Object} [point] x,y object of point coordinates we want to check.
       * @return {Boolean} true if point is contained within an area of given object
       */
      containsPoint: function (e, target, point) {
        var ignoreZoom = true,
            pointer = point || this.getPointer(e, ignoreZoom),
            xy;

        if (target.group && target.group === this._activeObject && target.group.type === 'activeSelection') {
          xy = this._normalizePointer(target.group, pointer);
        }
        else {
          xy = { x: pointer.x, y: pointer.y };
        }
        // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
        // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
        return (target.containsPoint(xy) || target._findTargetCorner(pointer));
      },

      /**
       * @private
       */
      _normalizePointer: function (object, pointer) {
        var m = object.calcTransformMatrix(),
            invertedM = fabric.util.invertTransform(m),
            vptPointer = this.restorePointerVpt(pointer);
        return fabric.util.transformPoint(vptPointer, invertedM);
      },

      /**
       * Returns true if object is transparent at a certain location
       * @param {fabric.Object} target Object to check
       * @param {Number} x Left coordinate
       * @param {Number} y Top coordinate
       * @return {Boolean}
       */
      isTargetTransparent: function (target, x, y) {
        if (target.shouldCache() && target._cacheCanvas) {
          var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
              targetRelativeX = target.cacheTranslationX + (normalizedPointer.x * target.zoomX),
              targetRelativeY = target.cacheTranslationY + (normalizedPointer.y * target.zoomY);

          var isTransparent = fabric.util.isTransparent(
            target._cacheContext, targetRelativeX, targetRelativeY, this.targetFindTolerance);

          return isTransparent;
        }

        var ctx = this.contextCache,
            originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

        target.selectionBackgroundColor = '';

        this.clearContext(ctx);

        ctx.save();
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        target.render(ctx);
        ctx.restore();

        target === this._activeObject && target._renderControls(ctx, {
          hasBorders: false,
          transparentCorners: false
        }, {
          hasBorders: false,
        });

        target.selectionBackgroundColor = originalColor;

        var isTransparent = fabric.util.isTransparent(
          ctx, x, y, this.targetFindTolerance);

        return isTransparent;
      },

      /**
       * takes an event and determins if selection key has been pressed
       * @private
       * @param {Event} e Event object
       */
      _isSelectionKeyPressed: function(e) {
        var selectionKeyPressed = false;

        if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {
          selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
        }
        else {
          selectionKeyPressed = e[this.selectionKey];
        }

        return selectionKeyPressed;
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _shouldClearSelection: function (e, target) {
        var activeObjects = this.getActiveObjects(),
            activeObject = this._activeObject;

        return (
          !target
          ||
          (target &&
            activeObject &&
            activeObjects.length > 1 &&
            activeObjects.indexOf(target) === -1 &&
            activeObject !== target &&
            !this._isSelectionKeyPressed(e))
          ||
          (target && !target.evented)
          ||
          (target &&
            !target.selectable &&
            activeObject &&
            activeObject !== target)
        );
      },

      /**
       * centeredScaling from object can't override centeredScaling from canvas.
       * this should be fixed, since object setting should take precedence over canvas.
       * @private
       * @param {fabric.Object} target
       */
      _shouldCenterTransform: function (target) {
        if (!target) {
          return;
        }

        var t = this._currentTransform,
            centerTransform;

        if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
          centerTransform = this.centeredScaling || target.centeredScaling;
        }
        else if (t.action === 'rotate') {
          centerTransform = this.centeredRotation || target.centeredRotation;
        }

        return centerTransform ? !t.altKey : t.altKey;
      },

      /**
       * @private
       */
      _getOriginFromCorner: function(target, corner) {
        var origin = {
          x: target.originX,
          y: target.originY
        };

        if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
          origin.x = 'right';
        }
        else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
          origin.x = 'left';
        }

        if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
          origin.y = 'bottom';
        }
        else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
          origin.y = 'top';
        }

        return origin;
      },

      /**
       * @private
       */
      _getActionFromCorner: function(target, corner, e) {
        if (!corner) {
          return 'drag';
        }

        switch (corner) {
          case 'mtr':
            return 'rotate';
          case 'ml':
          case 'mr':
            return e[this.altActionKey] ? 'skewY' : 'scaleX';
          case 'mt':
          case 'mb':
            return e[this.altActionKey] ? 'skewX' : 'scaleY';
          default:
            return 'scale';
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _setupCurrentTransform: function (e, target) {
        if (!target) {
          return;
        }

        var pointer = this.getPointer(e),
            corner = target._findTargetCorner(this.getPointer(e, true)),
            action = this._getActionFromCorner(target, corner, e),
            origin = this._getOriginFromCorner(target, corner);

        this._currentTransform = {
          target: target,
          action: action,
          corner: corner,
          scaleX: target.scaleX,
          scaleY: target.scaleY,
          skewX: target.skewX,
          skewY: target.skewY,
          // used by transation
          offsetX: pointer.x - target.left,
          offsetY: pointer.y - target.top,
          originX: origin.x,
          originY: origin.y,
          ex: pointer.x,
          ey: pointer.y,
          lastX: pointer.x,
          lastY: pointer.y,
          // unsure they are usefull anymore.
          // left: target.left,
          // top: target.top,
          theta: degreesToRadians(target.angle),
          // end of unsure
          width: target.width * target.scaleX,
          mouseXSign: 1,
          mouseYSign: 1,
          shiftKey: e.shiftKey,
          altKey: e[this.centeredKey]
        };

        this._currentTransform.original = {
          left: target.left,
          top: target.top,
          scaleX: target.scaleX,
          scaleY: target.scaleY,
          skewX: target.skewX,
          skewY: target.skewY,
          originX: origin.x,
          originY: origin.y
        };

        this._resetCurrentTransform();
        this._beforeTransform(e);
      },

      /**
       * Translates object by "setting" its left/top
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @return {Boolean} true if the translation occurred
       */
      _translateObject: function (x, y) {
        var transform = this._currentTransform,
            target = transform.target,
            newLeft = x - transform.offsetX,
            newTop = y - transform.offsetY,
            moveX = !target.get('lockMovementX') && target.left !== newLeft,
            moveY = !target.get('lockMovementY') && target.top !== newTop;

        moveX && target.set('left', newLeft);
        moveY && target.set('top', newTop);
        return moveX || moveY;
      },

      /**
       * Check if we are increasing a positive skew or lower it,
       * checking mouse direction and pressed corner.
       * @private
       */
      _changeSkewTransformOrigin: function(mouseMove, t, by) {
        var property = 'originX', origins = { 0: 'center' },
            skew = t.target.skewX, originA = 'left', originB = 'right',
            corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
            flipSign = 1;

        mouseMove = mouseMove > 0 ? 1 : -1;
        if (by === 'y') {
          skew = t.target.skewY;
          originA = 'top';
          originB = 'bottom';
          property = 'originY';
        }
        origins[-1] = originA;
        origins[1] = originB;

        t.target.flipX && (flipSign *= -1);
        t.target.flipY && (flipSign *= -1);

        if (skew === 0) {
          t.skewSign = -corner * mouseMove * flipSign;
          t[property] = origins[-mouseMove];
        }
        else {
          skew = skew > 0 ? 1 : -1;
          t.skewSign = skew;
          t[property] = origins[skew * corner * flipSign];
        }
      },

      /**
       * Skew object by mouse events
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @param {String} by Either 'x' or 'y'
       * @return {Boolean} true if the skewing occurred
       */
      _skewObject: function (x, y, by) {
        var t = this._currentTransform,
            target = t.target, skewed = false,
            lockSkewingX = target.get('lockSkewingX'),
            lockSkewingY = target.get('lockSkewingY');

        if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
          return false;
        }

        // Get the constraint point
        var center = target.getCenterPoint(),
            actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
            lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
            actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();

        this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
        actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
        constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
        // Actually skew the object
        skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
        t.lastX = x;
        t.lastY = y;
        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        return skewed;
      },

      /**
       * Set object skew
       * @private
       * @return {Boolean} true if the skewing occurred
       */
      _setObjectSkew: function(localMouse, transform, by, _dim) {
        var target = transform.target, newValue, skewed = false,
            skewSign = transform.skewSign, newDim, dimNoSkew,
            otherBy, _otherBy, _by, newDimMouse, skewX, skewY;

        if (by === 'x') {
          otherBy = 'y';
          _otherBy = 'Y';
          _by = 'X';
          skewX = 0;
          skewY = target.skewY;
        }
        else {
          otherBy = 'x';
          _otherBy = 'X';
          _by = 'Y';
          skewX = target.skewX;
          skewY = 0;
        }

        dimNoSkew = target._getTransformedDimensions(skewX, skewY);
        newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
        if (newDimMouse <= 2) {
          newValue = 0;
        }
        else {
          newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
                                          (dimNoSkew[otherBy] / target['scale' + _otherBy]));
          newValue = fabric.util.radiansToDegrees(newValue);
        }
        skewed = target['skew' + _by] !== newValue;
        target.set('skew' + _by, newValue);
        if (target['skew' + _otherBy] !== 0) {
          newDim = target._getTransformedDimensions();
          newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
          target.set('scale' + _otherBy, newValue);
        }
        return skewed;
      },

      /**
       * Scales object by invoking its scaleX/scaleY methods
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
       *                    When not provided, an object is scaled by both dimensions equally
       * @return {Boolean} true if the scaling occurred
       */
      _scaleObject: function (x, y, by) {
        var t = this._currentTransform,
            target = t.target,
            lockScalingX = target.lockScalingX,
            lockScalingY = target.lockScalingY,
            lockScalingFlip = target.lockScalingFlip;

        if (lockScalingX && lockScalingY) {
          return false;
        }

        // Get the constraint point
        var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
            localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
            dim = target._getTransformedDimensions(), scaled = false;

        this._setLocalMouse(localMouse, t);

        // Actually scale the object
        scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);

        // Make sure the constraints apply
        target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        return scaled;
      },

      /**
       * @private
       * @return {Boolean} true if the scaling occurred
       */
      _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
        var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
            changeX, changeY, scaleX, scaleY;

        scaleX = localMouse.x * target.scaleX / _dim.x;
        scaleY = localMouse.y * target.scaleY / _dim.y;
        changeX = target.scaleX !== scaleX;
        changeY = target.scaleY !== scaleY;

        if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
          forbidScalingX = true;
          localMouse.x = 0;
        }

        if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
          forbidScalingY = true;
          localMouse.y = 0;
        }

        if (by === 'equally' && !lockScalingX && !lockScalingY) {
          scaled = this._scaleObjectEqually(localMouse, target, transform, _dim);
        }
        else if (!by) {
          forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
          forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
        }
        else if (by === 'x' && !target.get('lockUniScaling')) {
          forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
        }
        else if (by === 'y' && !target.get('lockUniScaling')) {
          forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
        }
        transform.newScaleX = scaleX;
        transform.newScaleY = scaleY;
        forbidScalingX || forbidScalingY || this._flipObject(transform, by);
        return scaled;
      },

      /**
       * @private
       * @return {Boolean} true if the scaling occurred
       */
      _scaleObjectEqually: function(localMouse, target, transform, _dim) {

        var dist = localMouse.y + localMouse.x,
            lastDist = _dim.y * transform.original.scaleY / target.scaleY +
                       _dim.x * transform.original.scaleX / target.scaleX,
            scaled, signX = localMouse.x < 0 ? -1 : 1,
            signY = localMouse.y < 0 ? -1 : 1;

        // We use transform.scaleX/Y instead of target.scaleX/Y
        // because the object may have a min scale and we'll loose the proportions
        transform.newScaleX = signX * Math.abs(transform.original.scaleX * dist / lastDist);
        transform.newScaleY = signY * Math.abs(transform.original.scaleY * dist / lastDist);
        scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;
        target.set('scaleX', transform.newScaleX);
        target.set('scaleY', transform.newScaleY);
        return scaled;
      },

      /**
       * @private
       */
      _flipObject: function(transform, by) {
        if (transform.newScaleX < 0 && by !== 'y') {
          if (transform.originX === 'left') {
            transform.originX = 'right';
          }
          else if (transform.originX === 'right') {
            transform.originX = 'left';
          }
        }

        if (transform.newScaleY < 0 && by !== 'x') {
          if (transform.originY === 'top') {
            transform.originY = 'bottom';
          }
          else if (transform.originY === 'bottom') {
            transform.originY = 'top';
          }
        }
      },

      /**
       * @private
       */
      _setLocalMouse: function(localMouse, t) {
        var target = t.target, zoom = this.getZoom(),
            padding = target.padding / zoom;

        if (t.originX === 'right') {
          localMouse.x *= -1;
        }
        else if (t.originX === 'center') {
          localMouse.x *= t.mouseXSign * 2;
          if (localMouse.x < 0) {
            t.mouseXSign = -t.mouseXSign;
          }
        }

        if (t.originY === 'bottom') {
          localMouse.y *= -1;
        }
        else if (t.originY === 'center') {
          localMouse.y *= t.mouseYSign * 2;
          if (localMouse.y < 0) {
            t.mouseYSign = -t.mouseYSign;
          }
        }

        // adjust the mouse coordinates when dealing with padding
        if (abs(localMouse.x) > padding) {
          if (localMouse.x < 0) {
            localMouse.x += padding;
          }
          else {
            localMouse.x -= padding;
          }
        }
        else { // mouse is within the padding, set to 0
          localMouse.x = 0;
        }

        if (abs(localMouse.y) > padding) {
          if (localMouse.y < 0) {
            localMouse.y += padding;
          }
          else {
            localMouse.y -= padding;
          }
        }
        else {
          localMouse.y = 0;
        }
      },

      /**
       * Rotates object by invoking its rotate method
       * @private
       * @param {Number} x pointer's x coordinate
       * @param {Number} y pointer's y coordinate
       * @return {Boolean} true if the rotation occurred
       */
      _rotateObject: function (x, y) {

        var t = this._currentTransform,
            target = t.target, constraintPosition,
            constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

        if (target.lockRotation) {
          return false;
        }

        var lastAngle = atan2(t.ey - constraintPosition.y, t.ex - constraintPosition.x),
            curAngle = atan2(y - constraintPosition.y, x - constraintPosition.x),
            angle = radiansToDegrees(curAngle - lastAngle + t.theta),
            hasRotated = true;

        if (target.snapAngle > 0) {
          var snapAngle  = target.snapAngle,
              snapThreshold  = target.snapThreshold || snapAngle,
              rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
              leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

          if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
            angle = leftAngleLocked;
          }
          else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
            angle = rightAngleLocked;
          }
        }

        // normalize angle to positive value
        if (angle < 0) {
          angle = 360 + angle;
        }
        angle %= 360;

        if (target.angle === angle) {
          hasRotated = false;
        }
        else {
          // rotation only happen here
          target.angle = angle;
          // Make sure the constraints apply
          target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
        }

        return hasRotated;
      },

      /**
       * Set the cursor type of the canvas element
       * @param {String} value Cursor type of the canvas element.
       * @see http://www.w3.org/TR/css3-ui/#cursor
       */
      setCursor: function (value) {
        this.upperCanvasEl.style.cursor = value;
      },

      /**
       * @param {fabric.Object} target to reset transform
       * @private
       */
      _resetObjectTransform: function (target) {
        target.scaleX = 1;
        target.scaleY = 1;
        target.skewX = 0;
        target.skewY = 0;
        target.rotate(0);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx to draw the selection on
       */
      _drawSelection: function (ctx) {
        var groupSelector = this._groupSelector,
            left = groupSelector.left,
            top = groupSelector.top,
            aleft = abs(left),
            atop = abs(top);

        if (this.selectionColor) {
          ctx.fillStyle = this.selectionColor;

          ctx.fillRect(
            groupSelector.ex - ((left > 0) ? 0 : -left),
            groupSelector.ey - ((top > 0) ? 0 : -top),
            aleft,
            atop
          );
        }

        if (!this.selectionLineWidth || !this.selectionBorderColor) {
          return;
        }
        ctx.lineWidth = this.selectionLineWidth;
        ctx.strokeStyle = this.selectionBorderColor;

        // selection border
        if (this.selectionDashArray.length > 1 && !supportLineDash) {

          var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
              py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

          ctx.beginPath();

          fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
          fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

          ctx.closePath();
          ctx.stroke();
        }
        else {
          fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
          ctx.strokeRect(
            groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
            aleft,
            atop
          );
        }
      },

      /**
       * Method that determines what object we are clicking on
       * the skipGroup parameter is for internal use, is needed for shift+click action
       * @param {Event} e mouse event
       * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
       */
      findTarget: function (e, skipGroup) {
        if (this.skipTargetFind) {
          return;
        }

        var ignoreZoom = true,
            pointer = this.getPointer(e, ignoreZoom),
            activeObject = this._activeObject,
            aObjects = this.getActiveObjects(),
            activeTarget, activeTargetSubs;

        // first check current group (if one exists)
        // active group does not check sub targets like normal groups.
        // if active group just exits.
        this.targets = [];

        if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
          return activeObject;
        }
        // if we hit the corner of an activeObject, let's return that.
        if (aObjects.length === 1 && activeObject._findTargetCorner(pointer)) {
          return activeObject;
        }
        if (aObjects.length === 1 &&
          activeObject === this._searchPossibleTargets([activeObject], pointer)) {
          if (!this.preserveObjectStacking) {
            return activeObject;
          }
          else {
            activeTarget = activeObject;
            activeTargetSubs = this.targets;
            this.targets = [];
          }
        }
        var target = this._searchPossibleTargets(this._objects, pointer);
        if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
          target = activeTarget;
          this.targets = activeTargetSubs;
        }
        return target;
      },

      /**
       * @private
       */
      _checkTarget: function(pointer, obj) {
        if (obj &&
            obj.visible &&
            obj.evented &&
            this.containsPoint(null, obj, pointer)){
          if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
            var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);
            if (!isTransparent) {
              return true;
            }
          }
          else {
            return true;
          }
        }
      },

      /**
       * @private
       */
      _searchPossibleTargets: function(objects, pointer) {

        // Cache all targets where their bounding box contains point.
        var target, i = objects.length, normalizedPointer, subTarget;
        // Do not check for currently grouped objects, since we check the parent group itself.
        // until we call this function specifically to search inside the activeGroup
        while (i--) {
          if (this._checkTarget(pointer, objects[i])) {
            target = objects[i];
            if (target.subTargetCheck && target instanceof fabric.Group) {
              normalizedPointer = this._normalizePointer(target, pointer);
              subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);
              subTarget && this.targets.push(subTarget);
            }
            break;
          }
        }
        return target;
      },

      /**
       * Returns pointer coordinates without the effect of the viewport
       * @param {Object} pointer with "x" and "y" number values
       * @return {Object} object with "x" and "y" number values
       */
      restorePointerVpt: function(pointer) {
        return fabric.util.transformPoint(
          pointer,
          fabric.util.invertTransform(this.viewportTransform)
        );
      },

      /**
       * Returns pointer coordinates relative to canvas.
       * Can return coordinates with or without viewportTransform.
       * ignoreZoom false gives back coordinates that represent
       * the point clicked on canvas element.
       * ignoreZoom true gives back coordinates after being processed
       * by the viewportTransform ( sort of coordinates of what is displayed
       * on the canvas where you are clicking.
       * ignoreZoom true = HTMLElement coordinates relative to top,left
       * ignoreZoom false, default = fabric space coordinates, the same used for shape position
       * To interact with your shapes top and left you want to use ignoreZoom true
       * most of the time, while ignoreZoom false will give you coordinates
       * compatible with the object.oCoords system.
       * of the time.
       * @param {Event} e
       * @param {Boolean} ignoreZoom
       * @return {Object} object with "x" and "y" number values
       */
      getPointer: function (e, ignoreZoom) {
        // return cached values if we are in the event processing chain
        if (this._absolutePointer && !ignoreZoom) {
          return this._absolutePointer;
        }
        if (this._pointer && ignoreZoom) {
          return this._pointer;
        }

        var pointer = getPointer(e),
            upperCanvasEl = this.upperCanvasEl,
            bounds = upperCanvasEl.getBoundingClientRect(),
            boundsWidth = bounds.width || 0,
            boundsHeight = bounds.height || 0,
            cssScale;

        if (!boundsWidth || !boundsHeight ) {
          if ('top' in bounds && 'bottom' in bounds) {
            boundsHeight = Math.abs( bounds.top - bounds.bottom );
          }
          if ('right' in bounds && 'left' in bounds) {
            boundsWidth = Math.abs( bounds.right - bounds.left );
          }
        }

        this.calcOffset();
        pointer.x = pointer.x - this._offset.left;
        pointer.y = pointer.y - this._offset.top;
        if (!ignoreZoom) {
          pointer = this.restorePointerVpt(pointer);
        }

        if (boundsWidth === 0 || boundsHeight === 0) {
          // If bounds are not available (i.e. not visible), do not apply scale.
          cssScale = { width: 1, height: 1 };
        }
        else {
          cssScale = {
            width: upperCanvasEl.width / boundsWidth,
            height: upperCanvasEl.height / boundsHeight
          };
        }

        return {
          x: pointer.x * cssScale.width,
          y: pointer.y * cssScale.height
        };
      },

      /**
       * @private
       * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
       */
      _createUpperCanvas: function () {
        var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');

        // there is no need to create a new upperCanvas element if we have already one.
        if (this.upperCanvasEl) {
          this.upperCanvasEl.className = '';
        }
        else {
          this.upperCanvasEl = this._createCanvasElement();
        }
        fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

        this.wrapperEl.appendChild(this.upperCanvasEl);

        this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
        this._applyCanvasStyle(this.upperCanvasEl);
        this.contextTop = this.upperCanvasEl.getContext('2d');
      },

      /**
       * @private
       */
      _createCacheCanvas: function () {
        this.cacheCanvasEl = this._createCanvasElement();
        this.cacheCanvasEl.setAttribute('width', this.width);
        this.cacheCanvasEl.setAttribute('height', this.height);
        this.contextCache = this.cacheCanvasEl.getContext('2d');
      },

      /**
       * @private
       */
      _initWrapperElement: function () {
        this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
          'class': this.containerClass
        });
        fabric.util.setStyle(this.wrapperEl, {
          width: this.width + 'px',
          height: this.height + 'px',
          position: 'relative'
        });
        fabric.util.makeElementUnselectable(this.wrapperEl);
      },

      /**
       * @private
       * @param {HTMLElement} element canvas element to apply styles on
       */
      _applyCanvasStyle: function (element) {
        var width = this.width || element.width,
            height = this.height || element.height;

        fabric.util.setStyle(element, {
          position: 'absolute',
          width: width + 'px',
          height: height + 'px',
          left: 0,
          top: 0,
          'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
        });
        element.width = width;
        element.height = height;
        fabric.util.makeElementUnselectable(element);
      },

      /**
       * Copy the entire inline style from one element (fromEl) to another (toEl)
       * @private
       * @param {Element} fromEl Element style is copied from
       * @param {Element} toEl Element copied style is applied to
       */
      _copyCanvasStyle: function (fromEl, toEl) {
        toEl.style.cssText = fromEl.style.cssText;
      },

      /**
       * Returns context of canvas where object selection is drawn
       * @return {CanvasRenderingContext2D}
       */
      getSelectionContext: function() {
        return this.contextTop;
      },

      /**
       * Returns &lt;canvas> element on which object selection is drawn
       * @return {HTMLCanvasElement}
       */
      getSelectionElement: function () {
        return this.upperCanvasEl;
      },

      /**
       * Returns currently active object
       * @return {fabric.Object} active object
       */
      getActiveObject: function () {
        return this._activeObject;
      },

      /**
       * Returns an array with the current selected objects
       * @return {fabric.Object} active object
       */
      getActiveObjects: function () {
        var active = this._activeObject;
        if (active) {
          if (active.type === 'activeSelection' && active._objects) {
            return active._objects.slice(0);
          }
          else {
            return [active];
          }
        }
        return [];
      },

      /**
       * @private
       * @param {fabric.Object} obj Object that was removed
       */
      _onObjectRemoved: function(obj) {
        // removing active object should fire "selection:cleared" events
        if (obj === this._activeObject) {
          this.fire('before:selection:cleared', { target: obj });
          this._discardActiveObject();
          this.fire('selection:cleared', { target: obj });
          obj.fire('deselected');
        }
        if (this._hoveredTarget === obj) {
          this._hoveredTarget = null;
        }
        this.callSuper('_onObjectRemoved', obj);
      },

      /**
       * @private
       * Compares the old activeObject with the current one and fires correct events
       * @param {fabric.Object} obj old activeObject
       */
      _fireSelectionEvents: function(oldObjects, e) {
        var somethingChanged = false, objects = this.getActiveObjects(),
            added = [], removed = [], opt = { e: e };
        oldObjects.forEach(function(oldObject) {
          if (objects.indexOf(oldObject) === -1) {
            somethingChanged = true;
            oldObject.fire('deselected', opt);
            removed.push(oldObject);
          }
        });
        objects.forEach(function(object) {
          if (oldObjects.indexOf(object) === -1) {
            somethingChanged = true;
            object.fire('selected', opt);
            added.push(object);
          }
        });
        if (oldObjects.length > 0 && objects.length > 0) {
          opt.selected = added;
          opt.deselected = removed;
          // added for backward compatibility
          opt.updated = added[0] || removed[0];
          opt.target = this._activeObject;
          somethingChanged && this.fire('selection:updated', opt);
        }
        else if (objects.length > 0) {
          // deprecated event
          if (objects.length === 1) {
            opt.target = added[0];
            this.fire('object:selected', opt);
          }
          opt.selected = added;
          // added for backward compatibility
          opt.target = this._activeObject;
          this.fire('selection:created', opt);
        }
        else if (oldObjects.length > 0) {
          opt.deselected = removed;
          this.fire('selection:cleared', opt);
        }
      },

      /**
       * Sets given object as the only active object on canvas
       * @param {fabric.Object} object Object to set as an active one
       * @param {Event} [e] Event (passed along when firing "object:selected")
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      setActiveObject: function (object, e) {
        var currentActives = this.getActiveObjects();
        this._setActiveObject(object, e);
        this._fireSelectionEvents(currentActives, e);
        return this;
      },

      /**
       * @private
       * @param {Object} object to set as active
       * @param {Event} [e] Event (passed along when firing "object:selected")
       * @return {Boolean} true if the selection happened
       */
      _setActiveObject: function(object, e) {
        if (this._activeObject === object) {
          return false;
        }
        if (!this._discardActiveObject(e, object)) {
          return false;
        }
        if (object.onSelect({ e: e })) {
          return false;
        }
        this._activeObject = object;
        return true;
      },

      /**
       * @private
       */
      _discardActiveObject: function(e, object) {
        var obj = this._activeObject;
        if (obj) {
          // onDeselect return TRUE to cancel selection;
          if (obj.onDeselect({ e: e, object: object })) {
            return false;
          }
          this._activeObject = null;
        }
        return true;
      },

      /**
       * Discards currently active object and fire events. If the function is called by fabric
       * as a consequence of a mouse event, the event is passed as a parameter and
       * sent to the fire function for the custom events. When used as a method the
       * e param does not have any application.
       * @param {event} e
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      discardActiveObject: function (e) {
        var currentActives = this.getActiveObjects();
        if (currentActives.length) {
          this.fire('before:selection:cleared', { target: currentActives[0], e: e });
        }
        this._discardActiveObject(e);
        this._fireSelectionEvents(currentActives, e);
        return this;
      },

      /**
       * Clears a canvas element and removes all event listeners
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      dispose: function () {
        var wrapper = this.wrapperEl;
        this.removeListeners();
        wrapper.removeChild(this.upperCanvasEl);
        wrapper.removeChild(this.lowerCanvasEl);
        this.upperCanvasEl = null;
        this.cacheCanvasEl = null;
        this.contextCache = null;
        this.contextTop = null;
        if (wrapper.parentNode) {
          wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
        }
        delete this.wrapperEl;
        fabric.StaticCanvas.prototype.dispose.call(this);
        return this;
      },

      /**
       * Clears all contexts (background, main, top) of an instance
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      clear: function () {
        // this.discardActiveGroup();
        this.discardActiveObject();
        this.clearContext(this.contextTop);
        return this.callSuper('clear');
      },

      /**
       * Draws objects' controls (borders/controls)
       * @param {CanvasRenderingContext2D} ctx Context to render controls on
       */
      drawControls: function(ctx) {
        var activeObject = this._activeObject;

        if (activeObject) {
          activeObject._renderControls(ctx);
        }
      },

      /**
       * @private
       */
      _toObject: function(instance, methodName, propertiesToInclude) {
        //If the object is part of the current selection group, it should
        //be transformed appropriately
        //i.e. it should be serialised as it would appear if the selection group
        //were to be destroyed.
        var originalProperties = this._realizeGroupTransformOnObject(instance),
            object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
        //Undo the damage we did by changing all of its properties
        this._unwindGroupTransformOnObject(instance, originalProperties);
        return object;
      },

      /**
       * Realises an object's group transformation on it
       * @private
       * @param {fabric.Object} [instance] the object to transform (gets mutated)
       * @returns the original values of instance which were changed
       */
      _realizeGroupTransformOnObject: function(instance) {
        if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
          var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
          //Copy all the positionally relevant properties across now
          var originalValues = {};
          layoutProps.forEach(function(prop) {
            originalValues[prop] = instance[prop];
          });
          this._activeObject.realizeTransform(instance);
          return originalValues;
        }
        else {
          return null;
        }
      },

      /**
       * Restores the changed properties of instance
       * @private
       * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
       * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
       */
      _unwindGroupTransformOnObject: function(instance, originalValues) {
        if (originalValues) {
          instance.set(originalValues);
        }
      },

      /**
       * @private
       */
      _setSVGObject: function(markup, instance, reviver) {
        //If the object is in a selection group, simulate what would happen to that
        //object when the group is deselected
        var originalProperties = this._realizeGroupTransformOnObject(instance);
        this.callSuper('_setSVGObject', markup, instance, reviver);
        this._unwindGroupTransformOnObject(instance, originalProperties);
      },

      setViewportTransform: function (vpt) {
        if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
          this._activeObject.clearContextTop();
        }
        fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
      }
    });

    // copying static properties manually to work around Opera's bug,
    // where "prototype" property is enumerable and overrides existing prototype
    for (var prop in fabric.StaticCanvas) {
      if (prop !== 'prototype') {
        fabric.Canvas[prop] = fabric.StaticCanvas[prop];
      }
    }

    if (fabric.isTouchSupported) {
      /** @ignore */
      fabric.Canvas.prototype._setCursorFromEvent = function() { };
    }
  })();


  (function() {

    var cursorOffset = {
          mt: 0, // n
          tr: 1, // ne
          mr: 2, // e
          br: 3, // se
          mb: 4, // s
          bl: 5, // sw
          ml: 6, // w
          tl: 7 // nw
        },
        addListener = fabric.util.addListener,
        removeListener = fabric.util.removeListener,
        RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
        addEventOptions = { passive: false };

    function checkClick(e, value) {
      return 'which' in e ? e.which === value : e.button === value - 1;
    }

    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

      /**
       * Map of cursor style values for each of the object controls
       * @private
       */
      cursorMap: [
        'n-resize',
        'ne-resize',
        'e-resize',
        'se-resize',
        's-resize',
        'sw-resize',
        'w-resize',
        'nw-resize'
      ],

      /**
       * Adds mouse listeners to canvas
       * @private
       */
      _initEventListeners: function () {
        // in case we initialized the class twice. This should not happen normally
        // but in some kind of applications where the canvas element may be changed
        // this is a workaround to having double listeners.
        this.removeListeners();
        this._bindEvents();
        this.addOrRemove(addListener, 'add');
      },

      addOrRemove: function(functor, eventjsFunctor) {
        functor(fabric.window, 'resize', this._onResize);
        functor(this.upperCanvasEl, 'mousedown', this._onMouseDown);
        functor(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
        functor(this.upperCanvasEl, 'mouseout', this._onMouseOut);
        functor(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
        functor(this.upperCanvasEl, 'wheel', this._onMouseWheel);
        functor(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
        functor(this.upperCanvasEl, 'dblclick', this._onDoubleClick);
        functor(this.upperCanvasEl, 'touchstart', this._onMouseDown, addEventOptions);
        functor(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);
        functor(this.upperCanvasEl, 'dragover', this._onDragOver);
        functor(this.upperCanvasEl, 'dragenter', this._onDragEnter);
        functor(this.upperCanvasEl, 'dragleave', this._onDragLeave);
        functor(this.upperCanvasEl, 'drop', this._onDrop);
        if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
          eventjs[eventjsFunctor](this.upperCanvasEl, 'gesture', this._onGesture);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'drag', this._onDrag);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'orientation', this._onOrientationChange);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'shake', this._onShake);
          eventjs[eventjsFunctor](this.upperCanvasEl, 'longpress', this._onLongPress);
        }
      },

      /**
       * Removes all event listeners
       */
      removeListeners: function() {
        this.addOrRemove(removeListener, 'remove');
        // if you dispose on a mouseDown, before mouse up, you need to clean document to...
        removeListener(fabric.document, 'mouseup', this._onMouseUp);
        removeListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);
        removeListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
        removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      },

      /**
       * @private
       */
      _bindEvents: function() {
        if (this.eventsBound) {
          // for any reason we pass here twice we do not want to bind events twice.
          return;
        }
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onResize = this._onResize.bind(this);
        this._onGesture = this._onGesture.bind(this);
        this._onDrag = this._onDrag.bind(this);
        this._onShake = this._onShake.bind(this);
        this._onLongPress = this._onLongPress.bind(this);
        this._onOrientationChange = this._onOrientationChange.bind(this);
        this._onMouseWheel = this._onMouseWheel.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onMouseEnter = this._onMouseEnter.bind(this);
        this._onContextMenu = this._onContextMenu.bind(this);
        this._onDoubleClick = this._onDoubleClick.bind(this);
        this._onDragOver = this._onDragOver.bind(this);
        this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
        this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
        this._onDrop = this._simpleEventHandler.bind(this, 'drop');
        this.eventsBound = true;
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js gesture
       * @param {Event} [self] Inner Event object
       */
      _onGesture: function(e, self) {
        this.__onTransformGesture && this.__onTransformGesture(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js drag
       * @param {Event} [self] Inner Event object
       */
      _onDrag: function(e, self) {
        this.__onDrag && this.__onDrag(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on wheel event
       */
      _onMouseWheel: function(e) {
        this.__onMouseWheel(e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseOut: function(e) {
        var target = this._hoveredTarget;
        this.fire('mouse:out', { target: target, e: e });
        this._hoveredTarget = null;
        target && target.fire('mouseout', { e: e });
        if (this._iTextInstances) {
          this._iTextInstances.forEach(function(obj) {
            if (obj.isEditing) {
              obj.hiddenTextarea.focus();
            }
          });
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseenter
       */
      _onMouseEnter: function(e) {
        if (!this.findTarget(e)) {
          this.fire('mouse:over', { target: null, e: e });
          this._hoveredTarget = null;
        }
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js orientation change
       * @param {Event} [self] Inner Event object
       */
      _onOrientationChange: function(e, self) {
        this.__onOrientationChange && this.__onOrientationChange(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       * @param {Event} [self] Inner Event object
       */
      _onShake: function(e, self) {
        this.__onShake && this.__onShake(e, self);
      },

      /**
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       * @param {Event} [self] Inner Event object
       */
      _onLongPress: function(e, self) {
        this.__onLongPress && this.__onLongPress(e, self);
      },

      /**
       * prevent default to allow drop event to be fired
       * @private
       * @param {Event} [e] Event object fired on Event.js shake
       */
      _onDragOver: function(e) {
        e.preventDefault();
        var target = this._simpleEventHandler('dragover', e);
        this._fireEnterLeaveEvents(target, e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onContextMenu: function (e) {
        if (this.stopContextMenu) {
          e.stopPropagation();
          e.preventDefault();
        }
        return false;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onDoubleClick: function (e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'dblclick');
        this._resetTransformEventData(e);
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseDown: function (e) {
        this.__onMouseDown(e);
        this._resetTransformEventData();
        addListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);
        addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);

        removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
        removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);

        if (e.type === 'touchstart') {
          // Unbind mousedown to prevent double triggers from touch devices
          removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
        }
        else {
          addListener(fabric.document, 'mouseup', this._onMouseUp);
          addListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      _onMouseUp: function (e) {
        this.__onMouseUp(e);
        this._resetTransformEventData();
        removeListener(fabric.document, 'mouseup', this._onMouseUp);
        removeListener(fabric.document, 'touchend', this._onMouseUp, addEventOptions);

        removeListener(fabric.document, 'mousemove', this._onMouseMove, addEventOptions);
        removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);

        addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove, addEventOptions);
        addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, addEventOptions);

        if (e.type === 'touchend') {
          // Wait 400ms before rebinding mousedown to prevent double triggers
          // from touch devices
          var _this = this;
          setTimeout(function() {
            addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
          }, 400);
        }
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      _onMouseMove: function (e) {
        !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
        this.__onMouseMove(e);
      },

      /**
       * @private
       */
      _onResize: function () {
        this.calcOffset();
      },

      /**
       * Decides whether the canvas should be redrawn in mouseup and mousedown events.
       * @private
       * @param {Object} target
       * @param {Object} pointer
       */
      _shouldRender: function(target, pointer) {
        var activeObject = this._activeObject;

        if (activeObject && activeObject.isEditing && target === activeObject) {
          // if we mouse up/down over a editing textbox a cursor change,
          // there is no need to re render
          return false;
        }
        return !!(
          (target && (
            target.isMoving ||
            target !== activeObject))
          ||
          (!target && !!activeObject)
          ||
          (!target && !activeObject && !this._groupSelector)
          ||
          (pointer &&
            this._previousPointer &&
            this.selection && (
              pointer.x !== this._previousPointer.x ||
            pointer.y !== this._previousPointer.y))
        );
      },

      /**
       * Method that defines the actions when mouse is released on canvas.
       * The method resets the currentTransform parameters, store the image corner
       * position in the image object and render the canvas on top.
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      __onMouseUp: function (e) {
        var target, transform = this._currentTransform,
            groupSelector = this._groupSelector,
            isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
        this._cacheTransformEventData(e);
        target = this._target;
        this._handleEvent(e, 'up:before');
        // if right/middle click just fire events and return
        // target undefined will make the _handleEvent search the target
        if (checkClick(e, RIGHT_CLICK)) {
          if (this.fireRightClick) {
            this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
          }
          return;
        }

        if (checkClick(e, MIDDLE_CLICK)) {
          if (this.fireMiddleClick) {
            this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
          }
          this._resetTransformEventData();
          return;
        }

        if (this.isDrawingMode && this._isCurrentlyDrawing) {
          this._onMouseUpInDrawingMode(e);
          return;
        }

        if (transform) {
          this._finalizeCurrentTransform(e);
        }

        var shouldRender = this._shouldRender(target, this._absolutePointer);

        if (target || !isClick) {
          this._maybeGroupObjects(e);
        }
        if (target) {
          target.isMoving = false;
        }
        this._setCursorFromEvent(e, target);
        this._handleEvent(e, 'up', LEFT_CLICK, isClick);
        this._groupSelector = null;
        this._currentTransform = null;
        target && (target.__corner = 0);
        shouldRender && this.requestRenderAll();
      },

      /**
       * @private
       * Handle event firing for target and subtargets
       * @param {Event} e event from mouse
       * @param {String} eventType event to fire (up, down or move)
       * @return {Fabric.Object} target return the the target found, for internal reasons.
       */
      _simpleEventHandler: function(eventType, e) {
        var target = this.findTarget(e),
            targets = this.targets,
            options = {
              e: e,
              target: target,
              subTargets: targets,
            };
        this.fire(eventType, options);
        target && target.fire(eventType, options);
        if (!targets) {
          return target;
        }
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire(eventType, options);
        }
        return target;
      },

      /**
       * @private
       * Handle event firing for target and subtargets
       * @param {Event} e event from mouse
       * @param {String} eventType event to fire (up, down or move)
       * @param {fabric.Object} targetObj receiving event
       * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
       * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
       */
      _handleEvent: function(e, eventType, button, isClick) {
        var target = this._target,
            targets = this.targets || [],
            options = {
              e: e,
              target: target,
              subTargets: targets,
              button: button || LEFT_CLICK,
              isClick: isClick || false,
              pointer: this._pointer,
              absolutePointer: this._absolutePointer,
              transform: this._currentTransform
            };
        this.fire('mouse:' + eventType, options);
        target && target.fire('mouse' + eventType, options);
        for (var i = 0; i < targets.length; i++) {
          targets[i].fire('mouse' + eventType, options);
        }
      },

      /**
       * @private
       * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
       */
      _finalizeCurrentTransform: function(e) {

        var transform = this._currentTransform,
            target = transform.target,
            eventName,
            options = {
              e: e,
              target: target,
              transform: transform,
            };

        if (target._scaling) {
          target._scaling = false;
        }

        target.setCoords();

        if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
          if (transform.actionPerformed) {
            eventName = this._addEventOptions(options, transform);
            this._fire(eventName, options);
          }
          this._fire('modified', options);
        }
      },

      /**
       * Mutate option object in order to add by property and give back the event name.
       * @private
       * @param {Object} options to mutate
       * @param {Object} transform to inspect action from
       */
      _addEventOptions: function(options, transform) {
        // we can probably add more details at low cost
        // scale change, rotation changes, translation changes
        var eventName, by;
        switch (transform.action) {
          case 'scaleX':
            eventName = 'scaled';
            by = 'x';
            break;
          case 'scaleY':
            eventName = 'scaled';
            by = 'y';
            break;
          case 'skewX':
            eventName = 'skewed';
            by = 'x';
            break;
          case 'skewY':
            eventName = 'skewed';
            by = 'y';
            break;
          case 'scale':
            eventName = 'scaled';
            by = 'equally';
            break;
          case 'rotate':
            eventName = 'rotated';
            break;
          case 'drag':
            eventName = 'moved';
            break;
        }
        options.by = by;
        return eventName;
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      _onMouseDownInDrawingMode: function(e) {
        this._isCurrentlyDrawing = true;
        if (this.getActiveObject()) {
          this.discardActiveObject(e).requestRenderAll();
        }
        if (this.clipTo) {
          fabric.util.clipContext(this, this.contextTop);
        }
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseDown(pointer);
        this._handleEvent(e, 'down');
      },

      /**
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      _onMouseMoveInDrawingMode: function(e) {
        if (this._isCurrentlyDrawing) {
          var pointer = this.getPointer(e);
          this.freeDrawingBrush.onMouseMove(pointer);
        }
        this.setCursor(this.freeDrawingCursor);
        this._handleEvent(e, 'move');
      },

      /**
       * @private
       * @param {Event} e Event object fired on mouseup
       */
      _onMouseUpInDrawingMode: function(e) {
        this._isCurrentlyDrawing = false;
        if (this.clipTo) {
          this.contextTop.restore();
        }
        this.freeDrawingBrush.onMouseUp();
        this._handleEvent(e, 'up');
      },

      /**
       * Method that defines the actions when mouse is clicked on canvas.
       * The method inits the currentTransform parameters and renders all the
       * canvas so the current image can be placed on the top canvas and the rest
       * in on the container one.
       * @private
       * @param {Event} e Event object fired on mousedown
       */
      __onMouseDown: function (e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'down:before');
        var target = this._target;
        // if right click just fire events
        if (checkClick(e, RIGHT_CLICK)) {
          if (this.fireRightClick) {
            this._handleEvent(e, 'down', RIGHT_CLICK);
          }
          return;
        }

        if (checkClick(e, MIDDLE_CLICK)) {
          if (this.fireMiddleClick) {
            this._handleEvent(e, 'down', MIDDLE_CLICK);
          }
          return;
        }

        if (this.isDrawingMode) {
          this._onMouseDownInDrawingMode(e);
          return;
        }

        // ignore if some object is being transformed at this moment
        if (this._currentTransform) {
          return;
        }

        var pointer = this._pointer;
        // save pointer for check in __onMouseUp event
        this._previousPointer = pointer;
        var shouldRender = this._shouldRender(target, pointer),
            shouldGroup = this._shouldGroup(e, target);
        if (this._shouldClearSelection(e, target)) {
          this.discardActiveObject(e);
        }
        else if (shouldGroup) {
          this._handleGrouping(e, target);
          target = this._activeObject;
        }

        if (this.selection && (!target ||
          (!target.selectable && !target.isEditing && target !== this._activeObject))) {
          this._groupSelector = {
            ex: pointer.x,
            ey: pointer.y,
            top: 0,
            left: 0
          };
        }

        if (target) {
          if (target.selectable) {
            this.setActiveObject(target, e);
          }
          if (target === this._activeObject && (target.__corner || !shouldGroup)) {
            this._setupCurrentTransform(e, target);
          }
        }
        this._handleEvent(e, 'down');
        // we must renderAll so that we update the visuals
        shouldRender && this.requestRenderAll();
      },

      /**
       * reset cache form common information needed during event processing
       * @private
       */
      _resetTransformEventData: function() {
        this._target = null;
        this._pointer = null;
        this._absolutePointer = null;
      },

      /**
       * Cache common information needed during event processing
       * @private
       * @param {Event} e Event object fired on event
       */
      _cacheTransformEventData: function(e) {
        // reset in order to avoid stale caching
        this._resetTransformEventData();
        this._pointer = this.getPointer(e, true);
        this._absolutePointer = this.restorePointerVpt(this._pointer);
        this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
      },

      /**
       * @private
       */
      _beforeTransform: function(e) {
        var t = this._currentTransform;
        this.stateful && t.target.saveState();
        this.fire('before:transform', {
          e: e,
          transform: t,
        });
        // determine if it's a drag or rotate case
        if (t.corner) {
          this.onBeforeScaleRotate(t.target);
        }
      },

      /**
       * Method that defines the actions when mouse is hovering the canvas.
       * The currentTransform parameter will definde whether the user is rotating/scaling/translating
       * an image or neither of them (only hovering). A group selection is also possible and would cancel
       * all any other type of action.
       * In case of an image transformation only the top canvas will be rendered.
       * @private
       * @param {Event} e Event object fired on mousemove
       */
      __onMouseMove: function (e) {
        this._handleEvent(e, 'move:before');
        this._cacheTransformEventData(e);
        var target, pointer;

        if (this.isDrawingMode) {
          this._onMouseMoveInDrawingMode(e);
          return;
        }
        if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
          return;
        }

        var groupSelector = this._groupSelector;

        // We initially clicked in an empty area, so we draw a box for multiple selection
        if (groupSelector) {
          pointer = this._pointer;

          groupSelector.left = pointer.x - groupSelector.ex;
          groupSelector.top = pointer.y - groupSelector.ey;

          this.renderTop();
        }
        else if (!this._currentTransform) {
          target = this.findTarget(e) || null;
          this._setCursorFromEvent(e, target);
          this._fireOverOutEvents(target, e);
        }
        else {
          this._transformObject(e);
        }
        this._handleEvent(e, 'move');
        this._resetTransformEventData();
      },

      /**
       * Manage the mouseout, mouseover events for the fabric object on the canvas
       * @param {Fabric.Object} target the target where the target from the mousemove event
       * @param {Event} e Event object fired on mousemove
       * @private
       */
      _fireOverOutEvents: function(target, e) {
        this.fireSynteticInOutEvents(target, e, {
          targetName: '_hoveredTarget',
          canvasEvtOut: 'mouse:out',
          evtOut: 'mouseout',
          canvasEvtIn: 'mouse:over',
          evtIn: 'mouseover',
        });
      },

      /**
       * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
       * @param {Fabric.Object} target the target where the target from the onDrag event
       * @param {Event} e Event object fired on ondrag
       * @private
       */
      _fireEnterLeaveEvents: function(target, e) {
        this.fireSynteticInOutEvents(target, e, {
          targetName: '_draggedoverTarget',
          evtOut: 'dragleave',
          evtIn: 'dragenter',
        });
      },

      /**
       * Manage the syntetic in/out events for the fabric objects on the canvas
       * @param {Fabric.Object} target the target where the target from the supported events
       * @param {Event} e Event object fired
       * @param {Object} config configuration for the function to work
       * @param {String} config.targetName property on the canvas where the old target is stored
       * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
       * @param {String} config.evtOut name of the event to fire for out
       * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
       * @param {String} config.evtIn name of the event to fire for in
       * @private
       */
      fireSynteticInOutEvents: function(target, e, config) {
        var inOpt, outOpt, oldTarget = this[config.targetName], outFires, inFires,
            targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
        if (targetChanged) {
          inOpt = { e: e, target: target, previousTarget: oldTarget };
          outOpt = { e: e, target: oldTarget, nextTarget: target };
          this[config.targetName] = target;
        }
        inFires = target && targetChanged;
        outFires = oldTarget && targetChanged;
        if (outFires) {
          canvasEvtOut && this.fire(canvasEvtOut, outOpt);
          oldTarget.fire(config.evtOut, outOpt);
        }
        if (inFires) {
          canvasEvtIn && this.fire(canvasEvtIn, inOpt);
          target.fire(config.evtIn, inOpt);
        }
      },

      /**
       * Method that defines actions when an Event Mouse Wheel
       * @param {Event} e Event object fired on mouseup
       */
      __onMouseWheel: function(e) {
        this._cacheTransformEventData(e);
        this._handleEvent(e, 'wheel');
        this._resetTransformEventData();
      },

      /**
       * @private
       * @param {Event} e Event fired on mousemove
       */
      _transformObject: function(e) {
        var pointer = this.getPointer(e),
            transform = this._currentTransform;

        transform.reset = false;
        transform.target.isMoving = true;
        transform.shiftKey = e.shiftKey;
        transform.altKey = e[this.centeredKey];

        this._beforeScaleTransform(e, transform);
        this._performTransformAction(e, transform, pointer);

        transform.actionPerformed && this.requestRenderAll();
      },

      /**
       * @private
       */
      _performTransformAction: function(e, transform, pointer) {
        var x = pointer.x,
            y = pointer.y,
            action = transform.action,
            actionPerformed = false,
            options = {
              target: transform.target,
              e: e,
              transform: transform,
              pointer: pointer
            };

        if (action === 'rotate') {
          (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', options);
        }
        else if (action === 'scale') {
          (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', options);
        }
        else if (action === 'scaleX') {
          (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', options);
        }
        else if (action === 'scaleY') {
          (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', options);
        }
        else if (action === 'skewX') {
          (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', options);
        }
        else if (action === 'skewY') {
          (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', options);
        }
        else {
          actionPerformed = this._translateObject(x, y);
          if (actionPerformed) {
            this._fire('moving', options);
            this.setCursor(options.target.moveCursor || this.moveCursor);
          }
        }
        transform.actionPerformed = transform.actionPerformed || actionPerformed;
      },

      /**
       * @private
       */
      _fire: function(eventName, options) {
        this.fire('object:' + eventName, options);
        options.target.fire(eventName, options);
      },

      /**
       * @private
       */
      _beforeScaleTransform: function(e, transform) {
        if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
          var centerTransform = this._shouldCenterTransform(transform.target);

          // Switch from a normal resize to center-based
          if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
             // Switch from center-based resize to normal one
             (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
          ) {
            this._resetCurrentTransform();
            transform.reset = true;
          }
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {Object} transform current tranform
       * @param {Number} x mouse position x from origin
       * @param {Number} y mouse poistion y from origin
       * @return {Boolean} true if the scaling occurred
       */
      _onScale: function(e, transform, x, y) {
        if (this._isUniscalePossible(e, transform.target)) {
          transform.currentAction = 'scale';
          return this._scaleObject(x, y);
        }
        else {
          // Switch from a normal resize to proportional
          if (!transform.reset && transform.currentAction === 'scale') {
            this._resetCurrentTransform();
          }

          transform.currentAction = 'scaleEqually';
          return this._scaleObject(x, y, 'equally');
        }
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target current target
       * @return {Boolean} true if unproportional scaling is possible
       */
      _isUniscalePossible: function(e, target) {
        return (e[this.uniScaleKey] || this.uniScaleTransform) && !target.get('lockUniScaling');
      },

      /**
       * Sets the cursor depending on where the canvas is being hovered.
       * Note: very buggy in Opera
       * @param {Event} e Event object
       * @param {Object} target Object that the mouse is hovering, if so.
       */
      _setCursorFromEvent: function (e, target) {
        if (!target) {
          this.setCursor(this.defaultCursor);
          return false;
        }

        var hoverCursor = target.hoverCursor || this.hoverCursor,
            activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
              this._activeObject : null,
            // only show proper corner when group selection is not active
            corner = (!activeSelection || !activeSelection.contains(target))
                      && target._findTargetCorner(this.getPointer(e, true));

        if (!corner) {
          this.setCursor(hoverCursor);
        }
        else {
          this.setCursor(this.getCornerCursor(corner, target, e));
        }
      },

      /**
       * @private
       */
      getCornerCursor: function(corner, target, e) {
        if (this.actionIsDisabled(corner, target, e)) {
          return this.notAllowedCursor;
        }
        else if (corner in cursorOffset) {
          return this._getRotatedCornerCursor(corner, target, e);
        }
        else if (corner === 'mtr' && target.hasRotatingPoint) {
          return this.rotationCursor;
        }
        else {
          return this.defaultCursor;
        }
      },

      actionIsDisabled: function(corner, target, e) {
        if (corner === 'mt' || corner === 'mb') {
          return e[this.altActionKey] ? target.lockSkewingX : target.lockScalingY;
        }
        else if (corner === 'ml' || corner === 'mr') {
          return e[this.altActionKey] ? target.lockSkewingY : target.lockScalingX;
        }
        else if (corner === 'mtr') {
          return target.lockRotation;
        }
        else {
          return this._isUniscalePossible(e, target) ?
            target.lockScalingX && target.lockScalingY : target.lockScalingX || target.lockScalingY;
        }
      },

      /**
       * @private
       */
      _getRotatedCornerCursor: function(corner, target, e) {
        var n = Math.round((target.angle % 360) / 45);

        if (n < 0) {
          n += 8; // full circle ahead
        }
        n += cursorOffset[corner];
        if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
          //if we are holding shift and we are on a mx corner...
          n += 2;
        }
        // normalize n to be from 0 to 7
        n %= 8;

        return this.cursorMap[n];
      }
    });
  })();


  (function() {

    var min = Math.min,
        max = Math.max;

    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       * @return {Boolean}
       */
      _shouldGroup: function(e, target) {
        var activeObject = this._activeObject;

        return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
              (activeObject !== target || activeObject.type === 'activeSelection');
      },

      /**
       * @private
       * @param {Event} e Event object
       * @param {fabric.Object} target
       */
      _handleGrouping: function (e, target) {
        var activeObject = this._activeObject;
        if (activeObject.__corner) {
          return;
        }
        if (target === activeObject) {
          // if it's a group, find target again, using activeGroup objects
          target = this.findTarget(e, true);
          // if even object is not found or we are on activeObjectCorner, bail out
          if (!target) {
            return;
          }
        }
        if (activeObject && activeObject.type === 'activeSelection') {
          this._updateActiveSelection(target, e);
        }
        else {
          this._createActiveSelection(target, e);
        }
      },

      /**
       * @private
       */
      _updateActiveSelection: function(target, e) {
        var activeSelection = this._activeObject,
            currentActiveObjects = activeSelection._objects.slice(0);
        if (activeSelection.contains(target)) {
          activeSelection.removeWithUpdate(target);
          this._hoveredTarget = target;
          if (activeSelection.size() === 1) {
            // activate last remaining object
            this._setActiveObject(activeSelection.item(0), e);
          }
        }
        else {
          activeSelection.addWithUpdate(target);
          this._hoveredTarget = activeSelection;
        }
        this._fireSelectionEvents(currentActiveObjects, e);
      },

      /**
       * @private
       */
      _createActiveSelection: function(target, e) {
        var currentActives = this.getActiveObjects(), group = this._createGroup(target);
        this._hoveredTarget = group;
        this._setActiveObject(group, e);
        this._fireSelectionEvents(currentActives, e);
      },

      /**
       * @private
       * @param {Object} target
       */
      _createGroup: function(target) {
        var objects = this.getObjects(),
            isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
            groupObjects = isActiveLower
              ? [this._activeObject, target]
              : [target, this._activeObject];
        this._activeObject.isEditing && this._activeObject.exitEditing();
        return new fabric.ActiveSelection(groupObjects, {
          canvas: this
        });
      },

      /**
       * @private
       * @param {Event} e mouse event
       */
      _groupSelectedObjects: function (e) {

        var group = this._collectObjects(),
            aGroup;

        // do not create group for 1 element only
        if (group.length === 1) {
          this.setActiveObject(group[0], e);
        }
        else if (group.length > 1) {
          aGroup = new fabric.ActiveSelection(group.reverse(), {
            canvas: this
          });
          this.setActiveObject(aGroup, e);
        }
      },

      /**
       * @private
       */
      _collectObjects: function() {
        var group = [],
            currentObject,
            x1 = this._groupSelector.ex,
            y1 = this._groupSelector.ey,
            x2 = x1 + this._groupSelector.left,
            y2 = y1 + this._groupSelector.top,
            selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
            selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
            allowIntersect = !this.selectionFullyContained,
            isClick = x1 === x2 && y1 === y2;
        // we iterate reverse order to collect top first in case of click.
        for (var i = this._objects.length; i--; ) {
          currentObject = this._objects[i];

          if (!currentObject || !currentObject.selectable || !currentObject.visible) {
            continue;
          }

          if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||
              currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
              (allowIntersect && currentObject.containsPoint(selectionX1Y1)) ||
              (allowIntersect && currentObject.containsPoint(selectionX2Y2))
          ) {
            group.push(currentObject);

            // only add one object if it's a click
            if (isClick) {
              break;
            }
          }
        }

        return group;
      },

      /**
       * @private
       */
      _maybeGroupObjects: function(e) {
        if (this.selection && this._groupSelector) {
          this._groupSelectedObjects(e);
        }
        this.setCursor(this.defaultCursor);
        // clear selection and current transformation
        this._groupSelector = null;
      }
    });

  })();


  (function () {

    var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');

    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

      /**
       * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
       * @param {Object} [options] Options object
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
       * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
       * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
       * @example <caption>Generate jpeg dataURL with lower quality</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'jpeg',
       *   quality: 0.8
       * });
       * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'png',
       *   left: 100,
       *   top: 100,
       *   width: 200,
       *   height: 200
       * });
       * @example <caption>Generate double scaled png dataURL</caption>
       * var dataURL = canvas.toDataURL({
       *   format: 'png',
       *   multiplier: 2
       * });
       */
      toDataURL: function (options) {
        options || (options = { });

        var format = options.format || 'png',
            quality = options.quality || 1,
            multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? 1 : 1 / this.getRetinaScaling()),
            cropping = {
              left: options.left || 0,
              top: options.top || 0,
              width: options.width || 0,
              height: options.height || 0,
            };
        return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
      },

      /**
       * @private
       */
      __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {

        var origWidth = this.width,
            origHeight = this.height,
            scaledWidth = (cropping.width || this.width) * multiplier,
            scaledHeight = (cropping.height || this.height) * multiplier,
            zoom = this.getZoom(),
            newZoom = zoom * multiplier,
            vp = this.viewportTransform,
            translateX = (vp[4] - cropping.left) * multiplier,
            translateY = (vp[5] - cropping.top) * multiplier,
            newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
            originalInteractive = this.interactive,
            originalSkipOffScreen = this.skipOffscreen,
            needsResize = origWidth !== scaledWidth || origHeight !== scaledHeight;

        this.viewportTransform = newVp;
        this.skipOffscreen = false;
        // setting interactive to false avoid exporting controls
        this.interactive = false;
        if (needsResize) {
          this.setDimensions({ width: scaledWidth, height: scaledHeight }, { backstoreOnly: true });
        }
        // call a renderAll to force sync update. This will cancel the scheduled requestRenderAll
        // from setDimensions
        this.renderAll();
        var data = this.__toDataURL(format, quality, cropping);
        this.interactive = originalInteractive;
        this.skipOffscreen = originalSkipOffScreen;
        this.viewportTransform = vp;
        //setDimensions with no option object is taking care of:
        //this.width, this.height, this.requestRenderAll()
        if (needsResize) {
          this.setDimensions({ width: origWidth, height: origHeight }, { backstoreOnly: true });
        }
        this.renderAll();
        return data;
      },

      /**
       * @private
       */
      __toDataURL: function(format, quality) {

        var canvasEl = this.contextContainer.canvas;
        // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
        if (format === 'jpg') {
          format = 'jpeg';
        }

        var data = supportQuality
          ? canvasEl.toDataURL('image/' + format, quality)
          : canvasEl.toDataURL('image/' + format);

        return data;
      },
    });

  })();


  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Populates canvas with data from the specified dataless JSON.
     * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
     * @deprecated since 1.2.2
     * @param {String|Object} json JSON string or object
     * @param {Function} callback Callback, invoked when json is parsed
     *                            and corresponding objects (e.g: {@link fabric.Image})
     *                            are initialized
     * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
     * @return {fabric.Canvas} instance
     * @chainable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
     */
    loadFromDatalessJSON: function (json, callback, reviver) {
      return this.loadFromJSON(json, callback, reviver);
    },

    /**
     * Populates canvas with data from the specified JSON.
     * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
     * @param {String|Object} json JSON string or object
     * @param {Function} callback Callback, invoked when json is parsed
     *                            and corresponding objects (e.g: {@link fabric.Image})
     *                            are initialized
     * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
     * @return {fabric.Canvas} instance
     * @chainable
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
     * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
     * @example <caption>loadFromJSON</caption>
     * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
     * @example <caption>loadFromJSON with reviver</caption>
     * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
     *   // `o` = json object
     *   // `object` = fabric.Object instance
     *   // ... do some stuff ...
     * });
     */
    loadFromJSON: function (json, callback, reviver) {
      if (!json) {
        return;
      }

      // serialize if it wasn't already
      var serialized = (typeof json === 'string')
        ? JSON.parse(json)
        : fabric.util.object.clone(json);

      var _this = this,
          renderOnAddRemove = this.renderOnAddRemove;
      this.renderOnAddRemove = false;

      this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
        _this.clear();
        _this._setBgOverlay(serialized, function () {
          enlivenedObjects.forEach(function(obj, index) {
            // we splice the array just in case some custom classes restored from JSON
            // will add more object to canvas at canvas init.
            _this.insertAt(obj, index);
          });
          _this.renderOnAddRemove = renderOnAddRemove;
          // remove parts i cannot set as options
          delete serialized.objects;
          delete serialized.backgroundImage;
          delete serialized.overlayImage;
          delete serialized.background;
          delete serialized.overlay;
          // this._initOptions does too many things to just
          // call it. Normally loading an Object from JSON
          // create the Object instance. Here the Canvas is
          // already an instance and we are just loading things over it
          _this._setOptions(serialized);
          _this.renderAll();
          callback && callback();
        });
      }, reviver);
      return this;
    },

    /**
     * @private
     * @param {Object} serialized Object with background and overlay information
     * @param {Function} callback Invoked after all background and overlay images/patterns loaded
     */
    _setBgOverlay: function(serialized, callback) {
      var loaded = {
        backgroundColor: false,
        overlayColor: false,
        backgroundImage: false,
        overlayImage: false
      };

      if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
        callback && callback();
        return;
      }

      var cbIfLoaded = function () {
        if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
          callback && callback();
        }
      };

      this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
      this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
      this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
      this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
    },

    /**
     * @private
     * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
     * @param {(Object|String)} value Value to set
     * @param {Object} loaded Set loaded property to true if property is set
     * @param {Object} callback Callback function to invoke after property is set
     */
    __setBgOverlay: function(property, value, loaded, callback) {
      var _this = this;

      if (!value) {
        loaded[property] = true;
        callback && callback();
        return;
      }

      if (property === 'backgroundImage' || property === 'overlayImage') {
        fabric.util.enlivenObjects([value], function(enlivedObject){
          _this[property] = enlivedObject[0];
          loaded[property] = true;
          callback && callback();
        });
      }
      else {
        this['set' + fabric.util.string.capitalize(property, true)](value, function() {
          loaded[property] = true;
          callback && callback();
        });
      }
    },

    /**
     * @private
     * @param {Array} objects
     * @param {Function} callback
     * @param {Function} [reviver]
     */
    _enlivenObjects: function (objects, callback, reviver) {
      if (!objects || objects.length === 0) {
        callback && callback([]);
        return;
      }

      fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
        callback && callback(enlivenedObjects);
      }, null, reviver);
    },

    /**
     * @private
     * @param {String} format
     * @param {Function} callback
     */
    _toDataURL: function (format, callback) {
      this.clone(function (clone) {
        callback(clone.toDataURL(format));
      });
    },

    /**
     * @private
     * @param {String} format
     * @param {Number} multiplier
     * @param {Function} callback
     */
    _toDataURLWithMultiplier: function (format, multiplier, callback) {
      this.clone(function (clone) {
        callback(clone.toDataURLWithMultiplier(format, multiplier));
      });
    },

    /**
     * Clones canvas instance
     * @param {Object} [callback] Receives cloned instance as a first argument
     * @param {Array} [properties] Array of properties to include in the cloned canvas and children
     */
    clone: function (callback, properties) {
      var data = JSON.stringify(this.toJSON(properties));
      this.cloneWithoutData(function(clone) {
        clone.loadFromJSON(data, function() {
          callback && callback(clone);
        });
      });
    },

    /**
     * Clones canvas instance without cloning existing data.
     * This essentially copies canvas dimensions, clipping properties, etc.
     * but leaves data empty (so that you can populate it with your own)
     * @param {Object} [callback] Receives cloned instance as a first argument
     */
    cloneWithoutData: function(callback) {
      var el = fabric.document.createElement('canvas');

      el.width = this.width;
      el.height = this.height;

      var clone = new fabric.Canvas(el);
      clone.clipTo = this.clipTo;
      if (this.backgroundImage) {
        clone.setBackgroundImage(this.backgroundImage.src, function() {
          clone.renderAll();
          callback && callback(clone);
        });
        clone.backgroundImageOpacity = this.backgroundImageOpacity;
        clone.backgroundImageStretch = this.backgroundImageStretch;
      }
      else {
        callback && callback(clone);
      }
    }
  });


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        toFixed = fabric.util.toFixed,
        capitalize = fabric.util.string.capitalize,
        degreesToRadians = fabric.util.degreesToRadians,
        supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
        objectCaching = !fabric.isLikelyNode,
        ALIASING_LIMIT = 2;

    if (fabric.Object) {
      return;
    }

    /**
     * Root object class from which all 2d shape classes inherit from
     * @class fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
     * @see {@link fabric.Object#initialize} for constructor definition
     *
     * @fires added
     * @fires removed
     *
     * @fires selected
     * @fires deselected
     * @fires modified
     * @fires modified
     * @fires moved
     * @fires scaled
     * @fires rotated
     * @fires skewed
     *
     * @fires rotating
     * @fires scaling
     * @fires moving
     * @fires skewing
     *
     * @fires mousedown
     * @fires mouseup
     * @fires mouseover
     * @fires mouseout
     * @fires mousewheel
     * @fires mousedblclick
     *
     * @fires dragover
     * @fires dragenter
     * @fires dragleave
     * @fires drop
     */
    fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

      /**
       * Type of an object (rect, circle, path, etc.).
       * Note that this property is meant to be read-only and not meant to be modified.
       * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
       * @type String
       * @default
       */
      type:                     'object',

      /**
       * Horizontal origin of transformation of an object (one of "left", "right", "center")
       * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
       * @type String
       * @default
       */
      originX:                  'left',

      /**
       * Vertical origin of transformation of an object (one of "top", "bottom", "center")
       * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
       * @type String
       * @default
       */
      originY:                  'top',

      /**
       * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
       * @type Number
       * @default
       */
      top:                      0,

      /**
       * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
       * @type Number
       * @default
       */
      left:                     0,

      /**
       * Object width
       * @type Number
       * @default
       */
      width:                    0,

      /**
       * Object height
       * @type Number
       * @default
       */
      height:                   0,

      /**
       * Object scale factor (horizontal)
       * @type Number
       * @default
       */
      scaleX:                   1,

      /**
       * Object scale factor (vertical)
       * @type Number
       * @default
       */
      scaleY:                   1,

      /**
       * When true, an object is rendered as flipped horizontally
       * @type Boolean
       * @default
       */
      flipX:                    false,

      /**
       * When true, an object is rendered as flipped vertically
       * @type Boolean
       * @default
       */
      flipY:                    false,

      /**
       * Opacity of an object
       * @type Number
       * @default
       */
      opacity:                  1,

      /**
       * Angle of rotation of an object (in degrees)
       * @type Number
       * @default
       */
      angle:                    0,

      /**
       * Angle of skew on x axes of an object (in degrees)
       * @type Number
       * @default
       */
      skewX:                    0,

      /**
       * Angle of skew on y axes of an object (in degrees)
       * @type Number
       * @default
       */
      skewY:                    0,

      /**
       * Size of object's controlling corners (in pixels)
       * @type Number
       * @default
       */
      cornerSize:               13,

      /**
       * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
       * @type Boolean
       * @default
       */
      transparentCorners:       true,

      /**
       * Default cursor value used when hovering over this object on canvas
       * @type String
       * @default
       */
      hoverCursor:              null,

      /**
       * Default cursor value used when moving this object on canvas
       * @type String
       * @default
       */
      moveCursor:               null,

      /**
       * Padding between object and its controlling borders (in pixels)
       * @type Number
       * @default
       */
      padding:                  0,

      /**
       * Color of controlling borders of an object (when it's active)
       * @type String
       * @default
       */
      borderColor:              'rgba(102,153,255,0.75)',

      /**
       * Array specifying dash pattern of an object's borders (hasBorder must be true)
       * @since 1.6.2
       * @type Array
       */
      borderDashArray:          null,

      /**
       * Color of controlling corners of an object (when it's active)
       * @type String
       * @default
       */
      cornerColor:              'rgba(102,153,255,0.5)',

      /**
       * Color of controlling corners of an object (when it's active and transparentCorners false)
       * @since 1.6.2
       * @type String
       * @default
       */
      cornerStrokeColor:        null,

      /**
       * Specify style of control, 'rect' or 'circle'
       * @since 1.6.2
       * @type String
       */
      cornerStyle:          'rect',

      /**
       * Array specifying dash pattern of an object's control (hasBorder must be true)
       * @since 1.6.2
       * @type Array
       */
      cornerDashArray:          null,

      /**
       * When true, this object will use center point as the origin of transformation
       * when being scaled via the controls.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredScaling:          false,

      /**
       * When true, this object will use center point as the origin of transformation
       * when being rotated via the controls.
       * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
       * @since 1.3.4
       * @type Boolean
       * @default
       */
      centeredRotation:         true,

      /**
       * Color of object's fill
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      fill:                     'rgb(0,0,0)',

      /**
       * Fill rule used to fill an object
       * accepted values are nonzero, evenodd
       * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
       * @type String
       * @default
       */
      fillRule:                 'nonzero',

      /**
       * Composite rule used for canvas globalCompositeOperation
       * @type String
       * @default
       */
      globalCompositeOperation: 'source-over',

      /**
       * Background color of an object.
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      backgroundColor:          '',

      /**
       * Selection Background color of an object. colored layer behind the object when it is active.
       * does not mix good with globalCompositeOperation methods.
       * @type String
       * @default
       */
      selectionBackgroundColor:          '',

      /**
       * When defined, an object is rendered via stroke and this property specifies its color
       * takes css colors https://www.w3.org/TR/css-color-3/
       * @type String
       * @default
       */
      stroke:                   null,

      /**
       * Width of a stroke used to render this object
       * @type Number
       * @default
       */
      strokeWidth:              1,

      /**
       * Array specifying dash pattern of an object's stroke (stroke must be defined)
       * @type Array
       */
      strokeDashArray:          null,

      /**
       * Line endings style of an object's stroke (one of "butt", "round", "square")
       * @type String
       * @default
       */
      strokeLineCap:            'butt',

      /**
       * Corner style of an object's stroke (one of "bevil", "round", "miter")
       * @type String
       * @default
       */
      strokeLineJoin:           'miter',

      /**
       * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
       * @type Number
       * @default
       */
      strokeMiterLimit:         4,

      /**
       * Shadow object representing shadow of this shape
       * @type fabric.Shadow
       * @default
       */
      shadow:                   null,

      /**
       * Opacity of object's controlling borders when object is active and moving
       * @type Number
       * @default
       */
      borderOpacityWhenMoving:  0.4,

      /**
       * Scale factor of object's controlling borders
       * @type Number
       * @default
       */
      borderScaleFactor:        1,

      /**
       * Transform matrix (similar to SVG's transform matrix)
       * @type Array
       */
      transformMatrix:          null,

      /**
       * Minimum allowed scale value of an object
       * @type Number
       * @default
       */
      minScaleLimit:            0,

      /**
       * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
       * But events still fire on it.
       * @type Boolean
       * @default
       */
      selectable:               true,

      /**
       * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
       * @type Boolean
       * @default
       */
      evented:                  true,

      /**
       * When set to `false`, an object is not rendered on canvas
       * @type Boolean
       * @default
       */
      visible:                  true,

      /**
       * When set to `false`, object's controls are not displayed and can not be used to manipulate object
       * @type Boolean
       * @default
       */
      hasControls:              true,

      /**
       * When set to `false`, object's controlling borders are not rendered
       * @type Boolean
       * @default
       */
      hasBorders:               true,

      /**
       * When set to `false`, object's controlling rotating point will not be visible or selectable
       * @type Boolean
       * @default
       */
      hasRotatingPoint:         true,

      /**
       * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
       * @type Number
       * @default
       */
      rotatingPointOffset:      40,

      /**
       * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
       * @type Boolean
       * @default
       */
      perPixelTargetFind:       false,

      /**
       * When `false`, default object's values are not included in its serialization
       * @type Boolean
       * @default
       */
      includeDefaultValues:     true,

      /**
       * Function that determines clipping of an object (context is passed as a first argument)
       * Note that context origin is at the object's center point (not left/top corner)
       * @deprecated since 2.0.0
       * @type Function
       */
      clipTo:                   null,

      /**
       * When `true`, object horizontal movement is locked
       * @type Boolean
       * @default
       */
      lockMovementX:            false,

      /**
       * When `true`, object vertical movement is locked
       * @type Boolean
       * @default
       */
      lockMovementY:            false,

      /**
       * When `true`, object rotation is locked
       * @type Boolean
       * @default
       */
      lockRotation:             false,

      /**
       * When `true`, object horizontal scaling is locked
       * @type Boolean
       * @default
       */
      lockScalingX:             false,

      /**
       * When `true`, object vertical scaling is locked
       * @type Boolean
       * @default
       */
      lockScalingY:             false,

      /**
       * When `true`, object non-uniform scaling is locked
       * @type Boolean
       * @default
       */
      lockUniScaling:           false,

      /**
       * When `true`, object horizontal skewing is locked
       * @type Boolean
       * @default
       */
      lockSkewingX:             false,

      /**
       * When `true`, object vertical skewing is locked
       * @type Boolean
       * @default
       */
      lockSkewingY:             false,

      /**
       * When `true`, object cannot be flipped by scaling into negative values
       * @type Boolean
       * @default
       */
      lockScalingFlip:          false,

      /**
       * When `true`, object is not exported in OBJECT/JSON
       * since 1.6.3
       * @type Boolean
       * @default
       */
      excludeFromExport:        false,

      /**
       * When `true`, object is cached on an additional canvas.
       * default to true
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      objectCaching:            objectCaching,

      /**
       * When `true`, object properties are checked for cache invalidation. In some particular
       * situation you may want this to be disabled ( spray brush, very big, groups)
       * or if your application does not allow you to modify properties for groups child you want
       * to disable it for groups.
       * default to false
       * since 1.7.0
       * @type Boolean
       * @default false
       */
      statefullCache:            false,

      /**
       * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
       * too much and will be redrawn with correct details at the end of scaling.
       * this setting is performance and application dependant.
       * default to true
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      noScaleCache:              true,

      /**
       * When set to `true`, object's cache will be rerendered next render call.
       * since 1.7.0
       * @type Boolean
       * @default true
       */
      dirty:                true,

      /**
       * keeps the value of the last hovered coner during mouse move.
       * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
       * It should be private, but there is no harm in using it as
       * a read-only property.
       * @type number|string|any
       * @default 0
       */
      __corner: 0,

      /**
       * Determins if the fill or the stroke is drawn first (one of "fill" or "stroke")
       * @type String
       * @default
       */
      paintFirst:           'fill',

      /**
       * List of properties to consider when checking if state
       * of an object is changed (fabric.Object#hasStateChanged)
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: (
        'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
        'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +
        'angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor ' +
        'skewX skewY fillRule paintFirst'
      ).split(' '),

      /**
       * List of properties to consider when checking if cache needs refresh
       * @type Array
       */
      cacheProperties: (
        'fill stroke strokeWidth strokeDashArray width height paintFirst' +
        ' strokeLineCap strokeLineJoin strokeMiterLimit backgroundColor'
      ).split(' '),

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        if (options) {
          this.setOptions(options);
        }
      },

      /**
       * Create a the canvas used to keep the cached copy of the object
       * @private
       */
      _createCacheCanvas: function() {
        this._cacheProperties = {};
        this._cacheCanvas = fabric.document.createElement('canvas');
        this._cacheContext = this._cacheCanvas.getContext('2d');
        this._updateCacheCanvas();
        // if canvas gets created, is empty, so dirty.
        this.dirty = true;
      },

      /**
       * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
       * and each side do not cross fabric.cacheSideLimit
       * those numbers are configurable so that you can get as much detail as you want
       * making bargain with performances.
       * @param {Object} dims
       * @param {Object} dims.width width of canvas
       * @param {Object} dims.height height of canvas
       * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _limitCacheSize: function(dims) {
        var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
            width = dims.width, height = dims.height,
            max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
        if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
          if (width < min) {
            dims.width = min;
          }
          if (height < min) {
            dims.height = min;
          }
          return dims;
        }
        var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
            capValue = fabric.util.capValue,
            x = capValue(min, limitedDims.x, max),
            y = capValue(min, limitedDims.y, max);
        if (width > x) {
          dims.zoomX /= width / x;
          dims.width = x;
          dims.capped = true;
        }
        if (height > y) {
          dims.zoomY /= height / y;
          dims.height = y;
          dims.capped = true;
        }
        return dims;
      },

      /**
       * Return the dimension and the zoom level needed to create a cache canvas
       * big enough to host the object to be cached.
       * @private
       * @param {Object} dim.x width of object to be cached
       * @param {Object} dim.y height of object to be cached
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _getCacheCanvasDimensions: function() {
        var zoom = this.canvas && this.canvas.getZoom() || 1,
            objectScale = this.getObjectScaling(),
            retina = this.canvas && this.canvas._isRetinaScaling() ? fabric.devicePixelRatio : 1,
            dim = this._getNonTransformedDimensions(),
            zoomX = objectScale.scaleX * zoom * retina,
            zoomY = objectScale.scaleY * zoom * retina,
            width = dim.x * zoomX,
            height = dim.y * zoomY;
        return {
          // for sure this ALIASING_LIMIT is slightly crating problem
          // in situation in wich the cache canvas gets an upper limit
          width: width + ALIASING_LIMIT,
          height: height + ALIASING_LIMIT,
          zoomX: zoomX,
          zoomY: zoomY,
          x: dim.x,
          y: dim.y
        };
      },

      /**
       * Update width and height of the canvas for cache
       * returns true or false if canvas needed resize.
       * @private
       * @return {Boolean} true if the canvas has been resized
       */
      _updateCacheCanvas: function() {
        if (this.noScaleCache && this.canvas && this.canvas._currentTransform) {
          var target = this.canvas._currentTransform.target,
              action = this.canvas._currentTransform.action;
          if (this === target && action.slice && action.slice(0, 5) === 'scale') {
            return false;
          }
        }
        var canvas = this._cacheCanvas,
            dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
            minCacheSize = fabric.minCacheSideLimit,
            width = dims.width, height = dims.height, drawingWidth, drawingHeight,
            zoomX = dims.zoomX, zoomY = dims.zoomY,
            dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
            zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
            shouldRedraw = dimensionsChanged || zoomChanged,
            additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
        if (dimensionsChanged) {
          var canvasWidth = this._cacheCanvas.width,
              canvasHeight = this._cacheCanvas.height,
              sizeGrowing = width > canvasWidth || height > canvasHeight,
              sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
                canvasWidth > minCacheSize && canvasHeight > minCacheSize;
          shouldResizeCanvas = sizeGrowing || sizeShrinking;
          if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
            additionalWidth = width * 0.1;
            additionalHeight = height * 0.1;
          }
        }
        if (shouldRedraw) {
          if (shouldResizeCanvas) {
            canvas.width = Math.ceil(width + additionalWidth);
            canvas.height = Math.ceil(height + additionalHeight);
          }
          else {
            this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
            this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
          }
          drawingWidth = dims.x * zoomX / 2;
          drawingHeight = dims.y * zoomY / 2;
          this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
          this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
          this.cacheWidth = width;
          this.cacheHeight = height;
          this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
          this._cacheContext.scale(zoomX, zoomY);
          this.zoomX = zoomX;
          this.zoomY = zoomY;
          return true;
        }
        return false;
      },

      /**
       * Sets object's properties from options
       * @param {Object} [options] Options object
       */
      setOptions: function(options) {
        this._setOptions(options);
        this._initGradient(options.fill, 'fill');
        this._initGradient(options.stroke, 'stroke');
        this._initClipping(options);
        this._initPattern(options.fill, 'fill');
        this._initPattern(options.stroke, 'stroke');
      },

      /**
       * Transforms context when rendering an object
       * @param {CanvasRenderingContext2D} ctx Context
       */
      transform: function(ctx) {
        var m;
        if (this.group && !this.group._transformDone) {
          m = this.calcTransformMatrix();
        }
        else {
          m = this.calcOwnMatrix();
        }
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      },

      /**
       * Returns an object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

            object = {
              type:                     this.type,
              version:                  fabric.version,
              originX:                  this.originX,
              originY:                  this.originY,
              left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
              top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
              width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
              height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
              fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
              stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
              strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
              strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
              strokeLineCap:            this.strokeLineCap,
              strokeLineJoin:           this.strokeLineJoin,
              strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
              scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
              scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
              angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
              flipX:                    this.flipX,
              flipY:                    this.flipY,
              opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
              shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
              visible:                  this.visible,
              clipTo:                   this.clipTo && String(this.clipTo),
              backgroundColor:          this.backgroundColor,
              fillRule:                 this.fillRule,
              paintFirst:               this.paintFirst,
              globalCompositeOperation: this.globalCompositeOperation,
              transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
              skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
              skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)
            };

        fabric.util.populateWithProperties(this, object, propertiesToInclude);
        if (!this.includeDefaultValues) {
          object = this._removeDefaultValues(object);
        }

        return object;
      },

      /**
       * Returns (dataless) object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        // will be overwritten by subclasses
        return this.toObject(propertiesToInclude);
      },

      /**
       * @private
       * @param {Object} object
       */
      _removeDefaultValues: function(object) {
        var prototype = fabric.util.getKlass(object.type).prototype,
            stateProperties = prototype.stateProperties;
        stateProperties.forEach(function(prop) {
          if (object[prop] === prototype[prop]) {
            delete object[prop];
          }
          var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                        Object.prototype.toString.call(prototype[prop]) === '[object Array]';

          // basically a check for [] === []
          if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
            delete object[prop];
          }
        });

        return object;
      },

      /**
       * Returns a string representation of an instance
       * @return {String}
       */
      toString: function() {
        return '#<fabric.' + capitalize(this.type) + '>';
      },

      /**
       * Return the object scale factor counting also the group scaling
       * @return {Object} object with scaleX and scaleY properties
       */
      getObjectScaling: function() {
        var scaleX = this.scaleX, scaleY = this.scaleY;
        if (this.group) {
          var scaling = this.group.getObjectScaling();
          scaleX *= scaling.scaleX;
          scaleY *= scaling.scaleY;
        }
        return { scaleX: scaleX, scaleY: scaleY };
      },

      /**
       * Return the object opacity counting also the group property
       * @return {Number}
       */
      getObjectOpacity: function() {
        var opacity = this.opacity;
        if (this.group) {
          opacity *= this.group.getObjectOpacity();
        }
        return opacity;
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Object} thisArg
       */
      _set: function(key, value) {
        var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
            isChanged = this[key] !== value, groupNeedsUpdate = false;

        if (shouldConstrainValue) {
          value = this._constrainScale(value);
        }
        if (key === 'scaleX' && value < 0) {
          this.flipX = !this.flipX;
          value *= -1;
        }
        else if (key === 'scaleY' && value < 0) {
          this.flipY = !this.flipY;
          value *= -1;
        }
        else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
          value = new fabric.Shadow(value);
        }
        else if (key === 'dirty' && this.group) {
          this.group.set('dirty', value);
        }

        this[key] = value;

        if (isChanged) {
          groupNeedsUpdate = this.group && this.group.isOnACache();
          if (this.cacheProperties.indexOf(key) > -1) {
            this.dirty = true;
            groupNeedsUpdate && this.group.set('dirty', true);
          }
          else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
            this.group.set('dirty', true);
          }
        }

        return this;
      },

      /**
       * This callback function is called by the parent group of an object every
       * time a non-delegated property changes on the group. It is passed the key
       * and value as parameters. Not adding in this function's signature to avoid
       * Travis build error about unused variables.
       */
      setOnGroup: function() {
        // implemented by sub-classes, as needed.
      },

      /**
       * Retrieves viewportTransform from Object's canvas if possible
       * @method getViewportTransform
       * @memberOf fabric.Object.prototype
       * @return {Boolean}
       */
      getViewportTransform: function() {
        if (this.canvas && this.canvas.viewportTransform) {
          return this.canvas.viewportTransform;
        }
        return fabric.iMatrix.concat();
      },

      /*
       * @private
       * return if the object would be visible in rendering
       * @memberOf fabric.Object.prototype
       * @return {Boolean}
       */
      isNotVisible: function() {
        return this.opacity === 0 || (this.width === 0 && this.height === 0) || !this.visible;
      },

      /**
       * Renders an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        // do not render if width/height are zeros or object is not visible
        if (this.isNotVisible()) {
          return;
        }
        if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
          return;
        }
        ctx.save();
        this._setupCompositeOperation(ctx);
        this.drawSelectionBackground(ctx);
        this.transform(ctx);
        this._setOpacity(ctx);
        this._setShadow(ctx, this);
        if (this.transformMatrix) {
          ctx.transform.apply(ctx, this.transformMatrix);
        }
        this.clipTo && fabric.util.clipContext(this, ctx);
        if (this.shouldCache()) {
          if (!this._cacheCanvas) {
            this._createCacheCanvas();

          }
          if (this.isCacheDirty()) {
            this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
            this.drawObject(this._cacheContext);
            this.dirty = false;
          }
          this.drawCacheOnCanvas(ctx);
        }
        else {
          this._removeCacheCanvas();
          this.dirty = false;
          this.drawObject(ctx);
          if (this.objectCaching && this.statefullCache) {
            this.saveState({ propertySet: 'cacheProperties' });
          }
        }
        this.clipTo && ctx.restore();
        ctx.restore();
      },

      /**
       * Remove cacheCanvas and its dimensions from the objects
       */
      _removeCacheCanvas: function() {
        this._cacheCanvas = null;
        this.cacheWidth = 0;
        this.cacheHeight = 0;
      },

      /**
       * When set to `true`, force the object to have its own cache, even if it is inside a group
       * it may be needed when your object behave in a particular way on the cache and always needs
       * its own isolated canvas to render correctly.
       * Created to be overridden
       * since 1.7.12
       * @returns false
       */
      needsItsOwnCache: function() {
        if (this.paintFirst === 'stroke' && typeof this.shadow === 'object') {
          return true;
        }
        return false;
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        this.ownCaching = this.objectCaching &&
        (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
        return this.ownCaching;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * used by Group.shouldCache to know if child has a shadow recursively
       * @return {Boolean}
       */
      willDrawShadow: function() {
        return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
      },

      /**
       * Execute the drawing operation for an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawObject: function(ctx) {
        this._renderBackground(ctx);
        this._setStrokeStyles(ctx, this);
        this._setFillStyles(ctx, this);
        this._render(ctx);
      },

      /**
       * Paint the cached copy of the object on the target context.
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawCacheOnCanvas: function(ctx) {
        ctx.scale(1 / this.zoomX, 1 / this.zoomY);
        ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
      },

      /**
       * Check if cache is dirty
       * @param {Boolean} skipCanvas skip canvas checks because this object is painted
       * on parent canvas.
       */
      isCacheDirty: function(skipCanvas) {
        if (this.isNotVisible()) {
          return false;
        }
        if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
          // in this case the context is already cleared.
          return true;
        }
        else {
          if (this.dirty || (this.statefullCache && this.hasStateChanged('cacheProperties'))) {
            if (this._cacheCanvas && !skipCanvas) {
              var width = this.cacheWidth / this.zoomX;
              var height = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
            }
            return true;
          }
        }
        return false;
      },

      /**
       * Draws a background for the object big as its untrasformed dimensions
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderBackground: function(ctx) {
        if (!this.backgroundColor) {
          return;
        }
        var dim = this._getNonTransformedDimensions();
        ctx.fillStyle = this.backgroundColor;

        ctx.fillRect(
          -dim.x / 2,
          -dim.y / 2,
          dim.x,
          dim.y
        );
        // if there is background color no other shadows
        // should be casted
        this._removeShadow(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _setOpacity: function(ctx) {
        if (this.group && !this.group._transformDone) {
          ctx.globalAlpha = this.getObjectOpacity();
        }
        else {
          ctx.globalAlpha *= this.opacity;
        }
      },

      _setStrokeStyles: function(ctx, decl) {
        if (decl.stroke) {
          ctx.lineWidth = decl.strokeWidth;
          ctx.lineCap = decl.strokeLineCap;
          ctx.lineJoin = decl.strokeLineJoin;
          ctx.miterLimit = decl.strokeMiterLimit;
          ctx.strokeStyle = decl.stroke.toLive
            ? decl.stroke.toLive(ctx, this)
            : decl.stroke;
        }
      },

      _setFillStyles: function(ctx, decl) {
        if (decl.fill) {
          ctx.fillStyle = decl.fill.toLive
            ? decl.fill.toLive(ctx, this)
            : decl.fill;
        }
      },

      /**
       * @private
       * Sets line dash
       * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
       * @param {Array} dashArray array representing dashes
       * @param {Function} alternative function to call if browaser does not support lineDash
       */
      _setLineDash: function(ctx, dashArray, alternative) {
        if (!dashArray) {
          return;
        }
        // Spec requires the concatenation of two copies the dash list when the number of elements is odd
        if (1 & dashArray.length) {
          dashArray.push.apply(dashArray, dashArray);
        }
        if (supportsLineDash) {
          ctx.setLineDash(dashArray);
        }
        else {
          alternative && alternative(ctx);
        }
      },

      /**
       * Renders controls and borders for the object
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [styleOverride] properties to override the object style
       */
      _renderControls: function(ctx, styleOverride) {
        var vpt = this.getViewportTransform(),
            matrix = this.calcTransformMatrix(),
            options, drawBorders, drawControls;
        styleOverride = styleOverride || { };
        drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
        drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
        matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
        options = fabric.util.qrDecompose(matrix);
        ctx.save();
        ctx.translate(options.translateX, options.translateY);
        ctx.lineWidth = 1 * this.borderScaleFactor;
        if (!this.group) {
          ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        }
        if (styleOverride.forActiveSelection) {
          ctx.rotate(degreesToRadians(options.angle));
          drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
        }
        else {
          ctx.rotate(degreesToRadians(this.angle));
          drawBorders && this.drawBorders(ctx, styleOverride);
        }
        drawControls && this.drawControls(ctx, styleOverride);
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _setShadow: function(ctx) {
        if (!this.shadow) {
          return;
        }

        var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,
            multY = (this.canvas && this.canvas.viewportTransform[3]) || 1,
            scaling = this.getObjectScaling();
        if (this.canvas && this.canvas._isRetinaScaling()) {
          multX *= fabric.devicePixelRatio;
          multY *= fabric.devicePixelRatio;
        }
        ctx.shadowColor = this.shadow.color;
        ctx.shadowBlur = this.shadow.blur * fabric.browserShadowBlurConstant *
          (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
        ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;
        ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _removeShadow: function(ctx) {
        if (!this.shadow) {
          return;
        }

        ctx.shadowColor = '';
        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} filler fabric.Pattern or fabric.Gradient
       */
      _applyPatternGradientTransform: function(ctx, filler) {
        if (!filler || !filler.toLive) {
          return { offsetX: 0, offsetY: 0 };
        }
        var t = filler.gradientTransform || filler.patternTransform;
        var offsetX = -this.width / 2 + filler.offsetX || 0,
            offsetY = -this.height / 2 + filler.offsetY || 0;
        ctx.translate(offsetX, offsetY);
        if (t) {
          ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
        }
        return { offsetX: offsetX, offsetY: offsetY };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderPaintInOrder: function(ctx) {
        if (this.paintFirst === 'stroke') {
          this._renderStroke(ctx);
          this._renderFill(ctx);
        }
        else {
          this._renderFill(ctx);
          this._renderStroke(ctx);
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderFill: function(ctx) {
        if (!this.fill) {
          return;
        }

        ctx.save();
        this._applyPatternGradientTransform(ctx, this.fill);
        if (this.fillRule === 'evenodd') {
          ctx.fill('evenodd');
        }
        else {
          ctx.fill();
        }
        ctx.restore();
      },

      _renderStroke: function(ctx) {
        if (!this.stroke || this.strokeWidth === 0) {
          return;
        }

        if (this.shadow && !this.shadow.affectStroke) {
          this._removeShadow(ctx);
        }

        ctx.save();
        this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
        this._applyPatternGradientTransform(ctx, this.stroke);
        ctx.stroke();
        ctx.restore();
      },

      /**
       * This function is an helper for svg import. it returns the center of the object in the svg
       * untransformed coordinates
       * @private
       * @return {Object} center point from element coordinates
       */
      _findCenterFromElement: function() {
        return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
      },

      /**
       * This function is an helper for svg import. it decoompose the transformMatrix
       * and assign properties to object.
       * untransformed coordinates
       * @private
       * @chainable
       */
      _assignTransformMatrixProps: function() {
        if (this.transformMatrix) {
          var options = fabric.util.qrDecompose(this.transformMatrix);
          this.flipX = false;
          this.flipY = false;
          this.set('scaleX', options.scaleX);
          this.set('scaleY', options.scaleY);
          this.angle = options.angle;
          this.skewX = options.skewX;
          this.skewY = 0;
        }
      },

      /**
       * This function is an helper for svg import. it removes the transform matrix
       * and set to object properties that fabricjs can handle
       * @private
       * @param {Object} preserveAspectRatioOptions
       * @return {thisArg}
       */
      _removeTransformMatrix: function(preserveAspectRatioOptions) {
        var center = this._findCenterFromElement();
        if (this.transformMatrix) {
          this._assignTransformMatrixProps();
          center = fabric.util.transformPoint(center, this.transformMatrix);
        }
        this.transformMatrix = null;
        if (preserveAspectRatioOptions) {
          this.scaleX *= preserveAspectRatioOptions.scaleX;
          this.scaleY *= preserveAspectRatioOptions.scaleY;
          this.cropX = preserveAspectRatioOptions.cropX;
          this.cropY = preserveAspectRatioOptions.cropY;
          center.x += preserveAspectRatioOptions.offsetLeft;
          center.y += preserveAspectRatioOptions.offsetTop;
          this.width = preserveAspectRatioOptions.width;
          this.height = preserveAspectRatioOptions.height;
        }
        this.setPositionByOrigin(center, 'center', 'center');
      },

      /**
       * Clones an instance, using a callback method will work for every object.
       * @param {Function} callback Callback is invoked with a clone as a first argument
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       */
      clone: function(callback, propertiesToInclude) {
        var objectForm = this.toObject(propertiesToInclude);
        if (this.constructor.fromObject) {
          this.constructor.fromObject(objectForm, callback);
        }
        else {
          fabric.Object._fromObject('Object', objectForm, callback);
        }
      },

      /**
       * Creates an instance of fabric.Image out of an object
       * @param {Function} callback callback, invoked with an instance as a first argument
       * @param {Object} [options] for clone as image, passed to toDataURL
       * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image
       * @return {fabric.Object} thisArg
       */
      cloneAsImage: function(callback, options) {
        var dataUrl = this.toDataURL(options);
        fabric.util.loadImage(dataUrl, function(img) {
          if (callback) {
            callback(new fabric.Image(img));
          }
        });
        return this;
      },

      /**
       * Converts an object into a data-url-like string
       * @param {Object} options Options object
       * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
       * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
       * @param {Number} [options.multiplier=1] Multiplier to scale by
       * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
       * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
       * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
       * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
       * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
       * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
       */
      toDataURL: function(options) {
        options || (options = { });

        var el = fabric.util.createCanvasElement(),
            boundingRect = this.getBoundingRect();

        el.width = boundingRect.width;
        el.height = boundingRect.height;
        fabric.util.wrapElement(el, 'div');
        var canvas = new fabric.StaticCanvas(el, {
          enableRetinaScaling: options.enableRetinaScaling,
          renderOnAddRemove: false,
          skipOffscreen: false,
        });
        // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
        if (options.format === 'jpg') {
          options.format = 'jpeg';
        }

        if (options.format === 'jpeg') {
          canvas.backgroundColor = '#fff';
        }

        var origParams = {
          left: this.left,
          top: this.top
        };

        this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

        var originalCanvas = this.canvas;
        canvas.add(this);
        var data = canvas.toDataURL(options);
        this.set(origParams).setCoords();
        this.canvas = originalCanvas;
        // canvas.dispose will call image.dispose that will nullify the elements
        // since this canvas is a simple element for the process, we remove references
        // to objects in this way in order to avoid object trashing.
        canvas._objects = [];
        canvas.dispose();
        canvas = null;

        return data;
      },

      /**
       * Returns true if specified type is identical to the type of an instance
       * @param {String} type Type to check against
       * @return {Boolean}
       */
      isType: function(type) {
        return this.type === type;
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity of this instance (is 1 unless subclassed)
       */
      complexity: function() {
        return 1;
      },

      /**
       * Returns a JSON representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} JSON
       */
      toJSON: function(propertiesToInclude) {
        // delegate, not alias
        return this.toObject(propertiesToInclude);
      },

      /**
       * Sets gradient (fill or stroke) of an object
       * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
       * @param {String} property Property name 'stroke' or 'fill'
       * @param {Object} [options] Options object
       * @param {String} [options.type] Type of gradient 'radial' or 'linear'
       * @param {Number} [options.x1=0] x-coordinate of start point
       * @param {Number} [options.y1=0] y-coordinate of start point
       * @param {Number} [options.x2=0] x-coordinate of end point
       * @param {Number} [options.y2=0] y-coordinate of end point
       * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
       * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
       * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
       * @param {Object} [options.gradientTransform] transforMatrix for gradient
       * @return {fabric.Object} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
       * @example <caption>Set linear gradient</caption>
       * object.setGradient('fill', {
       *   type: 'linear',
       *   x1: -object.width / 2,
       *   y1: 0,
       *   x2: object.width / 2,
       *   y2: 0,
       *   colorStops: {
       *     0: 'red',
       *     0.5: '#005555',
       *     1: 'rgba(0,0,255,0.5)'
       *   }
       * });
       * canvas.renderAll();
       * @example <caption>Set radial gradient</caption>
       * object.setGradient('fill', {
       *   type: 'radial',
       *   x1: 0,
       *   y1: 0,
       *   x2: 0,
       *   y2: 0,
       *   r1: object.width / 2,
       *   r2: 10,
       *   colorStops: {
       *     0: 'red',
       *     0.5: '#005555',
       *     1: 'rgba(0,0,255,0.5)'
       *   }
       * });
       * canvas.renderAll();
       */
      setGradient: function(property, options) {
        options || (options = { });

        var gradient = { colorStops: [] };

        gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
        gradient.coords = {
          x1: options.x1,
          y1: options.y1,
          x2: options.x2,
          y2: options.y2
        };

        if (options.r1 || options.r2) {
          gradient.coords.r1 = options.r1;
          gradient.coords.r2 = options.r2;
        }

        gradient.gradientTransform = options.gradientTransform;
        fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);

        return this.set(property, fabric.Gradient.forObject(this, gradient));
      },

      /**
       * Sets pattern fill of an object
       * @param {Object} options Options object
       * @param {(String|HTMLImageElement)} options.source Pattern source
       * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
       * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
       * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
       * @return {fabric.Object} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
       * @example <caption>Set pattern</caption>
       * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {
       *   object.setPatternFill({
       *     source: img,
       *     repeat: 'repeat'
       *   });
       *   canvas.renderAll();
       * });
       */
      setPatternFill: function(options) {
        return this.set('fill', new fabric.Pattern(options));
      },

      /**
       * Sets {@link fabric.Object#shadow|shadow} of an object
       * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
       * @param {String} [options.color=rgb(0,0,0)] Shadow color
       * @param {Number} [options.blur=0] Shadow blur
       * @param {Number} [options.offsetX=0] Shadow horizontal offset
       * @param {Number} [options.offsetY=0] Shadow vertical offset
       * @return {fabric.Object} thisArg
       * @chainable
       * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
       * @example <caption>Set shadow with string notation</caption>
       * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
       * canvas.renderAll();
       * @example <caption>Set shadow with object notation</caption>
       * object.setShadow({
       *   color: 'red',
       *   blur: 10,
       *   offsetX: 20,
       *   offsetY: 20
       * });
       * canvas.renderAll();
       */
      setShadow: function(options) {
        return this.set('shadow', options ? new fabric.Shadow(options) : null);
      },

      /**
       * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
       * @param {String} color Color value
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setColor: function(color) {
        this.set('fill', color);
        return this;
      },

      /**
       * Sets "angle" of an instance with centered rotation
       * @param {Number} angle Angle value (in degrees)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      rotate: function(angle) {
        var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

        if (shouldCenterOrigin) {
          this._setOriginToCenter();
        }

        this.set('angle', angle);

        if (shouldCenterOrigin) {
          this._resetOrigin();
        }

        return this;
      },

      /**
       * Centers object horizontally on canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      centerH: function () {
        this.canvas && this.canvas.centerObjectH(this);
        return this;
      },

      /**
       * Centers object horizontally on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenterH: function () {
        this.canvas && this.canvas.viewportCenterObjectH(this);
        return this;
      },

      /**
       * Centers object vertically on canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      centerV: function () {
        this.canvas && this.canvas.centerObjectV(this);
        return this;
      },

      /**
       * Centers object vertically on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenterV: function () {
        this.canvas && this.canvas.viewportCenterObjectV(this);
        return this;
      },

      /**
       * Centers object vertically and horizontally on canvas to which is was added last
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      center: function () {
        this.canvas && this.canvas.centerObject(this);
        return this;
      },

      /**
       * Centers object on current viewport of canvas to which it was added last.
       * You might need to call `setCoords` on an object after centering, to update controls area.
       * @return {fabric.Object} thisArg
       * @chainable
       */
      viewportCenter: function () {
        this.canvas && this.canvas.viewportCenterObject(this);
        return this;
      },

      /**
       * Returns coordinates of a pointer relative to an object
       * @param {Event} e Event to operate upon
       * @param {Object} [pointer] Pointer to operate upon (instead of event)
       * @return {Object} Coordinates of a pointer (x, y)
       */
      getLocalPointer: function(e, pointer) {
        pointer = pointer || this.canvas.getPointer(e);
        var pClicked = new fabric.Point(pointer.x, pointer.y),
            objectLeftTop = this._getLeftTopCoords();
        if (this.angle) {
          pClicked = fabric.util.rotatePoint(
            pClicked, objectLeftTop, degreesToRadians(-this.angle));
        }
        return {
          x: pClicked.x - objectLeftTop.x,
          y: pClicked.y - objectLeftTop.y
        };
      },

      /**
       * Sets canvas globalCompositeOperation for specific object
       * custom composition operation for the particular object can be specifed using globalCompositeOperation property
       * @param {CanvasRenderingContext2D} ctx Rendering canvas context
       */
      _setupCompositeOperation: function (ctx) {
        if (this.globalCompositeOperation) {
          ctx.globalCompositeOperation = this.globalCompositeOperation;
        }
      }
    });

    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

    extend(fabric.Object.prototype, fabric.Observable);

    /**
     * Defines the number of fraction digits to use when serializing object values.
     * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
     * @static
     * @memberOf fabric.Object
     * @constant
     * @type Number
     */
    fabric.Object.NUM_FRACTION_DIGITS = 2;

    fabric.Object._fromObject = function(className, object, callback, extraParam) {
      var klass = fabric[className];
      object = clone(object, true);
      fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
        if (typeof patterns[0] !== 'undefined') {
          object.fill = patterns[0];
        }
        if (typeof patterns[1] !== 'undefined') {
          object.stroke = patterns[1];
        }
        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
        callback && callback(instance);
      });
    };

    /**
     * Unique id used internally when creating SVG elements
     * @static
     * @memberOf fabric.Object
     * @type Number
     */
    fabric.Object.__uid = 0;

  })(exports);


  (function() {

    var degreesToRadians = fabric.util.degreesToRadians,
        originXOffset = {
          left: -0.5,
          center: 0,
          right: 0.5
        },
        originYOffset = {
          top: -0.5,
          center: 0,
          bottom: 0.5
        };

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Translates the coordinates from a set of origin to another (based on the object's dimensions)
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
       * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
        var x = point.x,
            y = point.y,
            offsetX, offsetY, dim;

        if (typeof fromOriginX === 'string') {
          fromOriginX = originXOffset[fromOriginX];
        }
        else {
          fromOriginX -= 0.5;
        }

        if (typeof toOriginX === 'string') {
          toOriginX = originXOffset[toOriginX];
        }
        else {
          toOriginX -= 0.5;
        }

        offsetX = toOriginX - fromOriginX;

        if (typeof fromOriginY === 'string') {
          fromOriginY = originYOffset[fromOriginY];
        }
        else {
          fromOriginY -= 0.5;
        }

        if (typeof toOriginY === 'string') {
          toOriginY = originYOffset[toOriginY];
        }
        else {
          toOriginY -= 0.5;
        }

        offsetY = toOriginY - fromOriginY;

        if (offsetX || offsetY) {
          dim = this._getTransformedDimensions();
          x = point.x + offsetX * dim.x;
          y = point.y + offsetY * dim.y;
        }

        return new fabric.Point(x, y);
      },

      /**
       * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToCenterPoint: function(point, originX, originY) {
        var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
        if (this.angle) {
          return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
        }
        return p;
      },

      /**
       * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
       * @param {fabric.Point} center The point which corresponds to center of the object
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      translateToOriginPoint: function(center, originX, originY) {
        var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
        if (this.angle) {
          return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
        }
        return p;
      },

      /**
       * Returns the real center coordinates of the object
       * @return {fabric.Point}
       */
      getCenterPoint: function() {
        var leftTop = new fabric.Point(this.left, this.top);
        return this.translateToCenterPoint(leftTop, this.originX, this.originY);
      },

      /**
       * Returns the coordinates of the object based on center coordinates
       * @param {fabric.Point} point The point which corresponds to the originX and originY params
       * @return {fabric.Point}
       */
      // getOriginPoint: function(center) {
      //   return this.translateToOriginPoint(center, this.originX, this.originY);
      // },

      /**
       * Returns the coordinates of the object as if it has a different origin
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      getPointByOrigin: function(originX, originY) {
        var center = this.getCenterPoint();
        return this.translateToOriginPoint(center, originX, originY);
      },

      /**
       * Returns the point in local coordinates
       * @param {fabric.Point} point The point relative to the global coordinate system
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {fabric.Point}
       */
      toLocalPoint: function(point, originX, originY) {
        var center = this.getCenterPoint(),
            p, p2;

        if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
          p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
        }
        else {
          p = new fabric.Point(this.left, this.top);
        }

        p2 = new fabric.Point(point.x, point.y);
        if (this.angle) {
          p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
        }
        return p2.subtractEquals(p);
      },

      /**
       * Returns the point in global coordinates
       * @param {fabric.Point} The point relative to the local coordinate system
       * @return {fabric.Point}
       */
      // toGlobalPoint: function(point) {
      //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
      // },

      /**
       * Sets the position of the object taking into consideration the object's origin
       * @param {fabric.Point} pos The new position of the object
       * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
       * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
       * @return {void}
       */
      setPositionByOrigin: function(pos, originX, originY) {
        var center = this.translateToCenterPoint(pos, originX, originY),
            position = this.translateToOriginPoint(center, this.originX, this.originY);
        this.set('left', position.x);
        this.set('top', position.y);
      },

      /**
       * @param {String} to One of 'left', 'center', 'right'
       */
      adjustPosition: function(to) {
        var angle = degreesToRadians(this.angle),
            hypotFull = this.getScaledWidth(),
            xFull = fabric.util.cos(angle) * hypotFull,
            yFull = fabric.util.sin(angle) * hypotFull,
            offsetFrom, offsetTo;

        //TODO: this function does not consider mixed situation like top, center.
        if (typeof this.originX === 'string') {
          offsetFrom = originXOffset[this.originX];
        }
        else {
          offsetFrom = this.originX - 0.5;
        }
        if (typeof to === 'string') {
          offsetTo = originXOffset[to];
        }
        else {
          offsetTo = to - 0.5;
        }
        this.left += xFull * (offsetTo - offsetFrom);
        this.top += yFull * (offsetTo - offsetFrom);
        this.setCoords();
        this.originX = to;
      },

      /**
       * Sets the origin/position of the object to it's center point
       * @private
       * @return {void}
       */
      _setOriginToCenter: function() {
        this._originalOriginX = this.originX;
        this._originalOriginY = this.originY;

        var center = this.getCenterPoint();

        this.originX = 'center';
        this.originY = 'center';

        this.left = center.x;
        this.top = center.y;
      },

      /**
       * Resets the origin/position of the object to it's original origin
       * @private
       * @return {void}
       */
      _resetOrigin: function() {
        var originPoint = this.translateToOriginPoint(
          this.getCenterPoint(),
          this._originalOriginX,
          this._originalOriginY);

        this.originX = this._originalOriginX;
        this.originY = this._originalOriginY;

        this.left = originPoint.x;
        this.top = originPoint.y;

        this._originalOriginX = null;
        this._originalOriginY = null;
      },

      /**
       * @private
       */
      _getLeftTopCoords: function() {
        return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
      },
    });

  })();


  (function() {

    function getCoords(coords) {
      return [
        new fabric.Point(coords.tl.x, coords.tl.y),
        new fabric.Point(coords.tr.x, coords.tr.y),
        new fabric.Point(coords.br.x, coords.br.y),
        new fabric.Point(coords.bl.x, coords.bl.y)
      ];
    }

    var degreesToRadians = fabric.util.degreesToRadians,
        multiplyMatrices = fabric.util.multiplyTransformMatrices,
        transformPoint = fabric.util.transformPoint;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Describe object's corner position in canvas element coordinates.
       * properties are tl,mt,tr,ml,mr,bl,mb,br,mtr for the main controls.
       * each property is an object with x, y and corner.
       * The `corner` property contains in a similar manner the 4 points of the
       * interactive area of the corner.
       * The coordinates depends from this properties: width, height, scaleX, scaleY
       * skewX, skewY, angle, strokeWidth, viewportTransform, top, left, padding.
       * The coordinates get updated with @method setCoords.
       * You can calculate them without updating with @method calcCoords;
       * @memberOf fabric.Object.prototype
       */
      oCoords: null,

      /**
       * Describe object's corner position in canvas object absolute coordinates
       * properties are tl,tr,bl,br and describe the four main corner.
       * each property is an object with x, y, instance of Fabric.Point.
       * The coordinates depends from this properties: width, height, scaleX, scaleY
       * skewX, skewY, angle, strokeWidth, top, left.
       * Those coordinates are usefull to understand where an object is. They get updated
       * with oCoords but they do not need to be updated when zoom or panning change.
       * The coordinates get updated with @method setCoords.
       * You can calculate them without updating with @method calcCoords(true);
       * @memberOf fabric.Object.prototype
       */
      aCoords: null,

      /**
       * storage for object transform matrix
       */
      ownMatrixCache: null,

      /**
       * storage for object full transform matrix
       */
      matrixCache: null,

      /**
       * return correct set of coordinates for intersection
       */
      getCoords: function(absolute, calculate) {
        if (!this.oCoords) {
          this.setCoords();
        }
        var coords = absolute ? this.aCoords : this.oCoords;
        return getCoords(calculate ? this.calcCoords(absolute) : coords);
      },

      /**
       * Checks if object intersects with an area formed by 2 points
       * @param {Object} pointTL top-left point of area
       * @param {Object} pointBR bottom-right point of area
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object intersects with an area formed by 2 points
       */
      intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
        var coords = this.getCoords(absolute, calculate),
            intersection = fabric.Intersection.intersectPolygonRectangle(
              coords,
              pointTL,
              pointBR
            );
        return intersection.status === 'Intersection';
      },

      /**
       * Checks if object intersects with another object
       * @param {Object} other Object to test
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object intersects with another object
       */
      intersectsWithObject: function(other, absolute, calculate) {
        var intersection = fabric.Intersection.intersectPolygonPolygon(
          this.getCoords(absolute, calculate),
          other.getCoords(absolute, calculate)
        );

        return intersection.status === 'Intersection'
          || other.isContainedWithinObject(this, absolute, calculate)
          || this.isContainedWithinObject(other, absolute, calculate);
      },

      /**
       * Checks if object is fully contained within area of another object
       * @param {Object} other Object to test
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully contained within area of another object
       */
      isContainedWithinObject: function(other, absolute, calculate) {
        var points = this.getCoords(absolute, calculate),
            i = 0, lines = other._getImageLines(
              calculate ? other.calcCoords(absolute) : absolute ? other.aCoords : other.oCoords
            );
        for (; i < 4; i++) {
          if (!other.containsPoint(points[i], lines)) {
            return false;
          }
        }
        return true;
      },

      /**
       * Checks if object is fully contained within area formed by 2 points
       * @param {Object} pointTL top-left point of area
       * @param {Object} pointBR bottom-right point of area
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully contained within area formed by 2 points
       */
      isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
        var boundingRect = this.getBoundingRect(absolute, calculate);

        return (
          boundingRect.left >= pointTL.x &&
          boundingRect.left + boundingRect.width <= pointBR.x &&
          boundingRect.top >= pointTL.y &&
          boundingRect.top + boundingRect.height <= pointBR.y
        );
      },

      /**
       * Checks if point is inside the object
       * @param {fabric.Point} point Point to check against
       * @param {Object} [lines] object returned from @method _getImageLines
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if point is inside the object
       */
      containsPoint: function(point, lines, absolute, calculate) {
        var lines = lines || this._getImageLines(
              calculate ? this.calcCoords(absolute) : absolute ? this.aCoords : this.oCoords
            ),
            xPoints = this._findCrossPoints(point, lines);

        // if xPoints is odd then point is inside the object
        return (xPoints !== 0 && xPoints % 2 === 1);
      },

      /**
       * Checks if object is contained within the canvas with current viewportTransform
       * the check is done stopping at first point that appears on screen
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is fully or partially contained within canvas
       */
      isOnScreen: function(calculate) {
        if (!this.canvas) {
          return false;
        }
        var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
        var points = this.getCoords(true, calculate), point;
        for (var i = 0; i < 4; i++) {
          point = points[i];
          if (point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y) {
            return true;
          }
        }
        // no points on screen, check intersection with absolute coordinates
        if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
          return true;
        }
        return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
      },

      /**
       * Checks if the object contains the midpoint between canvas extremities
       * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
       * @private
       * @param {Fabric.Point} pointTL Top Left point
       * @param {Fabric.Point} pointBR Top Right point
       * @param {Boolean} calculate use coordinates of current position instead of .oCoords
       * @return {Boolean} true if the objects containe the point
       */
      _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
        // worst case scenario the object is so big that contains the screen
        var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
        if (this.containsPoint(centerPoint, null, true, calculate)) {
          return true;
        }
        return false;
      },

      /**
       * Checks if object is partially contained within the canvas with current viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
       * @return {Boolean} true if object is partially contained within canvas
       */
      isPartiallyOnScreen: function(calculate) {
        if (!this.canvas) {
          return false;
        }
        var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
        if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
          return true;
        }
        return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
      },

      /**
       * Method that returns an object with the object edges in it, given the coordinates of the corners
       * @private
       * @param {Object} oCoords Coordinates of the object corners
       */
      _getImageLines: function(oCoords) {
        return {
          topline: {
            o: oCoords.tl,
            d: oCoords.tr
          },
          rightline: {
            o: oCoords.tr,
            d: oCoords.br
          },
          bottomline: {
            o: oCoords.br,
            d: oCoords.bl
          },
          leftline: {
            o: oCoords.bl,
            d: oCoords.tl
          }
        };
      },

      /**
       * Helper method to determine how many cross points are between the 4 object edges
       * and the horizontal line determined by a point on canvas
       * @private
       * @param {fabric.Point} point Point to check
       * @param {Object} lines Coordinates of the object being evaluated
       */
      // remove yi, not used but left code here just in case.
      _findCrossPoints: function(point, lines) {
        var b1, b2, a1, a2, xi, // yi,
            xcount = 0,
            iLine;

        for (var lineKey in lines) {
          iLine = lines[lineKey];
          // optimisation 1: line below point. no cross
          if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
            continue;
          }
          // optimisation 2: line above point. no cross
          if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
            continue;
          }
          // optimisation 3: vertical line case
          if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
            xi = iLine.o.x;
            // yi = point.y;
          }
          // calculate the intersection point
          else {
            b1 = 0;
            b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
            a1 = point.y - b1 * point.x;
            a2 = iLine.o.y - b2 * iLine.o.x;

            xi = -(a1 - a2) / (b1 - b2);
            // yi = a1 + b1 * xi;
          }
          // dont count xi < point.x cases
          if (xi >= point.x) {
            xcount += 1;
          }
          // optimisation 4: specific for square images
          if (xcount === 2) {
            break;
          }
        }
        return xcount;
      },

      /**
       * Returns coordinates of object's bounding rectangle (left, top, width, height)
       * the box is intented as aligned to axis of canvas.
       * @param {Boolean} [absolute] use coordinates without viewportTransform
       * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
       * @return {Object} Object with left, top, width, height properties
       */
      getBoundingRect: function(absolute, calculate) {
        var coords = this.getCoords(absolute, calculate);
        return fabric.util.makeBoundingBoxFromPoints(coords);
      },

      /**
       * Returns width of an object bounding box counting transformations
       * before 2.0 it was named getWidth();
       * @return {Number} width value
       */
      getScaledWidth: function() {
        return this._getTransformedDimensions().x;
      },

      /**
       * Returns height of an object bounding box counting transformations
       * before 2.0 it was named getHeight();
       * @return {Number} height value
       */
      getScaledHeight: function() {
        return this._getTransformedDimensions().y;
      },

      /**
       * Makes sure the scale is valid and modifies it if necessary
       * @private
       * @param {Number} value
       * @return {Number}
       */
      _constrainScale: function(value) {
        if (Math.abs(value) < this.minScaleLimit) {
          if (value < 0) {
            return -this.minScaleLimit;
          }
          else {
            return this.minScaleLimit;
          }
        }
        else if (value === 0) {
          return 0.0001;
        }
        return value;
      },

      /**
       * Scales an object (equally by x and y)
       * @param {Number} value Scale factor
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scale: function(value) {
        this._set('scaleX', value);
        this._set('scaleY', value);
        return this.setCoords();
      },

      /**
       * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
       * @param {Number} value New width value
       * @param {Boolean} absolute ignore viewport
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scaleToWidth: function(value, absolute) {
        // adjust to bounding rect factor so that rotated shapes would fit as well
        var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
        return this.scale(value / this.width / boundingRectFactor);
      },

      /**
       * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
       * @param {Number} value New height value
       * @param {Boolean} absolute ignore viewport
       * @return {fabric.Object} thisArg
       * @chainable
       */
      scaleToHeight: function(value, absolute) {
        // adjust to bounding rect factor so that rotated shapes would fit as well
        var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
        return this.scale(value / this.height / boundingRectFactor);
      },

      /**
       * Calculate and returns the .coords of an object.
       * @return {Object} Object with tl, tr, br, bl ....
       * @chainable
       */
      calcCoords: function(absolute) {
        var rotateMatrix = this._calcRotateMatrix(),
            translateMatrix = this._calcTranslateMatrix(),
            startMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
            vpt = this.getViewportTransform(),
            finalMatrix = absolute ? startMatrix : multiplyMatrices(vpt, startMatrix),
            dim = this._getTransformedDimensions(),
            w = dim.x / 2, h = dim.y / 2,
            tl = transformPoint({ x: -w, y: -h }, finalMatrix),
            tr = transformPoint({ x: w, y: -h }, finalMatrix),
            bl = transformPoint({ x: -w, y: h }, finalMatrix),
            br = transformPoint({ x: w, y: h }, finalMatrix);
        if (!absolute) {
          var padding = this.padding, angle = degreesToRadians(this.angle),
              cos = fabric.util.cos(angle), sin = fabric.util.sin(angle),
              cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
              cosPMinusSinP = cosP - sinP;
          if (padding) {
            tl.x -= cosPMinusSinP;
            tl.y -= cosPSinP;
            tr.x += cosPSinP;
            tr.y -= cosPMinusSinP;
            bl.x -= cosPSinP;
            bl.y += cosPMinusSinP;
            br.x += cosPMinusSinP;
            br.y += cosPSinP;
          }
          var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
              mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
              mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
              mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
              mtr = new fabric.Point(mt.x + sin * this.rotatingPointOffset, mt.y - cos * this.rotatingPointOffset);
        }

        // if (!absolute) {
        //   var canvas = this.canvas;
        //   setTimeout(function() {
        //     canvas.contextTop.clearRect(0, 0, 700, 700);
        //     canvas.contextTop.fillStyle = 'green';
        //     canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
        //     canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
        //     canvas.contextTop.fillRect(br.x, br.y, 3, 3);
        //     canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
        //     canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
        //     canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
        //     canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
        //     canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
        //     canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
        //   }, 50);
        // }

        var coords = {
          // corners
          tl: tl, tr: tr, br: br, bl: bl,
        };
        if (!absolute) {
          // middle
          coords.ml = ml;
          coords.mt = mt;
          coords.mr = mr;
          coords.mb = mb;
          // rotating point
          coords.mtr = mtr;
        }
        return coords;
      },

      /**
       * Sets corner position coordinates based on current angle, width and height
       * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
       * @param {Boolean} [ignoreZoom] set oCoords with or without the viewport transform.
       * @param {Boolean} [skipAbsolute] skip calculation of aCoords, usefull in setViewportTransform
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setCoords: function(ignoreZoom, skipAbsolute) {
        this.oCoords = this.calcCoords(ignoreZoom);
        if (!skipAbsolute) {
          this.aCoords = this.calcCoords(true);
        }

        // set coordinates of the draggable boxes in the corners used to scale/rotate the image
        ignoreZoom || (this._setCornerCoords && this._setCornerCoords());

        return this;
      },

      /**
       * calculate rotation matrix of an object
       * @return {Array} rotation matrix for the object
       */
      _calcRotateMatrix: function() {
        if (this.angle) {
          var theta = degreesToRadians(this.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);
          return [cos, sin, -sin, cos, 0, 0];
        }
        return fabric.iMatrix.concat();
      },

      /**
       * calculate the translation matrix for an object transform
       * @return {Array} rotation matrix for the object
       */
      _calcTranslateMatrix: function() {
        var center = this.getCenterPoint();
        return [1, 0, 0, 1, center.x, center.y];
      },

      transformMatrixKey: function(skipGroup) {
        var sep = '_', prefix = '';
        if (!skipGroup && this.group) {
          prefix = this.group.transformMatrixKey(skipGroup) + sep;
        }      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
          sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
          sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
      },

      /**
       * calculate trasform Matrix that represent current transformation from
       * object properties.
       * @param {Boolean} [skipGroup] return transformMatrix for object and not go upward with parents
       * @return {Array} matrix Transform Matrix for the object
       */
      calcTransformMatrix: function(skipGroup) {
        if (skipGroup) {
          return this.calcOwnMatrix();
        }
        var key = this.transformMatrixKey(), cache = this.matrixCache || (this.matrixCache = {});
        if (cache.key === key) {
          return cache.value;
        }
        var matrix = this.calcOwnMatrix();
        if (this.group) {
          matrix = multiplyMatrices(this.group.calcTransformMatrix(), matrix);
        }
        cache.key = key;
        cache.value = matrix;
        return matrix;
      },

      calcOwnMatrix: function() {
        var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
        if (cache.key === key) {
          return cache.value;
        }
        var matrix = this._calcTranslateMatrix(),
            rotateMatrix,
            dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true);
        if (this.angle) {
          rotateMatrix = this._calcRotateMatrix();
          matrix = multiplyMatrices(matrix, rotateMatrix);
        }
        matrix = multiplyMatrices(matrix, dimensionMatrix);
        cache.key = key;
        cache.value = matrix;
        return matrix;
      },

      _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
        var skewMatrix,
            scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),
            scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),
            scaleMatrix = [scaleX, 0, 0, scaleY, 0, 0];
        if (skewX) {
          skewMatrix = [1, 0, Math.tan(degreesToRadians(skewX)), 1];
          scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
        }
        if (skewY) {
          skewMatrix = [1, Math.tan(degreesToRadians(skewY)), 0, 1];
          scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
        }
        return scaleMatrix;
      },


      /*
       * Calculate object dimensions from its properties
       * @private
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _getNonTransformedDimensions: function() {
        var strokeWidth = this.strokeWidth,
            w = this.width + strokeWidth,
            h = this.height + strokeWidth;
        return { x: w, y: h };
      },

      /*
       * Calculate object bounding boxdimensions from its properties scale, skew.
       * @private
       * @return {Object} .x width dimension
       * @return {Object} .y height dimension
       */
      _getTransformedDimensions: function(skewX, skewY) {
        if (typeof skewX === 'undefined') {
          skewX = this.skewX;
        }
        if (typeof skewY === 'undefined') {
          skewY = this.skewY;
        }
        var dimensions = this._getNonTransformedDimensions();
        if (skewX === 0 && skewY === 0) {
          return { x: dimensions.x * this.scaleX, y: dimensions.y * this.scaleY };
        }
        var dimX = dimensions.x / 2, dimY = dimensions.y / 2,
            points = [
              {
                x: -dimX,
                y: -dimY
              },
              {
                x: dimX,
                y: -dimY
              },
              {
                x: -dimX,
                y: dimY
              },
              {
                x: dimX,
                y: dimY
              }],
            i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),
            bbox;
        for (i = 0; i < points.length; i++) {
          points[i] = fabric.util.transformPoint(points[i], transformMatrix);
        }
        bbox = fabric.util.makeBoundingBoxFromPoints(points);
        return { x: bbox.width, y: bbox.height };
      },

      /*
       * Calculate object dimensions for controls. include padding and canvas zoom
       * private
       */
      _calculateCurrentDimensions: function()  {
        var vpt = this.getViewportTransform(),
            dim = this._getTransformedDimensions(),
            p = fabric.util.transformPoint(dim, vpt, true);

        return p.scalarAdd(2 * this.padding);
      },
    });
  })();


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Moves an object to the bottom of the stack of drawn objects
     * @return {fabric.Object} thisArg
     * @chainable
     */
    sendToBack: function() {
      if (this.group) {
        fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
      }
      else {
        this.canvas.sendToBack(this);
      }
      return this;
    },

    /**
     * Moves an object to the top of the stack of drawn objects
     * @return {fabric.Object} thisArg
     * @chainable
     */
    bringToFront: function() {
      if (this.group) {
        fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
      }
      else {
        this.canvas.bringToFront(this);
      }
      return this;
    },

    /**
     * Moves an object down in stack of drawn objects
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    sendBackwards: function(intersecting) {
      if (this.group) {
        fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
      }
      else {
        this.canvas.sendBackwards(this, intersecting);
      }
      return this;
    },

    /**
     * Moves an object up in stack of drawn objects
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    bringForward: function(intersecting) {
      if (this.group) {
        fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
      }
      else {
        this.canvas.bringForward(this, intersecting);
      }
      return this;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {Number} index New position of object
     * @return {fabric.Object} thisArg
     * @chainable
     */
    moveTo: function(index) {
      if (this.group && this.group.type !== 'activeSelection') {
        fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
      }
      else {
        this.canvas.moveTo(this, index);
      }
      return this;
    }
  });


  /* _TO_SVG_START_ */
  (function() {
    function getSvgColorString(prop, value) {
      if (!value) {
        return prop + ': none; ';
      }
      else if (value.toLive) {
        return prop + ': url(#SVGID_' + value.id + '); ';
      }
      else {
        var color = new fabric.Color(value),
            str = prop + ': ' + color.toRgb() + '; ',
            opacity = color.getAlpha();
        if (opacity !== 1) {
          //change the color in rgb + opacity
          str += prop + '-opacity: ' + opacity.toString() + '; ';
        }
        return str;
      }
    }

    var toFixed = fabric.util.toFixed;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
      /**
       * Returns styles-string for svg-export
       * @param {Boolean} skipShadow a boolean to skip shadow filter output
       * @return {String}
       */
      getSvgStyles: function(skipShadow) {

        var fillRule = this.fillRule,
            strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
            strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
            strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
            strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
            strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
            opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
            visibility = this.visible ? '' : ' visibility: hidden;',
            filter = skipShadow ? '' : this.getSvgFilter(),
            fill = getSvgColorString('fill', this.fill),
            stroke = getSvgColorString('stroke', this.stroke);

        return [
          stroke,
          'stroke-width: ', strokeWidth, '; ',
          'stroke-dasharray: ', strokeDashArray, '; ',
          'stroke-linecap: ', strokeLineCap, '; ',
          'stroke-linejoin: ', strokeLineJoin, '; ',
          'stroke-miterlimit: ', strokeMiterLimit, '; ',
          fill,
          'fill-rule: ', fillRule, '; ',
          'opacity: ', opacity, ';',
          filter,
          visibility
        ].join('');
      },

      /**
       * Returns styles-string for svg-export
       * @param {Object} style the object from which to retrieve style properties
       * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
       * @return {String}
       */
      getSvgSpanStyles: function(style, useWhiteSpace) {
        var term = '; ';
        var fontFamily = style.fontFamily ?
          'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
            '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
        var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
            fontFamily = fontFamily,
            fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
            fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
            fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
            fill = style.fill ? getSvgColorString('fill', style.fill) : '',
            stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
            textDecoration = this.getSvgTextDecoration(style),
            deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
        if (textDecoration) {
          textDecoration = 'text-decoration: ' + textDecoration + term;
        }

        return [
          stroke,
          strokeWidth,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration,
          fill,
          deltaY,
          useWhiteSpace ? 'white-space: pre; ' : ''
        ].join('');
      },

      /**
       * Returns text-decoration property for svg-export
       * @param {Object} style the object from which to retrieve style properties
       * @return {String}
       */
      getSvgTextDecoration: function(style) {
        if ('overline' in style || 'underline' in style || 'linethrough' in style) {
          return (style.overline ? 'overline ' : '') +
            (style.underline ? 'underline ' : '') + (style.linethrough ? 'line-through ' : '');
        }
        return '';
      },

      /**
       * Returns filter for svg shadow
       * @return {String}
       */
      getSvgFilter: function() {
        return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
      },

      /**
       * Returns id attribute for svg output
       * @return {String}
       */
      getSvgId: function() {
        return this.id ? 'id="' + this.id + '" ' : '';
      },

      /**
       * Returns transform-string for svg-export
       * @return {String}
       */
      getSvgTransform: function() {
        var angle = this.angle,
            skewX = (this.skewX % 360),
            skewY = (this.skewY % 360),
            center = this.getCenterPoint(),

            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

            translatePart = 'translate(' +
                              toFixed(center.x, NUM_FRACTION_DIGITS) +
                              ' ' +
                              toFixed(center.y, NUM_FRACTION_DIGITS) +
                            ')',

            anglePart = angle !== 0
              ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')
              : '',

            scalePart = (this.scaleX === 1 && this.scaleY === 1)
              ? '' :
              (' scale(' +
                toFixed(this.scaleX, NUM_FRACTION_DIGITS) +
                ' ' +
                toFixed(this.scaleY, NUM_FRACTION_DIGITS) +
              ')'),

            skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',

            skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',

            flipXPart = this.flipX ? ' matrix(-1 0 0 1 0 0) ' : '',

            flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 0)' : '';

        return [
          translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart
        ].join('');
      },

      /**
       * Returns transform-string for svg-export from the transform matrix of single elements
       * @return {String}
       */
      getSvgTransformMatrix: function() {
        return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';
      },

      _setSVGBg: function(textBgRects) {
        if (this.backgroundColor) {
          var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
          textBgRects.push(
            '\t\t<rect ',
            this._getFillAttributes(this.backgroundColor),
            ' x="',
            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
            '" y="',
            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
            '" width="',
            toFixed(this.width, NUM_FRACTION_DIGITS),
            '" height="',
            toFixed(this.height, NUM_FRACTION_DIGITS),
            '"></rect>\n');
        }
      },

      /**
       * @private
       */
      _createBaseSVGMarkup: function() {
        var markup = [];

        if (this.fill && this.fill.toLive) {
          markup.push(this.fill.toSVG(this, false));
        }
        if (this.stroke && this.stroke.toLive) {
          markup.push(this.stroke.toSVG(this, false));
        }
        if (this.shadow) {
          markup.push(this.shadow.toSVG(this));
        }
        return markup;
      },

      addPaintOrder: function() {
        return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
      }
    });
  })();
  /* _TO_SVG_END_ */


  (function() {

    var extend = fabric.util.object.extend,
        originalSet = 'stateProperties';

    /*
      Depends on `stateProperties`
    */
    function saveProps(origin, destination, props) {
      var tmpObj = { }, deep = true;
      props.forEach(function(prop) {
        tmpObj[prop] = origin[prop];
      });
      extend(origin[destination], tmpObj, deep);
    }

    function _isEqual(origValue, currentValue, firstPass) {
      if (origValue === currentValue) {
        // if the objects are identical, return
        return true;
      }
      else if (Array.isArray(origValue)) {
        if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
          return false;
        }
        for (var i = 0, len = origValue.length; i < len; i++) {
          if (!_isEqual(origValue[i], currentValue[i])) {
            return false;
          }
        }
        return true;
      }
      else if (origValue && typeof origValue === 'object') {
        var keys = Object.keys(origValue), key;
        if (!currentValue ||
            typeof currentValue !== 'object' ||
            (!firstPass && keys.length !== Object.keys(currentValue).length)
        ) {
          return false;
        }
        for (var i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (!_isEqual(origValue[key], currentValue[key])) {
            return false;
          }
        }
        return true;
      }
    }


    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * Returns true if object state (one of its state properties) was changed
       * @param {String} [propertySet] optional name for the set of property we want to save
       * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
       */
      hasStateChanged: function(propertySet) {
        propertySet = propertySet || originalSet;
        var dashedPropertySet = '_' + propertySet;
        if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
          return true;
        }
        return !_isEqual(this[dashedPropertySet], this, true);
      },

      /**
       * Saves state of an object
       * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
       * @return {fabric.Object} thisArg
       */
      saveState: function(options) {
        var propertySet = options && options.propertySet || originalSet,
            destination = '_' + propertySet;
        if (!this[destination]) {
          return this.setupState(options);
        }
        saveProps(this, destination, this[propertySet]);
        if (options && options.stateProperties) {
          saveProps(this, destination, options.stateProperties);
        }
        return this;
      },

      /**
       * Setups state of an object
       * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
       * @return {fabric.Object} thisArg
       */
      setupState: function(options) {
        options = options || { };
        var propertySet = options.propertySet || originalSet;
        options.propertySet = propertySet;
        this['_' + propertySet] = { };
        this.saveState(options);
        return this;
      }
    });
  })();


  (function() {

    var degreesToRadians = fabric.util.degreesToRadians;

    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

      /**
       * The object interactivity controls.
       * @private
       */
      _controlsVisibility: null,

      /**
       * Determines which corner has been clicked
       * @private
       * @param {Object} pointer The pointer indicating the mouse position
       * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
       */
      _findTargetCorner: function(pointer) {
        // objects in group, anykind, are not self modificable,
        // must not return an hovered corner.
        if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
          return false;
        }

        var ex = pointer.x,
            ey = pointer.y,
            xPoints,
            lines;
        this.__corner = 0;
        for (var i in this.oCoords) {

          if (!this.isControlVisible(i)) {
            continue;
          }

          if (i === 'mtr' && !this.hasRotatingPoint) {
            continue;
          }

          if (this.get('lockUniScaling') &&
             (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
            continue;
          }

          lines = this._getImageLines(this.oCoords[i].corner);

          // debugging

          // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);

          // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
          // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

          xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
          if (xPoints !== 0 && xPoints % 2 === 1) {
            this.__corner = i;
            return i;
          }
        }
        return false;
      },

      /**
       * Sets the coordinates of the draggable boxes in the corners of
       * the image used to scale/rotate it.
       * @private
       */
      _setCornerCoords: function() {
        var coords = this.oCoords,
            newTheta = degreesToRadians(45 - this.angle),
            /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
            /* 0.707106 stands for sqrt(2)/2 */
            cornerHypotenuse = this.cornerSize * 0.707106,
            cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta),
            sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta),
            x, y;

        for (var point in coords) {
          x = coords[point].x;
          y = coords[point].y;
          coords[point].corner = {
            tl: {
              x: x - sinHalfOffset,
              y: y - cosHalfOffset
            },
            tr: {
              x: x + cosHalfOffset,
              y: y - sinHalfOffset
            },
            bl: {
              x: x - cosHalfOffset,
              y: y + sinHalfOffset
            },
            br: {
              x: x + sinHalfOffset,
              y: y + cosHalfOffset
            }
          };
        }
      },

      /**
       * Draws a colored layer behind the object, inside its selection borders.
       * Requires public options: padding, selectionBackgroundColor
       * this function is called when the context is transformed
       * has checks to be skipped when the object is on a staticCanvas
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawSelectionBackground: function(ctx) {
        if (!this.selectionBackgroundColor ||
          (this.canvas && !this.canvas.interactive) ||
          (this.canvas && this.canvas._activeObject !== this)
        ) {
          return this;
        }
        ctx.save();
        var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
            vpt = this.canvas.viewportTransform;
        ctx.translate(center.x, center.y);
        ctx.scale(1 / vpt[0], 1 / vpt[3]);
        ctx.rotate(degreesToRadians(this.angle));
        ctx.fillStyle = this.selectionBackgroundColor;
        ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
        ctx.restore();
        return this;
      },

      /**
       * Draws borders of an object's bounding box.
       * Requires public properties: width, height
       * Requires public options: padding, borderColor
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawBorders: function(ctx, styleOverride) {
        styleOverride = styleOverride || {};
        var wh = this._calculateCurrentDimensions(),
            strokeWidth = 1 / this.borderScaleFactor,
            width = wh.x + strokeWidth,
            height = wh.y + strokeWidth,
            drawRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
              styleOverride.hasRotatingPoint : this.hasRotatingPoint,
            hasControls = typeof styleOverride.hasControls !== 'undefined' ?
              styleOverride.hasControls : this.hasControls,
            rotatingPointOffset = typeof styleOverride.rotatingPointOffset !== 'undefined' ?
              styleOverride.rotatingPointOffset : this.rotatingPointOffset;

        ctx.save();
        ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
        this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

        ctx.strokeRect(
          -width / 2,
          -height / 2,
          width,
          height
        );

        if (drawRotatingPoint && this.isControlVisible('mtr') && hasControls) {

          var rotateHeight = -height / 2;

          ctx.beginPath();
          ctx.moveTo(0, rotateHeight);
          ctx.lineTo(0, rotateHeight - rotatingPointOffset);
          ctx.stroke();
        }

        ctx.restore();
        return this;
      },

      /**
       * Draws borders of an object's bounding box when it is inside a group.
       * Requires public properties: width, height
       * Requires public options: padding, borderColor
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {object} options object representing current object parameters
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawBordersInGroup: function(ctx, options, styleOverride) {
        styleOverride = styleOverride || {};
        var p = this._getNonTransformedDimensions(),
            matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
            wh = fabric.util.transformPoint(p, matrix),
            strokeWidth = 1 / this.borderScaleFactor,
            width = wh.x + strokeWidth,
            height = wh.y + strokeWidth;

        ctx.save();
        this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
        ctx.strokeStyle = styleOverride.borderColor || this.borderColor;

        ctx.strokeRect(
          -width / 2,
          -height / 2,
          width,
          height
        );

        ctx.restore();
        return this;
      },

      /**
       * Draws corners of an object's bounding box.
       * Requires public properties: width, height
       * Requires public options: cornerSize, padding
       * @param {CanvasRenderingContext2D} ctx Context to draw on
       * @param {Object} styleOverride object to override the object style
       * @return {fabric.Object} thisArg
       * @chainable
       */
      drawControls: function(ctx, styleOverride) {
        styleOverride = styleOverride || {};
        var wh = this._calculateCurrentDimensions(),
            width = wh.x,
            height = wh.y,
            scaleOffset = styleOverride.cornerSize || this.cornerSize,
            left = -(width + scaleOffset) / 2,
            top = -(height + scaleOffset) / 2,
            transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
              styleOverride.transparentCorners : this.transparentCorners,
            hasRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
              styleOverride.hasRotatingPoint : this.hasRotatingPoint,
            methodName = transparentCorners ? 'stroke' : 'fill';

        ctx.save();
        ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
        if (!this.transparentCorners) {
          ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
        }
        this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);

        // top-left
        this._drawControl('tl', ctx, methodName,
          left,
          top, styleOverride);

        // top-right
        this._drawControl('tr', ctx, methodName,
          left + width,
          top, styleOverride);

        // bottom-left
        this._drawControl('bl', ctx, methodName,
          left,
          top + height, styleOverride);

        // bottom-right
        this._drawControl('br', ctx, methodName,
          left + width,
          top + height, styleOverride);

        if (!this.get('lockUniScaling')) {

          // middle-top
          this._drawControl('mt', ctx, methodName,
            left + width / 2,
            top, styleOverride);

          // middle-bottom
          this._drawControl('mb', ctx, methodName,
            left + width / 2,
            top + height, styleOverride);

          // middle-right
          this._drawControl('mr', ctx, methodName,
            left + width,
            top + height / 2, styleOverride);

          // middle-left
          this._drawControl('ml', ctx, methodName,
            left,
            top + height / 2, styleOverride);
        }

        // middle-top-rotate
        if (hasRotatingPoint) {
          this._drawControl('mtr', ctx, methodName,
            left + width / 2,
            top - this.rotatingPointOffset, styleOverride);
        }

        ctx.restore();

        return this;
      },

      /**
       * @private
       */
      _drawControl: function(control, ctx, methodName, left, top, styleOverride) {
        styleOverride = styleOverride || {};
        if (!this.isControlVisible(control)) {
          return;
        }
        var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
        switch (styleOverride.cornerStyle || this.cornerStyle) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
            ctx[methodName]();
            if (stroke) {
              ctx.stroke();
            }
            break;
          default:
            this.transparentCorners || ctx.clearRect(left, top, size, size);
            ctx[methodName + 'Rect'](left, top, size, size);
            if (stroke) {
              ctx.strokeRect(left, top, size, size);
            }
        }
      },

      /**
       * Returns true if the specified control is visible, false otherwise.
       * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
       * @returns {Boolean} true if the specified control is visible, false otherwise
       */
      isControlVisible: function(controlName) {
        return this._getControlsVisibility()[controlName];
      },

      /**
       * Sets the visibility of the specified control.
       * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
       * @param {Boolean} visible true to set the specified control visible, false otherwise
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setControlVisible: function(controlName, visible) {
        this._getControlsVisibility()[controlName] = visible;
        return this;
      },

      /**
       * Sets the visibility state of object controls.
       * @param {Object} [options] Options object
       * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
       * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
       * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
       * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
       * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
       * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
       * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
       * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
       * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
       * @return {fabric.Object} thisArg
       * @chainable
       */
      setControlsVisibility: function(options) {
        options || (options = { });

        for (var p in options) {
          this.setControlVisible(p, options[p]);
        }
        return this;
      },

      /**
       * Returns the instance of the control visibility set for this object.
       * @private
       * @returns {Object}
       */
      _getControlsVisibility: function() {
        if (!this._controlsVisibility) {
          this._controlsVisibility = {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: true,
            mt: true,
            mr: true,
            mb: true,
            mtr: true
          };
        }
        return this._controlsVisibility;
      },

      /**
       * This callback function is called every time _discardActiveObject or _setActiveObject
       * try to to deselect this object. If the function returns true, the process is cancelled
       * @param {Object} [options] options sent from the upper functions
       * @param {Event} [options.e] event if the process is generated by an event
       */
      onDeselect: function() {
        // implemented by sub-classes, as needed.
      },


      /**
       * This callback function is called every time _discardActiveObject or _setActiveObject
       * try to to select this object. If the function returns true, the process is cancelled
       * @param {Object} [options] options sent from the upper functions
       * @param {Event} [options.e] event if the process is generated by an event
       */
      onSelect: function() {
        // implemented by sub-classes, as needed.
      }
    });
  })();


  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Animation duration (in ms) for fx* methods
     * @type Number
     * @default
     */
    FX_DURATION: 500,

    /**
     * Centers object horizontally with animation.
     * @param {fabric.Object} object Object to center
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxCenterObjectH: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.left,
        endValue: this.getCenter().left,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('left', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function() {
          object.setCoords();
          onComplete();
        }
      });

      return this;
    },

    /**
     * Centers object vertically with animation.
     * @param {fabric.Object} object Object to center
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxCenterObjectV: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.top,
        endValue: this.getCenter().top,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('top', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function() {
          object.setCoords();
          onComplete();
        }
      });

      return this;
    },

    /**
     * Same as `fabric.Canvas#remove` but animated
     * @param {fabric.Object} object Object to remove
     * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxRemove: function (object, callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: object.opacity,
        endValue: 0,
        duration: this.FX_DURATION,
        onChange: function(value) {
          object.set('opacity', value);
          _this.requestRenderAll();
          onChange();
        },
        onComplete: function () {
          _this.remove(object);
          onComplete();
        }
      });

      return this;
    }
  });

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Animates object's properties
     * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
     * @param {Number|Object} value Value to animate property to (if string was given first) or options object
     * @return {fabric.Object} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
     * @chainable
     *
     * As object  multiple properties
     *
     * object.animate({ left: ..., top: ... });
     * object.animate({ left: ..., top: ... }, { duration: ... });
     *
     * As string  one property
     *
     * object.animate('left', ...);
     * object.animate('left', { duration: ... });
     *
     */
    animate: function() {
      if (arguments[0] && typeof arguments[0] === 'object') {
        var propsToAnimate = [], prop, skipCallbacks;
        for (prop in arguments[0]) {
          propsToAnimate.push(prop);
        }
        for (var i = 0, len = propsToAnimate.length; i < len; i++) {
          prop = propsToAnimate[i];
          skipCallbacks = i !== len - 1;
          this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
        }
      }
      else {
        this._animate.apply(this, arguments);
      }
      return this;
    },

    /**
     * @private
     * @param {String} property Property to animate
     * @param {String} to Value to animate to
     * @param {Object} [options] Options object
     * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
     */
    _animate: function(property, to, options, skipCallbacks) {
      var _this = this, propPair;

      to = to.toString();

      if (!options) {
        options = { };
      }
      else {
        options = fabric.util.object.clone(options);
      }

      if (~property.indexOf('.')) {
        propPair = property.split('.');
      }

      var currentValue = propPair
        ? this.get(propPair[0])[propPair[1]]
        : this.get(property);

      if (!('from' in options)) {
        options.from = currentValue;
      }

      if (~to.indexOf('=')) {
        to = currentValue + parseFloat(to.replace('=', ''));
      }
      else {
        to = parseFloat(to);
      }

      fabric.util.animate({
        startValue: options.from,
        endValue: to,
        byValue: options.by,
        easing: options.easing,
        duration: options.duration,
        abort: options.abort && function() {
          return options.abort.call(_this);
        },
        onChange: function(value, valueProgress, timeProgress) {
          if (propPair) {
            _this[propPair[0]][propPair[1]] = value;
          }
          else {
            _this.set(property, value);
          }
          if (skipCallbacks) {
            return;
          }
          options.onChange && options.onChange(value, valueProgress, timeProgress);
        },
        onComplete: function(value, valueProgress, timeProgress) {
          if (skipCallbacks) {
            return;
          }

          _this.setCoords();
          options.onComplete && options.onComplete(value, valueProgress, timeProgress);
        }
      });
    }
  });


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        clone = fabric.util.object.clone,
        coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
        supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

    if (fabric.Line) {
      fabric.warn('fabric.Line is already defined');
      return;
    }

    /**
     * Line class
     * @class fabric.Line
     * @extends fabric.Object
     * @see {@link fabric.Line#initialize} for constructor definition
     */
    fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'line',

      /**
       * x value or first line edge
       * @type Number
       * @default
       */
      x1: 0,

      /**
       * y value or first line edge
       * @type Number
       * @default
       */
      y1: 0,

      /**
       * x value or second line edge
       * @type Number
       * @default
       */
      x2: 0,

      /**
       * y value or second line edge
       * @type Number
       * @default
       */
      y2: 0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

      /**
       * Constructor
       * @param {Array} [points] Array of points
       * @param {Object} [options] Options object
       * @return {fabric.Line} thisArg
       */
      initialize: function(points, options) {
        if (!points) {
          points = [0, 0, 0, 0];
        }

        this.callSuper('initialize', options);

        this.set('x1', points[0]);
        this.set('y1', points[1]);
        this.set('x2', points[2]);
        this.set('y2', points[3]);

        this._setWidthHeight(options);
      },

      /**
       * @private
       * @param {Object} [options] Options
       */
      _setWidthHeight: function(options) {
        options || (options = { });

        this.width = Math.abs(this.x2 - this.x1);
        this.height = Math.abs(this.y2 - this.y1);

        this.left = 'left' in options
          ? options.left
          : this._getLeftToOriginX();

        this.top = 'top' in options
          ? options.top
          : this._getTopToOriginY();
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);
        if (typeof coordProps[key] !== 'undefined') {
          this._setWidthHeight();
        }
        return this;
      },

      /**
       * @private
       * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
       */
      _getLeftToOriginX: makeEdgeToOriginGetter(
        { // property names
          origin: 'originX',
          axis1: 'x1',
          axis2: 'x2',
          dimension: 'width'
        },
        { // possible values of origin
          nearest: 'left',
          center: 'center',
          farthest: 'right'
        }
      ),

      /**
       * @private
       * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
       */
      _getTopToOriginY: makeEdgeToOriginGetter(
        { // property names
          origin: 'originY',
          axis1: 'y1',
          axis2: 'y2',
          dimension: 'height'
        },
        { // possible values of origin
          nearest: 'top',
          center: 'center',
          farthest: 'bottom'
        }
      ),

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();

        if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
          // move from center (of virtual box) to its left/top corner
          // we can't assume x1, y1 is top left and x2, y2 is bottom right
          var p = this.calcLinePoints();
          ctx.moveTo(p.x1, p.y1);
          ctx.lineTo(p.x2, p.y2);
        }

        ctx.lineWidth = this.strokeWidth;

        // TODO: test this
        // make sure setting "fill" changes color of a line
        // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
        var origStrokeStyle = ctx.strokeStyle;
        ctx.strokeStyle = this.stroke || ctx.fillStyle;
        this.stroke && this._renderStroke(ctx);
        ctx.strokeStyle = origStrokeStyle;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var p = this.calcLinePoints();

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
        ctx.closePath();
      },

      /**
       * This function is an helper for svg import. it returns the center of the object in the svg
       * untransformed coordinates
       * @private
       * @return {Object} center point from element coordinates
       */
      _findCenterFromElement: function() {
        return {
          x: (this.x1 + this.x2) / 2,
          y: (this.y1 + this.y2) / 2,
        };
      },

      /**
       * Returns object representation of an instance
       * @methd toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
      },

      /*
       * Calculate object dimensions from its properties
       * @private
       */
      _getNonTransformedDimensions: function() {
        var dim = this.callSuper('_getNonTransformedDimensions');
        if (this.strokeLineCap === 'butt') {
          if (this.width === 0) {
            dim.y -= this.strokeWidth;
          }
          if (this.height === 0) {
            dim.x -= this.strokeWidth;
          }
        }
        return dim;
      },

      /**
       * Recalculates line points given width and height
       * @private
       */
      calcLinePoints: function() {
        var xMult = this.x1 <= this.x2 ? -1 : 1,
            yMult = this.y1 <= this.y2 ? -1 : 1,
            x1 = (xMult * this.width * 0.5),
            y1 = (yMult * this.height * 0.5),
            x2 = (xMult * this.width * -0.5),
            y2 = (yMult * this.height * -0.5);

        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        };
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(),
            p = this.calcLinePoints();
        markup.push(
          '<line ', this.getSvgId(),
          'x1="', p.x1,
          '" y1="', p.y1,
          '" x2="', p.x2,
          '" y2="', p.y2,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(),
          '"/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
     * @static
     * @memberOf fabric.Line
     * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
     */
    fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

    /**
     * Returns fabric.Line instance from an SVG element
     * @static
     * @memberOf fabric.Line
     * @param {SVGElement} element Element to parse
     * @param {Object} [options] Options object
     * @param {Function} [callback] callback function invoked after parsing
     */
    fabric.Line.fromElement = function(element, callback, options) {
      options = options || { };
      var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
          points = [
            parsedAttributes.x1 || 0,
            parsedAttributes.y1 || 0,
            parsedAttributes.x2 || 0,
            parsedAttributes.y2 || 0
          ];
      callback(new fabric.Line(points, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Line instance from an object representation
     * @static
     * @memberOf fabric.Line
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     */
    fabric.Line.fromObject = function(object, callback) {
      function _callback(instance) {
        delete instance.points;
        callback && callback(instance);
      }    var options = clone(object, true);
      options.points = [object.x1, object.y1, object.x2, object.y2];
      fabric.Object._fromObject('Line', options, _callback, 'points');
    };

    /**
     * Produces a function that calculates distance from canvas edge to Line origin.
     */
    function makeEdgeToOriginGetter(propertyNames, originValues) {
      var origin = propertyNames.origin,
          axis1 = propertyNames.axis1,
          axis2 = propertyNames.axis2,
          dimension = propertyNames.dimension,
          nearest = originValues.nearest,
          center = originValues.center,
          farthest = originValues.farthest;

      return function() {
        switch (this.get(origin)) {
          case nearest:
            return Math.min(this.get(axis1), this.get(axis2));
          case center:
            return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
          case farthest:
            return Math.max(this.get(axis1), this.get(axis2));
        }
      };

    }

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        pi = Math.PI;

    if (fabric.Circle) {
      fabric.warn('fabric.Circle is already defined.');
      return;
    }

    /**
     * Circle class
     * @class fabric.Circle
     * @extends fabric.Object
     * @see {@link fabric.Circle#initialize} for constructor definition
     */
    fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'circle',

      /**
       * Radius of this circle
       * @type Number
       * @default
       */
      radius: 0,

      /**
       * Start angle of the circle, moving clockwise
       * deprectated type, this should be in degree, this was an oversight.
       * probably will change to degrees in next major version
       * @type Number
       * @default 0
       */
      startAngle: 0,

      /**
       * End angle of the circle
       * deprectated type, this should be in degree, this was an oversight.
       * probably will change to degrees in next major version
       * @type Number
       * @default 2Pi
       */
      endAngle: pi * 2,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Circle} thisArg
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);

        if (key === 'radius') {
          this.setRadius(value);
        }

        return this;
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(), x = 0, y = 0,
            angle = (this.endAngle - this.startAngle) % ( 2 * pi);

        if (angle === 0) {
          markup.push(
            '<circle ', this.getSvgId(),
            'cx="' + x + '" cy="' + y + '" ',
            'r="', this.radius,
            '" style="', this.getSvgStyles(),
            '" transform="', this.getSvgTransform(),
            ' ', this.getSvgTransformMatrix(), '"',
            this.addPaintOrder(),
            '/>\n'
          );
        }
        else {
          var startX = fabric.util.cos(this.startAngle) * this.radius,
              startY = fabric.util.sin(this.startAngle) * this.radius,
              endX = fabric.util.cos(this.endAngle) * this.radius,
              endY = fabric.util.sin(this.endAngle) * this.radius,
              largeFlag = angle > pi ? '1' : '0';

          markup.push(
            '<path d="M ' + startX + ' ' + startY,
            ' A ' + this.radius + ' ' + this.radius,
            ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
            '" style="', this.getSvgStyles(),
            '" transform="', this.getSvgTransform(),
            ' ', this.getSvgTransformMatrix(), '"',
            this.addPaintOrder(),
            '"/>\n'
          );
        }

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();
        ctx.arc(
          0,
          0,
          this.radius,
          this.startAngle,
          this.endAngle, false);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Returns horizontal radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRadiusX: function() {
        return this.get('radius') * this.get('scaleX');
      },

      /**
       * Returns vertical radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRadiusY: function() {
        return this.get('radius') * this.get('scaleY');
      },

      /**
       * Sets radius of an object (and updates width accordingly)
       * @return {fabric.Circle} thisArg
       */
      setRadius: function(value) {
        this.radius = value;
        return this.set('width', value * 2).set('height', value * 2);
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
     * @static
     * @memberOf fabric.Circle
     * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
     */
    fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

    /**
     * Returns {@link fabric.Circle} instance from an SVG element
     * @static
     * @memberOf fabric.Circle
     * @param {SVGElement} element Element to parse
     * @param {Function} [callback] Options callback invoked after parsing is finished
     * @param {Object} [options] Options object
     * @throws {Error} If value of `r` attribute is missing or invalid
     */
    fabric.Circle.fromElement = function(element, callback) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

      if (!isValidRadius(parsedAttributes)) {
        throw new Error('value of `r` attribute is required and can not be negative');
      }

      parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
      parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
      callback(new fabric.Circle(parsedAttributes));
    };

    /**
     * @private
     */
    function isValidRadius(attributes) {
      return (('radius' in attributes) && (attributes.radius >= 0));
    }
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Circle} instance from an object representation
     * @static
     * @memberOf fabric.Circle
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     * @return {Object} Instance of fabric.Circle
     */
    fabric.Circle.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Circle', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.Triangle) {
      fabric.warn('fabric.Triangle is already defined');
      return;
    }

    /**
     * Triangle class
     * @class fabric.Triangle
     * @extends fabric.Object
     * @return {fabric.Triangle} thisArg
     * @see {@link fabric.Triangle#initialize} for constructor definition
     */
    fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'triangle',

      /**
       * Width is set to 100 to compensate the old initialize code that was setting it to 100
       * @type Number
       * @default
       */
      width: 100,

      /**
       * Height is set to 100 to compensate the old initialize code that was setting it to 100
       * @type Number
       * @default
       */
      height: 100,

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2;

        ctx.beginPath();
        ctx.moveTo(-widthBy2, heightBy2);
        ctx.lineTo(0, -heightBy2);
        ctx.lineTo(widthBy2, heightBy2);
        ctx.closePath();

        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var widthBy2 = this.width / 2,
            heightBy2 = this.height / 2;

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
        ctx.closePath();
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(),
            widthBy2 = this.width / 2,
            heightBy2 = this.height / 2,
            points = [
              -widthBy2 + ' ' + heightBy2,
              '0 ' + -heightBy2,
              widthBy2 + ' ' + heightBy2
            ]
              .join(',');

        markup.push(
          '<polygon ', this.getSvgId(),
          'points="', points,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(), '"',
          this.addPaintOrder(),
          '/>'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /**
     * Returns {@link fabric.Triangle} instance from an object representation
     * @static
     * @memberOf fabric.Triangle
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     */
    fabric.Triangle.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Triangle', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        piBy2   = Math.PI * 2;

    if (fabric.Ellipse) {
      fabric.warn('fabric.Ellipse is already defined.');
      return;
    }

    /**
     * Ellipse class
     * @class fabric.Ellipse
     * @extends fabric.Object
     * @return {fabric.Ellipse} thisArg
     * @see {@link fabric.Ellipse#initialize} for constructor definition
     */
    fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'ellipse',

      /**
       * Horizontal radius
       * @type Number
       * @default
       */
      rx:   0,

      /**
       * Vertical radius
       * @type Number
       * @default
       */
      ry:   0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @return {fabric.Ellipse} thisArg
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        this.set('rx', options && options.rx || 0);
        this.set('ry', options && options.ry || 0);
      },

      /**
       * @private
       * @param {String} key
       * @param {*} value
       * @return {fabric.Ellipse} thisArg
       */
      _set: function(key, value) {
        this.callSuper('_set', key, value);
        switch (key) {

          case 'rx':
            this.rx = value;
            this.set('width', value * 2);
            break;

          case 'ry':
            this.ry = value;
            this.set('height', value * 2);
            break;

        }
        return this;
      },

      /**
       * Returns horizontal radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRx: function() {
        return this.get('rx') * this.get('scaleX');
      },

      /**
       * Returns Vertical radius of an object (according to how an object is scaled)
       * @return {Number}
       */
      getRy: function() {
        return this.get('ry') * this.get('scaleY');
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup();
        markup.push(
          '<ellipse ', this.getSvgId(),
          'cx="0" cy="0" ',
          'rx="', this.rx,
          '" ry="', this.ry,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(), '"',
          this.addPaintOrder(),
          '/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render on
       */
      _render: function(ctx) {
        ctx.beginPath();
        ctx.save();
        ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
        ctx.arc(
          0,
          0,
          this.rx,
          0,
          piBy2,
          false);
        ctx.restore();
        this._renderPaintInOrder(ctx);
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
     * @static
     * @memberOf fabric.Ellipse
     * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
     */
    fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

    /**
     * Returns {@link fabric.Ellipse} instance from an SVG element
     * @static
     * @memberOf fabric.Ellipse
     * @param {SVGElement} element Element to parse
     * @param {Function} [callback] Options callback invoked after parsing is finished
     * @return {fabric.Ellipse}
     */
    fabric.Ellipse.fromElement = function(element, callback) {

      var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

      parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
      parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
      callback(new fabric.Ellipse(parsedAttributes));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Ellipse} instance from an object representation
     * @static
     * @memberOf fabric.Ellipse
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as first argument
     * @return {fabric.Ellipse}
     */
    fabric.Ellipse.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Ellipse', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend;

    if (fabric.Rect) {
      fabric.warn('fabric.Rect is already defined');
      return;
    }

    /**
     * Rectangle class
     * @class fabric.Rect
     * @extends fabric.Object
     * @return {fabric.Rect} thisArg
     * @see {@link fabric.Rect#initialize} for constructor definition
     */
    fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

      /**
       * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'rect',

      /**
       * Horizontal border radius
       * @type Number
       * @default
       */
      rx:   0,

      /**
       * Vertical border radius
       * @type Number
       * @default
       */
      ry:   0,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

      /**
       * Constructor
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        this._initRxRy();
      },

      /**
       * Initializes rx/ry attributes
       * @private
       */
      _initRxRy: function() {
        if (this.rx && !this.ry) {
          this.ry = this.rx;
        }
        else if (this.ry && !this.rx) {
          this.rx = this.ry;
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {

        // optimize 1x1 case (used in spray brush)
        if (this.width === 1 && this.height === 1) {
          ctx.fillRect(-0.5, -0.5, 1, 1);
          return;
        }

        var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
            ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
            w = this.width,
            h = this.height,
            x = -this.width / 2,
            y = -this.height / 2,
            isRounded = rx !== 0 || ry !== 0,
            /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
            k = 1 - 0.5522847498;
        ctx.beginPath();

        ctx.moveTo(x + rx, y);

        ctx.lineTo(x + w - rx, y);
        isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

        ctx.lineTo(x + w, y + h - ry);
        isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

        ctx.lineTo(x + rx, y + h);
        isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

        ctx.lineTo(x, y + ry);
        isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

        ctx.closePath();

        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var x = -this.width / 2,
            y = -this.height / 2,
            w = this.width,
            h = this.height;

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
        ctx.closePath();
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2;
        markup.push(
          '<rect ', this.getSvgId(),
          'x="', x, '" y="', y,
          '" rx="', this.get('rx'), '" ry="', this.get('ry'),
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(), '"',
          this.addPaintOrder(),
          '/>\n');

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
     * @static
     * @memberOf fabric.Rect
     * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
     */
    fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

    /**
     * Returns {@link fabric.Rect} instance from an SVG element
     * @static
     * @memberOf fabric.Rect
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Rect.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options = options || { };

      var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);

      parsedAttributes.left = parsedAttributes.left || 0;
      parsedAttributes.top  = parsedAttributes.top  || 0;
      var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
      rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
      callback(rect);
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Rect} instance from an object representation
     * @static
     * @memberOf fabric.Rect
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
     */
    fabric.Rect.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Rect', object, callback);
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        min = fabric.util.array.min,
        max = fabric.util.array.max,
        toFixed = fabric.util.toFixed;

    if (fabric.Polyline) {
      fabric.warn('fabric.Polyline is already defined');
      return;
    }

    /**
     * Polyline class
     * @class fabric.Polyline
     * @extends fabric.Object
     * @see {@link fabric.Polyline#initialize} for constructor definition
     */
    fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'polyline',

      /**
       * Points array
       * @type Array
       * @default
       */
      points: null,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

      /**
       * Constructor
       * @param {Array} points Array of points (where each point is an object with x and y)
       * @param {Object} [options] Options object
       * @return {fabric.Polyline} thisArg
       * @example
       * var poly = new fabric.Polyline([
       *     { x: 10, y: 10 },
       *     { x: 50, y: 30 },
       *     { x: 40, y: 70 },
       *     { x: 60, y: 50 },
       *     { x: 100, y: 150 },
       *     { x: 40, y: 100 }
       *   ], {
       *   stroke: 'red',
       *   left: 100,
       *   top: 100
       * });
       */
      initialize: function(points, options) {
        options = options || {};
        this.points = points || [];
        this.callSuper('initialize', options);
        var calcDim = this._calcDimensions();
        if (typeof options.left === 'undefined') {
          this.left = calcDim.left;
        }
        if (typeof options.top === 'undefined') {
          this.top = calcDim.top;
        }
        this.width = calcDim.width;
        this.height = calcDim.height;
        this.pathOffset = {
          x: calcDim.left + this.width / 2,
          y: calcDim.top + this.height / 2
        };
      },

      /**
       * Calculate the polygon min and max point from points array,
       * returning an object with left, top, widht, height to measure the
       * polygon size
       * @return {Object} object.left X coordinate of the polygon leftmost point
       * @return {Object} object.top Y coordinate of the polygon topmost point
       * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
       * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
       * @private
       */
      _calcDimensions: function() {

        var points = this.points,
            minX = min(points, 'x') || 0,
            minY = min(points, 'y') || 0,
            maxX = max(points, 'x') || 0,
            maxY = max(points, 'y') || 0,
            width = (maxX - minX),
            height = (maxY - minY);

        return {
          left: minX,
          top: minY,
          width: width,
          height: height
        };
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return extend(this.callSuper('toObject', propertiesToInclude), {
          points: this.points.concat()
        });
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
            markup = this._createBaseSVGMarkup(),
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

        for (var i = 0, len = this.points.length; i < len; i++) {
          points.push(
            toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
            toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
          );
        }
        markup.push(
          '<', this.type, ' ', this.getSvgId(),
          'points="', points.join(''),
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          ' ', this.getSvgTransformMatrix(), '"',
          this.addPaintOrder(),
          '/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */


      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      commonRender: function(ctx) {
        var point, len = this.points.length,
            x = this.pathOffset.x,
            y = this.pathOffset.y;

        if (!len || isNaN(this.points[len - 1].y)) {
          // do not draw if no points or odd points
          // NaN comes from parseFloat of a empty string in parser
          return false;
        }
        ctx.beginPath();
        ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
        for (var i = 0; i < len; i++) {
          point = this.points[i];
          ctx.lineTo(point.x - x, point.y - y);
        }
        return true;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (!this.commonRender(ctx)) {
          return;
        }
        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var p1, p2;

        ctx.beginPath();
        for (var i = 0, len = this.points.length; i < len; i++) {
          p1 = this.points[i];
          p2 = this.points[i + 1] || p1;
          fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
        }
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity of this instance
       */
      complexity: function() {
        return this.get('points').length;
      }
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
     * @static
     * @memberOf fabric.Polyline
     * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
     */
    fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

    /**
     * Returns fabric.Polyline instance from an SVG element
     * @static
     * @memberOf fabric.Polyline
     * @param {SVGElement} element Element to parser
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Polyline.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);

      callback(new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Polyline instance from an object representation
     * @static
     * @memberOf fabric.Polyline
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Polyline.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Polyline', object, callback, 'points');
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend;

    if (fabric.Polygon) {
      fabric.warn('fabric.Polygon is already defined');
      return;
    }

    /**
     * Polygon class
     * @class fabric.Polygon
     * @extends fabric.Polyline
     * @see {@link fabric.Polygon#initialize} for constructor definition
     */
    fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'polygon',

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (!this.commonRender(ctx)) {
          return;
        }
        ctx.closePath();
        this._renderPaintInOrder(ctx);
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        this.callSuper('_renderDashedStroke', ctx);
        ctx.closePath();
      },
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
     * @static
     * @memberOf fabric.Polygon
     * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
     */
    fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

    /**
     * Returns {@link fabric.Polygon} instance from an SVG element
     * @static
     * @memberOf fabric.Polygon
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Polygon.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }

      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);

      callback(new fabric.Polygon(points, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Polygon instance from an object representation
     * @static
     * @memberOf fabric.Polygon
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Polygon.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Polygon', object, callback, 'points');
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        min = fabric.util.array.min,
        max = fabric.util.array.max,
        extend = fabric.util.object.extend,
        _toString = Object.prototype.toString,
        drawArc = fabric.util.drawArc,
        commandLengths = {
          m: 2,
          l: 2,
          h: 1,
          v: 1,
          c: 6,
          s: 4,
          q: 4,
          t: 2,
          a: 7
        },
        repeatedCommands = {
          m: 'l',
          M: 'L'
        };

    if (fabric.Path) {
      fabric.warn('fabric.Path is already defined');
      return;
    }

    /**
     * Path class
     * @class fabric.Path
     * @extends fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
     * @see {@link fabric.Path#initialize} for constructor definition
     */
    fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'path',

      /**
       * Array of path points
       * @type Array
       * @default
       */
      path: null,

      cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

      stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

      /**
       * Constructor
       * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
       * @param {Object} [options] Options object
       * @return {fabric.Path} thisArg
       */
      initialize: function(path, options) {
        options = options || { };
        this.callSuper('initialize', options);

        if (!path) {
          path = [];
        }

        var fromArray = _toString.call(path) === '[object Array]';

        this.path = fromArray
          ? path
          // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
          : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

        if (!this.path) {
          return;
        }

        if (!fromArray) {
          this.path = this._parsePath();
        }

        this._setPositionDimensions(options);
      },

      /**
       * @private
       * @param {Object} options Options object
       */
      _setPositionDimensions: function(options) {
        var calcDim = this._parseDimensions();

        this.width = calcDim.width;
        this.height = calcDim.height;

        if (typeof options.left === 'undefined') {
          this.left = calcDim.left;
        }

        if (typeof options.top === 'undefined') {
          this.top = calcDim.top;
        }

        this.pathOffset = this.pathOffset || {
          x: calcDim.left + this.width / 2,
          y: calcDim.top + this.height / 2
        };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render path on
       */
      _renderPathCommands: function(ctx) {
        var current, // current instruction
            previous = null,
            subpathStartX = 0,
            subpathStartY = 0,
            x = 0, // current x
            y = 0, // current y
            controlX = 0, // current control point x
            controlY = 0, // current control point y
            tempX,
            tempY,
            l = -this.pathOffset.x,
            t = -this.pathOffset.y;

        ctx.beginPath();

        for (var i = 0, len = this.path.length; i < len; ++i) {

          current = this.path[i];

          switch (current[0]) { // first letter

            case 'l': // lineto, relative
              x += current[1];
              y += current[2];
              ctx.lineTo(x + l, y + t);
              break;

            case 'L': // lineto, absolute
              x = current[1];
              y = current[2];
              ctx.lineTo(x + l, y + t);
              break;

            case 'h': // horizontal lineto, relative
              x += current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'H': // horizontal lineto, absolute
              x = current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'v': // vertical lineto, relative
              y += current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'V': // verical lineto, absolute
              y = current[1];
              ctx.lineTo(x + l, y + t);
              break;

            case 'm': // moveTo, relative
              x += current[1];
              y += current[2];
              subpathStartX = x;
              subpathStartY = y;
              ctx.moveTo(x + l, y + t);
              break;

            case 'M': // moveTo, absolute
              x = current[1];
              y = current[2];
              subpathStartX = x;
              subpathStartY = y;
              ctx.moveTo(x + l, y + t);
              break;

            case 'c': // bezierCurveTo, relative
              tempX = x + current[5];
              tempY = y + current[6];
              controlX = x + current[3];
              controlY = y + current[4];
              ctx.bezierCurveTo(
                x + current[1] + l, // x1
                y + current[2] + t, // y1
                controlX + l, // x2
                controlY + t, // y2
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'C': // bezierCurveTo, absolute
              x = current[5];
              y = current[6];
              controlX = current[3];
              controlY = current[4];
              ctx.bezierCurveTo(
                current[1] + l,
                current[2] + t,
                controlX + l,
                controlY + t,
                x + l,
                y + t
              );
              break;

            case 's': // shorthand cubic bezierCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              ctx.bezierCurveTo(
                controlX + l,
                controlY + t,
                x + current[1] + l,
                y + current[2] + t,
                tempX + l,
                tempY + t
              );
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = x + current[1];
              controlY = y + current[2];

              x = tempX;
              y = tempY;
              break;

            case 'S': // shorthand cubic bezierCurveTo, absolute
              tempX = current[3];
              tempY = current[4];
              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              ctx.bezierCurveTo(
                controlX + l,
                controlY + t,
                current[1] + l,
                current[2] + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;

              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = current[1];
              controlY = current[2];

              break;

            case 'q': // quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              controlX = x + current[1];
              controlY = y + current[2];

              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'Q': // quadraticCurveTo, absolute
              tempX = current[3];
              tempY = current[4];

              ctx.quadraticCurveTo(
                current[1] + l,
                current[2] + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              controlX = current[1];
              controlY = current[2];
              break;

            case 't': // shorthand quadraticCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[1];
              tempY = y + current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;

              break;

            case 'T':
              tempX = current[1];
              tempY = current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              ctx.quadraticCurveTo(
                controlX + l,
                controlY + t,
                tempX + l,
                tempY + t
              );
              x = tempX;
              y = tempY;
              break;

            case 'a':
              // TODO: optimize this
              drawArc(ctx, x + l, y + t, [
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + x + l,
                current[7] + y + t
              ]);
              x += current[6];
              y += current[7];
              break;

            case 'A':
              // TODO: optimize this
              drawArc(ctx, x + l, y + t, [
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + l,
                current[7] + t
              ]);
              x = current[6];
              y = current[7];
              break;

            case 'z':
            case 'Z':
              x = subpathStartX;
              y = subpathStartY;
              ctx.closePath();
              break;
          }
          previous = current;
        }
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx context to render path on
       */
      _render: function(ctx) {
        this._renderPathCommands(ctx);
        this._renderPaintInOrder(ctx);
      },

      /**
       * Returns string representation of an instance
       * @return {String} string representation of an instance
       */
      toString: function() {
        return '#<fabric.Path (' + this.complexity() +
          '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var o = extend(this.callSuper('toObject', propertiesToInclude), {
          path: this.path.map(function(item) { return item.slice(); }),
          top: this.top,
          left: this.left,
        });
        return o;
      },

      /**
       * Returns dataless object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
        if (o.sourcePath) {
          delete o.path;
        }
        return o;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var chunks = [],
            markup = this._createBaseSVGMarkup(), addTransform = '';

        for (var i = 0, len = this.path.length; i < len; i++) {
          chunks.push(this.path[i].join(' '));
        }
        var path = chunks.join(' ');
        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
        markup.push(
          '<path ', this.getSvgId(),
          'd="', path,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(), addTransform,
          this.getSvgTransformMatrix(), '" stroke-linecap="round" ',
          this.addPaintOrder(),
          '/>\n'
        );

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns number representation of an instance complexity
       * @return {Number} complexity of this instance
       */
      complexity: function() {
        return this.path.length;
      },

      /**
       * @private
       */
      _parsePath: function() {
        var result = [],
            coords = [],
            currentPath,
            parsed,
            re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
            match,
            coordsStr;

        for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
          currentPath = this.path[i];

          coordsStr = currentPath.slice(1).trim();
          coords.length = 0;

          while ((match = re.exec(coordsStr))) {
            coords.push(match[0]);
          }

          coordsParsed = [currentPath.charAt(0)];

          for (var j = 0, jlen = coords.length; j < jlen; j++) {
            parsed = parseFloat(coords[j]);
            if (!isNaN(parsed)) {
              coordsParsed.push(parsed);
            }
          }

          var command = coordsParsed[0],
              commandLength = commandLengths[command.toLowerCase()],
              repeatedCommand = repeatedCommands[command] || command;

          if (coordsParsed.length - 1 > commandLength) {
            for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
              result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
              command = repeatedCommand;
            }
          }
          else {
            result.push(coordsParsed);
          }
        }

        return result;
      },

      /**
       * @private
       */
      _parseDimensions: function() {

        var aX = [],
            aY = [],
            current, // current instruction
            previous = null,
            subpathStartX = 0,
            subpathStartY = 0,
            x = 0, // current x
            y = 0, // current y
            controlX = 0, // current control point x
            controlY = 0, // current control point y
            tempX,
            tempY,
            bounds;

        for (var i = 0, len = this.path.length; i < len; ++i) {

          current = this.path[i];

          switch (current[0]) { // first letter

            case 'l': // lineto, relative
              x += current[1];
              y += current[2];
              bounds = [];
              break;

            case 'L': // lineto, absolute
              x = current[1];
              y = current[2];
              bounds = [];
              break;

            case 'h': // horizontal lineto, relative
              x += current[1];
              bounds = [];
              break;

            case 'H': // horizontal lineto, absolute
              x = current[1];
              bounds = [];
              break;

            case 'v': // vertical lineto, relative
              y += current[1];
              bounds = [];
              break;

            case 'V': // verical lineto, absolute
              y = current[1];
              bounds = [];
              break;

            case 'm': // moveTo, relative
              x += current[1];
              y += current[2];
              subpathStartX = x;
              subpathStartY = y;
              bounds = [];
              break;

            case 'M': // moveTo, absolute
              x = current[1];
              y = current[2];
              subpathStartX = x;
              subpathStartY = y;
              bounds = [];
              break;

            case 'c': // bezierCurveTo, relative
              tempX = x + current[5];
              tempY = y + current[6];
              controlX = x + current[3];
              controlY = y + current[4];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                x + current[1], // x1
                y + current[2], // y1
                controlX, // x2
                controlY, // y2
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'C': // bezierCurveTo, absolute
              controlX = current[3];
              controlY = current[4];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                current[1],
                current[2],
                controlX,
                controlY,
                current[5],
                current[6]
              );
              x = current[5];
              y = current[6];
              break;

            case 's': // shorthand cubic bezierCurveTo, relative

              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];

              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                x + current[1],
                y + current[2],
                tempX,
                tempY
              );
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = x + current[1];
              controlY = y + current[2];
              x = tempX;
              y = tempY;
              break;

            case 'S': // shorthand cubic bezierCurveTo, absolute
              tempX = current[3];
              tempY = current[4];
              if (previous[0].match(/[CcSs]/) === null) {
                // If there is no previous command or if the previous command was not a C, c, S, or s,
                // the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control points
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                current[1],
                current[2],
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              // set control point to 2nd one of this command
              // "... the first control point is assumed to be
              // the reflection of the second control point on
              // the previous command relative to the current point."
              controlX = current[1];
              controlY = current[2];
              break;

            case 'q': // quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[3];
              tempY = y + current[4];
              controlX = x + current[1];
              controlY = y + current[2];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'Q': // quadraticCurveTo, absolute
              controlX = current[1];
              controlY = current[2];
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                current[3],
                current[4]
              );
              x = current[3];
              y = current[4];
              break;

            case 't': // shorthand quadraticCurveTo, relative
              // transform to absolute x,y
              tempX = x + current[1];
              tempY = y + current[2];
              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }

              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;

              break;

            case 'T':
              tempX = current[1];
              tempY = current[2];

              if (previous[0].match(/[QqTt]/) === null) {
                // If there is no previous command or if the previous command was not a Q, q, T or t,
                // assume the control point is coincident with the current point
                controlX = x;
                controlY = y;
              }
              else {
                // calculate reflection of previous control point
                controlX = 2 * x - controlX;
                controlY = 2 * y - controlY;
              }
              bounds = fabric.util.getBoundsOfCurve(x, y,
                controlX,
                controlY,
                controlX,
                controlY,
                tempX,
                tempY
              );
              x = tempX;
              y = tempY;
              break;

            case 'a':
              // TODO: optimize this
              bounds = fabric.util.getBoundsOfArc(x, y,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6] + x,
                current[7] + y
              );
              x += current[6];
              y += current[7];
              break;

            case 'A':
              // TODO: optimize this
              bounds = fabric.util.getBoundsOfArc(x, y,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6],
                current[7]
              );
              x = current[6];
              y = current[7];
              break;

            case 'z':
            case 'Z':
              x = subpathStartX;
              y = subpathStartY;
              break;
          }
          previous = current;
          bounds.forEach(function (point) {
            aX.push(point.x);
            aY.push(point.y);
          });
          aX.push(x);
          aY.push(y);
        }

        var minX = min(aX) || 0,
            minY = min(aY) || 0,
            maxX = max(aX) || 0,
            maxY = max(aY) || 0,
            deltaX = maxX - minX,
            deltaY = maxY - minY,

            o = {
              left: minX,
              top: minY,
              width: deltaX,
              height: deltaY
            };

        return o;
      }
    });

    /**
     * Creates an instance of fabric.Path from an object
     * @static
     * @memberOf fabric.Path
     * @param {Object} object
     * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
     */
    fabric.Path.fromObject = function(object, callback) {
      if (typeof object.sourcePath === 'string') {
        var pathUrl = object.sourcePath;
        fabric.loadSVGFromURL(pathUrl, function (elements) {
          var path = elements[0];
          path.setOptions(object);
          callback && callback(path);
        });
      }
      else {
        fabric.Object._fromObject('Path', object, callback, 'path');
      }
    };

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
     * @static
     * @memberOf fabric.Path
     * @see http://www.w3.org/TR/SVG/paths.html#PathElement
     */
    fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

    /**
     * Creates an instance of fabric.Path from an SVG <path> element
     * @static
     * @memberOf fabric.Path
     * @param {SVGElement} element to parse
     * @param {Function} callback Callback to invoke when an fabric.Path instance is created
     * @param {Object} [options] Options object
     * @param {Function} [callback] Options callback invoked after parsing is finished
     */
    fabric.Path.fromElement = function(element, callback, options) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
      callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
    };
    /* _FROM_SVG_END_ */

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        min = fabric.util.array.min,
        max = fabric.util.array.max;

    if (fabric.Group) {
      return;
    }

    /**
     * Group class
     * @class fabric.Group
     * @extends fabric.Object
     * @mixes fabric.Collection
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
     * @see {@link fabric.Group#initialize} for constructor definition
     */
    fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'group',

      /**
       * Width of stroke
       * @type Number
       * @default
       */
      strokeWidth: 0,

      /**
       * Indicates if click events should also check for subtargets
       * @type Boolean
       * @default
       */
      subTargetCheck: false,

      /**
       * Groups are container, do not render anything on theyr own, ence no cache properties
       * @type Array
       * @default
       */
      cacheProperties: [],

      /**
       * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
       * available setting this boolean to true.
       * @type Boolean
       * @since 2.0.0
       * @default
       */
      useSetOnGroup: false,

      /**
       * Constructor
       * @param {Object} objects Group objects
       * @param {Object} [options] Options object
       * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
       * @return {Object} thisArg
       */
      initialize: function(objects, options, isAlreadyGrouped) {
        options = options || {};
        this._objects = [];
        // if objects enclosed in a group have been grouped already,
        // we cannot change properties of objects.
        // Thus we need to set options to group without objects,
        isAlreadyGrouped && this.callSuper('initialize', options);
        this._objects = objects || [];
        for (var i = this._objects.length; i--; ) {
          this._objects[i].group = this;
        }

        if (options.originX) {
          this.originX = options.originX;
        }
        if (options.originY) {
          this.originY = options.originY;
        }

        if (!isAlreadyGrouped) {
          var center = options && options.centerPoint;
          // if coming from svg i do not want to calc bounds.
          // i assume width and height are passed along options
          center || this._calcBounds();
          this._updateObjectsCoords(center);
          delete options.centerPoint;
          this.callSuper('initialize', options);
        }
        else {
          this._updateObjectsACoords();
        }

        this.setCoords();
      },

      /**
       * @private
       * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
       */
      _updateObjectsACoords: function() {
        var ignoreZoom = true, skipAbsolute = true;
        for (var i = this._objects.length; i--; ){
          this._objects[i].setCoords(ignoreZoom, skipAbsolute);
        }
      },

      /**
       * @private
       * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
       */
      _updateObjectsCoords: function(center) {
        var center = center || this.getCenterPoint();
        for (var i = this._objects.length; i--; ){
          this._updateObjectCoords(this._objects[i], center);
        }
      },

      /**
       * @private
       * @param {Object} object
       * @param {fabric.Point} center, current center of group.
       */
      _updateObjectCoords: function(object, center) {
        var objectLeft = object.left,
            objectTop = object.top,
            ignoreZoom = true, skipAbsolute = true;

        object.set({
          left: objectLeft - center.x,
          top: objectTop - center.y
        });
        object.group = this;
        object.setCoords(ignoreZoom, skipAbsolute);
      },

      /**
       * Returns string represenation of a group
       * @return {String}
       */
      toString: function() {
        return '#<fabric.Group: (' + this.complexity() + ')>';
      },

      /**
       * Adds an object to a group; Then recalculates group's dimension, position.
       * @param {Object} object
       * @return {fabric.Group} thisArg
       * @chainable
       */
      addWithUpdate: function(object) {
        this._restoreObjectsState();
        fabric.util.resetObjectTransform(this);
        if (object) {
          this._objects.push(object);
          object.group = this;
          object._set('canvas', this.canvas);
        }
        this._calcBounds();
        this._updateObjectsCoords();
        this.setCoords();
        this.dirty = true;
        return this;
      },

      /**
       * Removes an object from a group; Then recalculates group's dimension, position.
       * @param {Object} object
       * @return {fabric.Group} thisArg
       * @chainable
       */
      removeWithUpdate: function(object) {
        this._restoreObjectsState();
        fabric.util.resetObjectTransform(this);

        this.remove(object);
        this._calcBounds();
        this._updateObjectsCoords();
        this.setCoords();
        this.dirty = true;
        return this;
      },

      /**
       * @private
       */
      _onObjectAdded: function(object) {
        this.dirty = true;
        object.group = this;
        object._set('canvas', this.canvas);
      },

      /**
       * @private
       */
      _onObjectRemoved: function(object) {
        this.dirty = true;
        delete object.group;
      },

      /**
       * @private
       */
      _set: function(key, value) {
        var i = this._objects.length;
        if (this.useSetOnGroup) {
          while (i--) {
            this._objects[i].setOnGroup(key, value);
          }
        }
        if (key === 'canvas') {
          i = this._objects.length;
          while (i--) {
            this._objects[i]._set(key, value);
          }
        }
        this.callSuper('_set', key, value);
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var objsToObject = this.getObjects().map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = obj.group.includeDefaultValues;
          var _obj = obj.toObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
        return extend(this.callSuper('toObject', propertiesToInclude), {
          objects: objsToObject
        });
      },

      /**
       * Returns object representation of an instance, in dataless mode.
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toDatalessObject: function(propertiesToInclude) {
        var objsToObject, sourcePath = this.sourcePath;
        if (sourcePath) {
          objsToObject = sourcePath;
        }
        else {
          objsToObject = this.getObjects().map(function(obj) {
            var originalDefaults = obj.includeDefaultValues;
            obj.includeDefaultValues = obj.group.includeDefaultValues;
            var _obj = obj.toDatalessObject(propertiesToInclude);
            obj.includeDefaultValues = originalDefaults;
            return _obj;
          });
        }
        return extend(this.callSuper('toDatalessObject', propertiesToInclude), {
          objects: objsToObject
        });
      },

      /**
       * Renders instance on a given context
       * @param {CanvasRenderingContext2D} ctx context to render instance on
       */
      render: function(ctx) {
        this._transformDone = true;
        this.callSuper('render', ctx);
        this._transformDone = false;
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        var ownCache = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
        this.ownCaching = ownCache;
        if (ownCache) {
          for (var i = 0, len = this._objects.length; i < len; i++) {
            if (this._objects[i].willDrawShadow()) {
              this.ownCaching = false;
              return false;
            }
          }
        }
        return ownCache;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * @return {Boolean}
       */
      willDrawShadow: function() {
        if (this.shadow) {
          return this.callSuper('willDrawShadow');
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            return true;
          }
        }
        return false;
      },

      /**
       * Check if this group or its parent group are caching, recursively up
       * @return {Boolean}
       */
      isOnACache: function() {
        return this.ownCaching || (this.group && this.group.isOnACache());
      },

      /**
       * Execute the drawing operation for an object on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      drawObject: function(ctx) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          this._objects[i].render(ctx);
        }
      },

      /**
       * Check if cache is dirty
       */
      isCacheDirty: function() {
        if (this.callSuper('isCacheDirty')) {
          return true;
        }
        if (!this.statefullCache) {
          return false;
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].isCacheDirty(true)) {
            if (this._cacheCanvas) {
              // if this group has not a cache canvas there is nothing to clean
              var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
            }
            return true;
          }
        }
        return false;
      },

      /**
       * Retores original state of each of group objects (original state is that which was before group was created).
       * @private
       * @return {fabric.Group} thisArg
       * @chainable
       */
      _restoreObjectsState: function() {
        this._objects.forEach(this._restoreObjectState, this);
        return this;
      },

      /**
       * Realises the transform from this group onto the supplied object
       * i.e. it tells you what would happen if the supplied object was in
       * the group, and then the group was destroyed. It mutates the supplied
       * object.
       * @param {fabric.Object} object
       * @return {fabric.Object} transformedObject
       */
      realizeTransform: function(object) {
        var matrix = object.calcTransformMatrix(),
            options = fabric.util.qrDecompose(matrix),
            center = new fabric.Point(options.translateX, options.translateY);
        object.flipX = false;
        object.flipY = false;
        object.set('scaleX', options.scaleX);
        object.set('scaleY', options.scaleY);
        object.skewX = options.skewX;
        object.skewY = options.skewY;
        object.angle = options.angle;
        object.setPositionByOrigin(center, 'center', 'center');
        return object;
      },

      /**
       * Restores original state of a specified object in group
       * @private
       * @param {fabric.Object} object
       * @return {fabric.Group} thisArg
       */
      _restoreObjectState: function(object) {
        this.realizeTransform(object);
        object.setCoords();
        delete object.group;
        return this;
      },

      /**
       * Destroys a group (restoring state of its objects)
       * @return {fabric.Group} thisArg
       * @chainable
       */
      destroy: function() {
        // when group is destroyed objects needs to get a repaint to be eventually
        // displayed on canvas.
        this._objects.forEach(function(object) {
          object.set('dirty', true);
        });
        return this._restoreObjectsState();
      },

      /**
       * make a group an active selection, remove the group from canvas
       * the group has to be on canvas for this to work.
       * @return {fabric.ActiveSelection} thisArg
       * @chainable
       */
      toActiveSelection: function() {
        if (!this.canvas) {
          return;
        }
        var objects = this._objects, canvas = this.canvas;
        this._objects = [];
        var options = this.toObject();
        delete options.objects;
        var activeSelection = new fabric.ActiveSelection([]);
        activeSelection.set(options);
        activeSelection.type = 'activeSelection';
        canvas.remove(this);
        objects.forEach(function(object) {
          object.group = activeSelection;
          object.dirty = true;
          canvas.add(object);
        });
        activeSelection.canvas = canvas;
        activeSelection._objects = objects;
        canvas._activeObject = activeSelection;
        activeSelection.setCoords();
        return activeSelection;
      },

      /**
       * Destroys a group (restoring state of its objects)
       * @return {fabric.Group} thisArg
       * @chainable
       */
      ungroupOnCanvas: function() {
        return this._restoreObjectsState();
      },

      /**
       * Sets coordinates of all objects inside group
       * @return {fabric.Group} thisArg
       * @chainable
       */
      setObjectsCoords: function() {
        var ignoreZoom = true, skipAbsolute = true;
        this.forEachObject(function(object) {
          object.setCoords(ignoreZoom, skipAbsolute);
        });
        return this;
      },

      /**
       * @private
       */
      _calcBounds: function(onlyWidthHeight) {
        var aX = [],
            aY = [],
            o, prop,
            props = ['tr', 'br', 'bl', 'tl'],
            i = 0, iLen = this._objects.length,
            j, jLen = props.length,
            ignoreZoom = true;

        for ( ; i < iLen; ++i) {
          o = this._objects[i];
          o.setCoords(ignoreZoom);
          for (j = 0; j < jLen; j++) {
            prop = props[j];
            aX.push(o.oCoords[prop].x);
            aY.push(o.oCoords[prop].y);
          }
        }

        this.set(this._getBounds(aX, aY, onlyWidthHeight));
      },

      /**
       * @private
       */
      _getBounds: function(aX, aY, onlyWidthHeight) {
        var minXY = new fabric.Point(min(aX), min(aY)),
            maxXY = new fabric.Point(max(aX), max(aY)),
            obj = {
              width: (maxXY.x - minXY.x) || 0,
              height: (maxXY.y - minXY.y) || 0
            };

        if (!onlyWidthHeight) {
          obj.left = minXY.x || 0;
          obj.top = minXY.y || 0;
          if (this.originX === 'center') {
            obj.left += obj.width / 2;
          }
          if (this.originX === 'right') {
            obj.left += obj.width;
          }
          if (this.originY === 'center') {
            obj.top += obj.height / 2;
          }
          if (this.originY === 'bottom') {
            obj.top += obj.height;
          }
        }
        return obj;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns svg representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup();
        markup.push(
          '<g ', this.getSvgId(), 'transform="',
          /* avoiding styles intentionally */
          this.getSvgTransform(),
          this.getSvgTransformMatrix(),
          '" style="',
          this.getSvgFilter(),
          '">\n'
        );

        for (var i = 0, len = this._objects.length; i < len; i++) {
          markup.push('\t', this._objects[i].toSVG(reviver));
        }

        markup.push('</g>\n');

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */
    });

    /**
     * Returns {@link fabric.Group} instance from an object representation
     * @static
     * @memberOf fabric.Group
     * @param {Object} object Object to create a group from
     * @param {Function} [callback] Callback to invoke when an group instance is created
     */
    fabric.Group.fromObject = function(object, callback) {
      fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
        var options = fabric.util.object.clone(object, true);
        delete options.objects;
        callback && callback(new fabric.Group(enlivenedObjects, options, true));
      });
    };

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { });

    if (fabric.ActiveSelection) {
      return;
    }

    /**
     * Group class
     * @class fabric.ActiveSelection
     * @extends fabric.Group
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
     * @see {@link fabric.ActiveSelection#initialize} for constructor definition
     */
    fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'activeSelection',

      /**
       * Constructor
       * @param {Object} objects ActiveSelection objects
       * @param {Object} [options] Options object
       * @return {Object} thisArg
       */
      initialize: function(objects, options) {
        options = options || {};
        this._objects = objects || [];
        for (var i = this._objects.length; i--; ) {
          this._objects[i].group = this;
        }

        if (options.originX) {
          this.originX = options.originX;
        }
        if (options.originY) {
          this.originY = options.originY;
        }
        this._calcBounds();
        this._updateObjectsCoords();
        fabric.Object.prototype.initialize.call(this, options);
        this.setCoords();
      },

      /**
       * Change te activeSelection to a normal group,
       * High level function that automatically adds it to canvas as
       * active object. no events fired.
       * @since 2.0.0
       * @return {fabric.Group}
       */
      toGroup: function() {
        var objects = this._objects;
        this._objects = [];
        var options = this.toObject();
        var newGroup = new fabric.Group([]);
        delete options.objects;
        newGroup.set(options);
        newGroup.type = 'group';
        objects.forEach(function(object) {
          object.group = newGroup;
          object.canvas.remove(object);
        });
        newGroup._objects = objects;
        if (!this.canvas) {
          return newGroup;
        }
        var canvas = this.canvas;
        canvas.add(newGroup);
        canvas._activeObject = newGroup;
        newGroup.setCoords();
        return newGroup;
      },

      /**
       * If returns true, deselection is cancelled.
       * @since 2.0.0
       * @return {Boolean} [cancel]
       */
      onDeselect: function() {
        this.destroy();
        return false;
      },

      /**
       * Returns string representation of a group
       * @return {String}
       */
      toString: function() {
        return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
      },

      /**
       * @private
       */
      _set: function(key, value) {
        var i = this._objects.length;
        if (key === 'canvas') {
          while (i--) {
            this._objects[i].set(key, value);
          }
        }
        if (this.useSetOnGroup) {
          while (i--) {
            this._objects[i].setOnGroup(key, value);
          }
        }
        fabric.Object.prototype._set.call(this, key, value);
      },

      /**
       * Decide if the object should cache or not. Create its own cache level
       * objectCaching is a global flag, wins over everything
       * needsItsOwnCache should be used when the object drawing method requires
       * a cache step. None of the fabric classes requires it.
       * Generally you do not cache objects in groups because the group outside is cached.
       * @return {Boolean}
       */
      shouldCache: function() {
        return false;
      },

      /**
       * Check if this object or a child object will cast a shadow
       * @return {Boolean}
       */
      willDrawShadow: function() {
        if (this.shadow) {
          return this.callSuper('willDrawShadow');
        }
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            return true;
          }
        }
        return false;
      },

      /**
       * Check if this group or its parent group are caching, recursively up
       * @return {Boolean}
       */
      isOnACache: function() {
        return false;
      },

      /**
       * Renders controls and borders for the object
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [styleOverride] properties to override the object style
       * @param {Object} [childrenOverride] properties to override the children overrides
       */
      _renderControls: function(ctx, styleOverride, childrenOverride) {
        ctx.save();
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
        this.callSuper('_renderControls', ctx, styleOverride);
        childrenOverride = childrenOverride || { };
        if (typeof childrenOverride.hasControls === 'undefined') {
          childrenOverride.hasControls = false;
        }
        if (typeof childrenOverride.hasRotatingPoint === 'undefined') {
          childrenOverride.hasRotatingPoint = false;
        }
        childrenOverride.forActiveSelection = true;
        for (var i = 0, len = this._objects.length; i < len; i++) {
          this._objects[i]._renderControls(ctx, childrenOverride);
        }
        ctx.restore();
      },
    });

    /**
     * Returns {@link fabric.ActiveSelection} instance from an object representation
     * @static
     * @memberOf fabric.ActiveSelection
     * @param {Object} object Object to create a group from
     * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
     */
    fabric.ActiveSelection.fromObject = function(object, callback) {
      fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
        delete object.objects;
        callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
      });
    };

  })(exports);


  (function(global) {

    var extend = fabric.util.object.extend;

    if (!global.fabric) {
      global.fabric = { };
    }

    if (global.fabric.Image) {
      fabric.warn('fabric.Image is already defined.');
      return;
    }

    /**
     * Image class
     * @class fabric.Image
     * @extends fabric.Object
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
     * @see {@link fabric.Image#initialize} for constructor definition
     */
    fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'image',

      /**
       * crossOrigin value (one of "", "anonymous", "use-credentials")
       * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
       * @type String
       * @default
       */
      crossOrigin: '',

      /**
       * Width of a stroke.
       * For image quality a stroke multiple of 2 gives better results.
       * @type Number
       * @default
       */
      strokeWidth: 0,

      /**
       * private
       * contains last value of scaleX to detect
       * if the Image got resized after the last Render
       * @type Number
       */
      _lastScaleX: 1,

      /**
       * private
       * contains last value of scaleY to detect
       * if the Image got resized after the last Render
       * @type Number
       */
      _lastScaleY: 1,

      /**
       * private
       * contains last value of scaling applied by the apply filter chain
       * @type Number
       */
      _filterScalingX: 1,

      /**
       * private
       * contains last value of scaling applied by the apply filter chain
       * @type Number
       */
      _filterScalingY: 1,

      /**
       * minimum scale factor under which any resizeFilter is triggered to resize the image
       * 0 will disable the automatic resize. 1 will trigger automatically always.
       * number bigger than 1 are not implemented yet.
       * @type Number
       */
      minimumScaleTrigger: 0.5,

      /**
       * List of properties to consider when checking if
       * state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

      /**
       * When `true`, object is cached on an additional canvas.
       * default to false for images
       * since 1.7.0
       * @type Boolean
       * @default
       */
      objectCaching: false,

      /**
       * key used to retrieve the texture representing this image
       * since 2.0.0
       * @type String
       * @default
       */
      cacheKey: '',

      /**
       * Image crop in pixels from original image size.
       * since 2.0.0
       * @type Number
       * @default
       */
      cropX: 0,

      /**
       * Image crop in pixels from original image size.
       * since 2.0.0
       * @type Number
       * @default
       */
      cropY: 0,

      /**
       * Constructor
       * @param {HTMLImageElement | String} element Image element
       * @param {Object} [options] Options object
       * @param {function} [callback] callback function to call after eventual filters applied.
       * @return {fabric.Image} thisArg
       */
      initialize: function(element, options) {
        options || (options = { });
        this.filters = [];
        this.cacheKey = 'texture' + fabric.Object.__uid++;
        this.callSuper('initialize', options);
        this._initElement(element, options);
      },

      /**
       * Returns image element which this instance if based on
       * @return {HTMLImageElement} Image element
       */
      getElement: function() {
        return this._element;
      },

      /**
       * Sets image element for this instance to a specified one.
       * If filters defined they are applied to new image.
       * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
       * @param {HTMLImageElement} element
       * @param {Object} [options] Options object
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setElement: function(element, options) {
        var backend = fabric.filterBackend;
        if (backend && backend.evictCachesForKey) {
          backend.evictCachesForKey(this.cacheKey);
          backend.evictCachesForKey(this.cacheKey + '_filtered');
        }
        this._element = element;
        this._originalElement = element;
        this._initConfig(options);
        if (this.resizeFilter) {
          this.applyResizeFilters();
        }
        if (this.filters.length !== 0) {
          this.applyFilters();
        }
        return this;
      },

      /**
       * Delete cacheKey if we have a webGlBackend
       * delete reference to image elements
       */
      dispose: function() {
        var backend = fabric.filterBackend;
        if (backend && backend.evictCachesForKey) {
          backend.evictCachesForKey(this.cacheKey);
          backend.evictCachesForKey(this.cacheKey + '_filtered');
        }
        this._originalElement = undefined;
        this._element = undefined;
        this._filteredEl = undefined;
      },

      /**
       * Sets crossOrigin value (on an instance and corresponding image element)
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
        this._element.crossOrigin = value;

        return this;
      },

      /**
       * Returns original size of an image
       * @return {Object} Object with "width" and "height" properties
       */
      getOriginalSize: function() {
        var element = this.getElement();
        return {
          width: element.width,
          height: element.height
        };
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _stroke: function(ctx) {
        if (!this.stroke || this.strokeWidth === 0) {
          return;
        }
        var w = this.width / 2, h = this.height / 2;
        ctx.beginPath();
        ctx.moveTo(-w, -h);
        ctx.lineTo(w, -h);
        ctx.lineTo(w, h);
        ctx.lineTo(-w, h);
        ctx.lineTo(-w, -h);
        ctx.closePath();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderDashedStroke: function(ctx) {
        var x = -this.width / 2,
            y = -this.height / 2,
            w = this.width,
            h = this.height;

        ctx.save();
        this._setStrokeStyles(ctx, this);

        ctx.beginPath();
        fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
        fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
        ctx.closePath();
        ctx.restore();
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var filters = [];

        this.filters.forEach(function(filterObj) {
          if (filterObj) {
            filters.push(filterObj.toObject());
          }
        });
        var object = extend(
          this.callSuper(
            'toObject',
            ['crossOrigin', 'cropX', 'cropY'].concat(propertiesToInclude)
          ), {
            src: this.getSrc(),
            filters: filters,
          });
        if (this.resizeFilter) {
          object.resizeFilter = this.resizeFilter.toObject();
        }
        return object;
      },

      /**
       * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,hight.
       * @return {Boolean}
       */
      hasCrop: function() {
        return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
      },

      /* _TO_SVG_START_ */
      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2, clipPath = '';
        if (this.hasCrop()) {
          var clipPathId = fabric.Object.__uid++;
          markup.push(
            '<clipPath id="imageCrop_' + clipPathId + '">\n',
            '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
            '</clipPath>\n'
          );
          clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
        }
        markup.push('<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n');
        var imageMarkup = ['\t<image ', this.getSvgId(), 'xlink:href="', this.getSvgSrc(true),
          '" x="', x - this.cropX, '" y="', y - this.cropY,
          '" style="', this.getSvgStyles(),
          // we're essentially moving origin of transformation from top/left corner to the center of the shape
          // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
          // so that object's center aligns with container's left/top
          '" width="', this._element.width || this._element.naturalWidth,
          '" height="', this._element.height || this._element.height,
          '"', clipPath,
          '></image>\n'];
        if (this.paintFirst === 'fill') {
          Array.prototype.push.apply(markup, imageMarkup);
        }
        if (this.stroke || this.strokeDashArray) {
          var origFill = this.fill;
          this.fill = null;
          markup.push(
            '\t<rect ',
            'x="', x, '" y="', y,
            '" width="', this.width, '" height="', this.height,
            '" style="', this.getSvgStyles(),
            '"/>\n'
          );
          this.fill = origFill;
        }
        if (this.paintFirst !== 'fill') {
          Array.prototype.push.apply(markup, imageMarkup);
        }
        markup.push('</g>\n');

        return reviver ? reviver(markup.join('')) : markup.join('');
      },
      /* _TO_SVG_END_ */

      /**
       * Returns source of an image
       * @param {Boolean} filtered indicates if the src is needed for svg
       * @return {String} Source of an image
       */
      getSrc: function(filtered) {
        var element = filtered ? this._element : this._originalElement;
        if (element) {
          if (element.toDataURL) {
            return element.toDataURL();
          }
          return element.src;
        }
        else {
          return this.src || '';
        }
      },

      /**
       * Sets source of an image
       * @param {String} src Source string (URL)
       * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
       * @param {Object} [options] Options object
       * @return {fabric.Image} thisArg
       * @chainable
       */
      setSrc: function(src, callback, options) {
        fabric.util.loadImage(src, function(img) {
          this.setElement(img, options);
          this._setWidthHeight();
          callback(this);
        }, this, options && options.crossOrigin);
        return this;
      },

      /**
       * Returns string representation of an instance
       * @return {String} String representation of an instance
       */
      toString: function() {
        return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
      },

      applyResizeFilters: function() {
        var filter = this.resizeFilter,
            retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : 1,
            minimumScale = this.minimumScaleTrigger,
            scaleX = this.scaleX * retinaScaling,
            scaleY = this.scaleY * retinaScaling,
            elementToFilter = this._filteredEl || this._originalElement;
        if (this.group) {
          this.set('dirty', true);
        }
        if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
          this._element = elementToFilter;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          return;
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        var canvasEl = fabric.util.createCanvasElement(),
            cacheKey = this._filteredEl ? this.cacheKey : (this.cacheKey + '_filtered'),
            sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        filter.scaleX = scaleX;
        filter.scaleY = scaleY;
        fabric.filterBackend.applyFilters(
          [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
        this._filterScalingX = canvasEl.width / this._originalElement.width;
        this._filterScalingY = canvasEl.height / this._originalElement.height;
      },

      /**
       * Applies filters assigned to this image (from "filters" array) or from filter param
       * @method applyFilters
       * @param {Array} filters to be applied
       * @param {Boolean} forResizing specify if the filter operation is a resize operation
       * @return {thisArg} return the fabric.Image object
       * @chainable
       */
      applyFilters: function(filters) {

        filters = filters || this.filters || [];
        filters = filters.filter(function(filter) { return filter; });
        if (this.group) {
          this.set('dirty', true);
        }
        if (filters.length === 0) {
          this._element = this._originalElement;
          this._filteredEl = null;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          return this;
        }

        var imgElement = this._originalElement,
            sourceWidth = imgElement.naturalWidth || imgElement.width,
            sourceHeight = imgElement.naturalHeight || imgElement.height;

        if (this._element === this._originalElement) {
          // if the element is the same we need to create a new element
          var canvasEl = fabric.util.createCanvasElement();
          canvasEl.width = sourceWidth;
          canvasEl.height = sourceHeight;
          this._element = canvasEl;
          this._filteredEl = canvasEl;
        }
        else {
          // clear the existing element to get new filter data
          this._element.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        fabric.filterBackend.applyFilters(
          filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
        if (this._originalElement.width !== this._element.width ||
          this._originalElement.height !== this._element.height) {
          this._filterScalingX = this._element.width / this._originalElement.width;
          this._filterScalingY = this._element.height / this._originalElement.height;
        }
        return this;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        if (this.isMoving === false && this.resizeFilter && this._needsResize()) {
          this._lastScaleX = this.scaleX;
          this._lastScaleY = this.scaleY;
          this.applyResizeFilters();
        }
        this._stroke(ctx);
        this._renderPaintInOrder(ctx);
      },

      _renderFill: function(ctx) {
        var w = this.width, h = this.height, sW = w * this._filterScalingX, sH = h * this._filterScalingY,
            x = -w / 2, y = -h / 2, elementToDraw = this._element;
        elementToDraw && ctx.drawImage(elementToDraw,
          this.cropX * this._filterScalingX,
          this.cropY * this._filterScalingY,
          sW,
          sH,
          x, y, w, h);
      },

      /**
       * @private, needed to check if image needs resize
       */
      _needsResize: function() {
        return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);
      },

      /**
       * @private
       */
      _resetWidthHeight: function() {
        var element = this.getElement();

        this.set('width', element.width);
        this.set('height', element.height);
      },

      /**
       * The Image class's initialization method. This method is automatically
       * called by the constructor.
       * @private
       * @param {HTMLImageElement|String} element The element representing the image
       * @param {Object} [options] Options object
       */
      _initElement: function(element, options) {
        this.setElement(fabric.util.getById(element), options);
        fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
      },

      /**
       * @private
       * @param {Object} [options] Options object
       */
      _initConfig: function(options) {
        options || (options = { });
        this.setOptions(options);
        this._setWidthHeight(options);
        if (this._element && this.crossOrigin) {
          this._element.crossOrigin = this.crossOrigin;
        }
      },

      /**
       * @private
       * @param {Array} filters to be initialized
       * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
       */
      _initFilters: function(filters, callback) {
        if (filters && filters.length) {
          fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
            callback && callback(enlivenedObjects);
          }, 'fabric.Image.filters');
        }
        else {
          callback && callback();
        }
      },

      /**
       * @private
       * @param {Object} [options] Object with width/height properties
       */
      _setWidthHeight: function(options) {
        this.width = options && ('width' in options)
          ? options.width
          : (this.getElement()
            ? this.getElement().width || 0
            : 0);

        this.height = options && ('height' in options)
          ? options.height
          : (this.getElement()
            ? this.getElement().height || 0
            : 0);
      },

      /**
       * Calculate offset for center and scale factor for the image in order to respect
       * the preserveAspectRatio attribute
       * @private
       * @return {Object}
       */
      parsePreserveAspectRatioAttribute: function() {
        var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
            rWidth = this._element.width, rHeight = this._element.height,
            scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
            offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
        if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
          if (pAR.meetOrSlice === 'meet') {
            scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
            offset = (pWidth - rWidth * scaleX) / 2;
            if (pAR.alignX === 'Min') {
              offsetLeft = -offset;
            }
            if (pAR.alignX === 'Max') {
              offsetLeft = offset;
            }
            offset = (pHeight - rHeight * scaleY) / 2;
            if (pAR.alignY === 'Min') {
              offsetTop = -offset;
            }
            if (pAR.alignY === 'Max') {
              offsetTop = offset;
            }
          }
          if (pAR.meetOrSlice === 'slice') {
            scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
            offset = rWidth - pWidth / scaleX;
            if (pAR.alignX === 'Mid') {
              cropX = offset / 2;
            }
            if (pAR.alignX === 'Max') {
              cropX = offset;
            }
            offset = rHeight - pHeight / scaleY;
            if (pAR.alignY === 'Mid') {
              cropY = offset / 2;
            }
            if (pAR.alignY === 'Max') {
              cropY = offset;
            }
            rWidth = pWidth / scaleX;
            rHeight = pHeight / scaleY;
          }
        }
        else {
          scaleX = pWidth / rWidth;
          scaleY = pHeight / rHeight;
        }
        return {
          width: rWidth,
          height: rHeight,
          scaleX: scaleX,
          scaleY: scaleY,
          offsetLeft: offsetLeft,
          offsetTop: offsetTop,
          cropX: cropX,
          cropY: cropY
        };
      }
    });

    /**
     * Default CSS class name for canvas
     * @static
     * @type String
     * @default
     */
    fabric.Image.CSS_CANVAS = 'canvas-img';

    /**
     * Alias for getSrc
     * @static
     */
    fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

    /**
     * Creates an instance of fabric.Image from its object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} callback Callback to invoke when an image instance is created
     */
    fabric.Image.fromObject = function(_object, callback) {
      var object = fabric.util.object.clone(_object);
      fabric.util.loadImage(object.src, function(img, error) {
        if (error) {
          callback && callback(null, error);
          return;
        }
        fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
          object.filters = filters || [];
          fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
            object.resizeFilter = resizeFilters[0];
            var image = new fabric.Image(img, object);
            callback(image);
          });
        });
      }, null, object.crossOrigin);
    };

    /**
     * Creates an instance of fabric.Image from an URL string
     * @static
     * @param {String} url URL to create an image from
     * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
     * @param {Object} [imgOptions] Options object
     */
    fabric.Image.fromURL = function(url, callback, imgOptions) {
      fabric.util.loadImage(url, function(img) {
        callback && callback(new fabric.Image(img, imgOptions));
      }, null, imgOptions && imgOptions.crossOrigin);
    };

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
     * @static
     * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
     */
    fabric.Image.ATTRIBUTE_NAMES =
      fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin'.split(' '));

    /**
     * Returns {@link fabric.Image} instance from an SVG element
     * @static
     * @param {SVGElement} element Element to parse
     * @param {Object} [options] Options object
     * @param {Function} callback Callback to execute when fabric.Image object is created
     * @return {fabric.Image} Instance of fabric.Image
     */
    fabric.Image.fromElement = function(element, callback, options) {
      var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
      fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
        extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    };
    /* _FROM_SVG_END_ */

  })(exports);


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * @private
     * @return {Number} angle value
     */
    _getAngleValueForStraighten: function() {
      var angle = this.angle % 360;
      if (angle > 0) {
        return Math.round((angle - 1) / 90) * 90;
      }
      return Math.round(angle / 90) * 90;
    },

    /**
     * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    straighten: function() {
      this.rotate(this._getAngleValueForStraighten());
      return this;
    },

    /**
     * Same as {@link fabric.Object.prototype.straighten} but with animation
     * @param {Object} callbacks Object with callback functions
     * @param {Function} [callbacks.onComplete] Invoked on completion
     * @param {Function} [callbacks.onChange] Invoked on every step of animation
     * @return {fabric.Object} thisArg
     * @chainable
     */
    fxStraighten: function(callbacks) {
      callbacks = callbacks || { };

      var empty = function() { },
          onComplete = callbacks.onComplete || empty,
          onChange = callbacks.onChange || empty,
          _this = this;

      fabric.util.animate({
        startValue: this.get('angle'),
        endValue: this._getAngleValueForStraighten(),
        duration: this.FX_DURATION,
        onChange: function(value) {
          _this.rotate(value);
          onChange();
        },
        onComplete: function() {
          _this.setCoords();
          onComplete();
        },
      });

      return this;
    }
  });

  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Straightens object, then rerenders canvas
     * @param {fabric.Object} object Object to straighten
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    straightenObject: function (object) {
      object.straighten();
      this.requestRenderAll();
      return this;
    },

    /**
     * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
     * @param {fabric.Object} object Object to straighten
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    fxStraightenObject: function (object) {
      object.fxStraighten({
        onChange: this.requestRenderAllBound
      });
      return this;
    }
  });


  (function() {

    /**
     * Tests if webgl supports certain precision
     * @param {WebGL} Canvas WebGL context to test on
     * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
     * @returns {Boolean} Whether the user's browser WebGL supports given precision.
     */
    function testPrecision(gl, precision){
      var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        return false;
      }
      return true;
    }

    /**
     * Indicate whether this filtering backend is supported by the user's browser.
     * @param {Number} tileSize check if the tileSize is supported
     * @returns {Boolean} Whether the user's browser supports WebGL.
     */
    fabric.isWebglSupported = function(tileSize) {
      if (fabric.isLikelyNode) {
        return false;
      }
      tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
      var canvas = document.createElement('canvas');
      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      var isSupported = false;
      // eslint-disable-next-line
      if (gl) {
        fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        isSupported = fabric.maxTextureSize >= tileSize;
        var precisions = ['highp', 'mediump', 'lowp'];
        for (var i = 0; i < 3; i++){
          if (testPrecision(gl, precisions[i])){
            fabric.webGlPrecision = precisions[i];
            break;
          }      }
      }
      this.isSupported = isSupported;
      return isSupported;
    };

    fabric.WebglFilterBackend = WebglFilterBackend;

    /**
     * WebGL filter backend.
     */
    function WebglFilterBackend(options) {
      if (options && options.tileSize) {
        this.tileSize = options.tileSize;
      }
      this.setupGLContext(this.tileSize, this.tileSize);
      this.captureGPUInfo();
    }
    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

      tileSize: 2048,

      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you problably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {

      },

      /**
       * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
       */
      setupGLContext: function(width, height) {
        this.dispose();
        this.createWebGLCanvas(width, height);
        // eslint-disable-next-line
        this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
        this.chooseFastestCopyGLTo2DMethod(width, height);
      },

      /**
       * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
       * putImageData is faster than drawImage for that specific operation.
       */
      chooseFastestCopyGLTo2DMethod: function(width, height) {
        var canMeasurePerf = typeof window.performance !== 'undefined';
        var canUseImageData;
        try {
          new ImageData(1, 1);
          canUseImageData = true;
        }
        catch (e) {
          canUseImageData = false;
        }
        // eslint-disable-next-line no-undef
        var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
        // eslint-disable-next-line no-undef
        var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

        if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
          return;
        }

        var targetCanvas = fabric.util.createCanvasElement();
        // eslint-disable-next-line no-undef
        var imageBuffer = new ArrayBuffer(width * height * 4);
        var testContext = {
          imageBuffer: imageBuffer,
          destinationWidth: width,
          destinationHeight: height,
          targetCanvas: targetCanvas
        };
        var startTime, drawImageTime, putImageDataTime;
        targetCanvas.width = width;
        targetCanvas.height = height;

        startTime = window.performance.now();
        copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
        drawImageTime = window.performance.now() - startTime;

        startTime = window.performance.now();
        copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
        putImageDataTime = window.performance.now() - startTime;

        if (drawImageTime > putImageDataTime) {
          this.imageBuffer = imageBuffer;
          this.copyGLTo2D = copyGLTo2DPutImageData;
        }
        else {
          this.copyGLTo2D = copyGLTo2DDrawImage;
        }
      },

      /**
       * Create a canvas element and associated WebGL context and attaches them as
       * class properties to the GLFilterBackend class.
       */
      createWebGLCanvas: function(width, height) {
        var canvas = fabric.util.createCanvasElement();
        canvas.width = width;
        canvas.height = height;
        var glOptions = {
              alpha: true,
              premultipliedAlpha: false,
              depth: false,
              stencil: false,
              antialias: false
            },
            gl = canvas.getContext('webgl', glOptions);
        if (!gl) {
          gl = canvas.getContext('experimental-webgl', glOptions);
        }
        if (!gl) {
          return;
        }
        gl.clearColor(0, 0, 0, 0);
        // this canvas can fire webglcontextlost and webglcontextrestored
        this.canvas = canvas;
        this.gl = gl;
      },

      /**
       * Attempts to apply the requested filters to the source provided, drawing the filtered output
       * to the provided target canvas.
       *
       * @param {Array} filters The filters to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
       * @param {Number} width The width of the source input.
       * @param {Number} height The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
       * omitted, caching will be skipped.
       */
      applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
        var gl = this.gl;
        var cachedTexture;
        if (cacheKey) {
          cachedTexture = this.getCachedTexture(cacheKey, source);
        }
        var pipelineState = {
          originalWidth: source.width || source.originalWidth,
          originalHeight: source.height || source.originalHeight,
          sourceWidth: width,
          sourceHeight: height,
          destinationWidth: width,
          destinationHeight: height,
          context: gl,
          sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
          targetTexture: this.createTexture(gl, width, height),
          originalTexture: cachedTexture ||
            this.createTexture(gl, width, height, !cachedTexture && source),
          passes: filters.length,
          webgl: true,
          aPosition: this.aPosition,
          programCache: this.programCache,
          pass: 0,
          filterBackend: this,
          targetCanvas: targetCanvas
        };
        var tempFbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
        filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
        resizeCanvasIfNeeded(pipelineState);
        this.copyGLTo2D(gl, pipelineState);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.deleteTexture(pipelineState.sourceTexture);
        gl.deleteTexture(pipelineState.targetTexture);
        gl.deleteFramebuffer(tempFbo);
        targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
        return pipelineState;
      },

      /**
       * The same as the applyFilter method but with additional logging of WebGL
       * errors.
       */
      applyFiltersDebug: function(filters, source, width, height, targetCanvas, cacheKey) {
        // The following code is useful when debugging a specific issue but adds ~10x slowdown.
        var gl = this.gl;
        var ret = this.applyFilters(filters, source, width, height, targetCanvas, cacheKey);
        var glError = gl.getError();
        if (glError !== gl.NO_ERROR) {
          var errorString = this.glErrorToString(gl, glError);
          var error = new Error('WebGL Error ' + errorString);
          error.glErrorCode = glError;
          throw error;
        }
        return ret;
      },

      glErrorToString: function(context, errorCode) {
        if (!context) {
          return 'Context undefined for error code: ' + errorCode;
        }
        else if (typeof errorCode !== 'number') {
          return 'Error code is not a number';
        }
        switch (errorCode) {
          case context.NO_ERROR:
            return 'NO_ERROR';
          case context.INVALID_ENUM:
            return 'INVALID_ENUM';
          case context.INVALID_VALUE:
            return 'INVALID_VALUE';
          case context.INVALID_OPERATION:
            return 'INVALID_OPERATION';
          case context.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
          case context.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
          case context.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
          default:
            return 'UNKNOWN_ERROR';
        }
      },

      /**
       * Detach event listeners, remove references, and clean up caches.
       */
      dispose: function() {
        if (this.canvas) {
          this.canvas = null;
          this.gl = null;
        }
        this.clearWebGLCaches();
      },

      /**
       * Wipe out WebGL-related caches.
       */
      clearWebGLCaches: function() {
        this.programCache = {};
        this.textureCache = {};
      },

      /**
       * Create a WebGL texture object.
       *
       * Accepts specific dimensions to initialize the textuer to or a source image.
       *
       * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
       * @param {Number} width The width to initialize the texture at.
       * @param {Number} height The height to initialize the texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
       * @returns {WebGLTexture}
       */
      createTexture: function(gl, width, height, textureImageSource) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (textureImageSource) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
        }
        else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        return texture;
      },

      /**
       * Can be optionally used to get a texture from the cache array
       *
       * If an existing texture is not found, a new texture is created and cached.
       *
       * @param {String} uniqueId A cache key to use to find an existing texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
       * texture cache entry if one does not already exist.
       */
      getCachedTexture: function(uniqueId, textureImageSource) {
        if (this.textureCache[uniqueId]) {
          return this.textureCache[uniqueId];
        }
        else {
          var texture = this.createTexture(
            this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
          this.textureCache[uniqueId] = texture;
          return texture;
        }
      },

      /**
       * Clear out cached resources related to a source image that has been
       * filtered previously.
       *
       * @param {String} cacheKey The cache key provided when the source image was filtered.
       */
      evictCachesForKey: function(cacheKey) {
        if (this.textureCache[cacheKey]) {
          this.gl.deleteTexture(this.textureCache[cacheKey]);
          delete this.textureCache[cacheKey];
        }
      },

      copyGLTo2D: copyGLTo2DDrawImage,

      /**
       * Attempt to extract GPU information strings from a WebGL context.
       *
       * Useful information when debugging or blacklisting specific GPUs.
       *
       * @returns {Object} A GPU info object with renderer and vendor strings.
       */
      captureGPUInfo: function() {
        if (this.gpuInfo) {
          return this.gpuInfo;
        }
        var gl = this.gl;
        var ext = gl.getExtension('WEBGL_debug_renderer_info');
        var gpuInfo = { renderer: '', vendor: '' };
        if (ext) {
          var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
          var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
          if (renderer) {
            gpuInfo.renderer = renderer.toLowerCase();
          }
          if (vendor) {
            gpuInfo.vendor = vendor.toLowerCase();
          }
        }
        this.gpuInfo = gpuInfo;
        return gpuInfo;
      },
    };
  })();

  function resizeCanvasIfNeeded(pipelineState) {
    var targetCanvas = pipelineState.targetCanvas,
        width = targetCanvas.width, height = targetCanvas.height,
        dWidth = pipelineState.destinationWidth,
        dHeight = pipelineState.destinationHeight;

    if (width !== dWidth || height !== dHeight) {
      targetCanvas.width = dWidth;
      targetCanvas.height = dHeight;
    }
  }

  /**
   * Copy an input WebGL canvas on to an output 2D canvas.
   *
   * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
   * desired output image appearing in the bottom-left corner of the WebGL canvas.
   *
   * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
   * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
   * @param {Object} pipelineState The 2D target canvas to copy on to.
   */
  function copyGLTo2DDrawImage(gl, pipelineState) {
    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
        ctx = targetCanvas.getContext('2d');
    ctx.translate(0, targetCanvas.height); // move it down again
    ctx.scale(1, -1); // vertical flip
    // where is my image on the big glcanvas?
    var sourceY = glCanvas.height - targetCanvas.height;
    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
      targetCanvas.width, targetCanvas.height);
  }

  /**
   * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
   * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
   *
   * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
   * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
   * @param {Object} pipelineState The 2D target canvas to copy on to.
   */
  function copyGLTo2DPutImageData(gl, pipelineState) {
    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
        dWidth = pipelineState.destinationWidth,
        dHeight = pipelineState.destinationHeight,
        numBytes = dWidth * dHeight * 4;

    // eslint-disable-next-line no-undef
    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
    // eslint-disable-next-line no-undef
    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
    var imgData = new ImageData(u8Clamped, dWidth, dHeight);
    ctx.putImageData(imgData, 0, 0);
  }


  (function() {

    var noop = function() {};

    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

    /**
     * Canvas 2D filter backend.
     */
    function Canvas2dFilterBackend() {}
    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
      evictCachesForKey: noop,
      dispose: noop,
      clearWebGLCaches: noop,

      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you probably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {

      },

      /**
       * Apply a set of filters against a source image and draw the filtered output
       * to the provided destination canvas.
       *
       * @param {EnhancedFilter} filters The filter to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
       * @param {Number} sourceWidth The width of the source input.
       * @param {Number} sourceHeight The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       */
      applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
        var ctx = targetCanvas.getContext('2d');
        ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
        var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var pipelineState = {
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          imageData: imageData,
          originalEl: sourceElement,
          originalImageData: originalImageData,
          canvasEl: targetCanvas,
          ctx: ctx,
          filterBackend: this,
        };
        filters.forEach(function(filter) { filter.applyTo(pipelineState); });
        if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
          targetCanvas.width = pipelineState.imageData.width;
          targetCanvas.height = pipelineState.imageData.height;
        }
        ctx.putImageData(pipelineState.imageData, 0, 0);
        return pipelineState;
      },

    };
  })();


  /**
   * @namespace fabric.Image.filters
   * @memberOf fabric.Image
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   */
  fabric.Image.filters = fabric.Image.filters || { };

  /**
   * Root filter class from which all filter classes inherit from
   * @class fabric.Image.filters.BaseFilter
   * @memberOf fabric.Image.filters
   */
  fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'BaseFilter',

    /**
     * Array of attributes to send with buffers. do not modify
     * @private
     */

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    fragmentSource: 'precision highp float;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform sampler2D uTexture;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
      '}',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Sets filter's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Compile this filter's shader program.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
     * @param {String} fragmentSource fragmentShader source for compilation
     * @param {String} vertexSource vertexShader source for compilation
     */
    createProgram: function(gl, fragmentSource, vertexSource) {
      fragmentSource = fragmentSource || this.fragmentSource;
      vertexSource = vertexSource || this.vertexSource;
      if (fabric.webGlPrecision !== 'highp'){
        fragmentSource = fragmentSource.replace(
          /precision highp float/g,
          'precision ' + fabric.webGlPrecision + ' float'
        );
      }
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexSource);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Vertex shader compile error for ' + this.type + ': ' +
          gl.getShaderInfoLog(vertexShader)
        );
      }

      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Fragment shader compile error for ' + this.type + ': ' +
          gl.getShaderInfoLog(fragmentShader)
        );
      }

      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(
          // eslint-disable-next-line prefer-template
          'Shader link error for "${this.type}" ' +
          gl.getProgramInfoLog(program)
        );
      }

      var attributeLocations = this.getAttributeLocations(gl, program);
      var uniformLocations = this.getUniformLocations(gl, program) || { };
      uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
      uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
      return {
        program: program,
        attributeLocations: attributeLocations,
        uniformLocations: uniformLocations
      };
    },

    /**
     * Return a map of attribute names to WebGLAttributeLocation objects.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
     * @returns {Object} A map of attribute names to attribute locations.
     */
    getAttributeLocations: function(gl, program) {
      return {
        aPosition: gl.getAttribLocation(program, 'aPosition'),
      };
    },

    /**
     * Return a map of uniform names to WebGLUniformLocation objects.
     *
     * Intended to be overridden by subclasses.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
     * @returns {Object} A map of uniform names to uniform locations.
     */
    getUniformLocations: function (/* gl, program */) {
      // in case i do not need any special uniform i need to return an empty object
      return { };
    },

    /**
     * Send attribute data from this filter to its shader program on the GPU.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {Object} attributeLocations A map of shader attribute names to their locations.
     */
    sendAttributeData: function(gl, attributeLocations, aPositionData) {
      var attributeLocation = attributeLocations.aPosition;
      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(attributeLocation);
      gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
    },

    _setupFrameBuffer: function(options) {
      var gl = options.context, width, height;
      if (options.passes > 1) {
        width = options.destinationWidth;
        height = options.destinationHeight;
        if (options.sourceWidth !== width || options.sourceHeight !== height) {
          gl.deleteTexture(options.targetTexture);
          options.targetTexture = options.filterBackend.createTexture(gl, width, height);
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
          options.targetTexture, 0);
      }
      else {
        // draw last filter on canvas and not to framebuffer.
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.finish();
      }
    },

    _swapTextures: function(options) {
      options.passes--;
      options.pass++;
      var temp = options.targetTexture;
      options.targetTexture = options.sourceTexture;
      options.sourceTexture = temp;
    },

    /**
     * Intentionally left blank, to be overridden in custom filters
     * @param {Object} options
     **/
    isNeutralState: function(/* options */) {
      return false;
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        if (options.passes > 1 && this.isNeutralState(options)) {
          // avoid doing something that we do not need
          return;
        }
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else if (!this.isNeutralState()) {
        this.applyTo2d(options);
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      if (!options.programCache.hasOwnProperty(this.type)) {
        options.programCache[this.type] = this.createProgram(options.context);
      }
      return options.programCache[this.type];
    },

    /**
     * Apply this filter using webgl.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.originalTexture The texture of the original input image.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyToWebGL: function(options) {
      var gl = options.context;
      var shader = this.retrieveShader(options);
      if (options.pass === 0 && options.originalTexture) {
        gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
      }
      else {
        gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
      }
      gl.useProgram(shader.program);
      this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

      gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
      gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

      this.sendUniformData(gl, shader.uniformLocations);
      gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },

    bindAdditionalTexture: function(gl, texture, textureUnit) {
      gl.activeTexture(textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      // reset active texture to 0 as usual
      gl.activeTexture(gl.TEXTURE0);
    },

    unbindAdditionalTexture: function(gl, textureUnit) {
      gl.activeTexture(textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.activeTexture(gl.TEXTURE0);
    },

    getMainParameter: function() {
      return this[this.mainParameter];
    },

    setMainParameter: function(value) {
      this[this.mainParameter] = value;
    },

    /**
     * Send uniform data from this filter to its shader program on the GPU.
     *
     * Intended to be overridden by subclasses.
     *
     * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
     * @param {Object} uniformLocations A map of shader uniform names to their locations.
     */
    sendUniformData: function(/* gl, uniformLocations */) {
      // Intentionally left blank.  Override me in subclasses.
    },

    /**
     * If needed by a 2d filter, this functions can create an helper canvas to be used
     * remember that options.targetCanvas is available for use till end of chain.
     */
    createHelpLayer: function(options) {
      if (!options.helpLayer) {
        var helpLayer = document.createElement('canvas');
        helpLayer.width = options.sourceWidth;
        helpLayer.height = options.sourceHeight;
        options.helpLayer = helpLayer;
      }
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      var object = { type: this.type }, mainP = this.mainParameter;
      if (mainP) {
        object[mainP] = this[mainP];
      }
      return object;
    },

    /**
     * Returns a JSON representation of an instance
     * @return {Object} JSON
     */
    toJSON: function() {
      // delegate, not alias
      return this.toObject();
    }
  });

  fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
    var filter = new fabric.Image.filters[object.type](object);
    callback && callback(filter);
    return filter;
  };


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Color Matrix filter class
     * @class fabric.Image.filters.ColorMatrix
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
     * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
     * @example <caption>Kodachrome filter</caption>
     * var filter = new fabric.Image.filters.ColorMatrix({
     *  matrix: [
         1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
         -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
         -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
         0, 0, 0, 1, 0
        ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'ColorMatrix',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'uniform mat4 uColorMatrix;\n' +
        'uniform vec4 uConstants;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color *= uColorMatrix;\n' +
          'color += uConstants;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Colormatrix for pixels.
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * 0.0039215686 is the part of 1 that get translated to 1 in 2d
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ],

      mainParameter: 'matrix',

      /**
       * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
       * to save some calculation
       */
      colorsOnly: true,

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        // create a new array instead mutating the prototype with push
        this.matrix = this.matrix.slice(0);
      },

      /**
       * Intentionally left blank, to be overridden in custom filters
       * @param {Object} options
       **/
      isNeutralState: function(/* options */) {
        var _class = filters.ColorMatrix;
        for (var i = 20; i--;) {
          if (this.matrix[i] !== _class.prototype.matrix[i]) {
            return false;
          }
        }
        return true;
      },

      /**
       * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            iLen = data.length,
            m = this.matrix,
            r, g, b, a, i, colorsOnly = this.colorsOnly;

        for (i = 0; i < iLen; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          if (colorsOnly) {
            data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
            data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
            data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
          }
          else {
            a = data[i + 3];
            data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
            data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
            data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
            data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
          uConstants: gl.getUniformLocation(program, 'uConstants'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var m = this.matrix,
            matrix = [
              m[0], m[1], m[2], m[3],
              m[5], m[6], m[7], m[8],
              m[10], m[11], m[12], m[13],
              m[15], m[16], m[17], m[18]
            ],
            constants = [m[4], m[9], m[14], m[19]];
        gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
        gl.uniform4fv(uniformLocations.uConstants, constants);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] function to invoke after filter creation
     * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
     */
    fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Brightness filter class
     * @class fabric.Image.filters.Brightness
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Brightness({
     *   brightness: 0.05
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Brightness',

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uBrightness;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb += uBrightness;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Brightness value, from -1 to 1.
       * translated to -255 to 255 for 2d
       * 0.0039215686 is the part of 1 that get translated to 1 in 2d
       * @param {Number} brightness
       * @default
       */
      brightness: 0,

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'brightness',

      /**
      * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
      */
      applyTo2d: function(options) {
        if (this.brightness === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i, len = data.length,
            brightness = Math.round(this.brightness * 255);
        for (i = 0; i < len; i += 4) {
          data[i] = data[i] + brightness;
          data[i + 1] = data[i + 1] + brightness;
          data[i + 2] = data[i + 2] + brightness;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uBrightness: gl.getUniformLocation(program, 'uBrightness'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uBrightness, this.brightness);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
     */
    fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
     * @class fabric.Image.filters.Convolute
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example <caption>Sharpen filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 0, -1,  0,
     *            -1,  5, -1,
     *             0, -1,  0 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Blur filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 1/9, 1/9, 1/9,
     *             1/9, 1/9, 1/9,
     *             1/9, 1/9, 1/9 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Emboss filter</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   matrix: [ 1,   1,  1,
     *             1, 0.7, -1,
     *            -1,  -1, -1 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     * @example <caption>Emboss filter with opaqueness</caption>
     * var filter = new fabric.Image.filters.Convolute({
     *   opaque: true,
     *   matrix: [ 1,   1,  1,
     *             1, 0.7, -1,
     *            -1,  -1, -1 ]
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Convolute',

      /*
       * Opaque value (true/false)
       */
      opaque: false,

      /*
       * matrix for the filter, max 9x9
       */
      matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: {
        Convolute_3_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[9];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_3_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[9];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_5_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[25];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_5_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[25];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_7_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[49];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_7_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[49];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
        Convolute_9_1: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[81];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 0);\n' +
            'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
                'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'gl_FragColor = color;\n' +
          '}',
        Convolute_9_0: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform float uMatrix[81];\n' +
          'uniform float uStepW;\n' +
          'uniform float uStepH;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = vec4(0, 0, 0, 1);\n' +
            'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
              'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
                'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
                'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
              '}\n' +
            '}\n' +
            'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
            'gl_FragColor = color;\n' +
            'gl_FragColor.a = alpha;\n' +
          '}',
      },

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Convolute.prototype
       * @param {Object} [options] Options object
       * @param {Boolean} [options.opaque=false] Opaque value (true/false)
       * @param {Array} [options.matrix] Filter matrix
       */


      /**
      * Retrieves the cached shader.
      * @param {Object} options
      * @param {WebGLRenderingContext} options.context The GL context used for rendering.
      * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
      */
      retrieveShader: function(options) {
        var size = Math.sqrt(this.matrix.length);
        var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
        var shaderSource = this.fragmentSource[cacheKey];
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data,
            weights = this.matrix,
            side = Math.round(Math.sqrt(weights.length)),
            halfSide = Math.floor(side / 2),
            sw = imageData.width,
            sh = imageData.height,
            output = options.ctx.createImageData(sw, sh),
            dst = output.data,
            // go through the destination image pixels
            alphaFac = this.opaque ? 1 : 0,
            r, g, b, a, dstOff,
            scx, scy, srcOff, wt,
            x, y, cx, cy;

        for (y = 0; y < sh; y++) {
          for (x = 0; x < sw; x++) {
            dstOff = (y * sw + x) * 4;
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            r = 0; g = 0; b = 0; a = 0;

            for (cy = 0; cy < side; cy++) {
              for (cx = 0; cx < side; cx++) {
                scy = y + cy - halfSide;
                scx = x + cx - halfSide;

                // eslint-disable-next-line max-depth
                if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
                  continue;
                }

                srcOff = (scy * sw + scx) * 4;
                wt = weights[cy * side + cx];

                r += data[srcOff] * wt;
                g += data[srcOff + 1] * wt;
                b += data[srcOff + 2] * wt;
                // eslint-disable-next-line max-depth
                if (!alphaFac) {
                  a += data[srcOff + 3] * wt;
                }
              }
            }
            dst[dstOff] = r;
            dst[dstOff + 1] = g;
            dst[dstOff + 2] = b;
            if (!alphaFac) {
              dst[dstOff + 3] = a;
            }
            else {
              dst[dstOff + 3] = data[dstOff + 3];
            }
          }
        }
        options.imageData = output;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uMatrix: gl.getUniformLocation(program, 'uMatrix'),
          uOpaque: gl.getUniformLocation(program, 'uOpaque'),
          uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
          uSize: gl.getUniformLocation(program, 'uSize'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          opaque: this.opaque,
          matrix: this.matrix
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
     */
    fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Grayscale image filter class
     * @class fabric.Image.filters.Grayscale
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Grayscale();
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Grayscale',

      fragmentSource: {
        average: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'float average = (color.r + color.b + color.g) / 3.0;\n' +
            'gl_FragColor = vec4(average, average, average, color.a);\n' +
          '}',
        lightness: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform int uMode;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 col = texture2D(uTexture, vTexCoord);\n' +
            'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
            'gl_FragColor = vec4(average, average, average, col.a);\n' +
          '}',
        luminosity: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform int uMode;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 col = texture2D(uTexture, vTexCoord);\n' +
            'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
            'gl_FragColor = vec4(average, average, average, col.a);\n' +
          '}',
      },


      /**
       * Grayscale mode, between 'average', 'lightness', 'luminosity'
       * @param {String} type
       * @default
       */
      mode: 'average',

      mainParameter: 'mode',

      /**
       * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            len = data.length, value,
            mode = this.mode;
        for (i = 0; i < len; i += 4) {
          if (mode === 'average') {
            value = (data[i] + data[i + 1] + data[i + 2]) / 3;
          }
          else if (mode === 'lightness') {
            value = (Math.min(data[i], data[i + 1], data[i + 2]) +
              Math.max(data[i], data[i + 1], data[i + 2])) / 2;
          }
          else if (mode === 'luminosity') {
            value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
          }
          data[i] = value;
          data[i + 1] = value;
          data[i + 2] = value;
        }
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          var shaderSource = this.fragmentSource[this.mode];
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uMode: gl.getUniformLocation(program, 'uMode'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        // default average mode.
        var mode = 1;
        gl.uniform1i(uniformLocations.uMode, mode);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
     */
    fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Invert filter class
     * @class fabric.Image.filters.Invert
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Invert();
     * object.filters.push(filter);
     * object.applyFilters(canvas.renderAll.bind(canvas));
     */
    filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Invert',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uInvert;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'if (uInvert == 1) {\n' +
            'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
          '} else {\n' +
            'gl_FragColor = color;\n' +
          '}\n' +
        '}',

      /**
       * Filter invert. if false, does nothing
       * @param {Boolean} invert
       * @default
       */
      invert: true,

      mainParameter: 'invert',

      /**
       * Apply the Invert operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        if (!this.invert) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i,
            len = data.length;
        for (i = 0; i < len; i += 4) {
          data[i] = 255 - data[i];
          data[i + 1] = 255 - data[i + 1];
          data[i + 2] = 255 - data[i + 2];
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uInvert: gl.getUniformLocation(program, 'uInvert'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1i(uniformLocations.uInvert, this.invert);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
     */
    fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Noise filter class
     * @class fabric.Image.filters.Noise
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Noise({
     *   noise: 700
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Noise',

      /**
       * Fragment source for the noise program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uStepH;\n' +
        'uniform float uNoise;\n' +
        'uniform float uSeed;\n' +
        'varying vec2 vTexCoord;\n' +
        'float rand(vec2 co, float seed, float vScale) {\n' +
          'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
        '}\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'noise',

      /**
       * Noise value, from
       * @param {Number} noise
       * @default
       */
      noise: 0,

      /**
       * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.noise === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, i, len = data.length,
            noise = this.noise, rand;

        for (i = 0, len = data.length; i < len; i += 4) {

          rand = (0.5 - Math.random()) * noise;

          data[i] += rand;
          data[i + 1] += rand;
          data[i + 2] += rand;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uNoise: gl.getUniformLocation(program, 'uNoise'),
          uSeed: gl.getUniformLocation(program, 'uSeed'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
        gl.uniform1f(uniformLocations.uSeed, Math.random());
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          noise: this.noise
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
     */
    fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Pixelate filter class
     * @class fabric.Image.filters.Pixelate
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Pixelate({
     *   blocksize: 8
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Pixelate',

      blocksize: 4,

      mainParameter: 'blocksize',

      /**
       * Fragment source for the Pixelate program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uBlocksize;\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'float blockW = uBlocksize * uStepW;\n' +
          'float blockH = uBlocksize * uStepW;\n' +
          'int posX = int(vTexCoord.x / blockW);\n' +
          'int posY = int(vTexCoord.y / blockH);\n' +
          'float fposX = float(posX);\n' +
          'float fposY = float(posY);\n' +
          'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
          'vec4 color = texture2D(uTexture, squareCoords);\n' +
          'gl_FragColor = color;\n' +
        '}',

      /**
       * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.blocksize === 1) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data,
            iLen = imageData.height,
            jLen = imageData.width,
            index, i, j, r, g, b, a,
            _i, _j, _iLen, _jLen;

        for (i = 0; i < iLen; i += this.blocksize) {
          for (j = 0; j < jLen; j += this.blocksize) {

            index = (i * 4) * jLen + (j * 4);

            r = data[index];
            g = data[index + 1];
            b = data[index + 2];
            a = data[index + 3];

            _iLen = Math.min(i + this.blocksize, iLen);
            _jLen = Math.min(j + this.blocksize, jLen);
            for (_i = i; _i < _iLen; _i++) {
              for (_j = j; _j < _jLen; _j++) {
                index = (_i * 4) * jLen + (_j * 4);
                data[index] = r;
                data[index + 1] = g;
                data[index + 2] = b;
                data[index + 3] = a;
              }
            }
          }
        }
      },

      /**
       * Indicate when the filter is not gonna apply changes to the image
       **/
      isNeutralState: function() {
        return this.blocksize === 1;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
          uStepW: gl.getUniformLocation(program, 'uStepW'),
          uStepH: gl.getUniformLocation(program, 'uStepH'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
     */
    fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        extend = fabric.util.object.extend,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Remove white filter class
     * @class fabric.Image.filters.RemoveColor
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.RemoveColor({
     *   threshold: 0.2,
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'RemoveColor',

      /**
       * Color to remove, in any format understood by fabric.Color.
       * @param {String} type
       * @default
       */
      color: '#FFFFFF',

      /**
       * Fragment source for the brightness program
       */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uLow;\n' +
        'uniform vec4 uHigh;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
            'gl_FragColor.a = 0.0;\n' +
          '}\n' +
        '}',

      /**
       * distance to actual color, as value up or down from each r,g,b
       * between 0 and 1
       **/
      distance: 0.02,

      /**
       * For color to remove inside distance, use alpha channel for a smoother deletion
       * NOT IMPLEMENTED YET
       **/
      useAlpha: false,

      /**
       * Constructor
       * @memberOf fabric.Image.filters.RemoveWhite.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.color=#RRGGBB] Threshold value
       * @param {Number} [options.distance=10] Distance value
       */

      /**
       * Applies filter to canvas element
       * @param {Object} canvasEl Canvas element to apply filter to
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, i,
            distance = this.distance * 255,
            r, g, b,
            source = new fabric.Color(this.color).getSource(),
            lowC = [
              source[0] - distance,
              source[1] - distance,
              source[2] - distance,
            ],
            highC = [
              source[0] + distance,
              source[1] + distance,
              source[2] + distance,
            ];


        for (i = 0; i < data.length; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];

          if (r > lowC[0] &&
              g > lowC[1] &&
              b > lowC[2] &&
              r < highC[0] &&
              g < highC[1] &&
              b < highC[2]) {
            data[i + 3] = 0;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uLow: gl.getUniformLocation(program, 'uLow'),
          uHigh: gl.getUniformLocation(program, 'uHigh'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var source = new fabric.Color(this.color).getSource(),
            distance = parseFloat(this.distance),
            lowC = [
              0 + source[0] / 255 - distance,
              0 + source[1] / 255 - distance,
              0 + source[2] / 255 - distance,
              1
            ],
            highC = [
              source[0] / 255 + distance,
              source[1] / 255 + distance,
              source[2] / 255 + distance,
              1
            ];
        gl.uniform4fv(uniformLocations.uLow, lowC);
        gl.uniform4fv(uniformLocations.uHigh, highC);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return extend(this.callSuper('toObject'), {
          color: this.color,
          distance: this.distance
        });
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
     */
    fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    var matrices = {
      Brownie: [
        0.59970,0.34553,-0.27082,0,0.186,
        -0.03770,0.86095,0.15059,0,-0.1449,
        0.24113,-0.07441,0.44972,0,-0.02965,
        0,0,0,1,0
      ],
      Vintage: [
        0.62793,0.32021,-0.03965,0,0.03784,
        0.02578,0.64411,0.03259,0,0.02926,
        0.04660,-0.08512,0.52416,0,0.02023,
        0,0,0,1,0
      ],
      Kodachrome: [
        1.12855,-0.39673,-0.03992,0,0.24991,
        -0.16404,1.08352,-0.05498,0,0.09698,
        -0.16786,-0.56034,1.60148,0,0.13972,
        0,0,0,1,0
      ],
      Technicolor: [
        1.91252,-0.85453,-0.09155,0,0.04624,
        -0.30878,1.76589,-0.10601,0,-0.27589,
        -0.23110,-0.75018,1.84759,0,0.12137,
        0,0,0,1,0
      ],
      Polaroid: [
        1.438,-0.062,-0.062,0,0,
        -0.122,1.378,-0.122,0,0,
        -0.016,-0.016,1.483,0,0,
        0,0,0,1,0
      ],
      Sepia: [
        0.393, 0.769, 0.189, 0, 0,
        0.349, 0.686, 0.168, 0, 0,
        0.272, 0.534, 0.131, 0, 0,
        0, 0, 0, 1, 0
      ],
      BlackWhite: [
        1.5, 1.5, 1.5, 0, -1,
        1.5, 1.5, 1.5, 0, -1,
        1.5, 1.5, 1.5, 0, -1,
        0, 0, 0, 1, 0,
      ]
    };

    for (var key in matrices) {
      filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: key,

        /**
         * Colormatrix for the effect
         * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
         * outside the -1, 1 range.
         * @param {Array} matrix array of 20 numbers.
         * @default
         */
        matrix: matrices[key],

        /**
         * Lock the matrix export for this kind of static, parameter less filters.
         */
        mainParameter: false,
        /**
         * Lock the colormatrix on the color part, skipping alpha
         */
        colorsOnly: true,

      });
      fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
    }
  })(exports);


  (function(global) {

    var fabric = global.fabric,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Color Blend filter class
     * @class fabric.Image.filter.BlendColor
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @example
     * var filter = new fabric.Image.filters.BlendColor({
     *  color: '#000',
     *  mode: 'multiply'
     * });
     *
     * var filter = new fabric.Image.filters.BlendImage({
     *  image: fabricImageObject,
     *  mode: 'multiply',
     *  alpha: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */

    filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
      type: 'BlendColor',

      /**
       * Color to make the blend operation with. default to a reddish color since black or white
       * gives always strong result.
       **/
      color: '#F95C63',

      /**
       * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
       * darken, lighten, overlay, exclusion, tint.
       **/
      mode: 'multiply',

      /**
       * alpha value. represent the strength of the blend color operation.
       **/
      alpha: 1,

      /**
       * Fragment source for the Multiply program
       */
      fragmentSource: {
        multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
        screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
        add: 'gl_FragColor.rgb += uColor.rgb;\n',
        diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
        subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
        lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
        darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
        exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
        overlay: 'if (uColor.r < 0.5) {\n' +
            'gl_FragColor.r *= 2.0 * uColor.r;\n' +
          '} else {\n' +
            'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
          '}\n' +
          'if (uColor.g < 0.5) {\n' +
            'gl_FragColor.g *= 2.0 * uColor.g;\n' +
          '} else {\n' +
            'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
          '}\n' +
          'if (uColor.b < 0.5) {\n' +
            'gl_FragColor.b *= 2.0 * uColor.b;\n' +
          '} else {\n' +
            'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
          '}\n',
        tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
          'gl_FragColor.rgb += uColor.rgb;\n',
      },

      /**
       * build the fragment source for the filters, joining the common part with
       * the specific one.
       * @param {String} mode the mode of the filter, a key of this.fragmentSource
       * @return {String} the source to be compiled
       * @private
       */
      buildSource: function(mode) {
        return 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'gl_FragColor = color;\n' +
            'if (color.a > 0.0) {\n' +
              this.fragmentSource[mode] +
            '}\n' +
          '}';
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode, shaderSource;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          shaderSource = this.buildSource(this.mode);
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      /**
       * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            data = imageData.data, iLen = data.length,
            tr, tg, tb,
            r, g, b,
            source, alpha1 = 1 - this.alpha;

        source = new fabric.Color(this.color).getSource();
        tr = source[0] * this.alpha;
        tg = source[1] * this.alpha;
        tb = source[2] * this.alpha;

        for (var i = 0; i < iLen; i += 4) {

          r = data[i];
          g = data[i + 1];
          b = data[i + 2];

          switch (this.mode) {
            case 'multiply':
              data[i] = r * tr / 255;
              data[i + 1] = g * tg / 255;
              data[i + 2] = b * tb / 255;
              break;
            case 'screen':
              data[i] = 255 - (255 - r) * (255 - tr) / 255;
              data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
              data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
              break;
            case 'add':
              data[i] = r + tr;
              data[i + 1] = g + tg;
              data[i + 2] = b + tb;
              break;
            case 'diff':
            case 'difference':
              data[i] = Math.abs(r - tr);
              data[i + 1] = Math.abs(g - tg);
              data[i + 2] = Math.abs(b - tb);
              break;
            case 'subtract':
              data[i] = r - tr;
              data[i + 1] = g - tg;
              data[i + 2] = b - tb;
              break;
            case 'darken':
              data[i] = Math.min(r, tr);
              data[i + 1] = Math.min(g, tg);
              data[i + 2] = Math.min(b, tb);
              break;
            case 'lighten':
              data[i] = Math.max(r, tr);
              data[i + 1] = Math.max(g, tg);
              data[i + 2] = Math.max(b, tb);
              break;
            case 'overlay':
              data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
              data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
              data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
              break;
            case 'exclusion':
              data[i] = tr + r - ((2 * tr * r) / 255);
              data[i + 1] = tg + g - ((2 * tg * g) / 255);
              data[i + 2] = tb + b - ((2 * tb * b) / 255);
              break;
            case 'tint':
              data[i] = tr + r * alpha1;
              data[i + 1] = tg + g * alpha1;
              data[i + 2] = tb + b * alpha1;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uColor: gl.getUniformLocation(program, 'uColor'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var source = new fabric.Color(this.color).getSource();
        source[0] = this.alpha * source[0] / 255;
        source[1] = this.alpha * source[1] / 255;
        source[2] = this.alpha * source[2] / 255;
        source[3] = this.alpha;
        gl.uniform4fv(uniformLocations.uColor, source);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          color: this.color,
          mode: this.mode,
          alpha: this.alpha
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
     */
    fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric = global.fabric,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Image Blend filter class
     * @class fabric.Image.filter.BlendImage
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @example
     * var filter = new fabric.Image.filters.BlendColor({
     *  color: '#000',
     *  mode: 'multiply'
     * });
     *
     * var filter = new fabric.Image.filters.BlendImage({
     *  image: fabricImageObject,
     *  mode: 'multiply',
     *  alpha: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */

    filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
      type: 'BlendImage',

      /**
       * Color to make the blend operation with. default to a reddish color since black or white
       * gives always strong result.
       **/
      image: null,

      /**
       * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
       * darken, lighten, overlay, exclusion, tint.
       **/
      mode: 'multiply',

      /**
       * alpha value. represent the strength of the blend color operation.
       **/
      alpha: 1,

      vertexSource: 'attribute vec2 aPosition;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'uniform mat3 uTransformMatrix;\n' +
        'void main() {\n' +
          'vTexCoord = aPosition;\n' +
          'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
          'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
        '}',

      /**
       * Fragment source for the Multiply program
       */
      fragmentSource: {
        multiply: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform sampler2D uImage;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'varying vec2 vTexCoord2;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
            'color.rgba *= color2.rgba;\n' +
            'gl_FragColor = color;\n' +
          '}',
        mask: 'precision highp float;\n' +
          'uniform sampler2D uTexture;\n' +
          'uniform sampler2D uImage;\n' +
          'uniform vec4 uColor;\n' +
          'varying vec2 vTexCoord;\n' +
          'varying vec2 vTexCoord2;\n' +
          'void main() {\n' +
            'vec4 color = texture2D(uTexture, vTexCoord);\n' +
            'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
            'color.a = color2.a;\n' +
            'gl_FragColor = color;\n' +
          '}',
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var cacheKey = this.type + '_' + this.mode;
        var shaderSource = this.fragmentSource[this.mode];
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
        }
        return options.programCache[cacheKey];
      },

      applyToWebGL: function(options) {
        // load texture to blend.
        var gl = options.context,
            texture = this.createTexture(options.filterBackend, this.image);
        this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
        this.callSuper('applyToWebGL', options);
        this.unbindAdditionalTexture(gl, gl.TEXTURE1);
      },

      createTexture: function(backend, image) {
        return backend.getCachedTexture(image.cacheKey, image._element);
      },

      /**
       * Calculate a transformMatrix to adapt the image to blend over
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      calculateMatrix: function() {
        var image = this.image,
            width = image._element.width,
            height = image._element.height;
        return [
          1 / image.scaleX, 0, 0,
          0, 1 / image.scaleY, 0,
          -image.left / width, -image.top / height, 1
        ];
      },

      /**
       * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            resources = options.filterBackend.resources,
            data = imageData.data, iLen = data.length,
            width = options.imageData.width,
            height = options.imageData.height,
            tr, tg, tb, ta,
            r, g, b, a,
            canvas1, context, image = this.image, blendData;

        if (!resources.blendImage) {
          resources.blendImage = document.createElement('canvas');
        }
        canvas1 = resources.blendImage;
        if (canvas1.width !== width || canvas1.height !== height) {
          canvas1.width = width;
          canvas1.height = height;
        }
        context = canvas1.getContext('2d');
        context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
        context.drawImage(image._element, 0, 0, width, height);
        blendData = context.getImageData(0, 0, width, height).data;
        for (var i = 0; i < iLen; i += 4) {

          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          a = data[i + 3];

          tr = blendData[i];
          tg = blendData[i + 1];
          tb = blendData[i + 2];
          ta = blendData[i + 3];

          switch (this.mode) {
            case 'multiply':
              data[i] = r * tr / 255;
              data[i + 1] = g * tg / 255;
              data[i + 2] = b * tb / 255;
              data[i + 3] = a * ta / 255;
              break;
            case 'mask':
              data[i + 3] = ta;
              break;
          }
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
          uImage: gl.getUniformLocation(program, 'uImage'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var matrix = this.calculateMatrix();
        gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
        gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          image: this.image && this.image.toObject(),
          mode: this.mode,
          alpha: this.alpha
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} callback to be invoked after filter creation
     * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
     */
    fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
      fabric.Image.fromObject(object.image, function(image) {
        var options = fabric.util.object.clone(object);
        options.image = image;
        callback(new fabric.Image.filters.BlendImage(options));
      });
    };

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
        sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
        ceil = Math.ceil,
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Resize image filter class
     * @class fabric.Image.filters.Resize
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Resize();
     * object.filters.push(filter);
     * object.applyFilters(canvas.renderAll.bind(canvas));
     */
    filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Resize',

      /**
       * Resize type
       * @param {String} resizeType
       * @default
       */
      resizeType: 'hermite',

      /**
       * Scale factor for resizing, x axis
       * @param {Number} scaleX
       * @default
       */
      scaleX: 0,

      /**
       * Scale factor for resizing, y axis
       * @param {Number} scaleY
       * @default
       */
      scaleY: 0,

      /**
       * LanczosLobes parameter for lanczos filter
       * @param {Number} lanczosLobes
       * @default
       */
      lanczosLobes: 3,


      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uDelta: gl.getUniformLocation(program, 'uDelta'),
          uTaps: gl.getUniformLocation(program, 'uTaps'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
        gl.uniform1fv(uniformLocations.uTaps, this.taps);
      },

      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(options) {
        var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
        if (!options.programCache.hasOwnProperty(cacheKey)) {
          var fragmentShader = this.generateShader(filterWindow);
          options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
        }
        return options.programCache[cacheKey];
      },

      getFilterWindow: function() {
        var scale = this.tempScale;
        return Math.ceil(this.lanczosLobes / scale);
      },

      getTaps: function() {
        var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
            filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
        for (var i = 1; i <= filterWindow; i++) {
          taps[i - 1] = lobeFunction(i * scale);
        }
        return taps;
      },

      /**
       * Generate vertex and shader sources from the necessary steps numbers
       * @param {Number} filterWindow
       */
      generateShader: function(filterWindow) {
        var offsets = new Array(filterWindow),
            fragmentShader = this.fragmentSourceTOP, filterWindow;

        for (var i = 1; i <= filterWindow; i++) {
          offsets[i - 1] = i + '.0 * uDelta';
        }

        fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
        fragmentShader += 'void main() {\n';
        fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
        fragmentShader += '  float sum = 1.0;\n';

        offsets.forEach(function(offset, i) {
          fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
          fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
          fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
        });
        fragmentShader += '  gl_FragColor = color / sum;\n';
        fragmentShader += '}';
        return fragmentShader;
      },

      fragmentSourceTOP: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec2 uDelta;\n' +
        'varying vec2 vTexCoord;\n',

      /**
       * Apply the resize filter to the image
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(options) {
        if (options.webgl) {
          if (options.passes > 1 && this.isNeutralState(options)) {
            // avoid doing something that we do not need
            return;
          }
          options.passes++;
          this.width = options.sourceWidth;
          this.horizontal = true;
          this.dW = Math.round(this.width * this.scaleX);
          this.dH = options.sourceHeight;
          this.tempScale = this.dW / this.width;
          this.taps = this.getTaps();
          options.destinationWidth = this.dW;
          this._setupFrameBuffer(options);
          this.applyToWebGL(options);
          this._swapTextures(options);
          options.sourceWidth = options.destinationWidth;

          this.height = options.sourceHeight;
          this.horizontal = false;
          this.dH = Math.round(this.height * this.scaleY);
          this.tempScale = this.dH / this.height;
          this.taps = this.getTaps();
          options.destinationHeight = this.dH;
          this._setupFrameBuffer(options);
          this.applyToWebGL(options);
          this._swapTextures(options);
          options.sourceHeight = options.destinationHeight;
        }
        else if (!this.isNeutralState(options)) {
          this.applyTo2d(options);
        }
      },

      isNeutralState: function(options) {
        var scaleX = options.scaleX || this.scaleX,
            scaleY = options.scaleY || this.scaleY;
        return scaleX === 1 && scaleY === 1;
      },

      lanczosCreate: function(lobes) {
        return function(x) {
          if (x >= lobes || x <= -lobes) {
            return 0.0;
          }
          if (x < 1.19209290E-07 && x > -1.19209290E-07) {
            return 1.0;
          }
          x *= Math.PI;
          var xx = x / lobes;
          return (sin(x) / x) * sin(xx) / xx;
        };
      },

      /**
       * Applies filter to canvas element
       * @memberOf fabric.Image.filters.Resize.prototype
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} scaleX
       * @param {Number} scaleY
       */
      applyTo2d: function(options) {
        var imageData = options.imageData,
            scaleX = this.scaleX,
            scaleY = this.scaleY;

        this.rcpScaleX = 1 / scaleX;
        this.rcpScaleY = 1 / scaleY;

        var oW = imageData.width, oH = imageData.height,
            dW = round(oW * scaleX), dH = round(oH * scaleY),
            newData;

        if (this.resizeType === 'sliceHack') {
          newData = this.sliceByTwo(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'hermite') {
          newData = this.hermiteFastResize(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'bilinear') {
          newData = this.bilinearFiltering(options, oW, oH, dW, dH);
        }
        else if (this.resizeType === 'lanczos') {
          newData = this.lanczosResize(options, oW, oH, dW, dH);
        }
        options.imageData = newData;
      },

      /**
       * Filter sliceByTwo
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      sliceByTwo: function(options, oW, oH, dW, dH) {
        var imageData = options.imageData,
            mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
            stepH = oH * mult, resources = fabric.filterBackend.resources,
            tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
        if (!resources.sliceByTwo) {
          resources.sliceByTwo = document.createElement('canvas');
        }
        tmpCanvas = resources.sliceByTwo;
        if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
          tmpCanvas.width = oW * 1.5;
          tmpCanvas.height = oH;
        }
        ctx = tmpCanvas.getContext('2d');
        ctx.clearRect(0, 0, oW * 1.5, oH);
        ctx.putImageData(imageData, 0, 0);

        dW = floor(dW);
        dH = floor(dH);

        while (!doneW || !doneH) {
          oW = stepW;
          oH = stepH;
          if (dW < floor(stepW * mult)) {
            stepW = floor(stepW * mult);
          }
          else {
            stepW = dW;
            doneW = true;
          }
          if (dH < floor(stepH * mult)) {
            stepH = floor(stepH * mult);
          }
          else {
            stepH = dH;
            doneH = true;
          }
          ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
          sX = dX;
          sY = dY;
          dY += stepH;
        }
        return ctx.getImageData(sX, sY, dW, dH);
      },

      /**
       * Filter lanczosResize
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      lanczosResize: function(options, oW, oH, dW, dH) {

        function process(u) {
          var v, i, weight, idx, a, red, green,
              blue, alpha, fX, fY;
          center.x = (u + 0.5) * ratioX;
          icenter.x = floor(center.x);
          for (v = 0; v < dH; v++) {
            center.y = (v + 0.5) * ratioY;
            icenter.y = floor(center.y);
            a = 0; red = 0; green = 0; blue = 0; alpha = 0;
            for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
              if (i < 0 || i >= oW) {
                continue;
              }
              fX = floor(1000 * abs(i - center.x));
              if (!cacheLanc[fX]) {
                cacheLanc[fX] = { };
              }
              for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
                if (j < 0 || j >= oH) {
                  continue;
                }
                fY = floor(1000 * abs(j - center.y));
                if (!cacheLanc[fX][fY]) {
                  cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
                }
                weight = cacheLanc[fX][fY];
                if (weight > 0) {
                  idx = (j * oW + i) * 4;
                  a += weight;
                  red += weight * srcData[idx];
                  green += weight * srcData[idx + 1];
                  blue += weight * srcData[idx + 2];
                  alpha += weight * srcData[idx + 3];
                }
              }
            }
            idx = (v * dW + u) * 4;
            destData[idx] = red / a;
            destData[idx + 1] = green / a;
            destData[idx + 2] = blue / a;
            destData[idx + 3] = alpha / a;
          }

          if (++u < dW) {
            return process(u);
          }
          else {
            return destImg;
          }
        }

        var srcData = options.imageData.data,
            destImg = options.ctx.createImageData(dW, dH),
            destData = destImg.data,
            lanczos = this.lanczosCreate(this.lanczosLobes),
            ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
            rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
            range2X = ceil(ratioX * this.lanczosLobes / 2),
            range2Y = ceil(ratioY * this.lanczosLobes / 2),
            cacheLanc = { }, center = { }, icenter = { };

        return process(0);
      },

      /**
       * bilinearFiltering
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      bilinearFiltering: function(options, oW, oH, dW, dH) {
        var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
            color, offset = 0, origPix, ratioX = this.rcpScaleX,
            ratioY = this.rcpScaleY,
            w4 = 4 * (oW - 1), img = options.imageData,
            pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
            destPixels = destImage.data;
        for (i = 0; i < dH; i++) {
          for (j = 0; j < dW; j++) {
            x = floor(ratioX * j);
            y = floor(ratioY * i);
            xDiff = ratioX * j - x;
            yDiff = ratioY * i - y;
            origPix = 4 * (y * oW + x);

            for (chnl = 0; chnl < 4; chnl++) {
              a = pixels[origPix + chnl];
              b = pixels[origPix + 4 + chnl];
              c = pixels[origPix + w4 + chnl];
              d = pixels[origPix + w4 + 4 + chnl];
              color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                      c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
              destPixels[offset++] = color;
            }
          }
        }
        return destImage;
      },

      /**
       * hermiteFastResize
       * @param {Object} canvasEl Canvas element to apply filter to
       * @param {Number} oW Original Width
       * @param {Number} oH Original Height
       * @param {Number} dW Destination Width
       * @param {Number} dH Destination Height
       * @returns {ImageData}
       */
      hermiteFastResize: function(options, oW, oH, dW, dH) {
        var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
            ratioWHalf = ceil(ratioW / 2),
            ratioHHalf = ceil(ratioH / 2),
            img = options.imageData, data = img.data,
            img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
        for (var j = 0; j < dH; j++) {
          for (var i = 0; i < dW; i++) {
            var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
                gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
            for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
              var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                  centerX = (i + 0.5) * ratioW, w0 = dy * dy;
              for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
                var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                    w = sqrt(w0 + dx * dx);
                /* eslint-disable max-depth */
                if (w > 1 && w < -1) {
                  continue;
                }
                //hermite filter
                weight = 2 * w * w * w - 3 * w * w + 1;
                if (weight > 0) {
                  dx = 4 * (xx + yy * oW);
                  //alpha
                  gxA += weight * data[dx + 3];
                  weightsAlpha += weight;
                  //colors
                  if (data[dx + 3] < 255) {
                    weight = weight * data[dx + 3] / 250;
                  }
                  gxR += weight * data[dx];
                  gxG += weight * data[dx + 1];
                  gxB += weight * data[dx + 2];
                  weights += weight;
                }
                /* eslint-enable max-depth */
              }
            }
            data2[x2] = gxR / weights;
            data2[x2 + 1] = gxG / weights;
            data2[x2 + 2] = gxB / weights;
            data2[x2 + 3] = gxA / weightsAlpha;
          }
        }
        return img2;
      },

      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        return {
          type: this.type,
          scaleX: this.scaleX,
          scaleY: this.scaleY,
          resizeType: this.resizeType,
          lanczosLobes: this.lanczosLobes
        };
      }
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
     */
    fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Contrast filter class
     * @class fabric.Image.filters.Contrast
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Contrast({
     *   contrast: 40
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Contrast',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uContrast;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
          'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
          'gl_FragColor = color;\n' +
        '}',

      contrast: 0,

      mainParameter: 'contrast',

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Contrast.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
       */

      /**
        * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
        *
        * @param {Object} options
        * @param {ImageData} options.imageData The Uint8Array to be filtered.
        */
      applyTo2d: function(options) {
        if (this.contrast === 0) {
          return;
        }
        var imageData = options.imageData, i, len,
            data = imageData.data, len = data.length,
            contrast = Math.floor(this.contrast * 255),
            contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

        for (i = 0; i < len; i += 4) {
          data[i] = contrastF * (data[i] - 128) + 128;
          data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
          data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uContrast: gl.getUniformLocation(program, 'uContrast'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uContrast, this.contrast);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
     */
    fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Saturate filter class
     * @class fabric.Image.filters.Saturation
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Saturation({
     *   saturation: 100
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Saturation',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uSaturation;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float rgMax = max(color.r, color.g);\n' +
          'float rgbMax = max(rgMax, color.b);\n' +
          'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
          'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
          'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
          'gl_FragColor = color;\n' +
        '}',

      saturation: 0,

      mainParameter: 'saturation',

      /**
       * Constructor
       * @memberOf fabric.Image.filters.Saturate.prototype
       * @param {Object} [options] Options object
       * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
       */

      /**
       * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
       */
      applyTo2d: function(options) {
        if (this.saturation === 0) {
          return;
        }
        var imageData = options.imageData,
            data = imageData.data, len = data.length,
            adjust = -this.saturation, i, max;

        for (i = 0; i < len; i += 4) {
          max = Math.max(data[i], data[i + 1], data[i + 2]);
          data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
          data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
          data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uSaturation: gl.getUniformLocation(program, 'uSaturation'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
     */
    fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Blur filter class
     * @class fabric.Image.filters.Blur
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Blur({
     *   blur: 0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     * canvas.renderAll();
     */
    filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

      type: 'Blur',

      /*
  'gl_FragColor = vec4(0.0);',
  'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
  'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
  'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
  'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
  'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
  'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
  'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
  'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
  'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
  'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
  'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
  'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
  'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
  'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
  'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
  */

      /* eslint-disable max-len */
      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec2 uDelta;\n' +
        'varying vec2 vTexCoord;\n' +
        'const float nSamples = 15.0;\n' +
        'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
        'float random(vec3 scale) {\n' +
          /* use the fragment position for a different seed per-pixel */
          'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
        '}\n' +
        'void main() {\n' +
          'vec4 color = vec4(0.0);\n' +
          'float total = 0.0;\n' +
          'float offset = random(v3offset);\n' +
          'for (float t = -nSamples; t <= nSamples; t++) {\n' +
            'float percent = (t + offset - 0.5) / nSamples;\n' +
            'float weight = 1.0 - abs(percent);\n' +
            'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
            'total += weight;\n' +
          '}\n' +
          'gl_FragColor = color / total;\n' +
        '}',
      /* eslint-enable max-len */

      /**
       * blur value, in percentage of image dimensions.
       * specific to keep the image blur constant at different resolutions
       * range bewteen 0 and 1.
       */
      blur: 0,

      mainParameter: 'blur',

      applyTo: function(options) {
        if (options.webgl) {
          // this aspectRatio is used to give the same blur to vertical and horizontal
          this.aspectRatio = options.sourceWidth / options.sourceHeight;
          options.passes++;
          this._setupFrameBuffer(options);
          this.horizontal = true;
          this.applyToWebGL(options);
          this._swapTextures(options);
          this._setupFrameBuffer(options);
          this.horizontal = false;
          this.applyToWebGL(options);
          this._swapTextures(options);
        }
        else {
          this.applyTo2d(options);
        }
      },

      applyTo2d: function(options) {
        // paint canvasEl with current image data.
        //options.ctx.putImageData(options.imageData, 0, 0);
        options.imageData = this.simpleBlur(options);
      },

      simpleBlur: function(options) {
        var resources = options.filterBackend.resources, canvas1, canvas2,
            width = options.imageData.width,
            height = options.imageData.height;

        if (!resources.blurLayer1) {
          resources.blurLayer1 = fabric.util.createCanvasElement();
          resources.blurLayer2 = fabric.util.createCanvasElement();
        }
        canvas1 = resources.blurLayer1;
        canvas2 = resources.blurLayer2;
        if (canvas1.width !== width || canvas1.height !== height) {
          canvas2.width = canvas1.width = width;
          canvas2.height = canvas1.height = height;
        }
        var ctx1 = canvas1.getContext('2d'),
            ctx2 = canvas2.getContext('2d'),
            nSamples = 15,
            random, percent, j, i,
            blur = this.blur * 0.06 * 0.5;

        // load first canvas
        ctx1.putImageData(options.imageData, 0, 0);
        ctx2.clearRect(0, 0, width, height);

        for (i = -nSamples; i <= nSamples; i++) {
          random = (Math.random() - 0.5) / 4;
          percent = i / nSamples;
          j = blur * percent * width + random;
          ctx2.globalAlpha = 1 - Math.abs(percent);
          ctx2.drawImage(canvas1, j, random);
          ctx1.drawImage(canvas2, 0, 0);
          ctx2.globalAlpha = 1;
          ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
        for (i = -nSamples; i <= nSamples; i++) {
          random = (Math.random() - 0.5) / 4;
          percent = i / nSamples;
          j = blur * percent * height + random;
          ctx2.globalAlpha = 1 - Math.abs(percent);
          ctx2.drawImage(canvas1, random, j);
          ctx1.drawImage(canvas2, 0, 0);
          ctx2.globalAlpha = 1;
          ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        }
        options.ctx.drawImage(canvas1, 0, 0);
        var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
        ctx1.globalAlpha = 1;
        ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
        return newImageData;
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          delta: gl.getUniformLocation(program, 'uDelta'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        var delta = this.chooseRightDelta();
        gl.uniform2fv(uniformLocations.delta, delta);
      },

      /**
       * choose right value of image percentage to blur with
       * @returns {Array} a numeric array with delta values
       */
      chooseRightDelta: function() {
        var blurScale = 1, delta = [0, 0], blur;
        if (this.horizontal) {
          if (this.aspectRatio > 1) {
            // image is wide, i want to shrink radius horizontal
            blurScale = 1 / this.aspectRatio;
          }
        }
        else {
          if (this.aspectRatio < 1) {
            // image is tall, i want to shrink radius vertical
            blurScale = this.aspectRatio;
          }
        }
        blur = blurScale * this.blur * 0.12;
        if (this.horizontal) {
          delta[0] = blur;
        }
        else {
          delta[1] = blur;
        }
        return delta;
      },
    });

    /**
     * Deserialize a JSON definition of a BlurFilter into a concrete instance.
     */
    filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * Gamma filter class
     * @class fabric.Image.filters.Gamma
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.Gamma({
     *   brightness: 200
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'Gamma',

      fragmentSource: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec3 uGamma;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec3 correction = (1.0 / uGamma);\n' +
          'color.r = pow(color.r, correction.r);\n' +
          'color.g = pow(color.g, correction.g);\n' +
          'color.b = pow(color.b, correction.b);\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.rgb *= color.a;\n' +
        '}',

      /**
       * Gamma array value, from 0.01 to 2.2.
       * @param {Array} gamma
       * @default
       */
      gamma: [1, 1, 1],

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'gamma',

      /**
       * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
       *
       * @param {Object} options
       * @param {ImageData} options.imageData The Uint8Array to be filtered.
       */
      applyTo2d: function(options) {
        var imageData = options.imageData, data = imageData.data,
            gamma = this.gamma, len = data.length,
            rInv = 1 / gamma[0], gInv = 1 / gamma[1],
            bInv = 1 / gamma[2], i;

        if (!this.rVals) {
          // eslint-disable-next-line
          this.rVals = new Uint8Array(256);
          // eslint-disable-next-line
          this.gVals = new Uint8Array(256);
          // eslint-disable-next-line
          this.bVals = new Uint8Array(256);
        }

        // This is an optimization - pre-compute a look-up table for each color channel
        // instead of performing these pow calls for each pixel in the image.
        for (i = 0, len = 256; i < len; i++) {
          this.rVals[i] = Math.pow(i / 255, rInv) * 255;
          this.gVals[i] = Math.pow(i / 255, gInv) * 255;
          this.bVals[i] = Math.pow(i / 255, bInv) * 255;
        }
        for (i = 0, len = data.length; i < len; i += 4) {
          data[i] = this.rVals[data[i]];
          data[i + 1] = this.gVals[data[i + 1]];
          data[i + 2] = this.bVals[data[i + 2]];
        }
      },

      /**
       * Return WebGL uniform locations for this filter's shader.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {WebGLShaderProgram} program This filter's compiled shader program.
       */
      getUniformLocations: function(gl, program) {
        return {
          uGamma: gl.getUniformLocation(program, 'uGamma'),
        };
      },

      /**
       * Send data from this filter to its shader program's uniforms.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
       * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
       */
      sendUniformData: function(gl, uniformLocations) {
        gl.uniform3fv(uniformLocations.uGamma, this.gamma);
      },
    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
     */
    fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * A container class that knows how to apply a sequence of filters to an input image.
     */
    filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

      type: 'Composed',

      /**
       * A non sparse array of filters to apply
       */
      subFilters: [],

      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(options) {
        this.callSuper('initialize', options);
        // create a new array instead mutating the prototype with push
        this.subFilters = this.subFilters.slice(0);
      },

      /**
       * Apply this container's filters to the input image provided.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be applied.
       */
      applyTo: function(options) {
        options.passes += this.subFilters.length - 1;
        this.subFilters.forEach(function(filter) {
          filter.applyTo(options);
        });
      },

      /**
       * Serialize this filter into JSON.
       *
       * @returns {Object} A JSON representation of this filter.
       */
      toObject: function() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
        });
      },
    });

    /**
     * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
     */
    fabric.Image.filters.Composed.fromObject = function(object, callback) {
      var filters = object.subFilters || [],
          subFilters = filters.map(function(filter) {
            return new fabric.Image.filters[filter.type](filter);
          }),
          instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
      callback && callback(instance);
      return instance;
    };
  })(exports);


  (function(global) {

    var fabric  = global.fabric || (global.fabric = { }),
        filters = fabric.Image.filters,
        createClass = fabric.util.createClass;

    /**
     * HueRotation filter class
     * @class fabric.Image.filters.HueRotation
     * @memberOf fabric.Image.filters
     * @extends fabric.Image.filters.BaseFilter
     * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
     * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
     * @example
     * var filter = new fabric.Image.filters.HueRotation({
     *   rotation: -0.5
     * });
     * object.filters.push(filter);
     * object.applyFilters();
     */
    filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: 'HueRotation',

      /**
       * HueRotation value, from -1 to 1.
       * the unit is radians
       * @param {Number} myParameter
       * @default
       */
      rotation: 0,

      /**
       * Describe the property that is the filter parameter
       * @param {String} m
       * @default
       */
      mainParameter: 'rotation',

      calculateMatrix: function() {
        var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
            aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
        this.matrix = [
          1, 0, 0, 0, 0,
          0, 1, 0, 0, 0,
          0, 0, 1, 0, 0,
          0, 0, 0, 1, 0
        ];
        this.matrix[0] = cos + OneMinusCos / 3;
        this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[6] = cos + aThird * OneMinusCos;
        this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
        this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
        this.matrix[12] = cos + aThird * OneMinusCos;
      },

      /**
       * Apply this filter to the input image data provided.
       *
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(options) {
        this.calculateMatrix();
        fabric.Image.filters.BaseFilter.prototype.applyTo.call(this, options);
      },

    });

    /**
     * Returns filter instance from an object representation
     * @static
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] to be invoked after filter creation
     * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
     */
    fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

  })(exports);


  (function(global) {

    var fabric = global.fabric || (global.fabric = { }),
        clone = fabric.util.object.clone;

    if (fabric.Text) {
      fabric.warn('fabric.Text is already defined');
      return;
    }

    /**
     * Text class
     * @class fabric.Text
     * @extends fabric.Object
     * @return {fabric.Text} thisArg
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
     * @see {@link fabric.Text#initialize} for constructor definition
     */
    fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

      /**
       * Properties which when set cause object to change dimensions
       * @type Array
       * @private
       */
      _dimensionAffectingProps: [
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'text',
        'charSpacing',
        'textAlign',
        'styles',
      ],

      /**
       * @private
       */
      _reNewline: /\r?\n/,

      /**
       * Use this regular expression to filter for whitespaces that is not a new line.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reSpacesAndTabs: /[ \t\r]/g,

      /**
       * Use this regular expression to filter for whitespace that is not a new line.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reSpaceAndTab: /[ \t\r]/,

      /**
       * Use this regular expression to filter consecutive groups of non spaces.
       * Mostly used when text is 'justify' aligned.
       * @private
       */
      _reWords: /\S+/g,

      /**
       * Type of an object
       * @type String
       * @default
       */
      type:                 'text',

      /**
       * Font size (in pixels)
       * @type Number
       * @default
       */
      fontSize:             40,

      /**
       * Font weight (e.g. bold, normal, 400, 600, 800)
       * @type {(Number|String)}
       * @default
       */
      fontWeight:           'normal',

      /**
       * Font family
       * @type String
       * @default
       */
      fontFamily:           'Times New Roman',

      /**
       * Text decoration underline.
       * @type String
       * @default
       */
      underline:       false,

      /**
       * Text decoration overline.
       * @type String
       * @default
       */
      overline:       false,

      /**
       * Text decoration linethrough.
       * @type String
       * @default
       */
      linethrough:       false,

      /**
       * Text alignment. Possible values: "left", "center", "right", "justify",
       * "justify-left", "justify-center" or "justify-right".
       * @type String
       * @default
       */
      textAlign:            'left',

      /**
       * Font style . Possible values: "", "normal", "italic" or "oblique".
       * @type String
       * @default
       */
      fontStyle:            'normal',

      /**
       * Line height
       * @type Number
       * @default
       */
      lineHeight:           1.16,

      /**
       * Superscript schema object (minimum overlap)
       * @type {Object}
       * @default
       */
      superscript: {
        size:      0.60, // fontSize factor
        baseline: -0.35  // baseline-shift factor (upwards)
      },

      /**
       * Subscript schema object (minimum overlap)
       * @type {Object}
       * @default
       */
      subscript: {
        size:      0.60, // fontSize factor
        baseline:  0.11  // baseline-shift factor (downwards)
      },

      /**
       * Background color of text lines
       * @type String
       * @default
       */
      textBackgroundColor:  '',

      /**
       * List of properties to consider when checking if
       * state of an object is changed ({@link fabric.Object#hasStateChanged})
       * as well as for history (undo/redo) purposes
       * @type Array
       */
      stateProperties: fabric.Object.prototype.stateProperties.concat('fontFamily',
        'fontWeight',
        'fontSize',
        'text',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'fontStyle',
        'lineHeight',
        'textBackgroundColor',
        'charSpacing',
        'styles'),

      /**
       * List of properties to consider when checking if cache needs refresh
       * @type Array
       */
      cacheProperties: fabric.Object.prototype.cacheProperties.concat('fontFamily',
        'fontWeight',
        'fontSize',
        'text',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'fontStyle',
        'lineHeight',
        'textBackgroundColor',
        'charSpacing',
        'styles'),

      /**
       * When defined, an object is rendered via stroke and this property specifies its color.
       * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
       * @type String
       * @default
       */
      stroke:               null,

      /**
       * Shadow object representing shadow of this shape.
       * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
       * @type fabric.Shadow
       * @default
       */
      shadow:               null,

      /**
       * @private
       */
      _fontSizeFraction: 0.222,

      /**
       * @private
       */
      offsets: {
        underline: 0.10,
        linethrough: -0.315,
        overline: -0.88
      },

      /**
       * Text Line proportion to font Size (in pixels)
       * @type Number
       * @default
       */
      _fontSizeMult:             1.13,

      /**
       * additional space between characters
       * expressed in thousands of em unit
       * @type Number
       * @default
       */
      charSpacing:             0,

      /**
       * Object containing character styles - top-level properties -> line numbers,
       * 2nd-level properties - charater numbers
       * @type Object
       * @default
       */
      styles: null,

      /**
       * Reference to a context to measure text char or couple of chars
       * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
       * once created it will be referenced on fabric._measuringContext to avoide creating a canvas for every
       * text object created.
       * @type {CanvasRenderingContext2D}
       * @default
       */
      _measuringContext: null,

      /**
       * Baseline shift, stlyes only, keep at 0 for the main text object
       * @type {Number}
       * @default
       */
      deltaY: 0,

      /**
       * Array of properties that define a style unit (of 'styles').
       * @type {Array}
       * @default
       */
      _styleProperties: [
        'stroke',
        'strokeWidth',
        'fill',
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'underline',
        'overline',
        'linethrough',
        'deltaY',
        'textBackgroundColor',
      ],

      /**
       * contains characters bounding boxes
       */
      __charBounds: [],

      /**
       * use this size when measuring text. To avoid IE11 rounding errors
       * @type {Number}
       * @default
       * @readonly
       * @private
       */
      CACHE_FONT_SIZE: 400,

      /**
       * contains the min text width to avoid getting 0
       * @type {Number}
       * @default
       */
      MIN_TEXT_WIDTH: 2,

      /**
       * Constructor
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.Text} thisArg
       */
      initialize: function(text, options) {
        this.styles = options ? (options.styles || { }) : { };
        this.text = text;
        this.__skipDimension = true;
        this.callSuper('initialize', options);
        this.__skipDimension = false;
        this.initDimensions();
        this.setCoords();
        this.setupState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Return a contex for measurement of text string.
       * if created it gets stored for reuse
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.Text} thisArg
       */
      getMeasuringContext: function() {
        // if we did not return we have to measure something.
        if (!fabric._measuringContext) {
          fabric._measuringContext = this.canvas && this.canvas.contextCache ||
            fabric.util.createCanvasElement().getContext('2d');
        }
        return fabric._measuringContext;
      },

      /**
       * @private
       * Divides text into lines of text and lines of graphemes.
       */
      _splitText: function() {
        var newLines = this._splitTextIntoLines(this.text);
        this.textLines = newLines.lines;
        this._textLines = newLines.graphemeLines;
        this._unwrappedTextLines = newLines._unwrappedLines;
        this._text = newLines.graphemeText;
        return newLines;
      },

      /**
       * Initialize or update text dimensions.
       * Updates this.width and this.height with the proper values.
       * Does not return dimensions.
       */
      initDimensions: function() {
        if (this.__skipDimension) {
          return;
        }
        this._splitText();
        this._clearCache();
        this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
        if (this.textAlign.indexOf('justify') !== -1) {
          // once text is measured we need to make space fatter to make justified text.
          this.enlargeSpaces();
        }
        this.height = this.calcTextHeight();
        this.saveState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Enlarge space boxes and shift the others
       */
      enlargeSpaces: function() {
        var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
            continue;
          }
          accumulatedSpace = 0;
          line = this._textLines[i];
          currentLineWidth = this.getLineWidth(i);
          if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
            numberOfSpaces = spaces.length;
            diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
            for (var j = 0, jlen = line.length; j <= jlen; j++) {
              charBound = this.__charBounds[i][j];
              if (this._reSpaceAndTab.test(line[j])) {
                charBound.width += diffSpace;
                charBound.kernedWidth += diffSpace;
                charBound.left += accumulatedSpace;
                accumulatedSpace += diffSpace;
              }
              else {
                charBound.left += accumulatedSpace;
              }
            }
          }
        }
      },

      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @return {Boolean}
       */
      isEndOfWrapping: function(lineIndex) {
        return lineIndex === this._textLines.length - 1;
      },

      /**
       * Returns string representation of an instance
       * @return {String} String representation of text object
       */
      toString: function() {
        return '#<fabric.Text (' + this.complexity() +
          '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
      },

      /**
       * Return the dimension and the zoom level needed to create a cache canvas
       * big enough to host the object to be cached.
       * @private
       * @param {Object} dim.x width of object to be cached
       * @param {Object} dim.y height of object to be cached
       * @return {Object}.width width of canvas
       * @return {Object}.height height of canvas
       * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
       * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
       */
      _getCacheCanvasDimensions: function() {
        var dims = this.callSuper('_getCacheCanvasDimensions');
        var fontSize = this.fontSize;
        dims.width += fontSize * dims.zoomX;
        dims.height += fontSize * dims.zoomY;
        return dims;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        this._setTextStyles(ctx);
        this._renderTextLinesBackground(ctx);
        this._renderTextDecoration(ctx, 'underline');
        this._renderText(ctx);
        this._renderTextDecoration(ctx, 'overline');
        this._renderTextDecoration(ctx, 'linethrough');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderText: function(ctx) {
        if (this.paintFirst === 'stroke') {
          this._renderTextStroke(ctx);
          this._renderTextFill(ctx);
        }
        else {
          this._renderTextFill(ctx);
          this._renderTextStroke(ctx);
        }
      },

      /**
       * Set the font parameter of the context with the object properties or with charStyle
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Object} [charStyle] object with font style properties
       * @param {String} [charStyle.fontFamily] Font Family
       * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
       * @param {String} [charStyle.fontWeight] Font weight
       * @param {String} [charStyle.fontStyle] Font style (italic|normal)
       */
      _setTextStyles: function(ctx, charStyle, forMeasuring) {
        ctx.textBaseline = 'alphabetic';
        ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
      },

      /**
       * calculate and return the text Width measuring each line.
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @return {Number} Maximum width of fabric.Text object
       */
      calcTextWidth: function() {
        var maxWidth = this.getLineWidth(0);

        for (var i = 1, len = this._textLines.length; i < len; i++) {
          var currentLineWidth = this.getLineWidth(i);
          if (currentLineWidth > maxWidth) {
            maxWidth = currentLineWidth;
          }
        }
        return maxWidth;
      },

      /**
       * @private
       * @param {String} method Method name ("fillText" or "strokeText")
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} line Text to render
       * @param {Number} left Left position of text
       * @param {Number} top Top position of text
       * @param {Number} lineIndex Index of a line in a text
       */
      _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
        this._renderChars(method, ctx, line, left, top, lineIndex);
      },

      /**
       * Renders the text background for lines, taking care of style
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextLinesBackground: function(ctx) {
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
          return;
        }
        var lineTopOffset = 0, heightOfLine,
            lineLeftOffset, originalFill = ctx.fillStyle,
            line, lastColor,
            leftOffset = this._getLeftOffset(),
            topOffset = this._getTopOffset(),
            boxStart = 0, boxWidth = 0, charBox, currentColor;

        for (var i = 0, len = this._textLines.length; i < len; i++) {
          heightOfLine = this.getHeightOfLine(i);
          if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
            lineTopOffset += heightOfLine;
            continue;
          }
          line = this._textLines[i];
          lineLeftOffset = this._getLineLeftOffset(i);
          boxWidth = 0;
          boxStart = 0;
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
          for (var j = 0, jlen = line.length; j < jlen; j++) {
            charBox = this.__charBounds[i][j];
            currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
            if (currentColor !== lastColor) {
              ctx.fillStyle = lastColor;
              lastColor && ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                topOffset + lineTopOffset,
                boxWidth,
                heightOfLine / this.lineHeight
              );
              boxStart = charBox.left;
              boxWidth = charBox.width;
              lastColor = currentColor;
            }
            else {
              boxWidth += charBox.kernedWidth;
            }
          }
          if (currentColor) {
            ctx.fillStyle = currentColor;
            ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              topOffset + lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
          }
          lineTopOffset += heightOfLine;
        }
        ctx.fillStyle = originalFill;
        // if there is text background color no
        // other shadows should be casted
        this._removeShadow(ctx);
      },

      /**
       * @private
       * @param {Object} decl style declaration for cache
       * @param {String} decl.fontFamily fontFamily
       * @param {String} decl.fontStyle fontStyle
       * @param {String} decl.fontWeight fontWeight
       * @return {Object} reference to cache
       */
      getFontCache: function(decl) {
        var fontFamily = decl.fontFamily.toLowerCase();
        if (!fabric.charWidthsCache[fontFamily]) {
          fabric.charWidthsCache[fontFamily] = { };
        }
        var cache = fabric.charWidthsCache[fontFamily],
            cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
        if (!cache[cacheProp]) {
          cache[cacheProp] = { };
        }
        return cache[cacheProp];
      },

      /**
       * apply all the character style to canvas for rendering
       * @private
       * @param {String} _char
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} [decl]
       */
      _applyCharStyles: function(method, ctx, lineIndex, charIndex, styleDeclaration) {

        this._setFillStyles(ctx, styleDeclaration);
        this._setStrokeStyles(ctx, styleDeclaration);

        ctx.font = this._getFontDeclaration(styleDeclaration);
      },

      /**
       * measure and return the width of a single character.
       * possibly overridden to accommodate different measure logic or
       * to hook some external lib for character measurement
       * @private
       * @param {String} char to be measured
       * @param {Object} charStyle style of char to be measured
       * @param {String} [previousChar] previous char
       * @param {Object} [prevCharStyle] style of previous char
       */
      _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
        // first i try to return from cache
        var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
            previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
            stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
            fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

        if (previousChar && fontCache[previousChar] !== undefined) {
          previousWidth = fontCache[previousChar];
        }
        if (fontCache[_char] !== undefined) {
          kernedWidth = width = fontCache[_char];
        }
        if (stylesAreEqual && fontCache[couple] !== undefined) {
          coupleWidth = fontCache[couple];
          kernedWidth = coupleWidth - previousWidth;
        }
        if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
          var ctx = this.getMeasuringContext();
          // send a TRUE to specify measuring font size CACHE_FONT_SIZE
          this._setTextStyles(ctx, charStyle, true);
        }
        if (width === undefined) {
          kernedWidth = width = ctx.measureText(_char).width;
          fontCache[_char] = width;
        }
        if (previousWidth === undefined && stylesAreEqual && previousChar) {
          previousWidth = ctx.measureText(previousChar).width;
          fontCache[previousChar] = previousWidth;
        }
        if (stylesAreEqual && coupleWidth === undefined) {
          // we can measure the kerning couple and subtract the width of the previous character
          coupleWidth = ctx.measureText(couple).width;
          fontCache[couple] = coupleWidth;
          kernedWidth = coupleWidth - previousWidth;
        }
        return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
      },

      /**
       * Computes height of character at given position
       * @param {Number} line the line number
       * @param {Number} char the character number
       * @return {Number} fontSize of the character
       */
      getHeightOfChar: function(line, char) {
        return this.getValueOfPropertyAt(line, char, 'fontSize');
      },

      /**
       * measure a text line measuring all characters.
       * @param {Number} lineIndex line number
       * @return {Number} Line width
       */
      measureLine: function(lineIndex) {
        var lineInfo = this._measureLine(lineIndex);
        if (this.charSpacing !== 0) {
          lineInfo.width -= this._getWidthOfCharSpacing();
        }
        if (lineInfo.width < 0) {
          lineInfo.width = 0;
        }
        return lineInfo;
      },

      /**
       * measure every grapheme of a line, populating __charBounds
       * @param {Number} lineIndex
       * @return {Object} object.width total width of characters
       * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
       */
      _measureLine: function(lineIndex) {
        var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
            graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length);

        this.__charBounds[lineIndex] = lineBounds;
        for (i = 0; i < line.length; i++) {
          grapheme = line[i];
          graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
          lineBounds[i] = graphemeInfo;
          width += graphemeInfo.kernedWidth;
          prevGrapheme = grapheme;
        }
        // this latest bound box represent the last character of the line
        // to simplify cursor handling in interactive mode.
        lineBounds[i] = {
          left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
          width: 0,
          kernedWidth: 0,
          height: this.fontSize
        };
        return { width: width, numOfSpaces: numOfSpaces };
      },

      /**
       * Measure and return the info of a single grapheme.
       * needs the the info of previous graphemes already filled
       * @private
       * @param {String} grapheme to be measured
       * @param {Number} lineIndex index of the line where the char is
       * @param {Number} charIndex position in the line
       * @param {String} [prevGrapheme] character preceding the one to be measured
       */
      _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
        var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
            prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
            info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
            kernedWidth = info.kernedWidth,
            width = info.width, charSpacing;

        if (this.charSpacing !== 0) {
          charSpacing = this._getWidthOfCharSpacing();
          width += charSpacing;
          kernedWidth += charSpacing;
        }

        var box = {
          width: width,
          left: 0,
          height: style.fontSize,
          kernedWidth: kernedWidth,
          deltaY: style.deltaY,
        };
        if (charIndex > 0 && !skipLeft) {
          var previousBox = this.__charBounds[lineIndex][charIndex - 1];
          box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
        }
        return box;
      },

      /**
       * Calculate height of line at 'lineIndex'
       * @param {Number} lineIndex index of line to calculate
       * @return {Number}
       */
      getHeightOfLine: function(lineIndex) {
        if (this.__lineHeights[lineIndex]) {
          return this.__lineHeights[lineIndex];
        }

        var line = this._textLines[lineIndex],
            // char 0 is measured before the line cycle because it nneds to char
            // emptylines
            maxHeight = this.getHeightOfChar(lineIndex, 0);
        for (var i = 1, len = line.length; i < len; i++) {
          maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
        }

        return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
      },

      /**
       * Calculate text box height
       */
      calcTextHeight: function() {
        var lineHeight, height = 0;
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          lineHeight = this.getHeightOfLine(i);
          height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
        }
        return height;
      },

      /**
       * @private
       * @return {Number} Left offset
       */
      _getLeftOffset: function() {
        return -this.width / 2;
      },

      /**
       * @private
       * @return {Number} Top offset
       */
      _getTopOffset: function() {
        return -this.height / 2;
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} method Method name ("fillText" or "strokeText")
       */
      _renderTextCommon: function(ctx, method) {
        ctx.save();
        var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset(),
            offsets = this._applyPatternGradientTransform(ctx, method === 'fillText' ? this.fill : this.stroke);
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          var heightOfLine = this.getHeightOfLine(i),
              maxHeight = heightOfLine / this.lineHeight,
              leftOffset = this._getLineLeftOffset(i);
          this._renderTextLine(
            method,
            ctx,
            this._textLines[i],
            left + leftOffset - offsets.offsetX,
            top + lineHeights + maxHeight - offsets.offsetY,
            i
          );
          lineHeights += heightOfLine;
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextFill: function(ctx) {
        if (!this.fill && !this.styleHas('fill')) {
          return;
        }

        this._renderTextCommon(ctx, 'fillText');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextStroke: function(ctx) {
        if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
          return;
        }

        if (this.shadow && !this.shadow.affectStroke) {
          this._removeShadow(ctx);
        }

        ctx.save();
        this._setLineDash(ctx, this.strokeDashArray);
        ctx.beginPath();
        this._renderTextCommon(ctx, 'strokeText');
        ctx.closePath();
        ctx.restore();
      },

      /**
       * @private
       * @param {String} method
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {String} line Content of the line
       * @param {Number} left
       * @param {Number} top
       * @param {Number} lineIndex
       * @param {Number} charOffset
       */
      _renderChars: function(method, ctx, line, left, top, lineIndex) {
        // set proper line offset
        var lineHeight = this.getHeightOfLine(lineIndex),
            isJustify = this.textAlign.indexOf('justify') !== -1,
            actualStyle,
            nextStyle,
            charsToRender = '',
            charBox,
            boxWidth = 0,
            timeToRender,
            shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex);

        ctx.save();
        top -= lineHeight * this._fontSizeFraction / this.lineHeight;
        if (shortCut) {
          // render all the line in one pass without checking
          this._renderChar(method, ctx, lineIndex, 0, this.textLines[lineIndex], left, top, lineHeight);
          ctx.restore();
          return;
        }
        for (var i = 0, len = line.length - 1; i <= len; i++) {
          timeToRender = i === len || this.charSpacing;
          charsToRender += line[i];
          charBox = this.__charBounds[lineIndex][i];
          if (boxWidth === 0) {
            left += charBox.kernedWidth - charBox.width;
            boxWidth += charBox.width;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
          if (isJustify && !timeToRender) {
            if (this._reSpaceAndTab.test(line[i])) {
              timeToRender = true;
            }
          }
          if (!timeToRender) {
            // if we have charSpacing, we render char by char
            actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
            nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
            timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
          }
          if (timeToRender) {
            this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
            charsToRender = '';
            actualStyle = nextStyle;
            left += boxWidth;
            boxWidth = 0;
          }
        }
        ctx.restore();
      },

      /**
       * @private
       * @param {String} method
       * @param {CanvasRenderingContext2D} ctx Context to render on
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {String} _char
       * @param {Number} left Left coordinate
       * @param {Number} top Top coordinate
       * @param {Number} lineHeight Height of the line
       */
      _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
        var decl = this._getStyleDeclaration(lineIndex, charIndex),
            fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
            shouldFill = method === 'fillText' && fullDecl.fill,
            shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;

        if (!shouldStroke && !shouldFill) {
          return;
        }
        decl && ctx.save();

        this._applyCharStyles(method, ctx, lineIndex, charIndex, fullDecl);

        if (decl && decl.textBackgroundColor) {
          this._removeShadow(ctx);
        }
        if (decl && decl.deltaY) {
          top += decl.deltaY;
        }

        shouldFill && ctx.fillText(_char, left, top);
        shouldStroke && ctx.strokeText(_char, left, top);
        decl && ctx.restore();
      },

      /**
       * Turns the character into a 'superior figure' (i.e. 'superscript')
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      setSuperscript: function(start, end) {
        return this._setScript(start, end, this.superscript);
      },

      /**
       * Turns the character into an 'inferior figure' (i.e. 'subscript')
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      setSubscript: function(start, end) {
        return this._setScript(start, end, this.subscript);
      },

      /**
       * Applies 'schema' at given position
       * @private
       * @param {Number} start selection start
       * @param {Number} end selection end
       * @param {Number} schema
       * @returns {fabric.Text} thisArg
       * @chainable
       */
      _setScript: function(start, end, schema) {
        var loc = this.get2DCursorLocation(start, true),
            fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
            dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
            style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
        this.setSelectionStyles(style, start, end);
        return this;
      },

      /**
       * @private
       * @param {Object} prevStyle
       * @param {Object} thisStyle
       */
      _hasStyleChanged: function(prevStyle, thisStyle) {
        return prevStyle.fill !== thisStyle.fill ||
                prevStyle.stroke !== thisStyle.stroke ||
                prevStyle.strokeWidth !== thisStyle.strokeWidth ||
                prevStyle.fontSize !== thisStyle.fontSize ||
                prevStyle.fontFamily !== thisStyle.fontFamily ||
                prevStyle.fontWeight !== thisStyle.fontWeight ||
                prevStyle.fontStyle !== thisStyle.fontStyle ||
                prevStyle.deltaY !== thisStyle.deltaY;
      },

      /**
       * @private
       * @param {Object} prevStyle
       * @param {Object} thisStyle
       */
      _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
        return this._hasStyleChanged(prevStyle, thisStyle) ||
          prevStyle.overline !== thisStyle.overline ||
          prevStyle.underline !== thisStyle.underline ||
          prevStyle.linethrough !== thisStyle.linethrough;
      },

      /**
       * @private
       * @param {Number} lineIndex index text line
       * @return {Number} Line left offset
       */
      _getLineLeftOffset: function(lineIndex) {
        var lineWidth = this.getLineWidth(lineIndex);
        if (this.textAlign === 'center') {
          return (this.width - lineWidth) / 2;
        }
        if (this.textAlign === 'right') {
          return this.width - lineWidth;
        }
        if (this.textAlign === 'justify-center' && this.isEndOfWrapping(lineIndex)) {
          return (this.width - lineWidth) / 2;
        }
        if (this.textAlign === 'justify-right' && this.isEndOfWrapping(lineIndex)) {
          return this.width - lineWidth;
        }
        return 0;
      },

      /**
       * @private
       */
      _clearCache: function() {
        this.__lineWidths = [];
        this.__lineHeights = [];
        this.__charBounds = [];
      },

      /**
       * @private
       */
      _shouldClearDimensionCache: function() {
        var shouldClear = this._forceClearCache;
        shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
        if (shouldClear) {
          this.dirty = true;
          this._forceClearCache = false;
        }
        return shouldClear;
      },

      /**
       * Measure a single line given its index. Used to calculate the initial
       * text bounding box. The values are calculated and stored in __lineWidths cache.
       * @private
       * @param {Number} lineIndex line number
       * @return {Number} Line width
       */
      getLineWidth: function(lineIndex) {
        if (this.__lineWidths[lineIndex]) {
          return this.__lineWidths[lineIndex];
        }

        var width, line = this._textLines[lineIndex], lineInfo;

        if (line === '') {
          width = 0;
        }
        else {
          lineInfo = this.measureLine(lineIndex);
          width = lineInfo.width;
        }
        this.__lineWidths[lineIndex] = width;
        return width;
      },

      _getWidthOfCharSpacing: function() {
        if (this.charSpacing !== 0) {
          return this.fontSize * this.charSpacing / 1000;
        }
        return 0;
      },

      /**
       * Retrieves the value of property at given character position
       * @param {Number} lineIndex the line number
       * @param {Number} charIndex the charater number
       * @param {String} property the property name
       * @returns the value of 'property'
       */
      getValueOfPropertyAt: function(lineIndex, charIndex, property) {
        var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
        if (charStyle && typeof charStyle[property] !== 'undefined') {
          return charStyle[property];
        }
        return this[property];
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _renderTextDecoration: function(ctx, type) {
        if (!this[type] && !this.styleHas(type)) {
          return;
        }
        var heightOfLine, size, _size,
            lineLeftOffset, dy, _dy,
            line, lastDecoration,
            leftOffset = this._getLeftOffset(),
            topOffset = this._getTopOffset(), top,
            boxStart, boxWidth, charBox, currentDecoration,
            maxHeight, currentFill, lastFill,
            charSpacing = this._getWidthOfCharSpacing();

        for (var i = 0, len = this._textLines.length; i < len; i++) {
          heightOfLine = this.getHeightOfLine(i);
          if (!this[type] && !this.styleHas(type, i)) {
            topOffset += heightOfLine;
            continue;
          }
          line = this._textLines[i];
          maxHeight = heightOfLine / this.lineHeight;
          lineLeftOffset = this._getLineLeftOffset(i);
          boxStart = 0;
          boxWidth = 0;
          lastDecoration = this.getValueOfPropertyAt(i, 0, type);
          lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
          top = topOffset + maxHeight * (1 - this._fontSizeFraction);
          size = this.getHeightOfChar(i, 0);
          dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
          for (var j = 0, jlen = line.length; j < jlen; j++) {
            charBox = this.__charBounds[i][j];
            currentDecoration = this.getValueOfPropertyAt(i, j, type);
            currentFill = this.getValueOfPropertyAt(i, j, 'fill');
            _size = this.getHeightOfChar(i, j);
            _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
            if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) &&
                boxWidth > 0) {
              ctx.fillStyle = lastFill;
              lastDecoration && lastFill && ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                top + this.offsets[type] * size + dy,
                boxWidth,
                this.fontSize / 15
              );
              boxStart = charBox.left;
              boxWidth = charBox.width;
              lastDecoration = currentDecoration;
              lastFill = currentFill;
              size = _size;
              dy = _dy;
            }
            else {
              boxWidth += charBox.kernedWidth;
            }
          }
          ctx.fillStyle = currentFill;
          currentDecoration && currentFill && ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            top + this.offsets[type] * size + dy,
            boxWidth - charSpacing,
            this.fontSize / 15
          );
          topOffset += heightOfLine;
        }
        // if there is text background color no
        // other shadows should be casted
        this._removeShadow(ctx);
      },

      /**
       * return font declaration string for canvas context
       * @param {Object} [styleObject] object
       * @returns {String} font declaration formatted for canvas context.
       */
      _getFontDeclaration: function(styleObject, forMeasuring) {
        var style = styleObject || this, family = this.fontFamily,
            fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
        var fontFamily = family === undefined ||
        family.indexOf('\'') > -1 ||
        family.indexOf('"') > -1 || fontIsGeneric
          ? style.fontFamily : '"' + style.fontFamily + '"';
        return [
          // node-canvas needs "weight style", while browsers need "style weight"
          (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
          (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
          forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
          fontFamily
        ].join(' ');
      },

      /**
       * Renders text instance on a specified context
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        // do not render if object is not visible
        if (!this.visible) {
          return;
        }
        if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
          return;
        }
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
        }
        this.callSuper('render', ctx);
      },

      /**
       * Returns the text as an array of lines.
       * @param {String} text text to split
       * @returns {Array} Lines in the text
       */
      _splitTextIntoLines: function(text) {
        var lines = text.split(this._reNewline),
            newLines = new Array(lines.length),
            newLine = ['\n'],
            newText = [];
        for (var i = 0; i < lines.length; i++) {
          newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
          newText = newText.concat(newLines[i], newLine);
        }
        newText.pop();
        return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
      },

      /**
       * Returns object representation of an instance
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} Object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        var additionalProperties = [
          'text',
          'fontSize',
          'fontWeight',
          'fontFamily',
          'fontStyle',
          'lineHeight',
          'underline',
          'overline',
          'linethrough',
          'textAlign',
          'textBackgroundColor',
          'charSpacing',
        ].concat(propertiesToInclude);
        var obj = this.callSuper('toObject', additionalProperties);
        obj.styles = clone(this.styles, true);
        return obj;
      },

      /**
       * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
       * @param {String|Object} key Property name or object (if object, iterate over the object properties)
       * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      set: function(key, value) {
        this.callSuper('set', key, value);
        var needsDims = false;
        if (typeof key === 'object') {
          for (var _key in key) {
            needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
          }
        }
        else {
          needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
        }
        if (needsDims) {
          this.initDimensions();
          this.setCoords();
        }
        return this;
      },

      /**
       * Returns complexity of an instance
       * @return {Number} complexity
       */
      complexity: function() {
        return 1;
      }
    });

    /* _FROM_SVG_START_ */
    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
     * @static
     * @memberOf fabric.Text
     * @see: http://www.w3.org/TR/SVG/text.html#TextElement
     */
    fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
      'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

    /**
     * Default SVG font size
     * @static
     * @memberOf fabric.Text
     */
    fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

    /**
     * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
     * @static
     * @memberOf fabric.Text
     * @param {SVGElement} element Element to parse
     * @param {Function} callback callback function invoked after parsing
     * @param {Object} [options] Options object
     */
    fabric.Text.fromElement = function(element, callback, options) {
      if (!element) {
        return callback(null);
      }

      var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
          parsedAnchor = parsedAttributes.textAnchor || 'left';
      options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

      options.top = options.top || 0;
      options.left = options.left || 0;
      if (parsedAttributes.textDecoration) {
        var textDecoration = parsedAttributes.textDecoration;
        if (textDecoration.indexOf('underline') !== -1) {
          options.underline = true;
        }
        if (textDecoration.indexOf('overline') !== -1) {
          options.overline = true;
        }
        if (textDecoration.indexOf('line-through') !== -1) {
          options.linethrough = true;
        }
        delete options.textDecoration;
      }
      if ('dx' in parsedAttributes) {
        options.left += parsedAttributes.dx;
      }
      if ('dy' in parsedAttributes) {
        options.top += parsedAttributes.dy;
      }
      if (!('fontSize' in options)) {
        options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }

      var textContent = '';

      // The XML is not properly parsed in IE9 so a workaround to get
      // textContent is through firstChild.data. Another workaround would be
      // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
      if (!('textContent' in element)) {
        if ('firstChild' in element && element.firstChild !== null) {
          if ('data' in element.firstChild && element.firstChild.data !== null) {
            textContent = element.firstChild.data;
          }
        }
      }
      else {
        textContent = element.textContent;
      }

      textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
      var originalStrokeWidth = options.strokeWidth;
      options.strokeWidth = 0;

      var text = new fabric.Text(textContent, options),
          textHeightScaleFactor = text.getScaledHeight() / text.height,
          lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
          scaledDiff = lineHeightDiff * textHeightScaleFactor,
          textHeight = text.getScaledHeight() + scaledDiff,
          offX = 0;
      /*
        Adjust positioning:
          x/y attributes in SVG correspond to the bottom-left corner of text bounding box
          fabric output by default at top, left.
      */
      if (parsedAnchor === 'center') {
        offX = text.getScaledWidth() / 2;
      }
      if (parsedAnchor === 'right') {
        offX = text.getScaledWidth();
      }
      text.set({
        left: text.left - offX,
        top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
        strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
      });
      callback(text);
    };
    /* _FROM_SVG_END_ */

    /**
     * Returns fabric.Text instance from an object representation
     * @static
     * @memberOf fabric.Text
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
     */
    fabric.Text.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Text', object, callback, 'text');
    };

    fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

  })(exports);


  (function() {
    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(lineIndex) {
        if (!this.styles) {
          return true;
        }
        if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
          return true;
        }
        var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        for (var p1 in obj) {
          for (var p2 in obj[p1]) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
        return true;
      },

      /**
       * Returns true if object has a style property or has it ina specified line
       * @param {Number} lineIndex
       * @return {Boolean}
       */
      styleHas: function(property, lineIndex) {
        if (!this.styles || !property || property === '') {
          return false;
        }
        if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
          return false;
        }
        var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        // eslint-disable-next-line
        for (var p1 in obj) {
          // eslint-disable-next-line
          for (var p2 in obj[p1]) {
            if (typeof obj[p1][p2][property] !== 'undefined') {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * Check if characters in a text have a value for a property
       * whose value matches the textbox's value for that property.  If so,
       * the character-level property is deleted.  If the character
       * has no other properties, then it is also deleted.  Finally,
       * if the line containing that character has no other characters
       * then it also is deleted.
       *
       * @param {string} property The property to compare between characters and text.
       */
      cleanStyle: function(property) {
        if (!this.styles || !property || property === '') {
          return false;
        }
        var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
            allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
        // eslint-disable-next-line
        for (var p1 in obj) {
          letterCount = 0;
          // eslint-disable-next-line
          for (var p2 in obj[p1]) {
            var styleObject = obj[p1][p2],
                stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

            stylesCount++;

            if (stylePropertyHasBeenSet) {
              if (!stylePropertyValue) {
                stylePropertyValue = styleObject[property];
              }
              else if (styleObject[property] !== stylePropertyValue) {
                allStyleObjectPropertiesMatch = false;
              }

              if (styleObject[property] === this[property]) {
                delete styleObject[property];
              }
            }
            else {
              allStyleObjectPropertiesMatch = false;
            }

            if (Object.keys(styleObject).length !== 0) {
              letterCount++;
            }
            else {
              delete obj[p1][p2];
            }
          }

          if (letterCount === 0) {
            delete obj[p1];
          }
        }
        // if every grapheme has the same style set then
        // delete those styles and set it on the parent
        for (var i = 0; i < this._textLines.length; i++) {
          graphemeCount += this._textLines[i].length;
        }
        if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
          this[property] = stylePropertyValue;
          this.removeStyle(property);
        }
      },

      /**
       * Remove a style property or properties from all individual character styles
       * in a text object.  Deletes the character style object if it contains no other style
       * props.  Deletes a line style object if it contains no other character styles.
       *
       * @param {String} props The property to remove from character styles.
       */
      removeStyle: function(property) {
        if (!this.styles || !property || property === '') {
          return;
        }
        var obj = this.styles, line, lineNum, charNum;
        for (lineNum in obj) {
          line = obj[lineNum];
          for (charNum in line) {
            delete line[charNum][property];
            if (Object.keys(line[charNum]).length === 0) {
              delete line[charNum];
            }
          }
          if (Object.keys(line).length === 0) {
            delete obj[lineNum];
          }
        }
      },

      /**
       * @private
       */
      _extendStyles: function(index, styles) {
        var loc = this.get2DCursorLocation(index);

        if (!this._getLineStyle(loc.lineIndex)) {
          this._setLineStyle(loc.lineIndex, {});
        }

        if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
          this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
        }

        fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
      },

      /**
       * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
       * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
       * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. usefull to manage styles.
       */
      get2DCursorLocation: function(selectionStart, skipWrapping) {
        if (typeof selectionStart === 'undefined') {
          selectionStart = this.selectionStart;
        }
        var lines = skipWrapping ? this._unwrappedTextLines : this._textLines;
        var len = lines.length;
        for (var i = 0; i < len; i++) {
          if (selectionStart <= lines[i].length) {
            return {
              lineIndex: i,
              charIndex: selectionStart
            };
          }
          selectionStart -= lines[i].length + 1;
        }
        return {
          lineIndex: i - 1,
          charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
        };
      },

      /**
       * Gets style of a current selection/cursor (at the start position)
       * if startIndex or endIndex are not provided, slectionStart or selectionEnd will be used.
       * @param {Number} [startIndex] Start index to get styles at
       * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
       * @param {Boolean} [complete] get full style or not
       * @return {Array} styles an array with one, zero or more Style objects
       */
      getSelectionStyles: function(startIndex, endIndex, complete) {
        if (typeof startIndex === 'undefined') {
          startIndex = this.selectionStart || 0;
        }
        if (typeof endIndex === 'undefined') {
          endIndex = this.selectionEnd || startIndex;
        }
        var styles = [];
        for (var i = startIndex; i < endIndex; i++) {
          styles.push(this.getStyleAtPosition(i, complete));
        }
        return styles;
      },

      /**
       * Gets style of a current selection/cursor position
       * @param {Number} position  to get styles at
       * @param {Boolean} [complete] full style if true
       * @return {Object} style Style object at a specified index
       * @private
       */
      getStyleAtPosition: function(position, complete) {
        var loc = this.get2DCursorLocation(position),
            style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
              this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
        return style || {};
      },

      /**
       * Sets style of a current selection, if no selection exist, do not set anything.
       * @param {Object} [styles] Styles object
       * @param {Number} [startIndex] Start index to get styles at
       * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
       * @return {fabric.IText} thisArg
       * @chainable
       */
      setSelectionStyles: function(styles, startIndex, endIndex) {
        if (typeof startIndex === 'undefined') {
          startIndex = this.selectionStart || 0;
        }
        if (typeof endIndex === 'undefined') {
          endIndex = this.selectionEnd || startIndex;
        }
        for (var i = startIndex; i < endIndex; i++) {
          this._extendStyles(i, styles);
        }
        /* not included in _extendStyles to avoid clearing cache more than once */
        this._forceClearCache = true;
        return this;
      },

      /**
       * get the reference, not a clone, of the style object for a given character
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @return {Object} style object
       */
      _getStyleDeclaration: function(lineIndex, charIndex) {
        var lineStyle = this.styles && this.styles[lineIndex];
        if (!lineStyle) {
          return null;
        }
        return lineStyle[charIndex];
      },

      /**
       * return a new object that contains all the style property for a character
       * the object returned is newly created
       * @param {Number} lineIndex of the line where the character is
       * @param {Number} charIndex position of the character on the line
       * @return {Object} style object
       */
      getCompleteStyleDeclaration: function(lineIndex, charIndex) {
        var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
            styleObject = { }, prop;
        for (var i = 0; i < this._styleProperties.length; i++) {
          prop = this._styleProperties[i];
          styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
        }
        return styleObject;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(lineIndex, charIndex, style) {
        this.styles[lineIndex][charIndex] = style;
      },

      /**
       *
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(lineIndex, charIndex) {
        delete this.styles[lineIndex][charIndex];
      },

      /**
       * @param {Number} lineIndex
       * @private
       */
      _getLineStyle: function(lineIndex) {
        return this.styles[lineIndex];
      },

      /**
       * @param {Number} lineIndex
       * @param {Object} style
       * @private
       */
      _setLineStyle: function(lineIndex, style) {
        this.styles[lineIndex] = style;
      },

      /**
       * @param {Number} lineIndex
       * @private
       */
      _deleteLineStyle: function(lineIndex) {
        delete this.styles[lineIndex];
      }
    });
  })();


  (function() {

    function parseDecoration(object) {
      if (object.textDecoration) {
        object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
        object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
        object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
        delete object.textDecoration;
      }
    }

    /**
     * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
     * prefix when observing canvas.
     * @class fabric.IText
     * @extends fabric.Text
     * @mixes fabric.Observable
     *
     * @fires changed
     * @fires selection:changed
     * @fires editing:entered
     * @fires editing:exited
     *
     * @return {fabric.IText} thisArg
     * @see {@link fabric.IText#initialize} for constructor definition
     *
     * <p>Supported key combinations:</p>
     * <pre>
     *   Move cursor:                    left, right, up, down
     *   Select character:               shift + left, shift + right
     *   Select text vertically:         shift + up, shift + down
     *   Move cursor by word:            alt + left, alt + right
     *   Select words:                   shift + alt + left, shift + alt + right
     *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
     *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
     *   Jump to start/end of text:      cmd + up, cmd + down
     *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
     *   Delete character:               backspace
     *   Delete word:                    alt + backspace
     *   Delete line:                    cmd + backspace
     *   Forward delete:                 delete
     *   Copy text:                      ctrl/cmd + c
     *   Paste text:                     ctrl/cmd + v
     *   Cut text:                       ctrl/cmd + x
     *   Select entire text:             ctrl/cmd + a
     *   Quit editing                    tab or esc
     * </pre>
     *
     * <p>Supported mouse/touch combination</p>
     * <pre>
     *   Position cursor:                click/touch
     *   Create selection:               click/touch & drag
     *   Create selection:               click & shift + click
     *   Select word:                    double click
     *   Select line:                    triple click
     * </pre>
     */
    fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'i-text',

      /**
       * Index where text selection starts (or where cursor is when there is no selection)
       * @type Number
       * @default
       */
      selectionStart: 0,

      /**
       * Index where text selection ends
       * @type Number
       * @default
       */
      selectionEnd: 0,

      /**
       * Color of text selection
       * @type String
       * @default
       */
      selectionColor: 'rgba(17,119,255,0.3)',

      /**
       * Indicates whether text is in editing mode
       * @type Boolean
       * @default
       */
      isEditing: false,

      /**
       * Indicates whether a text can be edited
       * @type Boolean
       * @default
       */
      editable: true,

      /**
       * Border color of text object while it's in editing mode
       * @type String
       * @default
       */
      editingBorderColor: 'rgba(102,153,255,0.25)',

      /**
       * Width of cursor (in px)
       * @type Number
       * @default
       */
      cursorWidth: 2,

      /**
       * Color of default cursor (when not overwritten by character style)
       * @type String
       * @default
       */
      cursorColor: '#333',

      /**
       * Delay between cursor blink (in ms)
       * @type Number
       * @default
       */
      cursorDelay: 1000,

      /**
       * Duration of cursor fadein (in ms)
       * @type Number
       * @default
       */
      cursorDuration: 600,

      /**
       * Indicates whether internal text char widths can be cached
       * @type Boolean
       * @default
       */
      caching: true,

      /**
       * @private
       */
      _reSpace: /\s|\n/,

      /**
       * @private
       */
      _currentCursorOpacity: 0,

      /**
       * @private
       */
      _selectionDirection: null,

      /**
       * @private
       */
      _abortCursorAnimation: false,

      /**
       * @private
       */
      __widthOfSpace: [],

      /**
       * Helps determining when the text is in composition, so that the cursor
       * rendering is altered.
       */
      inCompositionMode: false,

      /**
       * Constructor
       * @param {String} text Text string
       * @param {Object} [options] Options object
       * @return {fabric.IText} thisArg
       */
      initialize: function(text, options) {
        this.callSuper('initialize', text, options);
        this.initBehavior();
      },

      /**
       * Sets selection start (left boundary of a selection)
       * @param {Number} index Index to set selection start to
       */
      setSelectionStart: function(index) {
        index = Math.max(index, 0);
        this._updateAndFire('selectionStart', index);
      },

      /**
       * Sets selection end (right boundary of a selection)
       * @param {Number} index Index to set selection end to
       */
      setSelectionEnd: function(index) {
        index = Math.min(index, this.text.length);
        this._updateAndFire('selectionEnd', index);
      },

      /**
       * @private
       * @param {String} property 'selectionStart' or 'selectionEnd'
       * @param {Number} index new position of property
       */
      _updateAndFire: function(property, index) {
        if (this[property] !== index) {
          this._fireSelectionChanged();
          this[property] = index;
        }
        this._updateTextarea();
      },

      /**
       * Fires the even of selection changed
       * @private
       */
      _fireSelectionChanged: function() {
        this.fire('selection:changed');
        this.canvas && this.canvas.fire('text:selection:changed', { target: this });
      },

      /**
       * Initialize text dimensions. Render all text on given context
       * or on a offscreen canvas to get the text width with measureText.
       * Updates this.width and this.height with the proper values.
       * Does not return dimensions.
       * @private
       */
      initDimensions: function() {
        this.isEditing && this.initDelayedCursor();
        this.clearContextTop();
        this.callSuper('initDimensions');
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      render: function(ctx) {
        this.clearContextTop();
        this.callSuper('render', ctx);
        // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
        // the correct position but not at every cursor animation.
        this.cursorOffsetCache = { };
        this.renderCursorOrSelection();
      },

      /**
       * @private
       * @param {CanvasRenderingContext2D} ctx Context to render on
       */
      _render: function(ctx) {
        this.callSuper('_render', ctx);
      },

      /**
       * Prepare and clean the contextTop
       */
      clearContextTop: function(skipRestore) {
        if (!this.isEditing) {
          return;
        }
        if (this.canvas && this.canvas.contextTop) {
          var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
          ctx.save();
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
          this.transform(ctx);
          this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
          this._clearTextArea(ctx);
          skipRestore || ctx.restore();
        }
      },

      /**
       * Renders cursor or selection (depending on what exists)
       */
      renderCursorOrSelection: function() {
        if (!this.isEditing || !this.canvas) {
          return;
        }
        var boundaries = this._getCursorBoundaries(), ctx;
        if (this.canvas && this.canvas.contextTop) {
          ctx = this.canvas.contextTop;
          this.clearContextTop(true);
        }
        else {
          ctx = this.canvas.contextContainer;
          ctx.save();
        }
        if (this.selectionStart === this.selectionEnd) {
          this.renderCursor(boundaries, ctx);
        }
        else {
          this.renderSelection(boundaries, ctx);
        }
        ctx.restore();
      },

      _clearTextArea: function(ctx) {
        // we add 4 pixel, to be sure to do not leave any pixel out
        var width = this.width + 4, height = this.height + 4;
        ctx.clearRect(-width / 2, -height / 2, width, height);
      },

      /**
       * Returns cursor boundaries (left, top, leftOffset, topOffset)
       * @private
       * @param {Array} chars Array of characters
       * @param {String} typeOfBoundaries
       */
      _getCursorBoundaries: function(position) {

        // left/top are left/top of entire text box
        // leftOffset/topOffset are offset from that left/top point of a text box

        if (typeof position === 'undefined') {
          position = this.selectionStart;
        }

        var left = this._getLeftOffset(),
            top = this._getTopOffset(),
            offsets = this._getCursorBoundariesOffsets(position);

        return {
          left: left,
          top: top,
          leftOffset: offsets.left,
          topOffset: offsets.top
        };
      },

      /**
       * @private
       */
      _getCursorBoundariesOffsets: function(position) {
        if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
          return this.cursorOffsetCache;
        }
        var lineLeftOffset,
            lineIndex,
            charIndex,
            topOffset = 0,
            leftOffset = 0,
            boundaries,
            cursorPosition = this.get2DCursorLocation(position);
        charIndex = cursorPosition.charIndex;
        lineIndex = cursorPosition.lineIndex;
        for (var i = 0; i < lineIndex; i++) {
          topOffset += this.getHeightOfLine(i);
        }
        lineLeftOffset = this._getLineLeftOffset(lineIndex);
        var bound = this.__charBounds[lineIndex][charIndex];
        bound && (leftOffset = bound.left);
        if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
          leftOffset -= this._getWidthOfCharSpacing();
        }
        boundaries = {
          top: topOffset,
          left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
        };
        this.cursorOffsetCache = boundaries;
        return this.cursorOffsetCache;
      },

      /**
       * Renders cursor
       * @param {Object} boundaries
       * @param {CanvasRenderingContext2D} ctx transformed context to draw on
       */
      renderCursor: function(boundaries, ctx) {
        var cursorLocation = this.get2DCursorLocation(),
            lineIndex = cursorLocation.lineIndex,
            charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
            charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
            multiplier = this.scaleX * this.canvas.getZoom(),
            cursorWidth = this.cursorWidth / multiplier,
            topOffset = boundaries.topOffset,
            dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');

        topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
          - charHeight * (1 - this._fontSizeFraction);

        if (this.inCompositionMode) {
          this.renderSelection(boundaries, ctx);
        }

        ctx.fillStyle = this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
        ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
        ctx.fillRect(
          boundaries.left + boundaries.leftOffset - cursorWidth / 2,
          topOffset + boundaries.top + dy,
          cursorWidth,
          charHeight);
      },

      /**
       * Renders text selection
       * @param {Object} boundaries Object with left/top/leftOffset/topOffset
       * @param {CanvasRenderingContext2D} ctx transformed context to draw on
       */
      renderSelection: function(boundaries, ctx) {

        var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
            selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
            isJustify = this.textAlign.indexOf('justify') !== -1,
            start = this.get2DCursorLocation(selectionStart),
            end = this.get2DCursorLocation(selectionEnd),
            startLine = start.lineIndex,
            endLine = end.lineIndex,
            startChar = start.charIndex < 0 ? 0 : start.charIndex,
            endChar = end.charIndex < 0 ? 0 : end.charIndex;

        for (var i = startLine; i <= endLine; i++) {
          var lineOffset = this._getLineLeftOffset(i) || 0,
              lineHeight = this.getHeightOfLine(i),
              realLineHeight = 0, boxStart = 0, boxEnd = 0;

          if (i === startLine) {
            boxStart = this.__charBounds[startLine][startChar].left;
          }
          if (i >= startLine && i < endLine) {
            boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
          }
          else if (i === endLine) {
            if (endChar === 0) {
              boxEnd = this.__charBounds[endLine][endChar].left;
            }
            else {
              var charSpacing = this._getWidthOfCharSpacing();
              boxEnd = this.__charBounds[endLine][endChar - 1].left
                + this.__charBounds[endLine][endChar - 1].width - charSpacing;
            }
          }
          realLineHeight = lineHeight;
          if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
            lineHeight /= this.lineHeight;
          }
          if (this.inCompositionMode) {
            ctx.fillStyle = this.compositionColor || 'black';
            ctx.fillRect(
              boundaries.left + lineOffset + boxStart,
              boundaries.top + boundaries.topOffset + lineHeight,
              boxEnd - boxStart,
              1);
          }
          else {
            ctx.fillStyle = this.selectionColor;
            ctx.fillRect(
              boundaries.left + lineOffset + boxStart,
              boundaries.top + boundaries.topOffset,
              boxEnd - boxStart,
              lineHeight);
          }


          boundaries.topOffset += realLineHeight;
        }
      },

      /**
       * High level function to know the height of the cursor.
       * the currentChar is the one that precedes the cursor
       * Returns fontSize of char at the current cursor
       * @return {Number} Character font size
       */
      getCurrentCharFontSize: function() {
        var cp = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
      },

      /**
       * High level function to know the color of the cursor.
       * the currentChar is the one that precedes the cursor
       * Returns color (fill) of char at the current cursor
       * @return {String} Character color (fill)
       */
      getCurrentCharColor: function() {
        var cp = this._getCurrentCharIndex();
        return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
      },

      /**
       * Returns the cursor position for the getCurrent.. functions
       * @private
       */
      _getCurrentCharIndex: function() {
        var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
            charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
        return { l: cursorPosition.lineIndex, c: charIndex };
      }
    });

    /**
     * Returns fabric.IText instance from an object representation
     * @static
     * @memberOf fabric.IText
     * @param {Object} object Object to create an instance from
     * @param {function} [callback] invoked with new instance as argument
     */
    fabric.IText.fromObject = function(object, callback) {
      parseDecoration(object);
      if (object.styles) {
        for (var i in object.styles) {
          for (var j in object.styles[i]) {
            parseDecoration(object.styles[i][j]);
          }
        }
      }
      fabric.Object._fromObject('IText', object, callback, 'text');
    };
  })();


  (function() {

    var clone = fabric.util.object.clone;

    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

      /**
       * Initializes all the interactive behavior of IText
       */
      initBehavior: function() {
        this.initAddedHandler();
        this.initRemovedHandler();
        this.initCursorSelectionHandlers();
        this.initDoubleClickSimulation();
        this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
      },

      onDeselect: function() {
        this.isEditing && this.exitEditing();
        this.selected = false;
      },

      /**
       * Initializes "added" event handler
       */
      initAddedHandler: function() {
        var _this = this;
        this.on('added', function() {
          var canvas = _this.canvas;
          if (canvas) {
            if (!canvas._hasITextHandlers) {
              canvas._hasITextHandlers = true;
              _this._initCanvasHandlers(canvas);
            }
            canvas._iTextInstances = canvas._iTextInstances || [];
            canvas._iTextInstances.push(_this);
          }
        });
      },

      initRemovedHandler: function() {
        var _this = this;
        this.on('removed', function() {
          var canvas = _this.canvas;
          if (canvas) {
            canvas._iTextInstances = canvas._iTextInstances || [];
            fabric.util.removeFromArray(canvas._iTextInstances, _this);
            if (canvas._iTextInstances.length === 0) {
              canvas._hasITextHandlers = false;
              _this._removeCanvasHandlers(canvas);
            }
          }
        });
      },

      /**
       * register canvas event to manage exiting on other instances
       * @private
       */
      _initCanvasHandlers: function(canvas) {
        canvas._mouseUpITextHandler = function() {
          if (canvas._iTextInstances) {
            canvas._iTextInstances.forEach(function(obj) {
              obj.__isMousedown = false;
            });
          }
        };
        canvas.on('mouse:up', canvas._mouseUpITextHandler);
      },

      /**
       * remove canvas event to manage exiting on other instances
       * @private
       */
      _removeCanvasHandlers: function(canvas) {
        canvas.off('mouse:up', canvas._mouseUpITextHandler);
      },

      /**
       * @private
       */
      _tick: function() {
        this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
      },

      /**
       * @private
       */
      _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

        var tickState;

        tickState = {
          isAborted: false,
          abort: function() {
            this.isAborted = true;
          },
        };

        obj.animate('_currentCursorOpacity', targetOpacity, {
          duration: duration,
          onComplete: function() {
            if (!tickState.isAborted) {
              obj[completeMethod]();
            }
          },
          onChange: function() {
            // we do not want to animate a selection, only cursor
            if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
              obj.renderCursorOrSelection();
            }
          },
          abort: function() {
            return tickState.isAborted;
          }
        });
        return tickState;
      },

      /**
       * @private
       */
      _onTickComplete: function() {

        var _this = this;

        if (this._cursorTimeout1) {
          clearTimeout(this._cursorTimeout1);
        }
        this._cursorTimeout1 = setTimeout(function() {
          _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
        }, 100);
      },

      /**
       * Initializes delayed cursor
       */
      initDelayedCursor: function(restart) {
        var _this = this,
            delay = restart ? 0 : this.cursorDelay;

        this.abortCursorAnimation();
        this._currentCursorOpacity = 1;
        this._cursorTimeout2 = setTimeout(function() {
          _this._tick();
        }, delay);
      },

      /**
       * Aborts cursor animation and clears all timeouts
       */
      abortCursorAnimation: function() {
        var shouldClear = this._currentTickState || this._currentTickCompleteState,
            canvas = this.canvas;
        this._currentTickState && this._currentTickState.abort();
        this._currentTickCompleteState && this._currentTickCompleteState.abort();

        clearTimeout(this._cursorTimeout1);
        clearTimeout(this._cursorTimeout2);

        this._currentCursorOpacity = 0;
        // to clear just itext area we need to transform the context
        // it may not be worth it
        if (shouldClear && canvas) {
          canvas.clearContext(canvas.contextTop || canvas.contextContainer);
        }

      },

      /**
       * Selects entire text
       * @return {fabric.IText} thisArg
       * @chainable
       */
      selectAll: function() {
        this.selectionStart = 0;
        this.selectionEnd = this._text.length;
        this._fireSelectionChanged();
        this._updateTextarea();
        return this;
      },

      /**
       * Returns selected text
       * @return {String}
       */
      getSelectedText: function() {
        return this._text.slice(this.selectionStart, this.selectionEnd).join('');
      },

      /**
       * Find new selection index representing start of current word according to current selection index
       * @param {Number} startFrom Surrent selection index
       * @return {Number} New selection index
       */
      findWordBoundaryLeft: function(startFrom) {
        var offset = 0, index = startFrom - 1;

        // remove space before cursor first
        if (this._reSpace.test(this._text[index])) {
          while (this._reSpace.test(this._text[index])) {
            offset++;
            index--;
          }
        }
        while (/\S/.test(this._text[index]) && index > -1) {
          offset++;
          index--;
        }

        return startFrom - offset;
      },

      /**
       * Find new selection index representing end of current word according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findWordBoundaryRight: function(startFrom) {
        var offset = 0, index = startFrom;

        // remove space after cursor first
        if (this._reSpace.test(this._text[index])) {
          while (this._reSpace.test(this._text[index])) {
            offset++;
            index++;
          }
        }
        while (/\S/.test(this._text[index]) && index < this.text.length) {
          offset++;
          index++;
        }

        return startFrom + offset;
      },

      /**
       * Find new selection index representing start of current line according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findLineBoundaryLeft: function(startFrom) {
        var offset = 0, index = startFrom - 1;

        while (!/\n/.test(this._text[index]) && index > -1) {
          offset++;
          index--;
        }

        return startFrom - offset;
      },

      /**
       * Find new selection index representing end of current line according to current selection index
       * @param {Number} startFrom Current selection index
       * @return {Number} New selection index
       */
      findLineBoundaryRight: function(startFrom) {
        var offset = 0, index = startFrom;

        while (!/\n/.test(this._text[index]) && index < this.text.length) {
          offset++;
          index++;
        }

        return startFrom + offset;
      },

      /**
       * Finds index corresponding to beginning or end of a word
       * @param {Number} selectionStart Index of a character
       * @param {Number} direction 1 or -1
       * @return {Number} Index of the beginning or end of a word
       */
      searchWordBoundary: function(selectionStart, direction) {
        var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
            _char     = this.text.charAt(index),
            reNonWord = /[ \n\.,;!\?\-]/;

        while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
          index += direction;
          _char = this.text.charAt(index);
        }
        if (reNonWord.test(_char) && _char !== '\n') {
          index += direction === 1 ? 0 : 1;
        }
        return index;
      },

      /**
       * Selects a word based on the index
       * @param {Number} selectionStart Index of a character
       */
      selectWord: function(selectionStart) {
        selectionStart = selectionStart || this.selectionStart;
        var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
            newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

        this.selectionStart = newSelectionStart;
        this.selectionEnd = newSelectionEnd;
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      },

      /**
       * Selects a line based on the index
       * @param {Number} selectionStart Index of a character
       * @return {fabric.IText} thisArg
       * @chainable
       */
      selectLine: function(selectionStart) {
        selectionStart = selectionStart || this.selectionStart;
        var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
            newSelectionEnd = this.findLineBoundaryRight(selectionStart);

        this.selectionStart = newSelectionStart;
        this.selectionEnd = newSelectionEnd;
        this._fireSelectionChanged();
        this._updateTextarea();
        return this;
      },

      /**
       * Enters editing state
       * @return {fabric.IText} thisArg
       * @chainable
       */
      enterEditing: function(e) {
        if (this.isEditing || !this.editable) {
          return;
        }

        if (this.canvas) {
          this.canvas.calcOffset();
          this.exitEditingOnOthers(this.canvas);
        }

        this.isEditing = true;

        this.initHiddenTextarea(e);
        this.hiddenTextarea.focus();
        this.hiddenTextarea.value = this.text;
        this._updateTextarea();
        this._saveEditingProps();
        this._setEditingProps();
        this._textBeforeEdit = this.text;

        this._tick();
        this.fire('editing:entered');
        this._fireSelectionChanged();
        if (!this.canvas) {
          return this;
        }
        this.canvas.fire('text:editing:entered', { target: this });
        this.initMouseMoveHandler();
        this.canvas.requestRenderAll();
        return this;
      },

      exitEditingOnOthers: function(canvas) {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.selected = false;
            if (obj.isEditing) {
              obj.exitEditing();
            }
          });
        }
      },

      /**
       * Initializes "mousemove" event handler
       */
      initMouseMoveHandler: function() {
        this.canvas.on('mouse:move', this.mouseMoveHandler);
      },

      /**
       * @private
       */
      mouseMoveHandler: function(options) {
        if (!this.__isMousedown || !this.isEditing) {
          return;
        }

        var newSelectionStart = this.getSelectionStartFromPointer(options.e),
            currentStart = this.selectionStart,
            currentEnd = this.selectionEnd;
        if (
          (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
          &&
          (currentStart === newSelectionStart || currentEnd === newSelectionStart)
        ) {
          return;
        }
        if (newSelectionStart > this.__selectionStartOnMouseDown) {
          this.selectionStart = this.__selectionStartOnMouseDown;
          this.selectionEnd = newSelectionStart;
        }
        else {
          this.selectionStart = newSelectionStart;
          this.selectionEnd = this.__selectionStartOnMouseDown;
        }
        if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
          this.restartCursorIfNeeded();
          this._fireSelectionChanged();
          this._updateTextarea();
          this.renderCursorOrSelection();
        }
      },

      /**
       * @private
       */
      _setEditingProps: function() {
        this.hoverCursor = 'text';

        if (this.canvas) {
          this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
        }

        this.borderColor = this.editingBorderColor;

        this.hasControls = this.selectable = false;
        this.lockMovementX = this.lockMovementY = true;
      },

      /**
       * convert from textarea to grapheme indexes
       */
      fromStringToGraphemeSelection: function(start, end, text) {
        var smallerTextStart = text.slice(0, start),
            graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
        if (start === end) {
          return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
        }
        var smallerTextEnd = text.slice(start, end),
            graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
      },

      /**
       * convert from fabric to textarea values
       */
      fromGraphemeToStringSelection: function(start, end, _text) {
        var smallerTextStart = _text.slice(0, start),
            graphemeStart = smallerTextStart.join('').length;
        if (start === end) {
          return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
        }
        var smallerTextEnd = _text.slice(start, end),
            graphemeEnd = smallerTextEnd.join('').length;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
      },

      /**
       * @private
       */
      _updateTextarea: function() {
        this.cursorOffsetCache = { };
        if (!this.hiddenTextarea) {
          return;
        }
        if (!this.inCompositionMode) {
          var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
          this.hiddenTextarea.selectionStart = newSelection.selectionStart;
          this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
        }
        this.updateTextareaPosition();
      },

      /**
       * @private
       */
      updateFromTextArea: function() {
        if (!this.hiddenTextarea) {
          return;
        }
        this.cursorOffsetCache = { };
        this.text = this.hiddenTextarea.value;
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
          this.setCoords();
        }
        var newSelection = this.fromStringToGraphemeSelection(
          this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
        this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
        if (!this.inCompositionMode) {
          this.selectionStart = newSelection.selectionStart;
        }
        this.updateTextareaPosition();
      },

      /**
       * @private
       */
      updateTextareaPosition: function() {
        if (this.selectionStart === this.selectionEnd) {
          var style = this._calcTextareaPosition();
          this.hiddenTextarea.style.left = style.left;
          this.hiddenTextarea.style.top = style.top;
        }
      },

      /**
       * @private
       * @return {Object} style contains style for hiddenTextarea
       */
      _calcTextareaPosition: function() {
        if (!this.canvas) {
          return { x: 1, y: 1 };
        }
        var desiredPostion = this.inCompositionMode ? this.compositionStart : this.selectionStart,
            boundaries = this._getCursorBoundaries(desiredPostion),
            cursorLocation = this.get2DCursorLocation(desiredPostion),
            lineIndex = cursorLocation.lineIndex,
            charIndex = cursorLocation.charIndex,
            charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
            leftOffset = boundaries.leftOffset,
            m = this.calcTransformMatrix(),
            p = {
              x: boundaries.left + leftOffset,
              y: boundaries.top + boundaries.topOffset + charHeight
            },
            upperCanvas = this.canvas.upperCanvasEl,
            upperCanvasWidth = upperCanvas.width,
            upperCanvasHeight = upperCanvas.height,
            maxWidth = upperCanvasWidth - charHeight,
            maxHeight = upperCanvasHeight - charHeight,
            scaleX = upperCanvas.clientWidth / upperCanvasWidth,
            scaleY = upperCanvas.clientHeight / upperCanvasHeight;

        p = fabric.util.transformPoint(p, m);
        p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
        p.x *= scaleX;
        p.y *= scaleY;
        if (p.x < 0) {
          p.x = 0;
        }
        if (p.x > maxWidth) {
          p.x = maxWidth;
        }
        if (p.y < 0) {
          p.y = 0;
        }
        if (p.y > maxHeight) {
          p.y = maxHeight;
        }

        // add canvas offset on document
        p.x += this.canvas._offset.left;
        p.y += this.canvas._offset.top;

        return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
      },

      /**
       * @private
       */
      _saveEditingProps: function() {
        this._savedProps = {
          hasControls: this.hasControls,
          borderColor: this.borderColor,
          lockMovementX: this.lockMovementX,
          lockMovementY: this.lockMovementY,
          hoverCursor: this.hoverCursor,
          defaultCursor: this.canvas && this.canvas.defaultCursor,
          moveCursor: this.canvas && this.canvas.moveCursor
        };
      },

      /**
       * @private
       */
      _restoreEditingProps: function() {
        if (!this._savedProps) {
          return;
        }

        this.hoverCursor = this._savedProps.hoverCursor;
        this.hasControls = this._savedProps.hasControls;
        this.borderColor = this._savedProps.borderColor;
        this.lockMovementX = this._savedProps.lockMovementX;
        this.lockMovementY = this._savedProps.lockMovementY;

        if (this.canvas) {
          this.canvas.defaultCursor = this._savedProps.defaultCursor;
          this.canvas.moveCursor = this._savedProps.moveCursor;
        }
      },

      /**
       * Exits from editing state
       * @return {fabric.IText} thisArg
       * @chainable
       */
      exitEditing: function() {
        var isTextChanged = (this._textBeforeEdit !== this.text);
        this.selected = false;
        this.isEditing = false;
        this.selectable = true;

        this.selectionEnd = this.selectionStart;

        if (this.hiddenTextarea) {
          this.hiddenTextarea.blur && this.hiddenTextarea.blur();
          this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
          this.hiddenTextarea = null;
        }

        this.abortCursorAnimation();
        this._restoreEditingProps();
        this._currentCursorOpacity = 0;
        if (this._shouldClearDimensionCache()) {
          this.initDimensions();
          this.setCoords();
        }
        this.fire('editing:exited');
        isTextChanged && this.fire('modified');
        if (this.canvas) {
          this.canvas.off('mouse:move', this.mouseMoveHandler);
          this.canvas.fire('text:editing:exited', { target: this });
          isTextChanged && this.canvas.fire('object:modified', { target: this });
        }
        return this;
      },

      /**
       * @private
       */
      _removeExtraneousStyles: function() {
        for (var prop in this.styles) {
          if (!this._textLines[prop]) {
            delete this.styles[prop];
          }
        }
      },

      /**
       * remove and reflow a style block from start to end.
       * @param {Number} start linear start position for removal (included in removal)
       * @param {Number} end linear end position for removal ( excluded from removal )
       */
      removeStyleFromTo: function(start, end) {
        var cursorStart = this.get2DCursorLocation(start, true),
            cursorEnd = this.get2DCursorLocation(end, true),
            lineStart = cursorStart.lineIndex,
            charStart = cursorStart.charIndex,
            lineEnd = cursorEnd.lineIndex,
            charEnd = cursorEnd.charIndex,
            i, styleObj;
        if (lineStart !== lineEnd) {
          // step1 remove the trailing of lineStart
          if (this.styles[lineStart]) {
            for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
              delete this.styles[lineStart][i];
            }
          }
          // step2 move the trailing of lineEnd to lineStart if needed
          if (this.styles[lineEnd]) {
            for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
              styleObj = this.styles[lineEnd][i];
              if (styleObj) {
                this.styles[lineStart] || (this.styles[lineStart] = { });
                this.styles[lineStart][charStart + i - charEnd] = styleObj;
              }
            }
          }
          // step3 detects lines will be completely removed.
          for (i = lineStart + 1; i <= lineEnd; i++) {
            delete this.styles[i];
          }
          // step4 shift remaining lines.
          this.shiftLineStyles(lineEnd, lineStart - lineEnd);
        }
        else {
          // remove and shift left on the same line
          if (this.styles[lineStart]) {
            styleObj = this.styles[lineStart];
            var diff = charEnd - charStart, numericChar, _char;
            for (i = charStart; i < charEnd; i++) {
              delete styleObj[i];
            }
            for (_char in this.styles[lineStart]) {
              numericChar = parseInt(_char, 10);
              if (numericChar >= charEnd) {
                styleObj[numericChar - diff] = styleObj[_char];
                delete styleObj[_char];
              }
            }
          }
        }
      },

      /**
       * Shifts line styles up or down
       * @param {Number} lineIndex Index of a line
       * @param {Number} offset Can any number?
       */
      shiftLineStyles: function(lineIndex, offset) {
        // shift all line styles by offset upward or downward
        // do not clone deep. we need new array, not new style objects
        var clonedStyles = clone(this.styles);
        for (var line in this.styles) {
          var numericLine = parseInt(line, 10);
          if (numericLine > lineIndex) {
            this.styles[numericLine + offset] = clonedStyles[numericLine];
            if (!clonedStyles[numericLine - offset]) {
              delete this.styles[numericLine];
            }
          }
        }
      },

      restartCursorIfNeeded: function() {
        if (!this._currentTickState || this._currentTickState.isAborted
          || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
        ) {
          this.initDelayedCursor();
        }
      },

      /**
       * Inserts new style object
       * @param {Number} lineIndex Index of a line
       * @param {Number} charIndex Index of a char
       * @param {Number} qty number of lines to add
       * @param {Array} copiedStyle Array of objects styles
       */
      insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
        var currentCharStyle,
            newLineStyles = {},
            somethingAdded = false;

        qty || (qty = 1);
        this.shiftLineStyles(lineIndex, qty);
        if (this.styles[lineIndex]) {
          currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
        }

        // we clone styles of all chars
        // after cursor onto the current line
        for (var index in this.styles[lineIndex]) {
          var numIndex = parseInt(index, 10);
          if (numIndex >= charIndex) {
            somethingAdded = true;
            newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
            // remove lines from the previous line since they're on a new line now
            delete this.styles[lineIndex][index];
          }
        }
        if (somethingAdded) {
          this.styles[lineIndex + qty] = newLineStyles;
        }
        else {
          delete this.styles[lineIndex + qty];
        }
        // for the other lines
        // we clone current char style onto the next (otherwise empty) line
        while (qty > 1) {
          qty--;
          if (copiedStyle && copiedStyle[qty]) {
            this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty]) };
          }
          else if (currentCharStyle) {
            this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
          }
          else {
            delete this.styles[lineIndex + qty];
          }
        }
        this._forceClearCache = true;
      },

      /**
       * Inserts style object for a given line/char index
       * @param {Number} lineIndex Index of a line
       * @param {Number} charIndex Index of a char
       * @param {Number} quantity number Style object to insert, if given
       * @param {Array} copiedStyle array of style objecs
       */
      insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
        if (!this.styles) {
          this.styles = {};
        }
        var currentLineStyles       = this.styles[lineIndex],
            currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

        quantity || (quantity = 1);
        // shift all char styles by quantity forward
        // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
        for (var index in currentLineStylesCloned) {
          var numericIndex = parseInt(index, 10);
          if (numericIndex >= charIndex) {
            currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
            // only delete the style if there was nothing moved there
            if (!currentLineStylesCloned[numericIndex - quantity]) {
              delete currentLineStyles[numericIndex];
            }
          }
        }
        this._forceClearCache = true;
        if (copiedStyle) {
          while (quantity--) {
            if (!Object.keys(copiedStyle[quantity]).length) {
              continue;
            }
            if (!this.styles[lineIndex]) {
              this.styles[lineIndex] = {};
            }
            this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
          }
          return;
        }
        if (!currentLineStyles) {
          return;
        }
        var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
        while (newStyle && quantity--) {
          this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
        }
      },

      /**
       * Inserts style object(s)
       * @param {Array} insertedText Characters at the location where style is inserted
       * @param {Number} start cursor index for inserting style
       * @param {Array} [copiedStyle] array of style objects to insert.
       */
      insertNewStyleBlock: function(insertedText, start, copiedStyle) {
        var cursorLoc = this.get2DCursorLocation(start, true),
            addedLines = [0], linesLenght = 0;
        for (var i = 0; i < insertedText.length; i++) {
          if (insertedText[i] === '\n') {
            linesLenght++;
            addedLines[linesLenght] = 0;
          }
          else {
            addedLines[linesLenght]++;
          }
        }
        if (addedLines[0] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
          copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
        }
        linesLenght && this.insertNewlineStyleObject(
          cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLenght);
        for (var i = 1; i < linesLenght; i++) {
          if (addedLines[i] > 0) {
            this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
          }
          else if (copiedStyle) {
            this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
          }
          copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
        }
        // we use i outside the loop to get it like linesLength
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
      },

      /**
       * Set the selectionStart and selectionEnd according to the ne postion of cursor
       * mimic the key - mouse navigation when shift is pressed.
       */
      setSelectionStartEndWithShift: function(start, end, newSelection) {
        if (newSelection <= start) {
          if (end === start) {
            this._selectionDirection = 'left';
          }
          else if (this._selectionDirection === 'right') {
            this._selectionDirection = 'left';
            this.selectionEnd = start;
          }
          this.selectionStart = newSelection;
        }
        else if (newSelection > start && newSelection < end) {
          if (this._selectionDirection === 'right') {
            this.selectionEnd = newSelection;
          }
          else {
            this.selectionStart = newSelection;
          }
        }
        else {
          // newSelection is > selection start and end
          if (end === start) {
            this._selectionDirection = 'right';
          }
          else if (this._selectionDirection === 'left') {
            this._selectionDirection = 'right';
            this.selectionStart = end;
          }
          this.selectionEnd = newSelection;
        }
      },

      setSelectionInBoundaries: function() {
        var length = this.text.length;
        if (this.selectionStart > length) {
          this.selectionStart = length;
        }
        else if (this.selectionStart < 0) {
          this.selectionStart = 0;
        }
        if (this.selectionEnd > length) {
          this.selectionEnd = length;
        }
        else if (this.selectionEnd < 0) {
          this.selectionEnd = 0;
        }
      }
    });
  })();


  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
    /**
     * Initializes "dbclick" event handler
     */
    initDoubleClickSimulation: function() {

      // for double click
      this.__lastClickTime = +new Date();

      // for triple click
      this.__lastLastClickTime = +new Date();

      this.__lastPointer = { };

      this.on('mousedown', this.onMouseDown);
    },

    /**
     * Default event handler to simulate triple click
     * @private
     */
    onMouseDown: function(options) {
      if (!this.canvas) {
        return;
      }
      this.__newClickTime = +new Date();
      var newPointer = options.pointer;
      if (this.isTripleClick(newPointer)) {
        this.fire('tripleclick', options);
        this._stopEvent(options.e);
      }
      this.__lastLastClickTime = this.__lastClickTime;
      this.__lastClickTime = this.__newClickTime;
      this.__lastPointer = newPointer;
      this.__lastIsEditing = this.isEditing;
      this.__lastSelected = this.selected;
    },

    isTripleClick: function(newPointer) {
      return this.__newClickTime - this.__lastClickTime < 500 &&
          this.__lastClickTime - this.__lastLastClickTime < 500 &&
          this.__lastPointer.x === newPointer.x &&
          this.__lastPointer.y === newPointer.y;
    },

    /**
     * @private
     */
    _stopEvent: function(e) {
      e.preventDefault && e.preventDefault();
      e.stopPropagation && e.stopPropagation();
    },

    /**
     * Initializes event handlers related to cursor or selection
     */
    initCursorSelectionHandlers: function() {
      this.initMousedownHandler();
      this.initMouseupHandler();
      this.initClicks();
    },

    /**
     * Initializes double and triple click event handlers
     */
    initClicks: function() {
      this.on('mousedblclick', function(options) {
        this.selectWord(this.getSelectionStartFromPointer(options.e));
      });
      this.on('tripleclick', function(options) {
        this.selectLine(this.getSelectionStartFromPointer(options.e));
      });
    },

    /**
     * Default event handler for the basic functionalities needed on _mouseDown
     * can be overridden to do something different.
     * Scope of this implementation is: find the click position, set selectionStart
     * find selectionEnd, initialize the drawing of either cursor or selection area
     */
    _mouseDownHandler: function(options) {
      if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }

      this.__isMousedown = true;

      if (this.selected) {
        this.setCursorByClick(options.e);
      }

      if (this.isEditing) {
        this.__selectionStartOnMouseDown = this.selectionStart;
        if (this.selectionStart === this.selectionEnd) {
          this.abortCursorAnimation();
        }
        this.renderCursorOrSelection();
      }
    },

    /**
     * Default event handler for the basic functionalities needed on mousedown:before
     * can be overridden to do something different.
     * Scope of this implementation is: verify the object is already selected when mousing down
     */
    _mouseDownHandlerBefore: function(options) {
      if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }
      if (this === this.canvas._activeObject) {
        this.selected = true;
      }
    },

    /**
     * Initializes "mousedown" event handler
     */
    initMousedownHandler: function() {
      this.on('mousedown', this._mouseDownHandler);
      this.on('mousedown:before', this._mouseDownHandlerBefore);
    },

    /**
     * Initializes "mouseup" event handler
     */
    initMouseupHandler: function() {
      this.on('mouseup', this.mouseUpHandler);
    },

    /**
     * standard hander for mouse up, overridable
     * @private
     */
    mouseUpHandler: function(options) {
      this.__isMousedown = false;
      if (!this.editable ||
        (options.transform && options.transform.actionPerformed) ||
        (options.e.button && options.e.button !== 1)) {
        return;
      }

      if (this.__lastSelected && !this.__corner) {
        this.enterEditing(options.e);
        if (this.selectionStart === this.selectionEnd) {
          this.initDelayedCursor(true);
        }
        else {
          this.renderCursorOrSelection();
        }
      }
      this.selected = true;
    },

    /**
     * Changes cursor location in a text depending on passed pointer (x/y) object
     * @param {Event} e Event object
     */
    setCursorByClick: function(e) {
      var newSelection = this.getSelectionStartFromPointer(e),
          start = this.selectionStart, end = this.selectionEnd;
      if (e.shiftKey) {
        this.setSelectionStartEndWithShift(start, end, newSelection);
      }
      else {
        this.selectionStart = newSelection;
        this.selectionEnd = newSelection;
      }
      if (this.isEditing) {
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Returns index of a character corresponding to where an object was clicked
     * @param {Event} e Event object
     * @return {Number} Index of a character
     */
    getSelectionStartFromPointer: function(e) {
      var mouseOffset = this.getLocalPointer(e),
          prevWidth = 0,
          width = 0,
          height = 0,
          charIndex = 0,
          lineIndex = 0,
          lineLeftOffset,
          line;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (height <= mouseOffset.y) {
          height += this.getHeightOfLine(i) * this.scaleY;
          lineIndex = i;
          if (i > 0) {
            charIndex += this._textLines[i - 1].length + 1;
          }
        }
        else {
          break;
        }
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      width = lineLeftOffset * this.scaleX;
      line = this._textLines[lineIndex];
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        prevWidth = width;
        // i removed something about flipX here, check.
        width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
        if (width <= mouseOffset.x) {
          charIndex++;
        }
        else {
          break;
        }
      }
      return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
    },

    /**
     * @private
     */
    _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
      // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
      var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
          distanceBtwNextCharAndCursor = width - mouseOffset.x,
          offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
            distanceBtwNextCharAndCursor < 0 ? 0 : 1,
          newSelectionStart = index + offset;
      // if object is horizontally flipped, mirror cursor location from the end
      if (this.flipX) {
        newSelectionStart = jlen - newSelectionStart;
      }

      if (newSelectionStart > this._text.length) {
        newSelectionStart = this._text.length;
      }

      return newSelectionStart;
    }
  });


  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes hidden textarea (needed to bring up keyboard in iOS)
     */
    initHiddenTextarea: function() {
      this.hiddenTextarea = fabric.document.createElement('textarea');
      this.hiddenTextarea.setAttribute('autocapitalize', 'off');
      this.hiddenTextarea.setAttribute('autocorrect', 'off');
      this.hiddenTextarea.setAttribute('autocomplete', 'off');
      this.hiddenTextarea.setAttribute('spellcheck', 'false');
      this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
      this.hiddenTextarea.setAttribute('wrap', 'off');
      var style = this._calcTextareaPosition();
      this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
      '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
      ' line-height: 1px; paddingtop: ' + style.fontSize + ';';
      fabric.document.body.appendChild(this.hiddenTextarea);

      fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
      fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

      if (!this._clickHandlerInitialized && this.canvas) {
        fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
        this._clickHandlerInitialized = true;
      }
    },

    /**
     * For functionalities on keyDown
     * Map a special key to a function of the instance/prototype
     * If you need different behaviour for ESC or TAB or arrows, you have to change
     * this map setting the name of a function that you build on the fabric.Itext or
     * your prototype.
     * the map change will affect all Instances unless you need for only some text Instances
     * in that case you have to clone this object and assign your Instance.
     * this.keysMap = fabric.util.object.clone(this.keysMap);
     * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
     */
    keysMap: {
      9:  'exitEditing',
      27: 'exitEditing',
      33: 'moveCursorUp',
      34: 'moveCursorDown',
      35: 'moveCursorRight',
      36: 'moveCursorLeft',
      37: 'moveCursorLeft',
      38: 'moveCursorUp',
      39: 'moveCursorRight',
      40: 'moveCursorDown',
    },

    /**
     * For functionalities on keyUp + ctrl || cmd
     */
    ctrlKeysMapUp: {
      67: 'copy',
      88: 'cut'
    },

    /**
     * For functionalities on keyDown + ctrl || cmd
     */
    ctrlKeysMapDown: {
      65: 'selectAll'
    },

    onClick: function() {
      // No need to trigger click event here, focus is enough to have the keyboard appear on Android
      this.hiddenTextarea && this.hiddenTextarea.focus();
    },

    /**
     * Handles keyup event
     * @param {Event} e Event object
     */
    onKeyDown: function(e) {
      if (!this.isEditing || this.inCompositionMode) {
        return;
      }
      if (e.keyCode in this.keysMap) {
        this[this.keysMap[e.keyCode]](e);
      }
      else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
        this[this.ctrlKeysMapDown[e.keyCode]](e);
      }
      else {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      if (e.keyCode >= 33 && e.keyCode <= 40) {
        // if i press an arrow key just update selection
        this.clearContextTop();
        this.renderCursorOrSelection();
      }
      else {
        this.canvas && this.canvas.requestRenderAll();
      }
    },

    /**
     * Handles keyup event
     * We handle KeyUp because ie11 and edge have difficulties copy/pasting
     * if a copy/cut event fired, keyup is dismissed
     * @param {Event} e Event object
     */
    onKeyUp: function(e) {
      if (!this.isEditing || this._copyDone || this.inCompositionMode) {
        this._copyDone = false;
        return;
      }
      if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
        this[this.ctrlKeysMapUp[e.keyCode]](e);
      }
      else {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      this.canvas && this.canvas.requestRenderAll();
    },

    /**
     * Handles onInput event
     * @param {Event} e Event object
     */
    onInput: function(e) {
      var fromPaste = this.fromPaste;
      this.fromPaste = false;
      e && e.stopPropagation();
      if (!this.isEditing) {
        return;
      }
      // decisions about style changes.
      var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
          charCount = this._text.length,
          nextCharCount = nextText.length,
          removedText, insertedText,
          charDiff = nextCharCount - charCount;
      if (this.hiddenTextarea.value === '') {
        this.styles = { };
        this.updateFromTextArea();
        this.fire('changed');
        if (this.canvas) {
          this.canvas.fire('text:changed', { target: this });
          this.canvas.requestRenderAll();
        }
        return;
      }

      var textareaSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart,
        this.hiddenTextarea.selectionEnd,
        this.hiddenTextarea.value
      );
      var backDelete = this.selectionStart > textareaSelection.selectionStart;

      if (this.selectionStart !== this.selectionEnd) {
        removedText = this._text.slice(this.selectionStart, this.selectionEnd);
        charDiff += this.selectionEnd - this.selectionStart;
      }
      else if (nextCharCount < charCount) {
        if (backDelete) {
          removedText = this._text.slice(this.selectionEnd + charDiff, this.selectionEnd);
        }
        else {
          removedText = this._text.slice(this.selectionStart, this.selectionStart - charDiff);
        }
      }
      insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
      if (removedText && removedText.length) {
        if (this.selectionStart !== this.selectionEnd) {
          this.removeStyleFromTo(this.selectionStart, this.selectionEnd);
        }
        else if (backDelete) {
          // detect differencies between forwardDelete and backDelete
          this.removeStyleFromTo(this.selectionEnd - removedText.length, this.selectionEnd);
        }
        else {
          this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + removedText.length);
        }
      }
      if (insertedText.length) {
        if (fromPaste && insertedText.join('') === fabric.copiedText) {
          this.insertNewStyleBlock(insertedText, this.selectionStart, fabric.copiedTextStyle);
        }
        else {
          this.insertNewStyleBlock(insertedText, this.selectionStart);
        }
      }
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
    },
    /**
     * Composition start
     */
    onCompositionStart: function() {
      this.inCompositionMode = true;
    },

    /**
     * Composition end
     */
    onCompositionEnd: function() {
      this.inCompositionMode = false;
    },

    // /**
    //  * Composition update
    //  */
    onCompositionUpdate: function(e) {
      this.compositionStart = e.target.selectionStart;
      this.compositionEnd = e.target.selectionEnd;
      this.updateTextareaPosition();
    },

    /**
     * Copies selected text
     * @param {Event} e Event object
     */
    copy: function() {
      if (this.selectionStart === this.selectionEnd) {
        //do not cut-copy if no selection
        return;
      }

      fabric.copiedText = this.getSelectedText();
      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
      this._copyDone = true;
    },

    /**
     * Pastes text
     * @param {Event} e Event object
     */
    paste: function() {
      this.fromPaste = true;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @return {Object} Clipboard data object
     */
    _getClipboardData: function(e) {
      return (e && e.clipboardData) || fabric.window.clipboardData;
    },

    /**
     * Finds the width in pixels before the cursor on the same line
     * @private
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Number} widthBeforeCursor width before cursor
     */
    _getWidthBeforeCursor: function(lineIndex, charIndex) {
      var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

      if (charIndex > 0) {
        bound = this.__charBounds[lineIndex][charIndex - 1];
        widthBeforeCursor += bound.left + bound.width;
      }
      return widthBeforeCursor;
    },

    /**
     * Gets start offset of a selection
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    getDownCursorOffset: function(e, isRight) {
      var selectionProp = this._getSelectionForOffset(e, isRight),
          cursorLocation = this.get2DCursorLocation(selectionProp),
          lineIndex = cursorLocation.lineIndex;
      // if on last line, down cursor goes to end of line
      if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
        // move to the end of a text
        return this._text.length - selectionProp;
      }
      var charIndex = cursorLocation.charIndex,
          widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
          indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
          textAfterCursor = this._textLines[lineIndex].slice(charIndex);
      return textAfterCursor.length + indexOnOtherLine + 2;
    },

    /**
     * private
     * Helps finding if the offset should be counted from Start or End
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    _getSelectionForOffset: function(e, isRight) {
      if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
        return this.selectionEnd;
      }
      else {
        return this.selectionStart;
      }
    },

    /**
     * @param {Event} e Event object
     * @param {Boolean} isRight
     * @return {Number}
     */
    getUpCursorOffset: function(e, isRight) {
      var selectionProp = this._getSelectionForOffset(e, isRight),
          cursorLocation = this.get2DCursorLocation(selectionProp),
          lineIndex = cursorLocation.lineIndex;
      if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
        // if on first line, up cursor goes to start of line
        return -selectionProp;
      }
      var charIndex = cursorLocation.charIndex,
          widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
          indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
          textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);
      // return a negative offset
      return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;
    },

    /**
     * for a given width it founds the matching character.
     * @private
     */
    _getIndexOnLine: function(lineIndex, width) {

      var line = this._textLines[lineIndex],
          lineLeftOffset = this._getLineLeftOffset(lineIndex),
          widthOfCharsOnLine = lineLeftOffset,
          indexOnLine = 0, charWidth, foundMatch;

      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charWidth = this.__charBounds[lineIndex][j].width;
        widthOfCharsOnLine += charWidth;
        if (widthOfCharsOnLine > width) {
          foundMatch = true;
          var leftEdge = widthOfCharsOnLine - charWidth,
              rightEdge = widthOfCharsOnLine,
              offsetFromLeftEdge = Math.abs(leftEdge - width),
              offsetFromRightEdge = Math.abs(rightEdge - width);

          indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
          break;
        }
      }

      // reached end
      if (!foundMatch) {
        indexOnLine = line.length - 1;
      }

      return indexOnLine;
    },


    /**
     * Moves cursor down
     * @param {Event} e Event object
     */
    moveCursorDown: function(e) {
      if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
        return;
      }
      this._moveCursorUpOrDown('Down', e);
    },

    /**
     * Moves cursor up
     * @param {Event} e Event object
     */
    moveCursorUp: function(e) {
      if (this.selectionStart === 0 && this.selectionEnd === 0) {
        return;
      }
      this._moveCursorUpOrDown('Up', e);
    },

    /**
     * Moves cursor up or down, fires the events
     * @param {String} direction 'Up' or 'Down'
     * @param {Event} e Event object
     */
    _moveCursorUpOrDown: function(direction, e) {
      // getUpCursorOffset
      // getDownCursorOffset
      var action = 'get' + direction + 'CursorOffset',
          offset = this[action](e, this._selectionDirection === 'right');
      if (e.shiftKey) {
        this.moveCursorWithShift(offset);
      }
      else {
        this.moveCursorWithoutShift(offset);
      }
      if (offset !== 0) {
        this.setSelectionInBoundaries();
        this.abortCursorAnimation();
        this._currentCursorOpacity = 1;
        this.initDelayedCursor();
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Moves cursor with shift
     * @param {Number} offset
     */
    moveCursorWithShift: function(offset) {
      var newSelection = this._selectionDirection === 'left'
        ? this.selectionStart + offset
        : this.selectionEnd + offset;
      this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
      return offset !== 0;
    },

    /**
     * Moves cursor up without shift
     * @param {Number} offset
     */
    moveCursorWithoutShift: function(offset) {
      if (offset < 0) {
        this.selectionStart += offset;
        this.selectionEnd = this.selectionStart;
      }
      else {
        this.selectionEnd += offset;
        this.selectionStart = this.selectionEnd;
      }
      return offset !== 0;
    },

    /**
     * Moves cursor left
     * @param {Event} e Event object
     */
    moveCursorLeft: function(e) {
      if (this.selectionStart === 0 && this.selectionEnd === 0) {
        return;
      }
      this._moveCursorLeftOrRight('Left', e);
    },

    /**
     * @private
     * @return {Boolean} true if a change happened
     */
    _move: function(e, prop, direction) {
      var newValue;
      if (e.altKey) {
        newValue = this['findWordBoundary' + direction](this[prop]);
      }
      else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
        newValue = this['findLineBoundary' + direction](this[prop]);
      }
      else {
        this[prop] += direction === 'Left' ? -1 : 1;
        return true;
      }
      if (typeof newValue !== undefined && this[prop] !== newValue) {
        this[prop] = newValue;
        return true;
      }
    },

    /**
     * @private
     */
    _moveLeft: function(e, prop) {
      return this._move(e, prop, 'Left');
    },

    /**
     * @private
     */
    _moveRight: function(e, prop) {
      return this._move(e, prop, 'Right');
    },

    /**
     * Moves cursor left without keeping selection
     * @param {Event} e
     */
    moveCursorLeftWithoutShift: function(e) {
      var change = true;
      this._selectionDirection = 'left';

      // only move cursor when there is no selection,
      // otherwise we discard it, and leave cursor on same place
      if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
        change = this._moveLeft(e, 'selectionStart');

      }
      this.selectionEnd = this.selectionStart;
      return change;
    },

    /**
     * Moves cursor left while keeping selection
     * @param {Event} e
     */
    moveCursorLeftWithShift: function(e) {
      if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
        return this._moveLeft(e, 'selectionEnd');
      }
      else if (this.selectionStart !== 0){
        this._selectionDirection = 'left';
        return this._moveLeft(e, 'selectionStart');
      }
    },

    /**
     * Moves cursor right
     * @param {Event} e Event object
     */
    moveCursorRight: function(e) {
      if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
        return;
      }
      this._moveCursorLeftOrRight('Right', e);
    },

    /**
     * Moves cursor right or Left, fires event
     * @param {String} direction 'Left', 'Right'
     * @param {Event} e Event object
     */
    _moveCursorLeftOrRight: function(direction, e) {
      var actionName = 'moveCursor' + direction + 'With';
      this._currentCursorOpacity = 1;

      if (e.shiftKey) {
        actionName += 'Shift';
      }
      else {
        actionName += 'outShift';
      }
      if (this[actionName](e)) {
        this.abortCursorAnimation();
        this.initDelayedCursor();
        this._fireSelectionChanged();
        this._updateTextarea();
      }
    },

    /**
     * Moves cursor right while keeping selection
     * @param {Event} e
     */
    moveCursorRightWithShift: function(e) {
      if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
        return this._moveRight(e, 'selectionStart');
      }
      else if (this.selectionEnd !== this._text.length) {
        this._selectionDirection = 'right';
        return this._moveRight(e, 'selectionEnd');
      }
    },

    /**
     * Moves cursor right without keeping selection
     * @param {Event} e Event object
     */
    moveCursorRightWithoutShift: function(e) {
      var changed = true;
      this._selectionDirection = 'right';

      if (this.selectionStart === this.selectionEnd) {
        changed = this._moveRight(e, 'selectionStart');
        this.selectionEnd = this.selectionStart;
      }
      else {
        this.selectionStart = this.selectionEnd;
      }
      return changed;
    },

    /**
     * Removes characters from start/end
     * start/end ar per grapheme position in _text array.
     *
     * @param {Number} start
     * @param {Number} end default to start + 1
     */
    removeChars: function(start, end) {
      if (typeof end === 'undefined') {
        end = start + 1;
      }
      this.removeStyleFromTo(start, end);
      this._text.splice(start, end - start);
      this.text = this._text.join('');
      this.set('dirty', true);
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this._removeExtraneousStyles();
    },

    /**
     * insert characters at start position, before start position.
     * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
     * if style array is provided, it must be as the same length of text in graphemes
     * if end is provided and is bigger than start, old text is replaced.
     * start/end ar per grapheme position in _text array.
     *
     * @param {String} text text to insert
     * @param {Array} style array of style objects
     * @param {Number} start
     * @param {Number} end default to start + 1
     */
    insertChars: function(text, style, start, end) {
      if (typeof end === 'undefined') {
        end = start;
      }
      if (end > start) {
        this.removeStyleFromTo(start, end);
      }
      var graphemes = fabric.util.string.graphemeSplit(text);
      this.insertNewStyleBlock(graphemes, start, style);
      this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
      this.text = this._text.join('');
      this.set('dirty', true);
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this._removeExtraneousStyles();
    },

  });


  /* _TO_SVG_START_ */
  (function() {
    var toFixed = fabric.util.toFixed,
        multipleSpacesRegex = /  +/g;

    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

      /**
       * Returns SVG representation of an instance
       * @param {Function} [reviver] Method for further parsing of svg representation.
       * @return {String} svg representation of an instance
       */
      toSVG: function(reviver) {
        var markup = this._createBaseSVGMarkup(),
            offsets = this._getSVGLeftTopOffsets(),
            textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
        this._wrapSVGTextAndBg(markup, textAndBg);

        return reviver ? reviver(markup.join('')) : markup.join('');
      },

      /**
       * @private
       */
      _getSVGLeftTopOffsets: function() {
        return {
          textLeft: -this.width / 2,
          textTop: -this.height / 2,
          lineTop: this.getHeightOfLine(0)
        };
      },

      /**
       * @private
       */
      _wrapSVGTextAndBg: function(markup, textAndBg) {
        var noShadow = true, filter = this.getSvgFilter(),
            style = filter === '' ? '' : ' style="' + filter + '"',
            textDecoration = this.getSvgTextDecoration(this);
        markup.push(
          '\t<g ', this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"',
          style, '>\n',
          textAndBg.textBgRects.join(''),
          '\t\t<text xml:space="preserve" ',
          (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
          (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
          (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
          (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
          (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
          'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
          textAndBg.textSpans.join(''),
          '</text>\n',
          '\t</g>\n'
        );
      },

      /**
       * @private
       * @param {Number} textTopOffset Text top offset
       * @param {Number} textLeftOffset Text left offset
       * @return {Object}
       */
      _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
        var textSpans = [],
            textBgRects = [],
            height = textTopOffset, lineOffset;
        // bounding-box background
        this._setSVGBg(textBgRects);

        // text and text-background
        for (var i = 0, len = this._textLines.length; i < len; i++) {
          lineOffset = this._getLineLeftOffset(i);
          if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
            this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
          }
          this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
          height += this.getHeightOfLine(i);
        }

        return {
          textSpans: textSpans,
          textBgRects: textBgRects
        };
      },

      /**
       * @private
       */
      _createTextCharSpan: function(_char, styleDecl, left, top) {
        var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
            styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
            fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
            dy = styleDecl.deltaY, dySpan = '',
            NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        if (dy) {
          dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
        }
        return [
          '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
          toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
          fillStyles, '>',
          fabric.util.string.escapeXml(_char),
          '</tspan>'
        ].join('');
      },

      _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
        // set proper line offset
        var lineHeight = this.getHeightOfLine(lineIndex),
            isJustify = this.textAlign.indexOf('justify') !== -1,
            actualStyle,
            nextStyle,
            charsToRender = '',
            charBox, style,
            boxWidth = 0,
            line = this._textLines[lineIndex],
            timeToRender;

        textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
        for (var i = 0, len = line.length - 1; i <= len; i++) {
          timeToRender = i === len || this.charSpacing;
          charsToRender += line[i];
          charBox = this.__charBounds[lineIndex][i];
          if (boxWidth === 0) {
            textLeftOffset += charBox.kernedWidth - charBox.width;
            boxWidth += charBox.width;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
          if (isJustify && !timeToRender) {
            if (this._reSpaceAndTab.test(line[i])) {
              timeToRender = true;
            }
          }
          if (!timeToRender) {
            // if we have charSpacing, we render char by char
            actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
            nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
            timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
          }
          if (timeToRender) {
            style = this._getStyleDeclaration(lineIndex, i) || { };
            textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
            charsToRender = '';
            actualStyle = nextStyle;
            textLeftOffset += boxWidth;
            boxWidth = 0;
          }
        }
      },

      _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(color),
          ' x="',
          toFixed(left, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(top, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      },

      _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
        var line = this._textLines[i],
            heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
            boxWidth = 0,
            boxStart = 0,
            charBox, currentColor,
            lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (currentColor !== lastColor) {
            lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
              textTopOffset, boxWidth, heightOfLine);
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
          textTopOffset, boxWidth, heightOfLine);
      },

      /**
       * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
       * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
       *
       * @private
       * @param {*} value
       * @return {String}
       */
      _getFillAttributes: function(value) {
        var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
        if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
          return 'fill="' + value + '"';
        }
        return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
      },

      /**
       * @private
       */
      _getSVGLineTopOffset: function(lineIndex) {
        var lineTopOffset = 0, lastHeight = 0;
        for (var j = 0; j < lineIndex; j++) {
          lineTopOffset += this.getHeightOfLine(j);
        }
        lastHeight = this.getHeightOfLine(j);
        return {
          lineTop: lineTopOffset,
          offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
        };
      },

      /**
       * Returns styles-string for svg-export
       * @param {Boolean} skipShadow a boolean to skip shadow filter output
       * @return {String}
       */
      getSvgStyles: function(skipShadow) {
        var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
        return svgStyle + ' white-space: pre;';
      },
    });
  })();
  /* _TO_SVG_END_ */


  (function(global) {

    var fabric = global.fabric || (global.fabric = {});

    /**
     * Textbox class, based on IText, allows the user to resize the text rectangle
     * and wraps lines automatically. Textboxes have their Y scaling locked, the
     * user can only change width. Height is adjusted automatically based on the
     * wrapping of lines.
     * @class fabric.Textbox
     * @extends fabric.IText
     * @mixes fabric.Observable
     * @return {fabric.Textbox} thisArg
     * @see {@link fabric.Textbox#initialize} for constructor definition
     */
    fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

      /**
       * Type of an object
       * @type String
       * @default
       */
      type: 'textbox',

      /**
       * Minimum width of textbox, in pixels.
       * @type Number
       * @default
       */
      minWidth: 20,

      /**
       * Minimum calculated width of a textbox, in pixels.
       * fixed to 2 so that an empty textbox cannot go to 0
       * and is still selectable without text.
       * @type Number
       * @default
       */
      dynamicMinWidth: 2,

      /**
       * Cached array of text wrapping.
       * @type Array
       */
      __cachedLines: null,

      /**
       * Override standard Object class values
       */
      lockScalingFlip: true,

      /**
       * Override standard Object class values
       * Textbox needs this on false
       */
      noScaleCache: false,

      /**
       * Properties which when set cause object to change dimensions
       * @type Object
       * @private
       */
      _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

      /**
       * Unlike superclass's version of this function, Textbox does not update
       * its width.
       * @private
       * @override
       */
      initDimensions: function() {
        if (this.__skipDimension) {
          return;
        }
        this.isEditing && this.initDelayedCursor();
        this.clearContextTop();
        this._clearCache();
        // clear dynamicMinWidth as it will be different after we re-wrap line
        this.dynamicMinWidth = 0;
        // wrap lines
        this._styleMap = this._generateStyleMap(this._splitText());
        // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
        if (this.dynamicMinWidth > this.width) {
          this._set('width', this.dynamicMinWidth);
        }
        if (this.textAlign.indexOf('justify') !== -1) {
          // once text is measured we need to make space fatter to make justified text.
          this.enlargeSpaces();
        }
        // clear cache and re-calculate height
        this.height = this.calcTextHeight();
        this.saveState({ propertySet: '_dimensionAffectingProps' });
      },

      /**
       * Generate an object that translates the style object so that it is
       * broken up by visual lines (new lines and automatic wrapping).
       * The original text styles object is broken up by actual lines (new lines only),
       * which is only sufficient for Text / IText
       * @private
       */
      _generateStyleMap: function(textInfo) {
        var realLineCount     = 0,
            realLineCharCount = 0,
            charCount         = 0,
            map               = {};

        for (var i = 0; i < textInfo.graphemeLines.length; i++) {
          if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
            realLineCharCount = 0;
            charCount++;
            realLineCount++;
          }
          else if (this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
            // this case deals with space's that are removed from end of lines when wrapping
            realLineCharCount++;
            charCount++;
          }

          map[i] = { line: realLineCount, offset: realLineCharCount };

          charCount += textInfo.graphemeLines[i].length;
          realLineCharCount += textInfo.graphemeLines[i].length;
        }

        return map;
      },

      /**
       * Returns true if object has a style property or has it ina specified line
       * @param {Number} lineIndex
       * @return {Boolean}
       */
      styleHas: function(property, lineIndex) {
        if (this._styleMap && !this.isWrapping) {
          var map = this._styleMap[lineIndex];
          if (map) {
            lineIndex = map.line;
          }
        }
        return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
      },

      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(lineIndex) {
        var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false;
        var map = this._styleMap[lineIndex];
        var mapNextLine = this._styleMap[lineIndex + 1];
        if (map) {
          lineIndex = map.line;
          offset = map.offset;
        }
        if (mapNextLine) {
          nextLineIndex = mapNextLine.line;
          shouldLimit = nextLineIndex === lineIndex;
          nextOffset = mapNextLine.offset;
        }
        obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
        for (var p1 in obj) {
          for (var p2 in obj[p1]) {
            if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
              // eslint-disable-next-line no-unused-vars
              for (var p3 in obj[p1][p2]) {
                return false;
              }
            }
          }
        }
        return true;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _getStyleDeclaration: function(lineIndex, charIndex) {
        if (this._styleMap && !this.isWrapping) {
          var map = this._styleMap[lineIndex];
          if (!map) {
            return null;
          }
          lineIndex = map.line;
          charIndex = map.offset + charIndex;
        }
        return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(lineIndex, charIndex, style) {
        var map = this._styleMap[lineIndex];
        lineIndex = map.line;
        charIndex = map.offset + charIndex;

        this.styles[lineIndex][charIndex] = style;
      },

      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(lineIndex, charIndex) {
        var map = this._styleMap[lineIndex];
        lineIndex = map.line;
        charIndex = map.offset + charIndex;

        delete this.styles[lineIndex][charIndex];
      },

      /**
      * probably broken need a fix
       * @param {Number} lineIndex
       * @private
       */
      _getLineStyle: function(lineIndex) {
        var map = this._styleMap[lineIndex];
        return this.styles[map.line];
      },

      /**
       * probably broken need a fix
       * @param {Number} lineIndex
       * @param {Object} style
       * @private
       */
      _setLineStyle: function(lineIndex, style) {
        var map = this._styleMap[lineIndex];
        this.styles[map.line] = style;
      },

      /**
       * probably broken need a fix
       * @param {Number} lineIndex
       * @private
       */
      _deleteLineStyle: function(lineIndex) {
        var map = this._styleMap[lineIndex];
        delete this.styles[map.line];
      },

      /**
       * Wraps text using the 'width' property of Textbox. First this function
       * splits text on newlines, so we preserve newlines entered by the user.
       * Then it wraps each line using the width of the Textbox by calling
       * _wrapLine().
       * @param {Array} lines The string array of text that is split into lines
       * @param {Number} desiredWidth width you want to wrap to
       * @returns {Array} Array of lines
       */
      _wrapText: function(lines, desiredWidth) {
        var wrapped = [], i;
        this.isWrapping = true;
        for (i = 0; i < lines.length; i++) {
          wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
        }
        this.isWrapping = false;
        return wrapped;
      },

      /**
       * Helper function to measure a string of text, given its lineIndex and charIndex offset
       * it gets called when charBounds are not available yet.
       * @param {CanvasRenderingContext2D} ctx
       * @param {String} text
       * @param {number} lineIndex
       * @param {number} charOffset
       * @returns {number}
       * @private
       */
      _measureWord: function(word, lineIndex, charOffset) {
        var width = 0, prevGrapheme, skipLeft = true;
        charOffset = charOffset || 0;
        for (var i = 0, len = word.length; i < len; i++) {
          var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
          width += box.kernedWidth;
          prevGrapheme = word[i];
        }
        return width;
      },

      /**
       * Wraps a line of text using the width of the Textbox and a context.
       * @param {Array} line The grapheme array that represent the line
       * @param {Number} lineIndex
       * @param {Number} desiredWidth width you want to wrap the line to
       * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
       * @returns {Array} Array of line(s) into which the given text is wrapped
       * to.
       */
      _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
        var lineWidth        = 0,
            graphemeLines    = [],
            line             = [],
            // spaces in different languges?
            words            = _line.split(this._reSpaceAndTab),
            word             = '',
            offset           = 0,
            infix            = ' ',
            wordWidth        = 0,
            infixWidth       = 0,
            largestWordWidth = 0,
            lineJustStarted = true,
            additionalSpace = this._getWidthOfCharSpacing(),
            reservedSpace = reservedSpace || 0;

        desiredWidth -= reservedSpace;
        for (var i = 0; i < words.length; i++) {
          // i would avoid resplitting the graphemes
          word = fabric.util.string.graphemeSplit(words[i]);
          wordWidth = this._measureWord(word, lineIndex, offset);
          offset += word.length;

          lineWidth += infixWidth + wordWidth - additionalSpace;

          if (lineWidth >= desiredWidth && !lineJustStarted) {
            graphemeLines.push(line);
            line = [];
            lineWidth = wordWidth;
            lineJustStarted = true;
          }
          else {
            lineWidth += additionalSpace;
          }

          if (!lineJustStarted) {
            line.push(infix);
          }
          line = line.concat(word);

          infixWidth = this._measureWord([infix], lineIndex, offset);
          offset++;
          lineJustStarted = false;
          // keep track of largest word
          if (wordWidth > largestWordWidth) {
            largestWordWidth = wordWidth;
          }
        }

        i && graphemeLines.push(line);

        if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
          this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
        }

        return graphemeLines;
      },

      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @param {Number} lineIndex text to split
       * @return {Boolean}
       */
      isEndOfWrapping: function(lineIndex) {
        if (!this._styleMap[lineIndex + 1]) {
          // is last line, return true;
          return true;
        }
        if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
          // this is last line before a line break, return true;
          return true;
        }
        return false;
      },

      /**
      * Gets lines of text to render in the Textbox. This function calculates
      * text wrapping on the fly every time it is called.
      * @param {String} text text to split
      * @returns {Array} Array of lines in the Textbox.
      * @override
      */
      _splitTextIntoLines: function(text) {
        var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
            graphemeLines = this._wrapText(newText.lines, this.width),
            lines = new Array(graphemeLines.length);

        for (var i = 0; i < graphemeLines.length; i++) {
          lines[i] = graphemeLines[i].join('');
        }
        newText.lines = lines;
        newText.graphemeLines = graphemeLines;
        return newText;
      },

      getMinWidth: function() {
        return Math.max(this.minWidth, this.dynamicMinWidth);
      },

      /**
       * Returns object representation of an instance
       * @method toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(propertiesToInclude) {
        return this.callSuper('toObject', ['minWidth'].concat(propertiesToInclude));
      }
    });

    /**
     * Returns fabric.Textbox instance from an object representation
     * @static
     * @memberOf fabric.Textbox
     * @param {Object} object Object to create an instance from
     * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
     */
    fabric.Textbox.fromObject = function(object, callback) {
      return fabric.Object._fromObject('Textbox', object, callback, 'text');
    };
  })(exports);


  (function() {

    /**
     * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
     * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
     */
    var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;

    fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
      lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {

      var t = transform.target;
      if (by === 'x' && t instanceof fabric.Textbox) {
        var tw = t._getTransformedDimensions().x;
        var w = t.width * (localMouse.x / tw);
        if (w >= t.getMinWidth()) {
          t.set('width', w);
          return true;
        }
      }
      else {
        return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
          lockScalingX, lockScalingY, by, lockScalingFlip, _dim);
      }
    };

    fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
      /**
       * @private
       */
      _removeExtraneousStyles: function() {
        for (var prop in this._styleMap) {
          if (!this._textLines[prop]) {
            delete this.styles[this._styleMap[prop].line];
          }
        }
      },

    });
  })();
  });
  var fabric_2 = fabric_1.fabric;

  var toolTypes = {
    SELECTOR: 0,
    CIRCLE: 1,
    TEXT: 2,
    PEN: 3,
    MARKPEN: 4,
    ERASER: 5
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = _freeGlobal || freeSelf || Function('return this')();

  var _root = root;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  var isArray_1 = isArray$1;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
  }

  var isSymbol_1 = isSymbol;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }
    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$1(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString$1;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  var _baseSlice = baseSlice;

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = '\\ud800-\\udfff',
      rsComboMarksRange$1 = '\\u0300-\\u036f',
      reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange$1 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo = '[' + rsComboRange$1 + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$1 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  var _unicodeToArray = unicodeToArray;

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return _hasUnicode(string)
      ? _unicodeToArray(string)
      : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString_1(string);

      var strSymbols = _hasUnicode(string)
        ? _stringToArray(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? _castSlice(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  var _createCaseFirst = createCaseFirst;

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = _createCaseFirst('toUpperCase');

  var upperFirst_1 = upperFirst;

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst_1(toString_1(string).toLowerCase());
  }

  var capitalize_1 = capitalize;

  /** Used to generate unique IDs. */
  var idCounter = 0;

  /**
   * Generates a unique ID. If `prefix` is given, the ID is appended to it.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {string} [prefix=''] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString_1(prefix) + id;
  }

  var uniqueId_1 = uniqueId;

  var pathEvents = [{
    origin: 'moving',
    instance: 'onMovingHandle'
  }, {
    origin: 'scaling',
    instance: 'onScalingHandle'
  }, {
    origin: 'rotating',
    instance: 'onRotatingHandle'
  }];

  var ToolBase =
  /*#__PURE__*/
  function () {
    function ToolBase(canvas, style) {
      _classCallCheck(this, ToolBase);

      this.cxt = canvas;
      this.style = style;
      this.isMouseDown = false;
      this.hasSelected = false;
      this.bindEvent();
    }

    _createClass(ToolBase, [{
      key: "bindEvent",
      value: function bindEvent() {// this.cxt.on('text:changed', ({
        //   target
        // }) => {
        //   console.log(target.text);
        // });
      }
    }, {
      key: "onMousedownHandle",
      value: function onMousedownHandle(event) {
        this.isMouseDown = true;
      }
    }, {
      key: "onMouseupHandle",
      value: function onMouseupHandle(event) {
        this.isMouseDown = false;
      }
    }, {
      key: "onMousemoveHandle",
      value: function onMousemoveHandle(event) {
        var _event$0$e = event[0].e,
            movementX = _event$0$e.movementX,
            movementY = _event$0$e.movementY;

        if (movementX < 0 && movementY < 0) {
          this.direction = 'leftTop';
        } else if (movementX < 0 && movementY > 0) {
          this.direction = 'leftBottom';
        } else if (movementX > 0 && movementY < 0) {
          this.direction = 'rightTop';
        } else if (movementX > 0 && movementY > 0) {
          this.direction = 'rightBottom';
        }

        if (this.isMouseDown) {
          this.onMouseDragHandle(event);
        }
      }
    }, {
      key: "onMouseDragHandle",
      value: function onMouseDragHandle(event) {}
    }, {
      key: "onMovingHandle",
      value: function onMovingHandle(e) {}
    }, {
      key: "onRotatingHandle",
      value: function onRotatingHandle(e) {}
    }, {
      key: "onScalingHandle",
      value: function onScalingHandle(e) {}
    }, {
      key: "renderPath",
      value: function renderPath(path) {
        var ignoreRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!path) return;
        path.id = uniqueId_1('wbPath');
        path.toolType = this.toolType;
        !ignoreRender && this.cxt.add(path);
        this.bindEvent(path);
      }
    }, {
      key: "bindEvent",
      value: function bindEvent(path) {
        var _this = this;

        if (!path) return;
        pathEvents.forEach(function (event) {
          path.on(event.origin, _this[event.instance]);
        });
        path.on('selected', function (e) {
          _this.hasSelected = true;
          console.log(path);
          path.hasControls = true;
        });
        path.on('deselected', function (e) {
          _this.hasSelected = false;
          path.hasControls = false;
        });
      }
    }, {
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;
      }
    }]);

    return ToolBase;
  }();

  var Circle =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Circle, _ToolBase);

    function Circle() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Circle);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Circle)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.CIRCLE;
      return _this;
    }

    _createClass(Circle, [{
      key: "onMousedownHandle",
      value: function onMousedownHandle(event) {
        _get(_getPrototypeOf(Circle.prototype), "onMousedownHandle", this).call(this, event);

        this.downPointer = event[0].pointer;
      }
    }, {
      key: "onMouseDragHandle",
      value: function onMouseDragHandle(event) {
        if (!this.hasSelected) {
          var _this$downPointer = this.downPointer,
              x = _this$downPointer.x,
              y = _this$downPointer.y;

          if (this.circle) {
            this.cxt.remove(this.circle);
            this.circle = null;
          }
          var radius = Math.abs(event[0].pointer.y - this.downPointer.y);
          var beginPointer = {
            left: x,
            top: y
          };

          if (this.direction === ('leftTop')) {
            beginPointer = {
              left: event[0].pointer.x,
              top: event[0].pointer.y
            };
          }

          var options = Object.assign({}, this.style, {
            radius: radius,
            left: beginPointer.left,
            top: beginPointer.top
          });
          this.circle = new fabric_2.Circle(options);
          this.renderPath(this.circle);
        }
      }
    }, {
      key: "onMouseupHandle",
      value: function onMouseupHandle(e) {
        _get(_getPrototypeOf(Circle.prototype), "onMouseupHandle", this).call(this, e);

        if (!this.circle) return;
        this.renderPath(this.circle);
        this.circle = null;
        this.downPointer = null;
      }
    }, {
      key: "getLineLength",
      value: function getLineLength(start, end) {
        return Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2));
      }
    }]);

    return Circle;
  }(ToolBase);

  var Text =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Text, _ToolBase);

    function Text() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Text);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Text)).call.apply(_getPrototypeOf2, [this].concat(arg)));

      _this.bindLintener();

      _this.toolType = toolTypes.TEXT;
      return _this;
    }

    _createClass(Text, [{
      key: "onMousedownHandle",
      value: function onMousedownHandle(event) {
        _get(_getPrototypeOf(Text.prototype), "onMousedownHandle", this).call(this, event);

        if (!this.hasSelected) {
          this.text = new fabric_2.Textbox(' ', {
            left: event[0].pointer.x,
            top: event[0].pointer.y,
            width: 100,
            lineHeight: 0.9,
            height: 40
          });
        }
      }
    }, {
      key: "bindLintener",
      value: function bindLintener() {
        this.cxt.on('text:changed', function (_ref) {
          var target = _ref.target;
          console.log(target);
        });
      }
    }, {
      key: "onMouseupHandle",
      value: function onMouseupHandle(event) {
        _get(_getPrototypeOf(Text.prototype), "onMouseupHandle", this).call(this, event);

        this.renderPath(this.text);
        this.text.enterEditing(event);
      }
    }]);

    return Text;
  }(ToolBase);

  var Pen =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Pen, _ToolBase);

    function Pen() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Pen);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Pen)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.PEN;

      _this.cxt.on('path:created', function (object) {
        if (_this.toolActive) {
          _this.renderPath(object.path, true);
        }
      });

      return _this;
    }

    _createClass(Pen, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;
        this.cxt.isDrawingMode = selected;
      }
    }, {
      key: "style",
      set: function set(style) {
        this.cxt.freeDrawingBrush.color = style.color;
        this.cxt.freeDrawingBrush.width = style.width;
      }
    }]);

    return Pen;
  }(ToolBase);

  var MarkPen =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(MarkPen, _ToolBase);

    function MarkPen() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MarkPen);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MarkPen)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.MARKPEN;

      _this.cxt.on('path:created', function (object) {
        if (_this.toolActive) {
          _this.renderPath(object.path, true);
        }
      });

      return _this;
    }

    _createClass(MarkPen, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;

        if (selected) {
          this.cxt.isDrawingMode = true;
        }
      }
    }, {
      key: "style",
      set: function set(style) {
        this.cxt.freeDrawingBrush.color = style.color;
        this.cxt.freeDrawingBrush.width = style.width;
      }
    }]);

    return MarkPen;
  }(ToolBase);

  var Eraser =
  /*#__PURE__*/
  function (_ToolBase) {
    _inherits(Eraser, _ToolBase);

    function Eraser() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Eraser);

      for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
        arg[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Eraser)).call.apply(_getPrototypeOf2, [this].concat(arg)));
      _this.toolType = toolTypes.ERASER;

      _this.cxt.on('path:created', function (object) {
        if (_this.toolActive) {
          object.path.selectable = false;

          _this.renderPath(object.path, true);
        }
      });

      return _this;
    }

    _createClass(Eraser, [{
      key: "selected",
      set: function set(selected) {
        this.toolActive = selected;

        if (selected) {
          this.cxt.freeDrawingBrush.color = '#fff';
          this.cxt.isDrawingMode = true;
        }
      }
    }, {
      key: "style",
      set: function set(style) {
        this.cxt.freeDrawingBrush.width = style.width;
      }
    }]);

    return Eraser;
  }(ToolBase);

  var Tools =
  /*#__PURE__*/
  function () {
    function Tools(canvas, style) {
      var _this = this;

      _classCallCheck(this, Tools);

      this.drawJSON = function (data) {
        var constructor = capitalize_1(data.type);
        fabric[constructor].fromObject(data, function (path) {
          _this.cxt.add(path);
        });
      };

      this.cxt = canvas;
      this.style = Object.assign({}, {
        fill: 'transparent'
      }, style);
      this.initTools();
    }

    _createClass(Tools, [{
      key: "initTools",
      value: function initTools() {
        this.toolList = [new Circle(this.cxt, this.style), new Text(this.cxt, this.style), new Pen(this.cxt, this.style), new MarkPen(this.cxt, this.style), new Eraser(this.cxt, this.style)];
      }
    }, {
      key: "tools",
      get: function get() {
        return this.toolList;
      }
    }]);

    return Tools;
  }();

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  var _arrayFilter = arrayFilter;

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = _createBaseFor();

  var _baseFor = baseFor;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$1.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$2.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

    return value === proto;
  }

  var _isPrototype = isPrototype;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    _baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  var _baseFilter = baseFilter;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new _ListCache;
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$6 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */
  var Map$1 = _getNative(_root, 'Map');

  var _Map = Map$1;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _ListCache) {
      var pairs = data.__data__;
      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new _MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;

  var _Stack = Stack;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);
    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new _MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;

  var _SetCache = SetCache;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  var _arraySome = arraySome;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!_arraySome(other, function(othValue, othIndex) {
              if (!_cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  /** Built-in value references. */
  var Uint8Array$1 = _root.Uint8Array;

  var _Uint8Array = Uint8Array$1;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$1 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$1:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag$1:
        var convert = _mapToArray;

      case setTag$1:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$1;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  var _equalByTag = equalByTag;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };

  var _getSymbols = getSymbols;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$a.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  /* Built-in method references that are verified to be native. */
  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;

  /* Built-in method references that are verified to be native. */
  var Promise$1 = _getNative(_root, 'Promise');

  var _Promise = Promise$1;

  /* Built-in method references that are verified to be native. */
  var Set = _getNative(_root, 'Set');

  var _Set = Set;

  /* Built-in method references that are verified to be native. */
  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;

  /** `Object#toString` result references. */
  var mapTag$2 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$2 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$2 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = _baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
      (_Map && getTag(new _Map) != mapTag$2) ||
      (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
      (_Set && getTag(new _Set) != setTag$2) ||
      (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
    getTag = function(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$2;
          case mapCtorString: return mapTag$2;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$2;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var _getTag = getTag;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$2 = '[object Object]';

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);

    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

    var objIsObj = objTag == objectTag$2,
        othIsObj = othTag == objectTag$2,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack);
      return (objIsArr || isTypedArray_1(object))
        ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$8.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$8.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new _Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new _Stack);
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
      return value !== value && other !== other;
    }
    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  var _baseIsMatch = baseIsMatch;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, _isStrictComparable(value)];
    }
    return result;
  }

  var _getMatchData = getMatchData;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = _getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol_1(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  var _isKey = isKey;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || _MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = _MapCache;

  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize_1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = _memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var _stringToPath = stringToPath;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }
    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = _castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) &&
      (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get_1(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn_1(object, path)
        : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity_1;
    }
    if (typeof value == 'object') {
      return isArray_1(value)
        ? _baseMatchesProperty(value[0], value[1])
        : _baseMatches(value);
    }
    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
    return func(collection, _baseIteratee(predicate, 3));
  }

  var filter_1 = filter;

  var Store =
  /*#__PURE__*/
  function () {
    function Store(props) {
      _classCallCheck(this, Store);

      var renderPath = props.renderPath;
      this.cxt = props.cxt;
      this.items = [];
      this.redos = [];
      this.undos = [];
    }

    _createClass(Store, [{
      key: "add",
      value: function add(pathInfo) {
        this.items.push(pathInfo);
      }
    }, {
      key: "drawPath",
      value: function drawPath(ptah) {
        this.cxt.add(path);
      }
    }, {
      key: "delete",
      value: function _delete(id) {
        var _this = this;

        var paths = [];

        if (!id) {
          //delete selected
          paths = filter_1(this.items, function (item) {
            return item.hasControls;
          });
        }
        paths = filter_1(this.items, function (item) {
          return item.id === id;
        });
        this.items = filter_1(this.items, function (item) {
          return item.id !== id;
        });
        paths.map(function (path) {
          return _this.cxt.remove(path);
        });
      }
    }, {
      key: "clearAll",
      value: function clearAll() {
        this.items = [];
        this.cxt.clear();
      }
    }, {
      key: "redo",
      value: function redo() {
        debugger;

        if (this.redos.length > 0) {
          var length = this.redos.length;
          var redoPath = this.redos[length - 1];
          this.cxt.add(redoPath);
          this.add(redoPath);
          this.redos = filter_1(this.redos, function (item) {
            return item.id !== redoPath.id;
          });
        }
      }
    }, {
      key: "undo",
      value: function undo() {
        debugger;
        var length = this.items.length;
        if (length === 0) return;
        var undoPath = this.items[length - 1];
        this.redos = _toConsumableArray(this.redos).concat([undoPath]);
        this.delete(undoPath.id);
      }
    }]);

    return Store;
  }();

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  var _arrayEach = arrayEach;

  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */
  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayEach : _baseEach;
    return func(collection, _castFunction(iteratee));
  }

  var forEach_1 = forEach;

  var mouseEvents = [{
    origin: 'mouse:up',
    instance: 'onMouseupHandle'
  }, {
    origin: 'mouse:down',
    instance: 'onMousedownHandle'
  }, {
    origin: 'mouse:move',
    instance: 'onMousemoveHandle'
  }];

  var whiteboard =
  /*#__PURE__*/
  function () {
    function whiteboard(props) {
      var _this = this;

      _classCallCheck(this, whiteboard);

      this.changeTool = function (tool) {
        forEach_1(_this.toolGroup.tools, function (itemTool) {
          if (tool === itemTool.toolType) {
            _this.currentTool = itemTool;
            itemTool.selected = true;
          } else {
            itemTool.selected = false;
          }
        });
        console.log(_this.currentTool);
      };

      var id = props.id,
          _props$width = props.width,
          width = _props$width === void 0 ? 1000 : _props$width,
          _props$height = props.height,
          height = _props$height === void 0 ? 700 : _props$height;
      this.props = props;
      this.originCanvas = findDom("#".concat(id));
      this.canvas = new fabric_2.Canvas(id, {
        width: width,
        height: height,
        selection: false
      });
      this.store = new Store({
        cxt: this.canvas
      });
      window.cxt = this.canvas; // need delete

      window.store = this.store;
      this.toolGroup = new Tools(this.canvas, {
        borderColor: '#00B8FC',
        cornerColor: '#FF4B59',
        cornerSize: 6,
        strokeWidth: 1,
        stroke: '#000000',
        hasControls: false,
        fontSize: 20,
        transparentCorners: true,
        color: 'rgba(26, 209, 255, .7)',
        width: 10
      });
      window.changeTool = this.changeTool;

      window.currentTool = function () {
        return _this.currentTool;
      };

      this.bindListener();
      this.checkParams();
    }

    _createClass(whiteboard, [{
      key: "redo",
      value: function redo() {
        this.store.redo();
      }
    }, {
      key: "undo",
      value: function undo() {
        this.store.undo();
      }
      /**
       * tool is one of toolTypes
       */

    }, {
      key: "drawJSON",

      /**
       * 
       * @param {JASON} data path instance json
       * draw receive data
       */
      value: function drawJSON(data) {
        this.toolGroup.drawJSON(data);
      }
    }, {
      key: "deleteAll",
      value: function deleteAll() {
        this.store.clearAll();
      }
      /**
       * param[id] path instance id
       */

    }, {
      key: "delete",
      value: function _delete(id) {
        this.store.delete(id);
      }
    }, {
      key: "bindListener",
      value: function bindListener() {
        var _this2 = this;

        mouseEvents.forEach(function (item) {
          _this2.canvas.on(item.origin, function () {
            for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
              arg[_key] = arguments[_key];
            }

            _this2.currentTool && _this2.currentTool[item.instance] && _this2.currentTool[item.instance](arg);
          });
        });
        this.canvas.on('path:created', function (object) {
          var path = object.path;
          var id = path.id,
              toolType = path.toolType;

          _this2.store.add(path);
        });
        this.canvas.on('selection:created', function (path) {});
        this.canvas.on('object:moving', function (path) {});
        this.canvas.on('object:rotating', function (path) {});
        this.canvas.on('object:skewing', function (path) {});
      }
    }, {
      key: "checkParams",
      value: function checkParams() {
        if (!this.props.id) {
          log.error('need whiteboard ID');
        }
      }
    }, {
      key: "currentToolInfo",
      set: function set(toolInfo) {
        var tool = toolInfo.tool;
        this.changeTool(tool);
      }
      /**
       * 
       */

    }, {
      key: "selection",
      set: function set(selection) {
        this.canvas && (this.canvas.selection = selection);
      }
    }]);

    return whiteboard;
  }();

  window.whitebord = whiteboard;

  return whiteboard;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2hpdGVib2FyZC5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3V0aWxzL2RvbS5qcyIsIi4uL3NyYy91dGlscy9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtZ2xvYmFscy9zcmMvZ2xvYmFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvYmFzZTY0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1lczYvaWVlZTc1NC5qcyIsIi4uL25vZGVfbW9kdWxlcy9idWZmZXItZXM2L2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvYnVmZmVyLWVzNi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcmVzb2x2ZS9zcmMvZW1wdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzIiwiLi4vc3JjL2NvbnN0YW50cy90b29scy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFNsaWNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9BcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUNhc2VGaXJzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdXBwZXJGaXJzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FwaXRhbGl6ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pcXVlSWQuanMiLCIuLi9zcmMvdG9vbHMvVG9vbEJhc2UuanMiLCIuLi9zcmMvdG9vbHMvQ2lyY2xlLmpzIiwiLi4vc3JjL3Rvb2xzL1RleHQuanMiLCIuLi9zcmMvdG9vbHMvUGVuLmpzIiwiLi4vc3JjL3Rvb2xzL01hcmtQZW4uanMiLCIuLi9zcmMvdG9vbHMvRXJhc2VyLmpzIiwiLi4vc3JjL3Rvb2xzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIi4uL3NyYy9TdG9yZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIi4uL3NyYy9XaGl0ZWJvYXJkLmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcmVhdGVEb20gPSBmdW5jdGlvbiAoZWwgPSAnZGl2JywgdHBsID0gJycsIGF0dHJzID0ge30sIGNuYW1lID0gJycpIHtcbiAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwpXG4gIGRvbS5jbGFzc05hbWUgPSBjbmFtZVxuICBkb20uaW5uZXJIVE1MID0gdHBsXG4gIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGxldCBrZXkgPSBpdGVtO1xuICAgIGxldCB2YWx1ZSA9IGF0dHJzW2l0ZW1dXG4gICAgaWYgKGVsID09PSAndmlkZW8nIHx8IGVsID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgfVxuICB9KVxuICByZXR1cm4gZG9tXG59XG5cbmV4cG9ydCBjb25zdCBoYXNDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChlbC5jbGFzc0xpc3QsIGl0ZW0gPT4gaXRlbSA9PT0gY2xhc3NOYW1lKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBjbGFzc05hbWUucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCAnJykuc3BsaXQoL1xccysvZykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW0gJiYgZWwuY2xhc3NMaXN0LmFkZChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZVxuICB9XG59XG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSkge1xuICAgIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgbGV0IHJlZyA9IG5ldyBSZWdFeHAoJyhcXFxcc3xeKScgKyBpdGVtICsgJyhcXFxcc3wkKScpXG4gICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShyZWcsICcgJylcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmIChoYXNDbGFzcyhlbCwgaXRlbSkpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGVsLCBpdGVtKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDbGFzcyhlbCwgaXRlbSlcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBmaW5kRG9tID0gZnVuY3Rpb24gKHNlbCwgZWwgPSBkb2N1bWVudCkge1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWwpXG59XG5cbmV4cG9ydCBjb25zdCBwYWRTdGFydCA9IGZ1bmN0aW9uIChzdHIsIGxlbmd0aCwgcGFkKSB7XG4gIGxldCBjaGFyc3RyID0gU3RyaW5nKHBhZCk7XG4gIGxldCBsZW4gPSBsZW5ndGggPj4gMDtcbiAgbGV0IG1heGxlbiA9IE1hdGguY2VpbChsZW4gLyBjaGFyc3RyLmxlbmd0aClcbiAgbGV0IGNoYXJzID0gW107XG4gIGxldCByID0gU3RyaW5nKHN0cilcbiAgd2hpbGUgKG1heGxlbi0tKSB7XG4gICAgY2hhcnMucHVzaChjaGFyc3RyKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKS5zdWJzdHJpbmcoMCwgbGVuIC0gci5sZW5ndGgpICsgclxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgaWYgKHdpbmRvdy5pc05hTih0aW1lKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIGxldCBob3VyID0gcGFkU3RhcnQoTWF0aC5mbG9vcih0aW1lIC8gMzYwMCksIDIsIDApXG4gIGxldCBtaW51dGUgPSBwYWRTdGFydChNYXRoLmZsb29yKCh0aW1lIC0gaG91ciAqIDM2MDApIC8gNjApLCAyLCAwKVxuICBsZXQgc2Vjb25kID0gcGFkU3RhcnQoTWF0aC5mbG9vcigodGltZSAtIGhvdXIgKiAzNjAwIC0gbWludXRlICogNjApKSwgMiwgMClcbiAgcmV0dXJuIChob3VyID09PSAnMDAnID8gW21pbnV0ZSwgc2Vjb25kXSA6IFtob3VyLCBtaW51dGUsIHNlY29uZF0pLmpvaW4oJzonKVxufVxuXG5leHBvcnQgY29uc3QgZXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZS50b3VjaGVzKSB7XG4gICAgbGV0IHRvdWNoID0gZS50b3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICBlLmNsaWVudFggPSB0b3VjaC5jbGllbnRYIHx8IDBcbiAgICBlLmNsaWVudFkgPSB0b3VjaC5jbGllbnRZIHx8IDBcbiAgICBlLm9mZnNldFggPSB0b3VjaC5wYWdlWCAtIHRvdWNoLnRhcmdldC5vZmZzZXRMZWZ0XG4gICAgZS5vZmZzZXRZID0gdG91Y2gucGFnZVkgLSB0b3VjaC50YXJnZXQub2Zmc2V0VG9wXG4gIH1cbiAgZS5fdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50XG59XG5cbmV4cG9ydCBjb25zdCB0eXBlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvKFteXFxzLipdKykoPz1dJCkvZylbMF1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZXBDb3B5ID0gZnVuY3Rpb24gKGRzdCwgc3JjKSB7XG4gIGlmICh0eXBlT2Yoc3JjKSA9PT0gJ09iamVjdCcgJiYgdHlwZU9mKGRzdCkgPT09ICdPYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodHlwZU9mKHNyY1trZXldKSA9PT0gJ09iamVjdCcgJiYgIShzcmNba2V5XSBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICAgIGlmICghZHN0W2tleV0pIHtcbiAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVlcENvcHkoZHN0W2tleV0sIHNyY1trZXldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZHN0XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCB7XG4gICdsb2cnOiBmdW5jdGlvbiAobG9nTXNnKSB7XG4gICAgY29uc29sZS5sb2cobG9nTXNnKTtcbiAgfSxcbiAgJ2Vycm9yJzogKG1zZykgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuIiwiXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXVxuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5leHBvcnQgZGVmYXVsdCBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuaW1wb3J0ICogYXMgaWVlZTc1NCBmcm9tICcuL2llZWU3NTQnXG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXknXG5cbmV4cG9ydCB2YXIgSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWVcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIF9rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5leHBvcnQge19rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGh9O1xuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICByZXR1cm4gdHJ1ZTtcbiAgLy8gcm9sbHVwIGlzc3Vlc1xuICAvLyB0cnkge1xuICAvLyAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAvLyAgIGFyci5fX3Byb3RvX18gPSB7XG4gIC8vICAgICBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuICAvLyAgICAgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gIC8vICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIC8vICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gICByZXR1cm4gZmFsc2VcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIC8vICAgdmFsdWU6IG51bGwsXG4gICAgLy8gICBjb25maWd1cmFibGU6IHRydWVcbiAgICAvLyB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5mdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJleHBvcnQgZGVmYXVsdCB7fTtcbiIsIi8qIGJ1aWxkOiBgbm9kZSBidWlsZC5qcyBtb2R1bGVzPUFMTCBleGNsdWRlPWdlc3R1cmVzLGFjY2Vzc29ycyByZXF1aXJlanMgbWluaWZpZXI9dWdsaWZ5anNgICovXG4vKiEgRmFicmljLmpzIENvcHlyaWdodCAyMDA4LTIwMTUsIFByaW50aW8gKEp1cml5IFpheXRzZXYsIE1heGltIENoZXJueWFrKSAqL1xuXG52YXIgZmFicmljID0gZmFicmljIHx8IHsgdmVyc2lvbjogJzIuMy4zJyB9O1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmZhYnJpYyA9IGZhYnJpYztcbn1cbi8qIF9BTURfU1RBUlRfICovXG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhYnJpYzsgfSk7XG59XG4vKiBfQU1EX0VORF8gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICBmYWJyaWMud2luZG93ID0gd2luZG93O1xufVxuZWxzZSB7XG4gIC8vIGFzc3VtZSB3ZSdyZSBydW5uaW5nIHVuZGVyIG5vZGUuanMgd2hlbiBkb2N1bWVudC93aW5kb3cgYXJlIG5vdCBwcmVzZW50XG4gIGZhYnJpYy5kb2N1bWVudCA9IHJlcXVpcmUoJ2pzZG9tJylcbiAgICAuanNkb20oXG4gICAgICBkZWNvZGVVUklDb21wb25lbnQoJyUzQyFET0NUWVBFJTIwaHRtbCUzRSUzQ2h0bWwlM0UlM0NoZWFkJTNFJTNDJTJGaGVhZCUzRSUzQ2JvZHklM0UlM0MlMkZib2R5JTNFJTNDJTJGaHRtbCUzRScpLFxuICAgICAgeyBmZWF0dXJlczoge1xuICAgICAgICBGZXRjaEV4dGVybmFsUmVzb3VyY2VzOiBbJ2ltZyddXG4gICAgICB9XG4gICAgICB9KTtcbiAgZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vbGl2aW5nL2dlbmVyYXRlZC91dGlscycpLmltcGxGb3JXcmFwcGVyO1xuICBmYWJyaWMubm9kZUNhbnZhcyA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS91dGlscycpLkNhbnZhcztcbiAgZmFicmljLndpbmRvdyA9IGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0VmlldztcbiAgRE9NUGFyc2VyID0gcmVxdWlyZSgneG1sZG9tJykuRE9NUGFyc2VyO1xufVxuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHRvdWNoIGV2ZW50c1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy53aW5kb3c7XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQncyBwcm9iYWJseSBOb2RlLmpzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc0xpa2VseU5vZGUgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4vKiBfRlJPTV9TVkdfU1RBUlRfICovXG4vKipcbiAqIEF0dHJpYnV0ZXMgcGFyc2VkIGZyb20gYWxsIFNWRyBlbGVtZW50c1xuICogQHR5cGUgYXJyYXlcbiAqL1xuZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTID0gW1xuICBcImRpc3BsYXlcIixcbiAgXCJ0cmFuc2Zvcm1cIixcbiAgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsXG4gIFwib3BhY2l0eVwiLFxuICBcInN0cm9rZVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsXG4gIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJpZFwiLCBcInBhaW50LW9yZGVyXCIsXG4gIFwiaW5zdGFudGlhdGVkX2J5X3VzZVwiXG5dO1xuLyogX0ZST01fU1ZHX0VORF8gKi9cblxuLyoqXG4gKiBQaXhlbCBwZXIgSW5jaCBhcyBhIGRlZmF1bHQgdmFsdWUgc2V0IHRvIDk2LiBDYW4gYmUgY2hhbmdlZCBmb3IgbW9yZSByZWFsaXN0aWMgY29udmVyc2lvbi5cbiAqL1xuZmFicmljLkRQSSA9IDk2O1xuZmFicmljLnJlTnVtID0gJyg/OlstK10/KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OmVbLStdP1xcXFxkKyk/KSc7XG5mYWJyaWMuZm9udFBhdGhzID0geyB9O1xuZmFicmljLmlNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5mYWJyaWMuY2FudmFzTW9kdWxlID0gJ2NhbnZhcyc7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLiAxTXB4ICwgNE1weCBzaG91bGQgYmUgZmluZS5cbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCA9IDIwOTcxNTI7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzIHdpZHRoIG9yIGhlaWdodC4gSUUgZml4ZXMgdGhlIG1heGltdW0gYXQgNTAwMFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQgPSA0MDk2O1xuXG4vKipcbiAqIExvd2VzdCBwaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMsIHNldCBhdCAyNTZQWFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWluQ2FjaGVTaWRlTGltaXQgPSAyNTY7XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogaWYgd2ViZ2wgaXMgZW5hYmxlZCBhbmQgYXZhaWxhYmxlLCB0ZXh0dXJlU2l6ZSB3aWxsIGRldGVybWluZSB0aGUgc2l6ZVxuICogb2YgdGhlIGNhbnZhcyBiYWNrZW5kXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnRleHR1cmVTaXplID0gMjA0ODtcblxuLyoqXG4gKiBFbmFibGUgd2ViZ2wgZm9yIGZpbHRlcmluZyBwaWN0dXJlIGlzIGF2YWlsYWJsZVxuICogQSBmaWx0ZXJpbmcgYmFja2VuZCB3aWxsIGJlIGluaXRpYWxpemVkLCB0aGlzIHdpbGwgYm90aCB0YWtlIG1lbW9yeSBhbmRcbiAqIHRpbWUgc2luY2UgYSBkZWZhdWx0IDIwNDh4MjA0OCBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgZ2wgY29udGV4dFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgPSB0cnVlO1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcbi8qKlxuICogQnJvd3Nlci1zcGVjaWZpYyBjb25zdGFudCB0byBhZGp1c3QgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnNoYWRvd0JsdXIgdmFsdWUsXG4gKiB3aGljaCBpcyB1bml0bGVzcyBhbmQgbm90IHJlbmRlcmVkIGVxdWFsbHkgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFZhbHVlcyB0aGF0IHdvcmsgcXVpdGUgd2VsbCAoYXMgb2YgT2N0b2JlciAyMDE3KSBhcmU6XG4gKiAtIENocm9tZTogMS41XG4gKiAtIEVkZ2U6IDEuNzVcbiAqIC0gRmlyZWZveDogMC45XG4gKiAtIFNhZmFyaTogMC45NVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdCAxXG4gKi9cbmZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ID0gMTtcblxuZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kID0gZnVuY3Rpb24oKSB7XG4gIGlmIChmYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgJiYgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgJiYgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQoZmFicmljLnRleHR1cmVTaXplKSkge1xuICAgIGNvbnNvbGUubG9nKCdtYXggdGV4dHVyZSBzaXplOiAnICsgZmFicmljLm1heFRleHR1cmVTaXplKTtcbiAgICByZXR1cm4gKG5ldyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kKHsgdGlsZVNpemU6IGZhYnJpYy50ZXh0dXJlU2l6ZSB9KSk7XG4gIH1cbiAgZWxzZSBpZiAoZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCkge1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQoKSk7XG4gIH1cbn07XG5cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZW5zdXJlIGdsb2JhbGl0eSBldmVuIGlmIGVudGlyZSBsaWJyYXJ5IHdlcmUgZnVuY3Rpb24gd3JhcHBlZCAoYXMgaW4gTWV0ZW9yLmpzIHBhY2thZ2luZyBzeXN0ZW0pXG4gIHdpbmRvdy5mYWJyaWMgPSBmYWJyaWM7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGV2ZW50TGlzdGVuZXIgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZXZlbnRMaXN0ZW5lcltldmVudExpc3RlbmVyLmluZGV4T2YoaGFuZGxlcildID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLnV0aWwuYXJyYXkuZmlsbChldmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVzIHNwZWNpZmllZCBldmVudFxuICAgKiBAZGVwcmVjYXRlZCBgb2JzZXJ2ZWAgZGVwcmVjYXRlZCBzaW5jZSAwLjguMzQgKHVzZSBgb25gIGluc3RlYWQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb25cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2ZShldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0geyB9O1xuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGV2ZW50IG9ic2VydmluZyBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IGhhbmRsZXIuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogd2l0aG91dCBhcmd1bWVudHMgcmVtb3ZlcyBhbGwgaGFuZGxlcnMgZm9yIGFsbCBldmVudHNcbiAgICogQGRlcHJlY2F0ZWQgYHN0b3BPYnNlcnZpbmdgIGRlcHJlY2F0ZWQgc2luY2UgMC44LjM0ICh1c2UgYG9mZmAgaW5zdGVhZClcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvZmZcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRvIGJlIGRlbGV0ZWQgZnJvbSBFdmVudExpc3RlbmVyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIHN0b3BPYnNlcnZpbmcoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWxsIGtleS92YWx1ZSBwYWlycyAoZXZlbnQgbmFtZSAtPiBldmVudCBoYW5kbGVyKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBldmVudCB3aXRoIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkIGBmaXJlYCBkZXByZWNhdGVkIHNpbmNlIDEuMC43ICh1c2UgYHRyaWdnZXJgIGluc3RlYWQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgdHJpZ2dlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZmlyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlyZShldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnNGb3JFdmVudCA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzRm9yRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc0ZvckV2ZW50W2ldICYmIGxpc3RlbmVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7IH0pO1xuICAgIH1cbiAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVyc0ZvckV2ZW50LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2V2ZW50c31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9ldmVudHN8RXZlbnRzIGRlbW99XG4gICAqL1xuICBmYWJyaWMuT2JzZXJ2YWJsZSA9IHtcbiAgICBvYnNlcnZlOiBvYnNlcnZlLFxuICAgIHN0b3BPYnNlcnZpbmc6IHN0b3BPYnNlcnZpbmcsXG4gICAgZmlyZTogZmlyZSxcblxuICAgIG9uOiBvYnNlcnZlLFxuICAgIG9mZjogc3RvcE9ic2VydmluZyxcbiAgICB0cmlnZ2VyOiBmaXJlXG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29sbGVjdGlvblxuICovXG5mYWJyaWMuQ29sbGVjdGlvbiA9IHtcblxuICBfb2JqZWN0czogW10sXG5cbiAgLyoqXG4gICAqIEFkZHMgb2JqZWN0cyB0byBjb2xsZWN0aW9uLCBDYW52YXMgb3IgR3JvdXAsIHRoZW4gcmVuZGVycyBjYW52YXNcbiAgICogKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApLlxuICAgKiBpbiBjYXNlIG9mIEdyb3VwIG5vIGNoYW5nZXMgdG8gYm91bmRpbmcgYm94IGFyZSBtYWRlLlxuICAgKiBPYmplY3RzIHNob3VsZCBiZSBpbnN0YW5jZXMgb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyBoaWdobHkgZGlzY291cmFnZWQgZm9yIGdyb3Vwcy5cbiAgICogeW91IGNhbiBhZGQgYSBidW5jaCBvZiBvYmplY3RzIHdpdGggdGhlIGFkZCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX29iamVjdHMucHVzaC5hcHBseSh0aGlzLl9vYmplY3RzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLl9vbk9iamVjdEFkZGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29uT2JqZWN0QWRkZWQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBvYmplY3QgaW50byBjb2xsZWN0aW9uIGF0IHNwZWNpZmllZCBpbmRleCwgdGhlbiByZW5kZXJzIGNhbnZhcyAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYClcbiAgICogQW4gb2JqZWN0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgaW5zZXJ0QXQgbWV0aG9kIGJ1dCB0aGVuIHlvdSBORUVEXG4gICAqIHRvIHJ1biBhIGFkZFdpdGhVcGRhdGUgY2FsbCBmb3IgdGhlIEdyb3VwIGNsYXNzIG9yIHBvc2l0aW9uL2Jib3ggd2lsbCBiZSB3cm9uZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBpbnNlcnQgb2JqZWN0IGF0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9uU3BsaWNpbmcgV2hlbiBgdHJ1ZWAsIG5vIHNwbGljaW5nIChzaGlmdGluZykgb2Ygb2JqZWN0cyBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBpbnNlcnRBdDogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIG5vblNwbGljaW5nKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKTtcbiAgICBpZiAobm9uU3BsaWNpbmcpIHtcbiAgICAgIG9iamVjdHNbaW5kZXhdID0gb2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgIH1cbiAgICB0aGlzLl9vbk9iamVjdEFkZGVkICYmIHRoaXMuX29uT2JqZWN0QWRkZWQob2JqZWN0KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG9iamVjdHMgZnJvbSBhIGNvbGxlY3Rpb24sIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBXaGVuIHNwZWNpZmllZCwgb25seSBvYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgcmV0dXJuZWRcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRPYmplY3RzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gby50eXBlID09PSB0eXBlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCBhdCBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICovXG4gIGl0ZW06IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdHMoKVtpbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIG9iamVjdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNoZWNrIGFnYWluc3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqL1xuICBjb250YWluczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmluZGV4T2Yob2JqZWN0KSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhIGNvbGxlY3Rpb24gY29tcGxleGl0eVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICovXG4gIGNvbXBsZXhpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RzKCkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyZW50KSB7XG4gICAgICBtZW1vICs9IGN1cnJlbnQuY29tcGxleGl0eSA/IGN1cnJlbnQuY29tcGxleGl0eSgpIDogMDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29tbW9uTWV0aG9kc1xuICovXG5mYWJyaWMuQ29tbW9uTWV0aG9kcyA9IHtcblxuICAvKipcbiAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBfc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXQocHJvcCwgb3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBHcmFkaWVudCB0b1xuICAgKi9cbiAgX2luaXRHcmFkaWVudDogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSkge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLmNvbG9yU3RvcHMgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuR3JhZGllbnQpKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5HcmFkaWVudChmaWxsZXIpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIFBhdHRlcm4gdG9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgcGF0dGVybiBsb2FkXG4gICAqL1xuICBfaW5pdFBhdHRlcm46IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuc291cmNlICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLlBhdHRlcm4pKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5QYXR0ZXJuKGZpbGxlciwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgX2luaXRDbGlwcGluZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jbGlwVG8gfHwgdHlwZW9mIG9wdGlvbnMuY2xpcFRvICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmdW5jdGlvbkJvZHkgPSBmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5jbGlwVG8pO1xuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25Cb2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jbGlwVG8gPSBuZXcgRnVuY3Rpb24oJ2N0eCcsIGZ1bmN0aW9uQm9keSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIHRoaXMuX3NldChwcm9wLCBvYmpbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9zZXRPYmplY3Qoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIGtleSAhPT0gJ2NsaXBUbycpIHtcbiAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUodGhpcy5nZXQoa2V5KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGB0cnVlYCB0byBgZmFsc2VgIG9yIGZyb20gYGZhbHNlYCB0byBgdHJ1ZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHRvZ2dsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgIXZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2ljIGdldHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICBQaUJ5MTgwID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgIFBpQnkyID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWxcbiAgICovXG4gIGZhYnJpYy51dGlsID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3Mgb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBjb3M6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDE7IH1cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gY29zKGEpID0gY29zKC1hKVxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5MjtcbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IGNhc2UgMzogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaW4gb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBzaW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5Miwgc2lnbiA9IDE7XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIHNpbigtYSkgPSAtc2luKGEpXG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBzaWduO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDM6IHJldHVybiAtc2lnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNpbihhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBQcmVzZW5jZSBvZiB2YWx1ZSAoYW5kIGl0cyBwb3NpdGlvbiBpbiBhbiBhcnJheSkgaXMgZGV0ZXJtaW5lZCB2aWEgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3JpZ2luYWwgYXJyYXlcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXk6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDIgc3BlY2lmaWVkIG9uZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHVwcGVyIGxpbWl0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSByYW5kb20gdmFsdWUgKGJldHdlZW4gbWluIGFuZCBtYXgpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tSW50OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgZGVncmVlc1RvUmFkaWFuczogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIHJhZGlhbnNUb0RlZ3JlZXM6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICAgIHJldHVybiByYWRpYW5zIC8gUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgcG9pbnRgIGFyb3VuZCBgb3JpZ2luYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW4sIHJhZGlhbnMpIHtcbiAgICAgIHBvaW50LnN1YnRyYWN0RXF1YWxzKG9yaWdpbik7XG4gICAgICB2YXIgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3Rvcihwb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHJ4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcbiAgICAgICAgICByeSA9IHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByeCxcbiAgICAgICAgeTogcnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0IHRvIHBvaW50IHBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLlBvaW50fSBwIFRoZSBwb2ludCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lnbm9yZU9mZnNldF0gSW5kaWNhdGVzIHRoYXQgdGhlIG9mZnNldCBzaG91bGQgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwLCB0LCBpZ25vcmVPZmZzZXQpIHtcbiAgICAgIGlmIChpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnksXG4gICAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSArIHRbNF0sXG4gICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55ICsgdFs1XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBwb2ludHMncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgNCBwb2ludHMgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWFrZUJvdW5kaW5nQm94RnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICB2YXIgeFBvaW50cyA9IFtwb2ludHNbMF0ueCwgcG9pbnRzWzFdLngsIHBvaW50c1syXS54LCBwb2ludHNbM10ueF0sXG4gICAgICAgICAgbWluWCA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih4UG9pbnRzKSxcbiAgICAgICAgICBtYXhYID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHhQb2ludHMpLFxuICAgICAgICAgIHdpZHRoID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgeVBvaW50cyA9IFtwb2ludHNbMF0ueSwgcG9pbnRzWzFdLnksIHBvaW50c1syXS55LCBwb2ludHNbM10ueV0sXG4gICAgICAgICAgbWluWSA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih5UG9pbnRzKSxcbiAgICAgICAgICBtYXhZID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHlQb2ludHMpLFxuICAgICAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCB0cmFuc2Zvcm1hdGlvbiB0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgaW52ZXJ0ZWQgdHJhbnNmb3JtXG4gICAgICovXG4gICAgaW52ZXJ0VHJhbnNmb3JtOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgYSA9IDEgLyAodFswXSAqIHRbM10gLSB0WzFdICogdFsyXSksXG4gICAgICAgICAgciA9IFthICogdFszXSwgLWEgKiB0WzFdLCAtYSAqIHRbMl0sIGEgKiB0WzBdXSxcbiAgICAgICAgICBvID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiB0WzRdLCB5OiB0WzVdIH0sIHIsIHRydWUpO1xuICAgICAgcls0XSA9IC1vLng7XG4gICAgICByWzVdID0gLW8ueTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIE51bWJlciN0b0ZpeGVkLCB3aGljaCBjb250cmFyeSB0byBuYXRpdmUgbWV0aG9kIHJldHVybnMgbnVtYmVyLCBub3Qgc3RyaW5nLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjdGlvbkRpZ2l0cyBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIFwibGVhdmVcIlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0b0ZpeGVkOiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChOdW1iZXIobnVtYmVyKS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYXR0cmlidXRlIHZhbHVlIHRvIHBpeGVsIHZhbHVlIGlmIGFwcGxpY2FibGUuXG4gICAgICogUmV0dXJucyBjb252ZXJ0ZWQgcGl4ZWxzIG9yIG9yaWdpbmFsIHZhbHVlIG5vdCBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgcGFyc2VVbml0OiBmdW5jdGlvbih2YWx1ZSwgZm9udFNpemUpIHtcbiAgICAgIHZhciB1bml0ID0gL1xcRHswLDJ9JC8uZXhlYyh2YWx1ZSksXG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoIWZvbnRTaXplKSB7XG4gICAgICAgIGZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDI1LjQ7XG5cbiAgICAgICAgY2FzZSAnY20nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMi41NDtcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEk7XG5cbiAgICAgICAgY2FzZSAncHQnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzI7IC8vIG9yICogNCAvIDNcblxuICAgICAgICBjYXNlICdwYyc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MiAqIDEyOyAvLyBvciAqIDE2XG5cbiAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmb250U2l6ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZmFsc2VGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIG9iamVjdCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGtsYXNzIFwiQ2xhc3NcIlxuICAgICAqL1xuICAgIGdldEtsYXNzOiBmdW5jdGlvbih0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgIC8vIGNhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9ubHlcbiAgICAgIHR5cGUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FtZWxpemUodHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlKVt0eXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBhdHRyaWJ1dGVzIGZvciBnaXZlbiBzdmcgdGhhdCBmYWJyaWMgcGFyc2VzXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBzdmcgZWxlbWVudCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHJpbmcgbmFtZXMgb2Ygc3VwcG9ydGVkIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBnZXRTdmdBdHRyaWJ1dGVzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnaWQnLFxuICAgICAgICAnY2xhc3MnXG4gICAgICBdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xpbmVhckdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWyd4MScsICd5MScsICd4MicsICd5MicsICdncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYWRpYWxHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybScsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdG9wJzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydvZmZzZXQnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2Ugc3RyaW5nIGUuZy4gJ2ZhYnJpYy5JbWFnZS5maWx0ZXInIG9yICdmYWJyaWMnXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgZm9yIGdpdmVuIG5hbWVzcGFjZSAoZGVmYXVsdCBmYWJyaWMpXG4gICAgICovXG4gICAgcmVzb2x2ZU5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZmFicmljO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoJy4nKSxcbiAgICAgICAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsIGksXG4gICAgICAgICAgb2JqID0gZ2xvYmFsIHx8IGZhYnJpYy53aW5kb3c7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBpbWFnZSBlbGVtZW50IGZyb20gZ2l2ZW4gdXJsIGFuZCBwYXNzZXMgaXQgdG8gYSBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHJlcHJlc2VudGluZyBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSB0byBzZXQgaW1hZ2UgZWxlbWVudCB0b1xuICAgICAqL1xuICAgIGxvYWRJbWFnZTogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgY29udGV4dCwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHZhciBvbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBpbWcpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IG9uTG9hZENhbGxiYWNrO1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0Vycm9yIGxvYWRpbmcgJyArIGltZy5zcmMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gZGF0YS11cmxzIGFwcGVhciB0byBiZSBidWdneSB3aXRoIGNyb3NzT3JpZ2luXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9jb21taXQvZDBhYmI5MGYxY2Q1YzVlZjlkMmE5NGQzZmIyMWEyMjMzMGRhM2UwYSNjb21taXRjb21tZW50LTQ1MTM3NjdcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzE1MTUyXG4gICAgICAvLyAgICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM1MDY5XG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGEnKSAhPT0gMCAmJiBjcm9zc09yaWdpbikge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIH1cblxuICAgICAgLy8gSUUxMCAvIElFMTEtRml4OiBTVkcgY29udGVudHMgZnJvbSBkYXRhOiBVUklcbiAgICAgIC8vIHdpbGwgb25seSBiZSBhdmFpbGFibGUgaWYgdGhlIElNRyBpcyBwcmVzZW50XG4gICAgICAvLyBpbiB0aGUgRE9NIChhbmQgdmlzaWJsZSlcbiAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsMTQpID09PSAnZGF0YTppbWFnZS9zdmcnKSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2VJbkRvbShpbWcsIG9uTG9hZENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgU1ZHIGltYWdlIHdpdGggZGF0YTogVVJMIHRvIHRoZSBkb21cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1nIEltYWdlIG9iamVjdCB3aXRoIGRhdGE6aW1hZ2Uvc3ZnIHNyY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBET00gZWxlbWVudCAoZGl2IGNvbnRhaW5pbmcgdGhlIFNWRyBpbWFnZSlcbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VJbkRvbTogZnVuY3Rpb24oaW1nLCBvbkxvYWRDYWxsYmFjaykge1xuICAgICAgdmFyIGRpdiA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gZGl2LnN0eWxlLnRvcCA9ICctMTAwJSc7XG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICBmYWJyaWMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgaW4gZnVuY3Rpb24gdG86XG4gICAgICAgKiAgIDEuIENhbGwgZXhpc3RpbmcgY2FsbGJhY2tcbiAgICAgICAqICAgMi4gQ2xlYW51cCBET01cbiAgICAgICAqL1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Mb2FkQ2FsbGJhY2soKTtcbiAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIGZyb20gdGhlaXIgb2JqZWN0IHJlcHJlc2VudGF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJldml2ZXIgTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygb2JqZWN0IGVsZW1lbnRzLFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2ssIG5hbWVzcGFjZSwgcmV2aXZlcikge1xuICAgICAgb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRPYmplY3RzID09PSBudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICBncm91cFNWR0VsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNlbnRlclBvaW50ID0ge1xuICAgICAgICAgICAgeDogb3B0aW9ucy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBvcHRpb25zLmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gbmV3IGZhYnJpYy5Hcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvcGVydGllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGRhc2hlZCBsaW5lIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkcmF3IGRhc2hlZCBsaW5lIGFyb3VuZCBzZWxlY3Rpb24gYXJlYS5cbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1wiPmRvdHRlZCBzdHJva2UgaW4gY2FudmFzPC9hPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggIHN0YXJ0IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHN0YXJ0IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBlbmQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIGVuZCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYSBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKi9cbiAgICBkcmF3RGFzaGVkTGluZTogZnVuY3Rpb24oY3R4LCB4LCB5LCB4MiwgeTIsIGRhKSB7XG4gICAgICB2YXIgZHggPSB4MiAtIHgsXG4gICAgICAgICAgZHkgPSB5MiAtIHksXG4gICAgICAgICAgbGVuID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgcm90ID0gYXRhbjIoZHksIGR4KSxcbiAgICAgICAgICBkYyA9IGRhLmxlbmd0aCxcbiAgICAgICAgICBkaSA9IDAsXG4gICAgICAgICAgZHJhdyA9IHRydWU7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5yb3RhdGUocm90KTtcblxuICAgICAgeCA9IDA7XG4gICAgICB3aGlsZSAobGVuID4geCkge1xuICAgICAgICB4ICs9IGRhW2RpKysgJSBkY107XG4gICAgICAgIGlmICh4ID4gbGVuKSB7XG4gICAgICAgICAgeCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBjdHhbZHJhdyA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHgsIDApO1xuICAgICAgICBkcmF3ID0gIWRyYXc7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW1hZ2UgZWxlbWVudCAod29ya3Mgb24gY2xpZW50IGFuZCBub2RlKVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIGltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMi4wLjBcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHJlY2VpdmVyIE9iamVjdCBpbXBsZW1lbnRpbmcgYGNsaXBUb2AgbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNsaXBcbiAgICAgKi9cbiAgICBjbGlwQ29udGV4dDogZnVuY3Rpb24ocmVjZWl2ZXIsIGN0eCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHJlY2VpdmVyLmNsaXBUbyhjdHgpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgbWF0cml4IEEgYnkgbWF0cml4IEIgdG8gbmVzdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgRmlyc3QgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGIgU2Vjb25kIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzMngyIGZsYWcgdG8gbXVsdGlwbHkgbWF0cmljZXMgYXMgMngyIG1hdHJpY2VzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBwcm9kdWN0IG9mIHRoZSB0d28gdHJhbnNmb3JtIG1hdHJpY2VzXG4gICAgICovXG4gICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlczogZnVuY3Rpb24oYSwgYiwgaXMyeDIpIHtcbiAgICAgIC8vIE1hdHJpeCBtdWx0aXBseSBhICogYlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYVswXSAqIGJbMF0gKyBhWzJdICogYlsxXSxcbiAgICAgICAgYVsxXSAqIGJbMF0gKyBhWzNdICogYlsxXSxcbiAgICAgICAgYVswXSAqIGJbMl0gKyBhWzJdICogYlszXSxcbiAgICAgICAgYVsxXSAqIGJbMl0gKyBhWzNdICogYlszXSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVswXSAqIGJbNF0gKyBhWzJdICogYls1XSArIGFbNF0sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMV0gKiBiWzRdICsgYVszXSAqIGJbNV0gKyBhWzVdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvbXBvc2VzIHN0YW5kYXJkIDJ4MiBtYXRyaXggaW50byB0cmFuc2Zvcm0gY29tcG9uZW50ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHFyRGVjb21wb3NlOiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYW5nbGUgPSBhdGFuMihhWzFdLCBhWzBdKSxcbiAgICAgICAgICBkZW5vbSA9IHBvdyhhWzBdLCAyKSArIHBvdyhhWzFdLCAyKSxcbiAgICAgICAgICBzY2FsZVggPSBzcXJ0KGRlbm9tKSxcbiAgICAgICAgICBzY2FsZVkgPSAoYVswXSAqIGFbM10gLSBhWzJdICogYSBbMV0pIC8gc2NhbGVYLFxuICAgICAgICAgIHNrZXdYID0gYXRhbjIoYVswXSAqIGFbMl0gKyBhWzFdICogYSBbM10sIGRlbm9tKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOiBhbmdsZSAgLyBQaUJ5MTgwLFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCAvIFBpQnkxODAsXG4gICAgICAgIHNrZXdZOiAwLFxuICAgICAgICB0cmFuc2xhdGVYOiBhWzRdLFxuICAgICAgICB0cmFuc2xhdGVZOiBhWzVdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBjdXN0b21UcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNjYWxlWCwgc2NhbGVZLCBza2V3WCkge1xuICAgICAgdmFyIHNrZXdNYXRyaXhYID0gWzEsIDAsIGFicyhNYXRoLnRhbihza2V3WCAqIFBpQnkxODApKSwgMV0sXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbYWJzKHNjYWxlWCksIDAsIDAsIGFicyhzY2FsZVkpXTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHNjYWxlTWF0cml4LCBza2V3TWF0cml4WCwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHJlc2V0T2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuc2NhbGVYID0gMTtcbiAgICAgIHRhcmdldC5zY2FsZVkgPSAxO1xuICAgICAgdGFyZ2V0LnNrZXdYID0gMDtcbiAgICAgIHRhcmdldC5za2V3WSA9IDA7XG4gICAgICB0YXJnZXQuZmxpcFggPSBmYWxzZTtcbiAgICAgIHRhcmdldC5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LnJvdGF0ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZnVuY3Rpb24gYm9keVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGdldCBib2R5IG9mXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBGdW5jdGlvbiBib2R5XG4gICAgICovXG4gICAgZ2V0RnVuY3Rpb25Cb2R5OiBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIChTdHJpbmcoZm4pLm1hdGNoKC9mdW5jdGlvbltee10qXFx7KFtcXHNcXFNdKilcXH0vKSB8fCB7fSlbMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBjb250ZXh0IGhhcyB0cmFuc3BhcmVudCBwaXhlbFxuICAgICAqIGF0IHNwZWNpZmllZCBsb2NhdGlvbiAodGFraW5nIHRvbGVyYW5jZSBpbnRvIGFjY291bnQpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2VcbiAgICAgKi9cbiAgICBpc1RyYW5zcGFyZW50OiBmdW5jdGlvbihjdHgsIHgsIHksIHRvbGVyYW5jZSkge1xuXG4gICAgICAvLyBJZiB0b2xlcmFuY2UgaXMgPiAwIGFkanVzdCBzdGFydCBjb29yZHMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICAvLyBJZiBtb3ZlcyBvZmYgQ2FudmFzIGZpeCB0byAwXG4gICAgICBpZiAodG9sZXJhbmNlID4gMCkge1xuICAgICAgICBpZiAoeCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHggLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeSAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9pc1RyYW5zcGFyZW50ID0gdHJ1ZSwgaSwgdGVtcCxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksICh0b2xlcmFuY2UgKiAyKSB8fCAxLCAodG9sZXJhbmNlICogMikgfHwgMSksXG4gICAgICAgICAgbCA9IGltYWdlRGF0YS5kYXRhLmxlbmd0aDtcblxuICAgICAgLy8gU3BsaXQgaW1hZ2UgZGF0YSAtIGZvciB0b2xlcmFuY2UgPiAxLCBwaXhlbERhdGFTaXplID0gNDtcbiAgICAgIGZvciAoaSA9IDM7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgdGVtcCA9IGltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICBfaXNUcmFuc3BhcmVudCA9IHRlbXAgPD0gMDtcbiAgICAgICAgaWYgKF9pc1RyYW5zcGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIGNvbG91ciBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBfaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGUgZnJvbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSB0byBiZSBwYXJzZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsaWduIGFuZCBtZWV0T3JTbGljZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIG1lZXRPclNsaWNlID0gJ21lZXQnLCBhbGlnblggPSAnTWlkJywgYWxpZ25ZID0gJ01pZCcsXG4gICAgICAgICAgYXNwZWN0UmF0aW9BdHRycyA9IGF0dHJpYnV0ZS5zcGxpdCgnICcpLCBhbGlnbjtcblxuICAgICAgaWYgKGFzcGVjdFJhdGlvQXR0cnMgJiYgYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICBpZiAobWVldE9yU2xpY2UgIT09ICdtZWV0JyAmJiBtZWV0T3JTbGljZSAhPT0gJ3NsaWNlJykge1xuICAgICAgICAgIGFsaWduID0gbWVldE9yU2xpY2U7XG4gICAgICAgICAgbWVldE9yU2xpY2UgPSAnbWVldCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICBhbGlnbiA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZGl2aWRlIGFsaWduIGluIGFsaWduWCBhbmQgYWxpZ25ZXG4gICAgICBhbGlnblggPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoMSwgNCkgOiAnbm9uZSc7XG4gICAgICBhbGlnblkgPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoNSwgOCkgOiAnbm9uZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWV0T3JTbGljZTogbWVldE9yU2xpY2UsXG4gICAgICAgIGFsaWduWDogYWxpZ25YLFxuICAgICAgICBhbGlnblk6IGFsaWduWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY2hhciB3aWR0aHMgY2FjaGUgZm9yIHRoZSBnaXZlbiBmb250IGZhbWlseSBvciBhbGwgdGhlIGNhY2hlIGlmIG5vXG4gICAgICogZm9udEZhbWlseSBpcyBzcGVjaWZpZWQuXG4gICAgICogVXNlIGl0IGlmIHlvdSBrbm93IHlvdSBhcmUgbG9hZGluZyBmb250cyBpbiBhIGxhenkgd2F5IGFuZCB5b3UgYXJlIG5vdCB3YWl0aW5nXG4gICAgICogZm9yIGN1c3RvbSBmb250cyB0byBsb2FkIHByb3Blcmx5IHdoZW4gYWRkaW5nIHRleHQgb2JqZWN0cyB0byB0aGUgY2FudmFzLlxuICAgICAqIElmIGEgdGV4dCBvYmplY3QgaXMgYWRkZWQgd2hlbiBpdHMgb3duIGZvbnQgaXMgbm90IGxvYWRlZCB5ZXQsIHlvdSB3aWxsIGdldCB3cm9uZ1xuICAgICAqIG1lYXN1cmVtZW50IGFuZCBzbyB3cm9uZyBib3VuZGluZyBib3hlcy5cbiAgICAgKiBBZnRlciB0aGUgZm9udCBjYWNoZSBpcyBjbGVhcmVkLCBlaXRoZXIgY2hhbmdlIHRoZSB0ZXh0T2JqZWN0IHRleHQgY29udGVudCBvciBjYWxsXG4gICAgICogaW5pdERpbWVuc2lvbnMoKSB0byB0cmlnZ2VyIGEgcmVjYWxjdWxhdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udEZhbWlseV0gZm9udCBmYW1pbHkgdG8gY2xlYXJcbiAgICAgKi9cbiAgICBjbGVhckZhYnJpY0ZvbnRDYWNoZTogZnVuY3Rpb24oZm9udEZhbWlseSkge1xuICAgICAgZm9udEZhbWlseSA9IChmb250RmFtaWx5IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBjdXJyZW50IGFzcGVjdCByYXRpbywgZGV0ZXJtaW5lcyB0aGUgbWF4IHdpZHRoIGFuZCBoZWlnaHQgdGhhdCBjYW5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXIgYXNwZWN0IHJhdGlvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW1BcmVhIE1heGltdW0gYXJlYSB5b3Ugd2FudCB0byBhY2hpZXZlXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnh9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBYXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBZXG4gICAgICovXG4gICAgbGltaXREaW1zQnlBcmVhOiBmdW5jdGlvbihhciwgbWF4aW11bUFyZWEpIHtcbiAgICAgIHZhciByb3VnaFdpZHRoID0gTWF0aC5zcXJ0KG1heGltdW1BcmVhICogYXIpLFxuICAgICAgICAgIHBlcmZMaW1pdFNpemVZID0gTWF0aC5mbG9vcihtYXhpbXVtQXJlYSAvIHJvdWdoV2lkdGgpO1xuICAgICAgcmV0dXJuIHsgeDogTWF0aC5mbG9vcihyb3VnaFdpZHRoKSwgeTogcGVyZkxpbWl0U2l6ZVkgfTtcbiAgICB9LFxuXG4gICAgY2FwVmFsdWU6IGZ1bmN0aW9uKG1pbiwgdmFsdWUsIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICAgIH0sXG5cbiAgICBmaW5kU2NhbGVUb0ZpdDogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZmluZFNjYWxlVG9Db3ZlcjogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH0sXG4gICAgICBzZWdtZW50VG9CZXppZXJDYWNoZSA9IHsgfSxcbiAgICAgIGJvdW5kc09mQ3VydmVDYWNoZSA9IHsgfSxcbiAgICAgIF9qb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG5cbiAgLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICAgKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gICAqIGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wL1xuICAgKi9cbiAgZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgICB2YXIgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICByZXR1cm4gYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddO1xuICAgIH1cblxuICAgIHZhciBQSSA9IE1hdGguUEksIHRoID0gcm90YXRlWCAqIFBJIC8gMTgwLFxuICAgICAgICBzaW5UaCA9IGZhYnJpYy51dGlsLnNpbih0aCksXG4gICAgICAgIGNvc1RoID0gZmFicmljLnV0aWwuY29zKHRoKSxcbiAgICAgICAgZnJvbVggPSAwLCBmcm9tWSA9IDA7XG5cbiAgICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICAgIHZhciBweCA9IC1jb3NUaCAqIHRvWCAqIDAuNSAtIHNpblRoICogdG9ZICogMC41LFxuICAgICAgICBweSA9IC1jb3NUaCAqIHRvWSAqIDAuNSArIHNpblRoICogdG9YICogMC41LFxuICAgICAgICByeDIgPSByeCAqIHJ4LCByeTIgPSByeSAqIHJ5LCBweTIgPSBweSAqIHB5LCBweDIgPSBweCAqIHB4LFxuICAgICAgICBwbCA9IHJ4MiAqIHJ5MiAtIHJ4MiAqIHB5MiAtIHJ5MiAqIHB4MixcbiAgICAgICAgcm9vdCA9IDA7XG5cbiAgICBpZiAocGwgPCAwKSB7XG4gICAgICB2YXIgcyA9IE1hdGguc3FydCgxIC0gcGwgLyAocngyICogcnkyKSk7XG4gICAgICByeCAqPSBzO1xuICAgICAgcnkgKj0gcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByb290ID0gKGxhcmdlID09PSBzd2VlcCA/IC0xLjAgOiAxLjApICpcbiAgICAgICAgICAgICAgTWF0aC5zcXJ0KCBwbCAvIChyeDIgKiBweTIgKyByeTIgKiBweDIpKTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSByb290ICogcnggKiBweSAvIHJ5LFxuICAgICAgICBjeSA9IC1yb290ICogcnkgKiBweCAvIHJ4LFxuICAgICAgICBjeDEgPSBjb3NUaCAqIGN4IC0gc2luVGggKiBjeSArIHRvWCAqIDAuNSxcbiAgICAgICAgY3kxID0gc2luVGggKiBjeCArIGNvc1RoICogY3kgKyB0b1kgKiAwLjUsXG4gICAgICAgIG1UaGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgxLCAwLCAocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnkpLFxuICAgICAgICBkdGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5LCAoLXB4IC0gY3gpIC8gcngsICgtcHkgLSBjeSkgLyByeSk7XG5cbiAgICBpZiAoc3dlZXAgPT09IDAgJiYgZHRoZXRhID4gMCkge1xuICAgICAgZHRoZXRhIC09IDIgKiBQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3dlZXAgPT09IDEgJiYgZHRoZXRhIDwgMCkge1xuICAgICAgZHRoZXRhICs9IDIgKiBQSTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gY3ViaWMgYmV6aWVyIHNlZ21lbnRzIDw9IDkwZGVnXG4gICAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGR0aGV0YSAvIFBJICogMikpLFxuICAgICAgICByZXN1bHQgPSBbXSwgbURlbHRhID0gZHRoZXRhIC8gc2VnbWVudHMsXG4gICAgICAgIG1UID0gOCAvIDMgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAqIE1hdGguc2luKG1EZWx0YSAvIDQpIC8gTWF0aC5zaW4obURlbHRhIC8gMiksXG4gICAgICAgIHRoMyA9IG1UaGV0YSArIG1EZWx0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gc2VnbWVudFRvQmV6aWVyKG1UaGV0YSwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpO1xuICAgICAgZnJvbVggPSByZXN1bHRbaV1bNF07XG4gICAgICBmcm9tWSA9IHJlc3VsdFtpXVs1XTtcbiAgICAgIG1UaGV0YSA9IHRoMztcbiAgICAgIHRoMyArPSBtRGVsdGE7XG4gICAgfVxuICAgIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKHRoMiwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpIHtcbiAgICB2YXIgYXJnc1N0cmluZzIgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXSkge1xuICAgICAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXTtcbiAgICB9XG5cbiAgICB2YXIgY29zdGgyID0gZmFicmljLnV0aWwuY29zKHRoMiksXG4gICAgICAgIHNpbnRoMiA9IGZhYnJpYy51dGlsLnNpbih0aDIpLFxuICAgICAgICBjb3N0aDMgPSBmYWJyaWMudXRpbC5jb3ModGgzKSxcbiAgICAgICAgc2ludGgzID0gZmFicmljLnV0aWwuc2luKHRoMyksXG4gICAgICAgIHRvWCA9IGNvc1RoICogcnggKiBjb3N0aDMgLSBzaW5UaCAqIHJ5ICogc2ludGgzICsgY3gxLFxuICAgICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMVkgPSBmcm9tWSArIG1UICogKCAtc2luVGggKiByeCAqIHNpbnRoMiArIGNvc1RoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgICBzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyaW5nMl0gPSBbXG4gICAgICBjcDFYLCBjcDFZLFxuICAgICAgY3AyWCwgY3AyWSxcbiAgICAgIHRvWCwgdG9ZXG4gICAgXTtcbiAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdO1xuICB9XG5cbiAgLypcbiAgICogUHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgICB0YiA9IE1hdGguYXRhbjIodnksIHZ4KTtcbiAgICBpZiAodGIgPj0gdGEpIHtcbiAgICAgIHJldHVybiB0YiAtIHRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgYXJjXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHNcbiAgICovXG4gIGZhYnJpYy51dGlsLmRyYXdBcmMgPSBmdW5jdGlvbihjdHgsIGZ4LCBmeSwgY29vcmRzKSB7XG4gICAgdmFyIHJ4ID0gY29vcmRzWzBdLFxuICAgICAgICByeSA9IGNvb3Jkc1sxXSxcbiAgICAgICAgcm90ID0gY29vcmRzWzJdLFxuICAgICAgICBsYXJnZSA9IGNvb3Jkc1szXSxcbiAgICAgICAgc3dlZXAgPSBjb29yZHNbNF0sXG4gICAgICAgIHR4ID0gY29vcmRzWzVdLFxuICAgICAgICB0eSA9IGNvb3Jkc1s2XSxcbiAgICAgICAgc2VncyA9IFtbXSwgW10sIFtdLCBbXV0sXG4gICAgICAgIHNlZ3NOb3JtID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzTm9ybS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2Vnc1tpXVswXSA9IHNlZ3NOb3JtW2ldWzBdICsgZng7XG4gICAgICBzZWdzW2ldWzFdID0gc2Vnc05vcm1baV1bMV0gKyBmeTtcbiAgICAgIHNlZ3NbaV1bMl0gPSBzZWdzTm9ybVtpXVsyXSArIGZ4O1xuICAgICAgc2Vnc1tpXVszXSA9IHNlZ3NOb3JtW2ldWzNdICsgZnk7XG4gICAgICBzZWdzW2ldWzRdID0gc2Vnc05vcm1baV1bNF0gKyBmeDtcbiAgICAgIHNlZ3NbaV1bNV0gPSBzZWdzTm9ybVtpXVs1XSArIGZ5O1xuICAgICAgY3R4LmJlemllckN1cnZlVG8uYXBwbHkoY3R4LCBzZWdzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBlbGxpcHRpYy1hcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0IHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4IGhvcml6b250YWwgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeSB2ZXJ0aWNhbCByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdCBhbmdsZSBvZiBob3Jpem9udGFsIGF4ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGFyZ2UgMSBvciAwLCB3aGF0ZXZlciB0aGUgYXJjIGlzIHRoZSBiaWcgb3IgdGhlIHNtYWxsIG9uIHRoZSAyIHBvaW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3dlZXAgMSBvciAwLCAxIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gdHggZW5kIHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gdHlcbiAgICovXG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjID0gZnVuY3Rpb24oZngsIGZ5LCByeCwgcnksIHJvdCwgbGFyZ2UsIHN3ZWVwLCB0eCwgdHkpIHtcblxuICAgIHZhciBmcm9tWCA9IDAsIGZyb21ZID0gMCwgYm91bmQsIGJvdW5kcyA9IFtdLFxuICAgICAgICBzZWdzID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBib3VuZCA9IGdldEJvdW5kc09mQ3VydmUoZnJvbVgsIGZyb21ZLCBzZWdzW2ldWzBdLCBzZWdzW2ldWzFdLCBzZWdzW2ldWzJdLCBzZWdzW2ldWzNdLCBzZWdzW2ldWzRdLCBzZWdzW2ldWzVdKTtcbiAgICAgIGJvdW5kcy5wdXNoKHsgeDogYm91bmRbMF0ueCArIGZ4LCB5OiBib3VuZFswXS55ICsgZnkgfSk7XG4gICAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzFdLnggKyBmeCwgeTogYm91bmRbMV0ueSArIGZ5IH0pO1xuICAgICAgZnJvbVggPSBzZWdzW2ldWzRdO1xuICAgICAgZnJvbVkgPSBzZWdzW2ldWzVdO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgYmV6aWVyY3VydmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgwIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgZmlyc3QgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHNlY29uZG8gY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIGVuZCBvZiBiZWl6ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gICAqL1xuICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaXZvbWlxLzU2L2VkaXQgIG5vIGNyZWRpdHMgYXZhaWxhYmxlIGZvciB0aGF0LlxuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkN1cnZlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgIGlmIChib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICAgIHJldHVybiBib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ107XG4gICAgfVxuXG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIHR2YWx1ZXMgPSBbXSxcbiAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzcXJ0YjJhYyA9IHNxcnQoYjJhYyk7XG4gICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLCBqbGVuID0gaiwgbXQ7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG5cbiAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICBib3VuZHNbMV1bal0gPSB5O1xuICAgIH1cblxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgIHtcbiAgICAgICAgeDogbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH1cbiAgICBdO1xuICAgIGJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGdldEJvdW5kc09mQ3VydmU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBqcyBvYmplY3QgdG8gYW5vdGhlclxuICAgKiBEb2VzIG5vdCBjbG9uZSBvciBleHRlbmQgZmFicmljLk9iamVjdCBzdWJjbGFzc2VzLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBXaGVyZSB0byBjb3B5IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgV2hlcmUgdG8gY29weSBmcm9tXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3RpbmF0aW9uLCBzb3VyY2UsIGRlZXApIHtcbiAgICAvLyBKU2NyaXB0IERvbnRFbnVtIGJ1ZyBpcyBub3QgdGFrZW4gY2FyZSBvZlxuICAgIC8vIHRoZSBkZWVwIGNsb25lIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5vdCBtZWFudCB0byBhdm9pZFxuICAgIC8vIGphdmFzY3JpcHQgdHJhcHMgb3IgY2xvbmluZyBodG1sIGVsZW1lbnQgb3Igc2VsZiByZWZlcmVuY2VkIG9iamVjdHMuXG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSAmJiBzb3VyY2UgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIC8vIGF2b2lkIGNsb25pbmcgZGVlcCBpbWFnZXMsIGNhbnZhc2VzLFxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltpXSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtpXSwgZGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gZXh0ZW5kKHsgfSwgc291cmNlW3Byb3BlcnR5XSwgZGVlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBzb3VuZHMgb2RkIGZvciBhbiBleHRlbmQgYnV0IGlzIG9rIGZvciByZWN1cnNpdmUgdXNlXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbXB0eSBvYmplY3QgYW5kIGNvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0IHRvIGl0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogVE9ETzogdGhpcyBmdW5jdGlvbiByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGlmIHlvdSB0cnkgdG8gY2xvbmUgbnVsbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjbG9uZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBjbG9uZShvYmplY3QsIGRlZXApIHtcbiAgICByZXR1cm4gZXh0ZW5kKHsgfSwgb2JqZWN0LCBkZWVwKTtcbiAgfVxuXG4gIC8qKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLm9iamVjdCAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QgPSB7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY2xvbmU6IGNsb25lXG4gIH07XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLnV0aWwsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYW1lbGl6ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyID8gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhcGl0YWxpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmlyc3RMZXR0ZXJPbmx5XSBJZiB0cnVlIG9ubHkgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIHN0YXkgdW50b3VjaGVkLCBpZiBmYWxzZSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgYXJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FwaXRhbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcsIGZpcnN0TGV0dGVyT25seSkge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgKGZpcnN0TGV0dGVyT25seSA/IHN0cmluZy5zbGljZSgxKSA6IHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIFhNTCBpbiBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEVzY2FwZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlWG1sKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZSBhIHN0cmluZyBpbiB0aGUgdXNlciBwZXJjZWl2ZWQgc2luZ2xlIHVuaXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgY29udGFpbmluZyB0aGUgZ3JhcGhlbWVzXG4gICAqL1xuICBmdW5jdGlvbiBncmFwaGVtZVNwbGl0KHRleHRzdHJpbmcpIHtcbiAgICB2YXIgaSA9IDAsIGNociwgZ3JhcGhlbWVzID0gW107XG4gICAgZm9yIChpID0gMCwgY2hyOyBpIDwgdGV4dHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChjaHIgPSBnZXRXaG9sZUNoYXIodGV4dHN0cmluZywgaSkpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGdyYXBoZW1lcy5wdXNoKGNocik7XG4gICAgfVxuICAgIHJldHVybiBncmFwaGVtZXM7XG4gIH1cblxuICAvLyB0YWtlbiBmcm9tIG1kbiBpbiB0aGUgY2hhckF0IGRvYyBwYWdlLlxuICBmdW5jdGlvbiBnZXRXaG9sZUNoYXIoc3RyLCBpKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgcmV0dXJuICcnOyAvLyBQb3NpdGlvbiBub3QgZm91bmRcbiAgICB9XG4gICAgaWYgKGNvZGUgPCAweEQ4MDAgfHwgY29kZSA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuXG4gICAgLy8gSGlnaCBzdXJyb2dhdGUgKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoIDw9IChpICsgMSkpIHtcbiAgICAgICAgdGhyb3cgJ0hpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGUnO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBzdHIuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBpZiAoMHhEQzAwID4gbmV4dCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpICsgc3RyLmNoYXJBdChpICsgMSk7XG4gICAgfVxuICAgIC8vIExvdyBzdXJyb2dhdGUgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIHZhciBwcmV2ID0gc3RyLmNoYXJDb2RlQXQoaSAtIDEpO1xuXG4gICAgLy8gKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwID4gcHJldiB8fCBwcmV2ID4gMHhEQkZGKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBwYXNzIG92ZXIgbG93IHN1cnJvZ2F0ZXMgbm93IGFzIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gICAgLy8gaW4gYSBwYWlyIHdoaWNoIHdlIGhhdmUgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdHJpbmcgdXRpbGl0aWVzXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqL1xuICBmYWJyaWMudXRpbC5zdHJpbmcgPSB7XG4gICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gICAgZXNjYXBlWG1sOiBlc2NhcGVYbWwsXG4gICAgZ3JhcGhlbWVTcGxpdDogZ3JhcGhlbWVTcGxpdFxuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAgIElTX0RPTlRFTlVNX0JVR0dZID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIHsgdG9TdHJpbmc6IDEgfSkge1xuICAgICAgICAgIGlmIChwID09PSAndG9TdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkoKSxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGFkZE1ldGhvZHMgPSBmdW5jdGlvbihrbGFzcywgc291cmNlLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkgaW4ga2xhc3MucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIChzb3VyY2VbcHJvcGVydHldICsgJycpLmluZGV4T2YoJ2NhbGxTdXBlcicpID4gLTEpIHtcblxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJjbGFzcyA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc291cmNlW3Byb3BlcnR5XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdpbml0aWFsaXplJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVNfRE9OVEVOVU1fQlVHR1kpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnRvU3RyaW5nID0gc291cmNlLnRvU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnZhbHVlT2YgPSBzb3VyY2UudmFsdWVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gU3ViY2xhc3MoKSB7IH1cblxuICBmdW5jdGlvbiBjYWxsU3VwZXIobWV0aG9kTmFtZSkge1xuICAgIHZhciBwYXJlbnRNZXRob2QgPSBudWxsLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBjbGltYiBwcm90b3R5cGUgY2hhaW4gdG8gZmluZCBtZXRob2Qgbm90IGVxdWFsIHRvIGNhbGxlZSdzIG1ldGhvZFxuICAgIHdoaWxlIChfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzKSB7XG4gICAgICB2YXIgc3VwZXJDbGFzc01ldGhvZCA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKF90aGlzW21ldGhvZE5hbWVdICE9PSBzdXBlckNsYXNzTWV0aG9kKSB7XG4gICAgICAgIHBhcmVudE1ldGhvZCA9IHN1cGVyQ2xhc3NNZXRob2Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBfdGhpcyA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50TWV0aG9kKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coJ3RyaWVkIHRvIGNhbGxTdXBlciAnICsgbWV0aG9kTmFtZSArICcsIG1ldGhvZCBub3QgZm91bmQgaW4gcHJvdG90eXBlIGNoYWluJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgID8gcGFyZW50TWV0aG9kLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgIDogcGFyZW50TWV0aG9kLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZvciBjcmVhdGlvbiBvZiBcImNsYXNzZXNcIi5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJlbnRdIG9wdGlvbmFsIFwiQ2xhc3NcIiB0byBpbmhlcml0IGZyb21cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAoYmUgY2FyZWZ1bCBtb2RpZnlpbmcgb2JqZWN0cyBkZWZpbmVkIGhlcmUgYXMgdGhpcyB3b3VsZCBhZmZlY3QgYWxsIGluc3RhbmNlcylcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKCkge1xuICAgIHZhciBwYXJlbnQgPSBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJlbnQgPSBwcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtsYXNzKCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAga2xhc3Muc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICBrbGFzcy5zdWJjbGFzc2VzID0gW107XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAga2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XG4gICAgICBwYXJlbnQuc3ViY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZE1ldGhvZHMoa2xhc3MsIHByb3BlcnRpZXNbaV0sIHBhcmVudCk7XG4gICAgfVxuICAgIGlmICgha2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZW1wdHlGdW5jdGlvbjtcbiAgICB9XG4gICAga2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2xhc3M7XG4gICAga2xhc3MucHJvdG90eXBlLmNhbGxTdXBlciA9IGNhbGxTdXBlcjtcbiAgICByZXR1cm4ga2xhc3M7XG4gIH1cblxuICBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciB1bmtub3duID0gJ3Vua25vd24nO1xuXG4gIC8qIEVWRU5UIEhBTkRMSU5HICovXG5cbiAgZnVuY3Rpb24gYXJlSG9zdE1ldGhvZHMob2JqZWN0KSB7XG4gICAgdmFyIG1ldGhvZE5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgdCwgaSwgbGVuID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdCA9IHR5cGVvZiBvYmplY3RbbWV0aG9kTmFtZXNbaV1dO1xuICAgICAgaWYgKCEoL14oPzpmdW5jdGlvbnxvYmplY3R8dW5rbm93bikkLykudGVzdCh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgdmFyIGdldEVsZW1lbnQsXG4gICAgICBzZXRFbGVtZW50LFxuICAgICAgZ2V0VW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdWlkID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuX191bmlxdWVJRCB8fCAoZWxlbWVudC5fX3VuaXF1ZUlEID0gJ3VuaXF1ZUlEX18nICsgdWlkKyspO1xuICAgICAgICB9O1xuICAgICAgfSkoKTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50cyA9IHsgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGdldEVsZW1lbnQgPSBmdW5jdGlvbiAodWlkKSB7XG4gICAgICByZXR1cm4gZWxlbWVudHNbdWlkXTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0RWxlbWVudCA9IGZ1bmN0aW9uICh1aWQsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzW3VpZF0gPSBlbGVtZW50O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIodWlkLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICB3cmFwcGVkSGFuZGxlcjogY3JlYXRlV3JhcHBlZEhhbmRsZXIodWlkLCBoYW5kbGVyKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVkSGFuZGxlcih1aWQsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChnZXRFbGVtZW50KHVpZCksIGUgfHwgZmFicmljLndpbmRvdy5ldmVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoZXIodWlkLCBldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChoYW5kbGVyc1t1aWRdICYmIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNGb3JFdmVudCA9IGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBoYW5kbGVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgZSB8fCBmYWJyaWMud2luZG93LmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgc2hvdWxkVXNlQWRkTGlzdGVuZXJSZW1vdmVMaXN0ZW5lciA9IChcbiAgICAgICAgYXJlSG9zdE1ldGhvZHMoZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicpICYmXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy53aW5kb3csICdhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInKSksXG5cbiAgICAgIHNob3VsZFVzZUF0dGFjaEV2ZW50RGV0YWNoRXZlbnQgPSAoXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdhdHRhY2hFdmVudCcsICdkZXRhY2hFdmVudCcpICYmXG4gICAgICAgIGFyZUhvc3RNZXRob2RzKGZhYnJpYy53aW5kb3csICdhdHRhY2hFdmVudCcsICdkZXRhY2hFdmVudCcpKSxcblxuICAgICAgLy8gSUUgYnJhbmNoXG4gICAgICBsaXN0ZW5lcnMgPSB7IH0sXG5cbiAgICAgIC8vIERPTSBMMCBicmFuY2hcbiAgICAgIGhhbmRsZXJzID0geyB9LFxuXG4gICAgICBhZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXI7XG5cbiAgaWYgKHNob3VsZFVzZUFkZExpc3RlbmVyUmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgLy8gc2luY2UgaWUxMCBvciBpZTkgY2FuIHVzZSBhZGRFdmVudExpc3RlbmVyIGJ1dCB0aGV5IGRvIG5vdCBzdXBwb3J0IG9wdGlvbnMsIGkgbmVlZCB0byBjaGVja1xuICAgICAgZWxlbWVudCAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICBlbGVtZW50ICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIHNob3VsZFVzZUF0dGFjaEV2ZW50RGV0YWNoRXZlbnQgPyBmYWxzZSA6IG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICBlbHNlIGlmIChzaG91bGRVc2VBdHRhY2hFdmVudERldGFjaEV2ZW50KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBzZXRFbGVtZW50KHVpZCwgZWxlbWVudCk7XG4gICAgICBpZiAoIWxpc3RlbmVyc1t1aWRdKSB7XG4gICAgICAgIGxpc3RlbmVyc1t1aWRdID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKCFsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0gPSBbXTtcblxuICAgICAgfVxuICAgICAgdmFyIGxpc3RlbmVyID0gY3JlYXRlTGlzdGVuZXIodWlkLCBoYW5kbGVyKTtcbiAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyLndyYXBwZWRIYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVpZCA9IGdldFVuaXF1ZUlkKGVsZW1lbnQpLCBsaXN0ZW5lcjtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdWlkXSAmJiBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbdWlkXVtldmVudE5hbWVdW2ldO1xuICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBsaXN0ZW5lci5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyLndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyc1t1aWRdW2V2ZW50TmFtZV1baV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdWlkID0gZ2V0VW5pcXVlSWQoZWxlbWVudCk7XG4gICAgICBpZiAoIWhhbmRsZXJzW3VpZF0pIHtcbiAgICAgICAgaGFuZGxlcnNbdWlkXSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdKSB7XG4gICAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICB2YXIgZXhpc3RpbmdIYW5kbGVyID0gZWxlbWVudFsnb24nICsgZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXS5wdXNoKGV4aXN0aW5nSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFsnb24nICsgZXZlbnROYW1lXSA9IGNyZWF0ZURpc3BhdGNoZXIodWlkLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgaGFuZGxlcnNbdWlkXVtldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1aWQgPSBnZXRVbmlxdWVJZChlbGVtZW50KTtcbiAgICAgIGlmIChoYW5kbGVyc1t1aWRdICYmIGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNGb3JFdmVudCA9IGhhbmRsZXJzW3VpZF1bZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcnNGb3JFdmVudFtpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcnNGb3JFdmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwucmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lcjtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBnZXR0aW5nIGV2ZW50J3MgY29vcmRpbmF0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UG9pbnRlcihldmVudCkge1xuICAgIGV2ZW50IHx8IChldmVudCA9IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICh0eXBlb2YgZXZlbnQuc3JjRWxlbWVudCAhPT0gdW5rbm93biA/IGV2ZW50LnNyY0VsZW1lbnQgOiBudWxsKSxcblxuICAgICAgICBzY3JvbGwgPSBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwb2ludGVyWChldmVudCkgKyBzY3JvbGwubGVmdCxcbiAgICAgIHk6IHBvaW50ZXJZKGV2ZW50KSArIHNjcm9sbC50b3BcbiAgICB9O1xuICB9XG5cbiAgdmFyIHBvaW50ZXJYID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmNsaWVudFg7XG4gICAgICB9LFxuXG4gICAgICBwb2ludGVyWSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5jbGllbnRZO1xuICAgICAgfTtcblxuICBmdW5jdGlvbiBfZ2V0UG9pbnRlcihldmVudCwgcGFnZVByb3AsIGNsaWVudFByb3ApIHtcbiAgICB2YXIgdG91Y2hQcm9wID0gZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyA/ICdjaGFuZ2VkVG91Y2hlcycgOiAndG91Y2hlcyc7XG4gICAgdmFyIHBvaW50ZXIsIGV2ZW50VG91Y2hQcm9wID0gZXZlbnRbdG91Y2hQcm9wXTtcblxuICAgIGlmIChldmVudFRvdWNoUHJvcCAmJiBldmVudFRvdWNoUHJvcFswXSkge1xuICAgICAgcG9pbnRlciA9IGV2ZW50VG91Y2hQcm9wWzBdW2NsaWVudFByb3BdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcG9pbnRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBvaW50ZXIgPSBldmVudFtjbGllbnRQcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRlcjtcbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIHBvaW50ZXJYID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZ2V0UG9pbnRlcihldmVudCwgJ3BhZ2VYJywgJ2NsaWVudFgnKTtcbiAgICB9O1xuICAgIHBvaW50ZXJZID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZ2V0UG9pbnRlcihldmVudCwgJ3BhZ2VZJywgJ2NsaWVudFknKTtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRlciA9IGdldFBvaW50ZXI7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBzZXR0aW5nIGVsZW1lbnQncyBzdHlsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHN0eWxlcztcbiAgICAgIHJldHVybiBzdHlsZXMuaW5kZXhPZignb3BhY2l0eScpID4gLTFcbiAgICAgICAgPyBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlcy5tYXRjaCgvb3BhY2l0eTpcXHMqKFxcZD9cXC4/XFxkKikvKVsxXSlcbiAgICAgICAgOiBlbGVtZW50O1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSA9PT0gJ2Zsb2F0JyB8fCBwcm9wZXJ0eSA9PT0gJ2Nzc0Zsb2F0JylcbiAgICAgICAgICA/ICh0eXBlb2YgZWxlbWVudFN0eWxlLnN0eWxlRmxvYXQgPT09ICd1bmRlZmluZWQnID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JylcbiAgICAgICAgICA6IHByb3BlcnR5O1xuICAgICAgICBlbGVtZW50U3R5bGVbbm9ybWFsaXplZFByb3BlcnR5XSA9IHN0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHBhcnNlRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0c09wYWNpdHkgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5vcGFjaXR5ID09PSAnc3RyaW5nJyxcbiAgICAgIHN1cHBvcnRzRmlsdGVycyA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLmZpbHRlciA9PT0gJ3N0cmluZycsXG4gICAgICByZU9wYWNpdHkgPSAvYWxwaGFcXHMqXFwoXFxzKm9wYWNpdHlcXHMqPVxccyooW15cXCldKylcXCkvLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50OyB9O1xuXG4gIGlmIChzdXBwb3J0c09wYWNpdHkpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHN1cHBvcnRzRmlsdGVycykge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgZXMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlICYmICFlbGVtZW50LmN1cnJlbnRTdHlsZS5oYXNMYXlvdXQpIHtcbiAgICAgICAgZXMuem9vbSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocmVPcGFjaXR5LnRlc3QoZXMuZmlsdGVyKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID49IDAuOTk5OSA/ICcnIDogKCdhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknKTtcbiAgICAgICAgZXMuZmlsdGVyID0gZXMuZmlsdGVyLnJlcGxhY2UocmVPcGFjaXR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXMuZmlsdGVyICs9ICcgYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5zZXRTdHlsZSA9IHNldFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBUYWtlcyBpZCBhbmQgcmV0dXJucyBhbiBlbGVtZW50IHdpdGggdGhhdCBpZCAoaWYgb25lIGV4aXN0cyBpbiBhIGRvY3VtZW50KVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlkXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gIH1cblxuICB2YXIgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzLFxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoZS5nLiBhcmd1bWVudHMgb3IgTm9kZUxpc3QpIHRvIGFuIGFycmF5XG4gICAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xuICAgICAgfTtcblxuICB0cnkge1xuICAgIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyA9IHRvQXJyYXkoZmFicmljLmRvY3VtZW50LmNoaWxkTm9kZXMpIGluc3RhbmNlb2YgQXJyYXk7XG4gIH1cbiAgY2F0Y2ggKGVycikgeyB9XG5cbiAgaWYgKCFzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMpIHtcbiAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5TGlrZS5sZW5ndGgpLCBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgYXR0cmlidXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVHlwZSBvZiBhbiBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKHByb3AgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdmb3InKSB7XG4gICAgICAgIGVsLmh0bWxGb3IgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xhc3MgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGFkZCBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCB0byBhbiBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCAmJiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdyYXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHdyYXBwZXIgRWxlbWVudCB0byB3cmFwIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhIHdyYXBwZXJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdyYXBwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQsIHdyYXBwZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3cmFwcGVyID0gbWFrZUVsZW1lbnQod3JhcHBlciwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlbGVtZW50IHNjcm9sbCBvZmZzZXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQvdG9wIHZhbHVlc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSB7XG5cbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDAsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBib2R5ID0gZmFicmljLmRvY3VtZW50LmJvZHkgfHwge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMFxuICAgICAgICB9O1xuXG4gICAgLy8gV2hpbGUgbG9vcCBjaGVja3MgKGFuZCB0aGVuIHNldHMgZWxlbWVudCB0bykgLnBhcmVudE5vZGUgT1IgLmhvc3RcbiAgICAvLyAgdG8gYWNjb3VudCBmb3IgU2hhZG93RE9NLiBXZSBzdGlsbCB3YW50IHRvIHRyYXZlcnNlIHVwIG91dCBvZiBTaGFkb3dET00sXG4gICAgLy8gIGJ1dCB0aGUgLnBhcmVudE5vZGUgb2YgYSByb290IFNoYWRvd0RPTSBub2RlIHdpbGwgYWx3YXlzIGJlIG51bGwsIGluc3RlYWRcbiAgICAvLyAgaXQgc2hvdWxkIGJlIGFjY2Vzc2VkIHRocm91Z2ggLmhvc3QuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDc2NTUyOC80MzgzOTM4XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3QpKSB7XG5cbiAgICAgIC8vIFNldCBlbGVtZW50IHRvIGVsZW1lbnQgcGFyZW50LCBvciAnaG9zdCcgaW4gY2FzZSBvZiBTaGFkb3dET01cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gZmFicmljLmRvY3VtZW50KSB7XG4gICAgICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8ICBkb2NFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCArPSBlbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvZmZzZXQgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgb2Zmc2V0IGZvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwibGVmdFwiIGFuZCBcInRvcFwiIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBkb2NFbGVtLFxuICAgICAgICBkb2MgPSBlbGVtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgYm94ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgc2Nyb2xsTGVmdFRvcCxcbiAgICAgICAgb2Zmc2V0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6ICdsZWZ0JyxcbiAgICAgICAgICBib3JkZXJUb3BXaWR0aDogICd0b3AnLFxuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAgICAgJ2xlZnQnLFxuICAgICAgICAgIHBhZGRpbmdUb3A6ICAgICAgJ3RvcCdcbiAgICAgICAgfTtcblxuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gb2Zmc2V0QXR0cmlidXRlcykge1xuICAgICAgb2Zmc2V0W29mZnNldEF0dHJpYnV0ZXNbYXR0cl1dICs9IHBhcnNlSW50KGdldEVsZW1lbnRTdHlsZShlbGVtZW50LCBhdHRyKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKCB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBzY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnRUb3AubGVmdCAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMCkgKyBvZmZzZXQubGVmdCxcbiAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbExlZnRUb3AudG9wIC0gKGRvY0VsZW0uY2xpZW50VG9wIHx8IDApICArIG9mZnNldC50b3BcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBzdHlsZSBhdHRyaWJ1dGUgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFN0eWxlIGF0dHJpYnV0ZSB0byBnZXQgZm9yIGVsZW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBTdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgZ2V0RWxlbWVudFN0eWxlO1xuICBpZiAoZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gc3R5bGUgPyBzdHlsZVthdHRyXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuc3R5bGVbYXR0cl07XG4gICAgICBpZiAoIXZhbHVlICYmIGVsZW1lbnQuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgc2VsZWN0UHJvcCA9ICd1c2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgID8gJ3VzZXJTZWxlY3QnXG4gICAgICAgICAgOiAnTW96VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgID8gJ01velVzZXJTZWxlY3QnXG4gICAgICAgICAgICA6ICdXZWJraXRVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICA/ICdXZWJraXRVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICA6ICdLaHRtbFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgICAgPyAnS2h0bWxVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICAgIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHVuc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHVuc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWJyaWMudXRpbC5mYWxzZUZ1bmN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnb24nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCBzZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2Ugc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50U2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGU7XG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRTZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRTZWxlY3RhYmxlO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBzY3JpcHQgZWxlbWVudCB3aXRoIGEgZ2l2ZW4gdXJsIGludG8gYSBkb2N1bWVudDsgaW52b2tlcyBjYWxsYmFjaywgd2hlbiB0aGF0IHNjcmlwdCBpcyBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgb2YgYSBzY3JpcHQgdG8gbG9hZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBzY3JpcHQgaXMgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjcmlwdCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGVhZEVsID0gZmFicmljLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgICAgc2NyaXB0RWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgICAgICAgbG9hZGluZyA9IHRydWU7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBzY3JpcHRFbC5vbmxvYWQgPSAvKiogQGlnbm9yZSAqLyBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlYWR5U3RhdGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSAhPT0gJ2xvYWRlZCcgJiZcbiAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFjayhlIHx8IGZhYnJpYy53aW5kb3cuZXZlbnQpO1xuICAgICAgICAgIHNjcmlwdEVsID0gc2NyaXB0RWwub25sb2FkID0gc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNjcmlwdEVsLnNyYyA9IHVybDtcbiAgICAgIGhlYWRFbC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgICAvLyBjYXVzZXMgaXNzdWUgaW4gT3BlcmFcbiAgICAgIC8vIGhlYWRFbC5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuZ2V0U2NyaXB0ID0gZ2V0U2NyaXB0O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVDYW52YXMoZWxlbWVudCkge1xuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgcmV0dXJuIGltcGwuX2NhbnZhcyB8fCBpbXBsLl9pbWFnZTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudFN0eWxlID0gZ2V0RWxlbWVudFN0eWxlO1xuICBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzID0gZ2V0Tm9kZUNhbnZhcztcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYWRkUGFyYW1Ub1VybCh1cmwsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcGFyYW07XG4gIH1cblxuICB2YXIgbWFrZVhIUiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjdG9yaWVzID0gW1xuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0sXG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSxcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7IH1cbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlcSA9IGZhY3Rvcmllc1tpXSgpO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhY3Rvcmllc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgfVxuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciBhYnN0cmFjdGlvbiBmb3Igc2VuZGluZyBYTUxIdHRwUmVxdWVzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gc2VuZCBYTUxIdHRwUmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9XCJHRVRcIl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtZXRlcnNdIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHVybCBpbiBHRVQgb3IgaW4gYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYm9keV0gYm9keSB0byBzZW5kIHdpdGggUE9TVCBvciBQVVQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ29tcGxldGUgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyxcbiAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgeGhyID0gbWFrZVhIUigpLFxuICAgICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMucGFyYW1ldGVycztcblxuICAgIC8qKiBAaWdub3JlICovXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uQ29tcGxldGUoeGhyKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5Rm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB1cmwgPSBhZGRQYXJhbVRvVXJsKHVybCwgb3B0aW9ucy5wYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnUE9TVCcgfHwgbWV0aG9kID09PSAnUFVUJykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KTtcbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgZmFicmljLnV0aWwucmVxdWVzdCA9IHJlcXVlc3Q7XG59KSgpO1xuXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUubG9nYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2dcbiAqL1xuZmFicmljLmxvZyA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLndhcm5gICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZyBhcyBhIHdhcm5pbmdcbiAqL1xuZmFicmljLndhcm4gPSBmdW5jdGlvbigpIHsgfTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICBbJ2xvZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2ROYW1lKSB7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjb25zb2xlW21ldGhvZE5hbWVdLmFwcGx5ID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgIGZhYnJpY1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uc29sZVttZXRob2ROYW1lXS5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnRWYWx1ZT0wXSBTdGFydGluZyB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZW5kVmFsdWU9MTAwXSBFbmRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ5VmFsdWU9MTAwXSBWYWx1ZSB0byBtb2RpZnkgdGhlIHByb3BlcnR5IGJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbj01MDBdIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMpIHtcblxuICAgIHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGltZXN0YW1wIHx8ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCA1MDAsXG4gICAgICAgICAgZmluaXNoID0gc3RhcnQgKyBkdXJhdGlvbiwgdGltZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2UgfHwgbm9vcCxcbiAgICAgICAgICBhYm9ydCA9IG9wdGlvbnMuYWJvcnQgfHwgbm9vcCxcbiAgICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IG5vb3AsXG4gICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgZnVuY3Rpb24odCwgYiwgYywgZCkge3JldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjt9LFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xuXG4gICAgICBvcHRpb25zLm9uU3RhcnQgJiYgb3B0aW9ucy5vblN0YXJ0KCk7XG5cbiAgICAgIChmdW5jdGlvbiB0aWNrKHRpY2t0aW1lKSB7XG4gICAgICAgIGlmIChhYm9ydCgpKSB7XG4gICAgICAgICAgb25Db21wbGV0ZShlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWUgPSB0aWNrdGltZSB8fCArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGltZSA+IGZpbmlzaCA/IGR1cmF0aW9uIDogKHRpbWUgLSBzdGFydCksXG4gICAgICAgICAgICB0aW1lUGVyYyA9IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24sXG4gICAgICAgICAgICBjdXJyZW50ID0gZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbiksXG4gICAgICAgICAgICB2YWx1ZVBlcmMgPSBNYXRoLmFicygoY3VycmVudCAtIHN0YXJ0VmFsdWUpIC8gYnlWYWx1ZSk7XG4gICAgICAgIG9uQ2hhbmdlKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpO1xuICAgICAgICBpZiAodGltZSA+IGZpbmlzaCkge1xuICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1GcmFtZSh0aWNrKTtcbiAgICAgIH0pKHN0YXJ0KTtcbiAgICB9KTtcblxuICB9XG5cbiAgdmFyIF9yZXF1ZXN0QW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFicmljLndpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gIHZhciBfY2FuY2VsQW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmYWJyaWMud2luZG93LmNsZWFyVGltZW91dDtcblxuICAvKipcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJhc2VkIG9uIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqIEluIG9yZGVyIHRvIGdldCBhIHByZWNpc2Ugc3RhcnQgdGltZSwgYHJlcXVlc3RBbmltRnJhbWVgIHNob3VsZCBiZSBjYWxsZWQgYXMgYW4gZW50cnkgaW50byB0aGUgbWV0aG9kXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IG9wdGlvbmFsIEVsZW1lbnQgdG8gYXNzb2NpYXRlIHdpdGggYW5pbWF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfcmVxdWVzdEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfY2FuY2VsQW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5hbmltYXRlID0gYW5pbWF0ZTtcbiAgZmFicmljLnV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWU7XG4gIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSA9IGNhbmNlbEFuaW1GcmFtZTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvLyBDYWxjdWxhdGUgYW4gaW4tYmV0d2VlbiBjb2xvci4gUmV0dXJucyBhIFwicmdiYSgpXCIgc3RyaW5nLlxuICAvLyBDcmVkaXQ6IEVkd2luIE1hcnRpbiA8ZWR3aW5AYml0c3Rvcm0ub3JnPlxuICAvLyAgICAgICAgIGh0dHA6Ly93d3cuYml0c3Rvcm0ub3JnL2pxdWVyeS9jb2xvci1hbmltYXRpb24vanF1ZXJ5LmFuaW1hdGUtY29sb3JzLmpzXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9yKGJlZ2luLCBlbmQsIHBvcykge1xuICAgIHZhciBjb2xvciA9ICdyZ2JhKCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMF0gKyBwb3MgKiAoZW5kWzBdIC0gYmVnaW5bMF0pKSwgMTApICsgJywnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzFdICsgcG9zICogKGVuZFsxXSAtIGJlZ2luWzFdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsyXSArIHBvcyAqIChlbmRbMl0gLSBiZWdpblsyXSkpLCAxMCk7XG5cbiAgICBjb2xvciArPSAnLCcgKyAoYmVnaW4gJiYgZW5kID8gcGFyc2VGbG9hdChiZWdpblszXSArIHBvcyAqIChlbmRbM10gLSBiZWdpblszXSkpIDogMSk7XG4gICAgY29sb3IgKz0gJyknO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBjb2xvciBmcm9tIG9uZSB0byBhbm90aGVyIHdpdGhpbiBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLCBpbnZva2luZyBjYWxsYmFja3MgYXMgdmFsdWUgaXMgYmVpbmcgY2hhbmdlZC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9Db2xvciBUaGUgc3RhcnRpbmcgY29sb3IgaW4gaGV4IG9yIHJnYihhKSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ2hhbmdlXSBDYWxsYmFjazsgaW52b2tlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNvbG9yRWFzaW5nXSBFYXNpbmcgZnVuY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgdGFrZSB0d28gYXJndW1lbnRzIChjdXJyZW50VGltZSwgZHVyYXRpb24pLiBUaHVzIHRoZSByZWd1bGFyIGFuaW1hdGlvbiBlYXNpbmcgZnVuY3Rpb25zIGNhbm5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZUNvbG9yKGZyb21Db2xvciwgdG9Db2xvciwgZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoZnJvbUNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgZW5kQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRvQ29sb3IpLmdldFNvdXJjZSgpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQob3B0aW9ucywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uIHx8IDUwMCxcbiAgICAgIHN0YXJ0VmFsdWU6IHN0YXJ0Q29sb3IsXG4gICAgICBlbmRWYWx1ZTogZW5kQ29sb3IsXG4gICAgICBieVZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGVhc2luZzogZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgcG9zVmFsdWUgPSBvcHRpb25zLmNvbG9yRWFzaW5nXG4gICAgICAgICAgPyBvcHRpb25zLmNvbG9yRWFzaW5nKGN1cnJlbnRUaW1lLCBkdXJhdGlvbilcbiAgICAgICAgICA6IDEgLSBNYXRoLmNvcyhjdXJyZW50VGltZSAvIGR1cmF0aW9uICogKE1hdGguUEkgLyAyKSk7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcihzdGFydFZhbHVlLCBieVZhbHVlLCBwb3NWYWx1ZSk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yID0gYW5pbWF0ZUNvbG9yO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUoYSwgYywgcCwgcykge1xuICAgIGlmIChhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgIGEgPSBjO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vaGFuZGxlIHRoZSAwLzAgY2FzZTpcbiAgICAgIGlmIChjID09PSAwICYmIGEgPT09IDApIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGE6IGEsIGM6IGMsIHA6IHAsIHM6IHMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsYXN0aWMob3B0cywgdCwgZCkge1xuICAgIHJldHVybiBvcHRzLmEgKlxuICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgTWF0aC5zaW4oICh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICk7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluUXVhcnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0IC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiAtYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIE1hdGguc2luKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQgLyBkKSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gMCkgPyBiIDogYyAqIE1hdGgucG93KDIsIDEwICogKHQgLyBkIC0gMSkpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuICh0ID09PSBkKSA/IGIgKyBjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdCAvIGQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmICh0ID09PSBkKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQ2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKE1hdGguc3FydCgxIC0gKHQgLz0gZCkgKiB0KSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNxcnQoMSAtICh0ID0gdCAvIGQgLSAxKSAqIHQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiAtZWxhc3RpYyhvcHRzLCB0LCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQ7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKSArIG9wdHMuYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0ID09PSAyKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAoMC4zICogMS41KTtcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIGVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5hICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKiAwLjUgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAtIGVhc2VPdXRCb3VuY2UgKGQgLSB0LCAwLCBjLCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKCh0IC89IGQpIDwgKDEgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPCBkIC8gMikge1xuICAgICAgcmV0dXJuIGVhc2VJbkJvdW5jZSAodCAqIDIsIDAsIGMsIGQpICogMC41ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VPdXRCb3VuY2UodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVhc2luZyBmdW5jdGlvbnNcbiAgICogU2VlIDxhIGhyZWY9XCJodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cIj5FYXNpbmcgRXF1YXRpb25zIGJ5IFJvYmVydCBQZW5uZXI8L2E+XG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZmFicmljLnV0aWwuZWFzZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgaW5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHQgLz0gKGQgLyAyKTtcbiAgICAgIGlmICh0IDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gLWMgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3ViaWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXG4gICAgZWFzZUluT3V0Q3ViaWM6IGVhc2VJbk91dEN1YmljLFxuICAgIGVhc2VJblF1YXJ0OiBlYXNlSW5RdWFydCxcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcbiAgICBlYXNlSW5PdXRRdWFydDogZWFzZUluT3V0UXVhcnQsXG4gICAgZWFzZUluUXVpbnQ6IGVhc2VJblF1aW50LFxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxuICAgIGVhc2VJbk91dFF1aW50OiBlYXNlSW5PdXRRdWludCxcbiAgICBlYXNlSW5TaW5lOiBlYXNlSW5TaW5lLFxuICAgIGVhc2VPdXRTaW5lOiBlYXNlT3V0U2luZSxcbiAgICBlYXNlSW5PdXRTaW5lOiBlYXNlSW5PdXRTaW5lLFxuICAgIGVhc2VJbkV4cG86IGVhc2VJbkV4cG8sXG4gICAgZWFzZU91dEV4cG86IGVhc2VPdXRFeHBvLFxuICAgIGVhc2VJbk91dEV4cG86IGVhc2VJbk91dEV4cG8sXG4gICAgZWFzZUluQ2lyYzogZWFzZUluQ2lyYyxcbiAgICBlYXNlT3V0Q2lyYzogZWFzZU91dENpcmMsXG4gICAgZWFzZUluT3V0Q2lyYzogZWFzZUluT3V0Q2lyYyxcbiAgICBlYXNlSW5FbGFzdGljOiBlYXNlSW5FbGFzdGljLFxuICAgIGVhc2VPdXRFbGFzdGljOiBlYXNlT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5PdXRFbGFzdGljOiBlYXNlSW5PdXRFbGFzdGljLFxuICAgIGVhc2VJbkJhY2s6IGVhc2VJbkJhY2ssXG4gICAgZWFzZU91dEJhY2s6IGVhc2VPdXRCYWNrLFxuICAgIGVhc2VJbk91dEJhY2s6IGVhc2VJbk91dEJhY2ssXG4gICAgZWFzZUluQm91bmNlOiBlYXNlSW5Cb3VuY2UsXG4gICAgZWFzZU91dEJvdW5jZTogZWFzZU91dEJvdW5jZSxcbiAgICBlYXNlSW5PdXRCb3VuY2U6IGVhc2VJbk91dEJvdW5jZVxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBuYW1lIGZhYnJpY1xuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgcGFyc2VVbml0ID0gZmFicmljLnV0aWwucGFyc2VVbml0LFxuICAgICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG5cbiAgICAgIHN2Z1ZhbGlkVGFnTmFtZXMgPSBbJ3BhdGgnLCAnY2lyY2xlJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAnZWxsaXBzZScsICdyZWN0JywgJ2xpbmUnLFxuICAgICAgICAnaW1hZ2UnLCAndGV4dCcsICdsaW5lYXJHcmFkaWVudCcsICdyYWRpYWxHcmFkaWVudCcsICdzdG9wJ10sXG4gICAgICBzdmdWaWV3Qm94RWxlbWVudHMgPSBbJ3N5bWJvbCcsICdpbWFnZScsICdtYXJrZXInLCAncGF0dGVybicsICd2aWV3JywgJ3N2ZyddLFxuICAgICAgc3ZnSW52YWxpZEFuY2VzdG9ycyA9IFsncGF0dGVybicsICdkZWZzJywgJ3N5bWJvbCcsICdtZXRhZGF0YScsICdjbGlwUGF0aCcsICdtYXNrJywgJ2Rlc2MnXSxcbiAgICAgIHN2Z1ZhbGlkUGFyZW50cyA9IFsnc3ltYm9sJywgJ2cnLCAnYScsICdzdmcnXSxcblxuICAgICAgYXR0cmlidXRlc01hcCA9IHtcbiAgICAgICAgY3g6ICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgeDogICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgcjogICAgICAgICAgICAgICAgICAgICdyYWRpdXMnLFxuICAgICAgICBjeTogICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIHk6ICAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgZGlzcGxheTogICAgICAgICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgdmlzaWJpbGl0eTogICAgICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAgICAgICAgICAgICd0cmFuc2Zvcm1NYXRyaXgnLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgJ2ZpbGwtcnVsZSc6ICAgICAgICAgICdmaWxsUnVsZScsXG4gICAgICAgICdmb250LWZhbWlseSc6ICAgICAgICAnZm9udEZhbWlseScsXG4gICAgICAgICdmb250LXNpemUnOiAgICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udC1zdHlsZSc6ICAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdmb250LXdlaWdodCc6ICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdsZXR0ZXItc3BhY2luZyc6ICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgICAncGFpbnQtb3JkZXInOiAgICAgICAgJ3BhaW50Rmlyc3QnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICAgJ3N0cm9rZURhc2hBcnJheScsXG4gICAgICAgICdzdHJva2UtbGluZWNhcCc6ICAgICAnc3Ryb2tlTGluZUNhcCcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW4nOiAgICAnc3Ryb2tlTGluZUpvaW4nLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQnOiAgJ3N0cm9rZU1pdGVyTGltaXQnLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAgICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICAgJ3RleHQtZGVjb3JhdGlvbic6ICAgICd0ZXh0RGVjb3JhdGlvbicsXG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICAgICAgICAndGV4dEFuY2hvcicsXG4gICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAnb3BhY2l0eSdcbiAgICAgIH0sXG5cbiAgICAgIGNvbG9yQXR0cmlidXRlcyA9IHtcbiAgICAgICAgc3Ryb2tlOiAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgIGZpbGw6ICAgJ2ZpbGxPcGFjaXR5J1xuICAgICAgfTtcblxuICBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRUYWdOYW1lcyk7XG4gIGZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZpZXdCb3hFbGVtZW50cyk7XG4gIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXggPSBnZXRTdmdSZWdleChzdmdJbnZhbGlkQW5jZXN0b3JzKTtcbiAgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRQYXJlbnRzKTtcblxuICBmYWJyaWMuY3NzUnVsZXMgPSB7IH07XG4gIGZhYnJpYy5ncmFkaWVudERlZnMgPSB7IH07XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXR0cihhdHRyKSB7XG4gICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBuYW1lc1xuICAgIGlmIChhdHRyIGluIGF0dHJpYnV0ZXNNYXApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzTWFwW2F0dHJdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKGF0dHIsIHZhbHVlLCBwYXJlbnRBdHRyaWJ1dGVzLCBmb250U2l6ZSkge1xuICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgICAgcGFyc2VkO1xuXG4gICAgaWYgKChhdHRyID09PSAnZmlsbCcgfHwgYXR0ciA9PT0gJ3N0cm9rZScpICYmIHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VEYXNoQXJyYXknKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdub25lJykge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8sL2csICcgJykuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3RyYW5zZm9ybU1hdHJpeCcpIHtcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhbHVlID0gbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCwgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndmlzaWJsZScpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09ICdub25lJyAmJiB2YWx1ZSAhPT0gJ2hpZGRlbic7XG4gICAgICAvLyBkaXNwbGF5PW5vbmUgb24gcGFyZW50IGVsZW1lbnQgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjaGlsZCBlbGVtZW50XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdvcGFjaXR5Jykge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHR5cGVvZiBwYXJlbnRBdHRyaWJ1dGVzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlICo9IHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3RleHRBbmNob3InIC8qIHRleHQtYW5jaG9yICovKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSAnc3RhcnQnID8gJ2xlZnQnIDogdmFsdWUgPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnY2hhclNwYWNpbmcnKSB7XG4gICAgICAvLyBwYXJzZVVuaXQgcmV0dXJucyBweCBhbmQgd2UgY29udmVydCBpdCB0byBlbVxuICAgICAgcGFyc2VkID0gcGFyc2VVbml0KHZhbHVlLCBmb250U2l6ZSkgLyBmb250U2l6ZSAqIDEwMDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdwYWludEZpcnN0Jykge1xuICAgICAgdmFyIGZpbGxJbmRleCA9IHZhbHVlLmluZGV4T2YoJ2ZpbGwnKTtcbiAgICAgIHZhciBzdHJva2VJbmRleCA9IHZhbHVlLmluZGV4T2YoJ3N0cm9rZScpO1xuICAgICAgdmFyIHZhbHVlID0gJ2ZpbGwnO1xuICAgICAgaWYgKGZpbGxJbmRleCA+IC0xICYmIHN0cm9rZUluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPCBmaWxsSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSAnc3Ryb2tlJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZpbGxJbmRleCA9PT0gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IGlzQXJyYXkgPyB2YWx1ZS5tYXAocGFyc2VVbml0KSA6IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiAoIWlzQXJyYXkgJiYgaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBmdW5jdGlvbiBnZXRTdmdSZWdleChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgYXJyLmpvaW4oJ3wnKSArICcpXFxcXGInLCAnaScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdHJva2VGaWxsT3BhY2l0eShhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBjb2xvckF0dHJpYnV0ZXMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0gPT09ICd1bmRlZmluZWQnIHx8IGF0dHJpYnV0ZXNbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBjb2xvci5zZXRBbHBoYSh0b0ZpeGVkKGNvbG9yLmdldEFscGhhKCkgKiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0sIDIpKS50b1JnYmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgbm9kZU5hbWVzKSB7XG4gICAgdmFyIG5vZGVOYW1lLCBub2RlQXJyYXkgPSBbXSwgbm9kZUxpc3QsIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWVzW2ldO1xuICAgICAgbm9kZUxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgbm9kZUFycmF5ID0gbm9kZUFycmF5LmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBTdHJpbmcgY29udGFpbmluZyBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDYgZWxlbWVudHMgcmVwcmVzZW50aW5nIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKi9cbiAgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYXJnc1swXSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihhcmdzWzBdKSxcbiAgICAgICAgICB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IGFyZ3NbMV07XG4gICAgICAgIHkgPSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXhbMF0gPSBjb3M7XG4gICAgICBtYXRyaXhbMV0gPSBzaW47XG4gICAgICBtYXRyaXhbMl0gPSAtc2luO1xuICAgICAgbWF0cml4WzNdID0gY29zO1xuICAgICAgbWF0cml4WzRdID0geCAtIChjb3MgKiB4IC0gc2luICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKHNpbiAqIHggKyBjb3MgKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIHBvcykge1xuICAgICAgbWF0cml4W3Bvc10gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbNF0gPSBhcmdzWzBdO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1hdHJpeFs1XSA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIGlNYXRyaXggPSBbXG4gICAgICAgICAgMSwgLy8gYVxuICAgICAgICAgIDAsIC8vIGJcbiAgICAgICAgICAwLCAvLyBjXG4gICAgICAgICAgMSwgLy8gZFxuICAgICAgICAgIDAsIC8vIGVcbiAgICAgICAgICAwICAvLyBmXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSAnKD86XFxcXHMrLD9cXFxccyp8LFxcXFxzKiknLFxuXG4gICAgICAgIHNrZXdYID0gJyg/Oihza2V3WClcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNrZXdZID0gJyg/Oihza2V3WSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHJvdGF0ZSA9ICcoPzoocm90YXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2NhbGUgPSAnKD86KHNjYWxlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zbGF0ZSA9ICcoPzoodHJhbnNsYXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIG1hdHJpeCA9ICcoPzoobWF0cml4KVxcXFxzKlxcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgJ1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNmb3JtID0gJyg/OicgK1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdYICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1kgK1xuICAgICAgICAgICAgICAgICAgICAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtcyA9ICcoPzonICsgdHJhbnNmb3JtICsgJyg/OicgKyBjb21tYVdzcCArICcqJyArIHRyYW5zZm9ybSArICcpKicgKyAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtTGlzdCA9ICdeXFxcXHMqKD86JyArIHRyYW5zZm9ybXMgKyAnPylcXFxccyokJyxcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjVHJhbnNmb3JtQXR0cmlidXRlXG4gICAgICAgIHJlVHJhbnNmb3JtTGlzdCA9IG5ldyBSZWdFeHAodHJhbnNmb3JtTGlzdCksXG4gICAgICAgIC8vID09IGVuZCB0cmFuc2Zvcm0gcmVnZXhwXG5cbiAgICAgICAgcmVUcmFuc2Zvcm0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSwgJ2cnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuXG4gICAgICAvLyBzdGFydCB3aXRoIGlkZW50aXR5IG1hdHJpeFxuICAgICAgdmFyIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgbWF0cmljZXMgPSBbXTtcblxuICAgICAgLy8gcmV0dXJuIGlmIG5vIGFyZ3VtZW50IHdhcyBnaXZlbiBvclxuICAgICAgLy8gYW4gYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggdHJhbnNmb3JtIGF0dHJpYnV0ZSByZWdleHBcbiAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgKGF0dHJpYnV0ZVZhbHVlICYmICFyZVRyYW5zZm9ybUxpc3QudGVzdChhdHRyaWJ1dGVWYWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVUcmFuc2Zvcm0sIGZ1bmN0aW9uKG1hdGNoKSB7XG5cbiAgICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSkuZXhlYyhtYXRjaCkuZmlsdGVyKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBtYXRjaCAhPT0gJycgJiYgbWF0Y2ggIT0gbnVsbFxuICAgICAgICAgICAgICByZXR1cm4gKCEhbWF0Y2gpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBtWzFdLFxuICAgICAgICAgICAgYXJncyA9IG0uc2xpY2UoMikubWFwKHBhcnNlRmxvYXQpO1xuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pO1xuICAgICAgICAgICAgcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgIG1hdHJpeCA9IGFyZ3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXBzaG90IGN1cnJlbnQgbWF0cml4IGludG8gbWF0cmljZXMgYXJyYXlcbiAgICAgICAgbWF0cmljZXMucHVzaChtYXRyaXguY29uY2F0KCkpO1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb21iaW5lZE1hdHJpeCA9IG1hdHJpY2VzWzBdO1xuICAgICAgd2hpbGUgKG1hdHJpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbWF0cmljZXMuc2hpZnQoKTtcbiAgICAgICAgY29tYmluZWRNYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGNvbWJpbmVkTWF0cml4LCBtYXRyaWNlc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRyaXg7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVTdHJpbmcoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBzdHlsZS5yZXBsYWNlKC87XFxzKiQvLCAnJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdmFyIHBhaXIgPSBjaHVuay5zcGxpdCgnOicpO1xuXG4gICAgICBhdHRyID0gcGFpclswXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gIHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZU9iamVjdChzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhdHRyID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCkge1xuICAgIHZhciBzdHlsZXMgPSB7IH07XG4gICAgZm9yICh2YXIgcnVsZSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSkge1xuICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBydWxlLnNwbGl0KCcgJykpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdKSB7XG4gICAgICAgICAgc3R5bGVzW3Byb3BlcnR5XSA9IGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIGZpcnN0TWF0Y2hpbmcsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICAvL3N0YXJ0IGZyb20gcmlnaHRtb3N0IHNlbGVjdG9yLlxuICAgIGZpcnN0TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3JzLnBvcCgpKTtcbiAgICBpZiAoZmlyc3RNYXRjaGluZyAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0TWF0Y2hpbmcgJiYgcGFyZW50TWF0Y2hpbmcgJiYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgc2VsZWN0b3IsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBpZiAocGFyZW50TWF0Y2hpbmcpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnMucG9wKCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpLCBtYXRjaGVyLCBpO1xuICAgIC8vIGkgY2hlY2sgaWYgYSBzZWxlY3RvciBtYXRjaGVzIHNsaWNpbmcgYXdheSBwYXJ0IGZyb20gaXQuXG4gICAgLy8gaWYgaSBnZXQgZW1wdHkgc3RyaW5nIGkgc2hvdWxkIG1hdGNoXG4gICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ14nICsgbm9kZU5hbWUsICdpJyk7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICBpZiAoaWQgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnIycgKyBpZCArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZXMgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuICAgICAgZm9yIChpID0gY2xhc3NOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGNsYXNzTmFtZXNbaV0gKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0byBzdXBwb3J0IElFOCBtaXNzaW5nIGdldEVsZW1lbnRCeUlkIG9uIFNWR2RvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50QnlJZChkb2MsIGlkKSB7XG4gICAgdmFyIGVsO1xuICAgIGRvYy5nZXRFbGVtZW50QnlJZCAmJiAoZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgdmFyIG5vZGUsIGksIGxlbiwgbm9kZWxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVsaXN0W2ldO1xuICAgICAgaWYgKGlkID09PSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIFsndXNlJywgJ3N2Zzp1c2UnXSksIGkgPSAwO1xuXG4gICAgd2hpbGUgKG5vZGVsaXN0Lmxlbmd0aCAmJiBpIDwgbm9kZWxpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwgPSBub2RlbGlzdFtpXSxcbiAgICAgICAgICB4bGluayA9IGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpLnN1YnN0cigxKSxcbiAgICAgICAgICB4ID0gZWwuZ2V0QXR0cmlidXRlKCd4JykgfHwgMCxcbiAgICAgICAgICB5ID0gZWwuZ2V0QXR0cmlidXRlKCd5JykgfHwgMCxcbiAgICAgICAgICBlbDIgPSBlbGVtZW50QnlJZChkb2MsIHhsaW5rKS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zID0gKGVsMi5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArICcgdHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKScsXG4gICAgICAgICAgcGFyZW50Tm9kZSwgb2xkTGVuZ3RoID0gbm9kZWxpc3QubGVuZ3RoLCBhdHRyLCBqLCBhdHRycywgbGVuO1xuXG4gICAgICBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWwyKTtcbiAgICAgIGlmICgvXnN2ZyQvaS50ZXN0KGVsMi5ub2RlTmFtZSkpIHtcbiAgICAgICAgdmFyIGVsMyA9IGVsMi5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2cnKTtcbiAgICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbDIuYXR0cmlidXRlcywgbGVuID0gYXR0cnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgICBlbDMuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbDIuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsMy5hcHBlbmRDaGlsZChlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwyID0gZWwzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG5cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgIWZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeC50ZXN0KGVsZW1lbnQubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhKHZpZXdCb3hBdHRyID0gdmlld0JveEF0dHIubWF0Y2gocmVWaWV3Qm94QXR0clZhbHVlKSkpLFxuICAgICAgICBtaXNzaW5nRGltQXR0ciA9ICghd2lkdGhBdHRyIHx8ICFoZWlnaHRBdHRyIHx8IHdpZHRoQXR0ciA9PT0gJzEwMCUnIHx8IGhlaWdodEF0dHIgPT09ICcxMDAlJyksXG4gICAgICAgIHRvQmVQYXJzZWQgPSBtaXNzaW5nVmlld0JveCAmJiBtaXNzaW5nRGltQXR0cixcbiAgICAgICAgcGFyc2VkRGltID0geyB9LCB0cmFuc2xhdGVNYXRyaXggPSAnJywgd2lkdGhEaWZmID0gMCwgaGVpZ2h0RGlmZiA9IDA7XG5cbiAgICBwYXJzZWREaW0ud2lkdGggPSAwO1xuICAgIHBhcnNlZERpbS5oZWlnaHQgPSAwO1xuICAgIHBhcnNlZERpbS50b0JlUGFyc2VkID0gdG9CZVBhcnNlZDtcblxuICAgIGlmICh0b0JlUGFyc2VkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nVmlld0JveCkge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBtaW5YID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMV0pO1xuICAgIG1pblkgPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsyXSk7XG4gICAgdmlld0JveFdpZHRoID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0clszXSk7XG4gICAgdmlld0JveEhlaWdodCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbNF0pO1xuXG4gICAgaWYgKCFtaXNzaW5nRGltQXR0cikge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgc2NhbGVYID0gcGFyc2VkRGltLndpZHRoIC8gdmlld0JveFdpZHRoO1xuICAgICAgc2NhbGVZID0gcGFyc2VkRGltLmhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gdmlld0JveFdpZHRoO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCAhPT0gJ25vbmUnKSB7XG4gICAgICAvL3RyYW5zbGF0ZSBhbGwgY29udGFpbmVyIGZvciB0aGUgZWZmZWN0IG9mIE1pZCwgTWluLCBNYXhcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVggOiBzY2FsZVkpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICB3aWR0aERpZmYgPSBwYXJzZWREaW0ud2lkdGggLSB2aWV3Qm94V2lkdGggKiBzY2FsZVg7XG4gICAgICBoZWlnaHREaWZmID0gcGFyc2VkRGltLmhlaWdodCAtIHZpZXdCb3hIZWlnaHQgKiBzY2FsZVg7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgIHdpZHRoRGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICBoZWlnaHREaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgIHdpZHRoRGlmZiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgIGhlaWdodERpZmYgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxICYmIG1pblggPT09IDAgJiYgbWluWSA9PT0gMCAmJiB4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgdHJhbnNsYXRlTWF0cml4ID0gJyB0cmFuc2xhdGUoJyArIHBhcnNlVW5pdCh4KSArICcgJyArIHBhcnNlVW5pdCh5KSArICcpICc7XG4gICAgfVxuXG4gICAgbWF0cml4ID0gdHJhbnNsYXRlTWF0cml4ICsgJyBtYXRyaXgoJyArIHNjYWxlWCArXG4gICAgICAgICAgICAgICAgICAnIDAnICtcbiAgICAgICAgICAgICAgICAgICcgMCAnICtcbiAgICAgICAgICAgICAgICAgIHNjYWxlWSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWCAqIHNjYWxlWCArIHdpZHRoRGlmZikgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblkgKiBzY2FsZVkgKyBoZWlnaHREaWZmKSArICcpICc7XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2cnKTtcbiAgICAgIC8vIGVsZW1lbnQuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbCA9IGVsZW1lbnQ7XG4gICAgICBtYXRyaXggPSBlbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICsgbWF0cml4O1xuICAgIH1cblxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2luZ09wdGlvbnNdIG9wdGlvbnMgZm9yIHBhcnNpbmcgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gc2V0dGluZ3NcbiAgICovXG4gIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssIGksIGxlbixcbiAgICAgICAgb3B0aW9ucyA9IGFwcGx5Vmlld2JveFRyYW5zZm9ybShkb2MpLFxuICAgICAgICBkZXNjZW5kYW50cyA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBwYXJzaW5nT3B0aW9ucyAmJiBwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBvcHRpb25zLnN2Z1VpZCA9IHN2Z1VpZDtcblxuICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgLy8gd2UncmUgbGlrZWx5IGluIG5vZGUsIHdoZXJlIFwibzMteG1sXCIgbGlicmFyeSBmYWlscyB0byBnRUJUTihcIipcIilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL25vZGUtbzMteG1sL2lzc3Vlcy8yMVxuICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpICYmXG4gICAgICAgICAgICAhaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWwsIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcblxuICAgIGlmICghZWxlbWVudHMgfHwgKGVsZW1lbnRzICYmICFlbGVtZW50cy5sZW5ndGgpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSwge30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRHcmFkaWVudERlZnMoZG9jKTtcbiAgICBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRDU1NSdWxlcyhkb2MpO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMsIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaW5zdGFuY2VzLCBvcHRpb25zLCBlbGVtZW50cywgZGVzY2VuZGFudHMpO1xuICAgICAgfVxuICAgIH0sIGNsb25lKG9wdGlvbnMpLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHJlRm9udERlY2xhcmF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICAnKG5vcm1hbHxpdGFsaWMpP1xcXFxzKihub3JtYWx8c21hbGwtY2Fwcyk/XFxcXHMqJyArXG4gICAgJyhub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMCk/XFxcXHMqKCcgK1xuICAgICAgZmFicmljLnJlTnVtICtcbiAgICAnKD86cHh8Y218bW18ZW18cHR8cGN8aW4pKikoPzpcXFxcLyhub3JtYWx8JyArIGZhYnJpYy5yZU51bSArICcpKT9cXFxccysoLiopJyk7XG5cbiAgZXh0ZW5kKGZhYnJpYywge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNob3J0IGZvbnQgZGVjbGFyYXRpb24sIGJ1aWxkaW5nIGFkZGluZyBpdHMgcHJvcGVydGllcyB0byBhIHN0eWxlIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGZvbnQgZGVjbGFyYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1N0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBwYXJzZUZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24odmFsdWUsIG9TdHlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVGb250RGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmb250U3R5bGUgPSBtYXRjaFsxXSxcbiAgICAgICAgICAvLyBmb250IHZhcmlhbnQgaXMgbm90IHVzZWRcbiAgICAgICAgICAvLyBmb250VmFyaWFudCA9IG1hdGNoWzJdLFxuICAgICAgICAgIGZvbnRXZWlnaHQgPSBtYXRjaFszXSxcbiAgICAgICAgICBmb250U2l6ZSA9IG1hdGNoWzRdLFxuICAgICAgICAgIGxpbmVIZWlnaHQgPSBtYXRjaFs1XSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gbWF0Y2hbNl07XG5cbiAgICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250V2VpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5mb250V2VpZ2h0ID0gaXNOYU4ocGFyc2VGbG9hdChmb250V2VpZ2h0KSkgPyBmb250V2VpZ2h0IDogcGFyc2VGbG9hdChmb250V2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICBvU3R5bGUuZm9udFNpemUgPSBwYXJzZVVuaXQoZm9udFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRGYW1pbHkpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/IDEgOiBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCByZXR1cm5pbmcgYWxsIG9mIHRoZSBncmFkaWVudCBkZWNsYXJhdGlvbnMgZm91bmQgaW4gaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEdyYWRpZW50IGRlZmluaXRpb25zOyBrZXkgY29ycmVzcG9uZHMgdG8gZWxlbWVudCBpZCwgdmFsdWUgLS0gdG8gZ3JhZGllbnQgZGVmaW5pdGlvbiBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0R3JhZGllbnREZWZzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciB0YWdBcnJheSA9IFtcbiAgICAgICAgICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOnJhZGlhbEdyYWRpZW50J10sXG4gICAgICAgICAgZWxMaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCB0YWdBcnJheSksXG4gICAgICAgICAgZWwsIGogPSAwLCBpZCwgeGxpbmssXG4gICAgICAgICAgZ3JhZGllbnREZWZzID0geyB9LCBpZHNUb1hsaW5rTWFwID0geyB9O1xuICAgICAgaiA9IGVsTGlzdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgZWwgPSBlbExpc3Rbal07XG4gICAgICAgIHhsaW5rID0gZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJyk7XG4gICAgICAgIGlkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBpZiAoeGxpbmspIHtcbiAgICAgICAgICBpZHNUb1hsaW5rTWFwW2lkXSA9IHhsaW5rLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudERlZnNbaWRdID0gZWw7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaWQgaW4gaWRzVG9YbGlua01hcCkge1xuICAgICAgICB2YXIgZWwyID0gZ3JhZGllbnREZWZzW2lkc1RvWGxpbmtNYXBbaWRdXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGVsID0gZ3JhZGllbnREZWZzW2lkXTtcbiAgICAgICAgd2hpbGUgKGVsMi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZWwyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhZGllbnREZWZzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzJyBuYW1lL3ZhbHVlLCBnaXZlbiBlbGVtZW50IGFuZCBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXM7XG4gICAgICogUGFyc2VzIHBhcmVudCBcImdcIiBub2RlcyByZWN1cnNpdmVseSB1cHdhcmRzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHBhcnNlZCBhdHRyaWJ1dGVzJyBuYW1lcy92YWx1ZXNcbiAgICAgKi9cbiAgICBwYXJzZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZXMsIHN2Z1VpZCkge1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IHsgfSxcbiAgICAgICAgICBmb250U2l6ZTtcblxuICAgICAgaWYgKHR5cGVvZiBzdmdVaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN2Z1VpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdmdVaWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwYXJlbnQgY29udGFpbmVyIChgZ2Agb3IgYGFgIG9yIGBzeW1ib2xgIG5vZGUpLCBwYXJzZSBpdHMgYXR0cmlidXRlcyByZWN1cnNpdmVseSB1cHdhcmRzXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeC50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudC5wYXJlbnROb2RlLCBhdHRyaWJ1dGVzLCBzdmdVaWQpO1xuICAgICAgfVxuICAgICAgZm9udFNpemUgPSAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLmZvbnRTaXplICkgfHxcbiAgICAgICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScpIHx8IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcblxuICAgICAgdmFyIG93bkF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbihtZW1vLCBhdHRyKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIGlmICh2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwgeyB9KTtcbiAgICAgIC8vIGFkZCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUsIHdoaWNoIHRha2UgcHJlY2VkZW5jZSBvdmVyIGF0dHJpYnV0ZXNcbiAgICAgIC8vIChzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHlsaW5nLmh0bWwjVXNpbmdQcmVzZW50YXRpb25BdHRyaWJ1dGVzKVxuICAgICAgb3duQXR0cmlidXRlcyA9IGV4dGVuZChvd25BdHRyaWJ1dGVzLFxuICAgICAgICBleHRlbmQoZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpLCBmYWJyaWMucGFyc2VTdHlsZUF0dHJpYnV0ZShlbGVtZW50KSkpO1xuXG4gICAgICB2YXIgbm9ybWFsaXplZEF0dHIsIG5vcm1hbGl6ZWRWYWx1ZSwgbm9ybWFsaXplZFN0eWxlID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbm9ybWFsaXplZEF0dHIgPSBub3JtYWxpemVBdHRyKGF0dHIpO1xuICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZShub3JtYWxpemVkQXR0ciwgb3duQXR0cmlidXRlc1thdHRyXSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuICAgICAgICBub3JtYWxpemVkU3R5bGVbbm9ybWFsaXplZEF0dHJdID0gbm9ybWFsaXplZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vcm1hbGl6ZWRTdHlsZSAmJiBub3JtYWxpemVkU3R5bGUuZm9udCkge1xuICAgICAgICBmYWJyaWMucGFyc2VGb250RGVjbGFyYXRpb24obm9ybWFsaXplZFN0eWxlLmZvbnQsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWVyZ2VkQXR0cnMgPSBleHRlbmQocGFyZW50QXR0cmlidXRlcywgbm9ybWFsaXplZFN0eWxlKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSA/IG1lcmdlZEF0dHJzIDogX3NldFN0cm9rZUZpbGxPcGFjaXR5KG1lcmdlZEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBzdmcgZWxlbWVudHMgdG8gY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIEFycmF5IG9mIGVsZW1lbnRzIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGZhYnJpYyBpbnN0YW5jZXMgKHRyYW5zZm9ybWVkIGZyb20gU1ZHIGVsZW1lbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcGFyc2VFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgICAgbmV3IGZhYnJpYy5FbGVtZW50c1BhcnNlcihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHBhcnNlZFBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KHBvaW50c1tpXSksXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gb2RkIG51bWJlciBvZiBwb2ludHMgaXMgYW4gZXJyb3JcbiAgICAgIC8vIGlmIChwYXJzZWRQb2ludHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZFBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgcnVsZXMgZm9yIGEgZ2l2ZW4gU1ZHIGRvY3VtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDU1MgcnVsZXMgb2YgdGhpcyBkb2N1bWVudFxuICAgICAqL1xuICAgIGdldENTU1J1bGVzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyksIGksIGxlbixcbiAgICAgICAgICBhbGxSdWxlcyA9IHsgfSwgcnVsZXM7XG5cbiAgICAgIC8vIHZlcnkgY3J1ZGUgcGFyc2luZyBvZiBzdHlsZSBjb250ZW50c1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgdGV4dENvbnRlbnQsIGJ1dCBwcm92aWRlcyB0ZXh0IGluc3RlYWQuXG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50IHx8IHN0eWxlc1tpXS50ZXh0O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKC8oW1xcc1xcU10qPylcXHMqXFx7KFtefV0qKVxcfS8pLFxuICAgICAgICAgICAgICBydWxlT2JqID0geyB9LCBkZWNsYXJhdGlvbiA9IG1hdGNoWzJdLnRyaW0oKSxcbiAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZVBhaXJzID0gZGVjbGFyYXRpb24ucmVwbGFjZSgvOyQvLCAnJykuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvcGVydHlWYWx1ZVBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHByb3BlcnR5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYWlyWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFpclsxXTtcbiAgICAgICAgICAgIHJ1bGVPYmpbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJ1bGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICBydWxlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihfcnVsZSkge1xuICAgICAgICAgICAgX3J1bGUgPSBfcnVsZS5yZXBsYWNlKC9ec3ZnL2ksICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoX3J1bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxSdWxlc1tfcnVsZV0pIHtcbiAgICAgICAgICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChhbGxSdWxlc1tfcnVsZV0sIHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFsbFJ1bGVzW19ydWxlXSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsUnVsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHVybCBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzLlxuICAgICAqIE5vdGUgdGhhdCBTVkcgaXMgZmV0Y2hlZCB2aWEgWE1MSHR0cFJlcXVlc3QsIHNvIGl0IG5lZWRzIHRvIGNvbmZvcm0gdG8gU09QIChTYW1lIE9yaWdpbiBQb2xpY3kpXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVVSTDogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuXG4gICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlxcblxccyovLCAnJykudHJpbSgpO1xuICAgICAgbmV3IGZhYnJpYy51dGlsLnJlcXVlc3QodXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKHIpIHtcblxuICAgICAgICB2YXIgeG1sID0gci5yZXNwb25zZVhNTDtcbiAgICAgICAgaWYgKHhtbCAmJiAheG1sLmRvY3VtZW50RWxlbWVudCAmJiBmYWJyaWMud2luZG93LkFjdGl2ZVhPYmplY3QgJiYgci5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICAgIHhtbC5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgICAgLy9JRSBjaG9rZXMgb24gRE9DVFlQRVxuICAgICAgICAgIHhtbC5sb2FkWE1MKHIucmVzcG9uc2VUZXh0LnJlcGxhY2UoLzwhRE9DVFlQRVtcXHNcXFNdKj8oXFxbW1xcc1xcU10qXFxdKSo/Pi9pLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCh4bWwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tU3RyaW5nOiBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICAgICAgdmFyIGRvYztcbiAgICAgIGlmICh0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBpZiAocGFyc2VyICYmIHBhcnNlci5wYXJzZUZyb21TdHJpbmcpIHtcbiAgICAgICAgICBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0cmluZywgJ3RleHQveG1sJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZhYnJpYy53aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICBkb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICBkb2MuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICAvLyBJRSBjaG9rZXMgb24gRE9DVFlQRVxuICAgICAgICBkb2MubG9hZFhNTChzdHJpbmcucmVwbGFjZSgvPCFET0NUWVBFW1xcc1xcU10qPyhcXFtbXFxzXFxTXSpcXF0pKj8+L2ksICcnKSk7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KGRvYy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucmV2aXZlciA9IHJldml2ZXI7XG4gIHRoaXMuc3ZnVWlkID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdmdVaWQpIHx8IDA7XG4gIHRoaXMucGFyc2luZ09wdGlvbnMgPSBwYXJzaW5nT3B0aW9ucztcbiAgdGhpcy5yZWdleFVybCA9IC9edXJsXFwoWydcIl0/IyhbXidcIl0rKVsnXCJdP1xcKS9nO1xufTtcblxuZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluc3RhbmNlcyA9IG5ldyBBcnJheSh0aGlzLmVsZW1lbnRzLmxlbmd0aCk7XG4gIHRoaXMubnVtRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICB0aGlzLmNyZWF0ZU9iamVjdHMoKTtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRoaXMuZWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdzdmdVaWQnLCB0aGlzLnN2Z1VpZCk7XG4gICAgKGZ1bmN0aW9uKF9vYmosIGkpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF9vYmouY3JlYXRlT2JqZWN0KF9vYmouZWxlbWVudHNbaV0sIGkpO1xuICAgICAgfSwgMCk7XG4gICAgfSkodGhpcywgaSk7XG4gIH1cbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlT2JqZWN0ID0gZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gIHZhciBrbGFzcyA9IGZhYnJpY1tmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShlbC50YWdOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXTtcbiAgaWYgKGtsYXNzICYmIGtsYXNzLmZyb21FbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2NyZWF0ZU9iamVjdChrbGFzcywgZWwsIGluZGV4KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgZmFicmljLmxvZyhlcnIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoZWNrSWZEb25lKCk7XG4gIH1cbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuX2NyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKGtsYXNzLCBlbCwgaW5kZXgpIHtcbiAga2xhc3MuZnJvbUVsZW1lbnQoZWwsIHRoaXMuY3JlYXRlQ2FsbGJhY2soaW5kZXgsIGVsKSwgdGhpcy5vcHRpb25zKTtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUuY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihpbmRleCwgZWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBfb3B0aW9ucztcbiAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCAnZmlsbCcpO1xuICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosICdzdHJva2UnKTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgZmFicmljLkltYWdlKSB7XG4gICAgICBfb3B0aW9ucyA9IG9iai5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUoZWwpO1xuICAgIH1cbiAgICBvYmouX3JlbW92ZVRyYW5zZm9ybU1hdHJpeChfb3B0aW9ucyk7XG4gICAgX3RoaXMucmV2aXZlciAmJiBfdGhpcy5yZXZpdmVyKGVsLCBvYmopO1xuICAgIF90aGlzLmluc3RhbmNlc1tpbmRleF0gPSBvYmo7XG4gICAgX3RoaXMuY2hlY2tJZkRvbmUoKTtcbiAgfTtcbn07XG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUucmVzb2x2ZUdyYWRpZW50ID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSkge1xuXG4gIHZhciBpbnN0YW5jZUZpbGxWYWx1ZSA9IG9ialtwcm9wZXJ0eV07XG4gIGlmICghKC9edXJsXFwoLykudGVzdChpbnN0YW5jZUZpbGxWYWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdyYWRpZW50SWQgPSB0aGlzLnJlZ2V4VXJsLmV4ZWMoaW5zdGFuY2VGaWxsVmFsdWUpWzFdO1xuICB0aGlzLnJlZ2V4VXJsLmxhc3RJbmRleCA9IDA7XG4gIGlmIChmYWJyaWMuZ3JhZGllbnREZWZzW3RoaXMuc3ZnVWlkXVtncmFkaWVudElkXSkge1xuICAgIG9iai5zZXQocHJvcGVydHksXG4gICAgICBmYWJyaWMuR3JhZGllbnQuZnJvbUVsZW1lbnQoZmFicmljLmdyYWRpZW50RGVmc1t0aGlzLnN2Z1VpZF1bZ3JhZGllbnRJZF0sIG9iaikpO1xuICB9XG59O1xuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlLmNoZWNrSWZEb25lID0gZnVuY3Rpb24oKSB7XG4gIGlmICgtLXRoaXMubnVtRWxlbWVudHMgPT09IDApIHtcbiAgICB0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuICAgICAgcmV0dXJuIGVsICE9IG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLmluc3RhbmNlcywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Qb2ludCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9pbnQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmFicmljLlBvaW50ID0gUG9pbnQ7XG5cbiAgLyoqXG4gICAqIFBvaW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9pbnRcbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgUG9pbnQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuUG9pbnQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdwb2ludCcsXG5cbiAgICBjb25zdHJ1Y3RvcjogUG9pbnQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmUgYW5kIHJldHVybnMgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IGluc3RhbmNlIHdpdGggYWRkZWQgdmFsdWVzXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGF0LngsIHRoaXMueSArIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCArPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgKz0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgd2l0aCBhZGRlZCB2YWx1ZVxuICAgICAqL1xuICAgIHNjYWxhckFkZDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBzY2FsYXIsIHRoaXMueSArIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyQWRkRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKz0gc2NhbGFyO1xuICAgICAgdGhpcy55ICs9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBvYmplY3Qgd2l0aCBzdWJ0cmFjdGVkIHZhbHVlc1xuICAgICAqL1xuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSB0aGF0LngsIHRoaXMueSAtIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54IC09IHRoYXQueDtcbiAgICAgIHRoaXMueSAtPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHNjYWxhciwgdGhpcy55IC0gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAtPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLT0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHlFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtdWx0aXBseUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBzY2FsYXIsIHRoaXMueSAvIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpdmlkZUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC89IHNjYWxhcjtcbiAgICAgIHRoaXMueSAvPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZXE6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA9PT0gdGhhdC54ICYmIHRoaXMueSA9PT0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPCB0aGF0LnggJiYgdGhpcy55IDwgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDw9IHRoYXQueCAmJiB0aGlzLnkgPD0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPiB0aGF0LnggJiYgdGhpcy55ID4gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID49IHRoYXQueCAmJiB0aGlzLnkgPj0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHRoaXMgb25lIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLCBwb3NpdGlvbiBvZiBpbnRlcnBvbGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDEgZGVmYXVsdCAwLjVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbGVycDogZnVuY3Rpb24gKHRoYXQsIHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdCA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHQgPSBNYXRoLm1heChNYXRoLm1pbigxLCB0KSwgMCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArICh0aGF0LnggLSB0aGlzLngpICogdCwgdGhpcy55ICsgKHRoYXQueSAtIHRoaXMueSkgKiB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdGhhdC54LFxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdGhhdC55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaWRQb2ludEZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoYXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtaW4gb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWluKHRoaXMueCwgdGhhdC54KSwgTWF0aC5taW4odGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWF4IG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1heCh0aGlzLngsIHRoYXQueCksIE1hdGgubWF4KHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFhZOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHkgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnQgZnJvbSBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RnJvbVBvaW50OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3YXBzIHgveSBvZiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKi9cbiAgICBzd2FwOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueTtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHRoYXQueCA9IHg7XG4gICAgICB0aGF0LnkgPSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhlIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5JbnRlcnNlY3Rpb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkludGVyc2VjdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJzZWN0aW9uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW50ZXJzZWN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24oc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfVxuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3Rpb247XG5cbiAgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIGNvbnN0cnVjdG9yOiBJbnRlcnNlY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcG9pbnQgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHBvaW50cyB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQocG9pbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9uZSBsaW5lIGludGVyc2VjdHMgYW5vdGhlclxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFNlZ21lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUgPSBmdW5jdGlvbiAoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB1YVQgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1YlQgPSAoYTIueCAtIGExLngpICogKGExLnkgLSBiMS55KSAtIChhMi55IC0gYTEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1QiA9IChiMi55IC0gYjEueSkgKiAoYTIueCAtIGExLngpIC0gKGIyLnggLSBiMS54KSAqIChhMi55IC0gYTEueSk7XG4gICAgaWYgKHVCICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YVQgLyB1QixcbiAgICAgICAgICB1YiA9IHViVCAvIHVCO1xuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignSW50ZXJzZWN0aW9uJyk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRQb2ludChuZXcgZmFicmljLlBvaW50KGExLnggKyB1YSAqIChhMi54IC0gYTEueCksIGExLnkgKyB1YSAqIChhMi55IC0gYTEueSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHVhVCA9PT0gMCB8fCB1YlQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignQ29pbmNpZGVudCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ1BhcmFsbGVsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBsaW5lIGludGVyc2VjdHMgcG9seWdvblxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFBvbHlnb25cbiAgICogZml4IGRldGVjdGlvbiBvZiBjb2luY2lkZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24gPSBmdW5jdGlvbihhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGIxLCBiMiwgaW50ZXIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGIxID0gcG9pbnRzW2ldO1xuICAgICAgYjIgPSBwb2ludHNbKGkgKyAxKSAlIGxlbmd0aF07XG4gICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZShhMSwgYTIsIGIxLCBiMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIGFub3RoZXIgcG9seWdvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czFcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhMSA9IHBvaW50czFbaV0sXG4gICAgICAgICAgYTIgPSBwb2ludHMxWyhpICsgMSkgJSBsZW5ndGhdLFxuICAgICAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGExLCBhMiwgcG9pbnRzMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIHJlY3RhbmdsZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAocG9pbnRzLCByMSwgcjIpIHtcbiAgICB2YXIgbWluID0gcjEubWluKHIyKSxcbiAgICAgICAgbWF4ID0gcjEubWF4KHIyKSxcbiAgICAgICAgdG9wUmlnaHQgPSBuZXcgZmFicmljLlBvaW50KG1heC54LCBtaW4ueSksXG4gICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgZmFicmljLlBvaW50KG1pbi54LCBtYXgueSksXG4gICAgICAgIGludGVyMSA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtaW4sIHRvcFJpZ2h0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24odG9wUmlnaHQsIG1heCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIzID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1heCwgYm90dG9tTGVmdCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXI0ID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGJvdHRvbUxlZnQsIG1pbiwgcG9pbnRzKSxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuXG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjEucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMi5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIzLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjQucG9pbnRzKTtcblxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQ29sb3IpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNvbG9yIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ29sb3IgY2xhc3NcbiAgICogVGhlIHB1cnBvc2Ugb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgdG8gYWJzdHJhY3QgYW5kIGVuY2Fwc3VsYXRlIGNvbW1vbiBjb2xvciBvcGVyYXRpb25zO1xuICAgKiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGVzIGluc3RhbmNlcyBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBvYmplY3RzLlxuICAgKlxuICAgKiBAY2xhc3MgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBvcHRpb25hbCBpbiBoZXggb3IgcmdiKGEpIG9yIGhzbCBmb3JtYXQgb3IgZnJvbSBrbm93biBjb2xvciBsaXN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMi8jY29sb3JzfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyeVBhcnNpbmdDb2xvcihjb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbG9yID0gQ29sb3I7XG5cbiAgZmFicmljLkNvbG9yLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjb2xvciBDb2xvciB2YWx1ZSB0byBwYXJzZVxuICAgICAqL1xuICAgIF90cnlQYXJzaW5nQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB2YXIgc291cmNlO1xuXG4gICAgICBpZiAoY29sb3IgaW4gQ29sb3IuY29sb3JOYW1lTWFwKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IuY29sb3JOYW1lTWFwW2NvbG9yXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHNvdXJjZSA9IFsyNTUsIDI1NSwgMjU1LCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgLy9pZiBjb2xvciBpcyBub3QgcmVjb2duaXplIGxldCdzIG1ha2UgYmxhY2sgYXMgY2FudmFzIGRvZXNcbiAgICAgICAgc291cmNlID0gWzAsIDAsIDAsIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFJlZCBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBIc2wgY29sb3JcbiAgICAgKi9cbiAgICBfcmdiVG9Ic2w6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHIgLz0gMjU1OyBnIC89IDI1NTsgYiAvPSAyNTU7XG5cbiAgICAgIHZhciBoLCBzLCBsLFxuICAgICAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heChbciwgZywgYl0pLFxuICAgICAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbihbciwgZywgYl0pO1xuXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoICogMzYwKSxcbiAgICAgICAgTWF0aC5yb3VuZChzICogMTAwKSxcbiAgICAgICAgTWF0aC5yb3VuZChsICogMTAwKVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAgICovXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0IgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgICAqL1xuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0JBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYmEoMC0yNTUsMC0yNTUsMC0yNTUsMC0xKVxuICAgICAqL1xuICAgIHRvUmdiYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiYSgnICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJywnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgICAqL1xuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbCgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwwLTEpXG4gICAgICovXG4gICAgdG9Ic2xhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbGEoJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSwnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVcbiAgICAgKi9cbiAgICB0b0hleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgciwgZywgYjtcblxuICAgICAgciA9IHNvdXJjZVswXS50b1N0cmluZygxNik7XG4gICAgICByID0gKHIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyByKSA6IHI7XG5cbiAgICAgIGcgPSBzb3VyY2VbMV0udG9TdHJpbmcoMTYpO1xuICAgICAgZyA9IChnLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgZykgOiBnO1xuXG4gICAgICBiID0gc291cmNlWzJdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGIgPSAoYi5sZW5ndGggPT09IDEpID8gKCcwJyArIGIpIDogYjtcblxuICAgICAgcmV0dXJuIHIudG9VcHBlckNhc2UoKSArIGcudG9VcHBlckNhc2UoKSArIGIudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVhBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NUNDXG4gICAgICovXG4gICAgdG9IZXhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCBhO1xuXG4gICAgICBhID0gTWF0aC5yb3VuZChzb3VyY2VbM10gKiAyNTUpO1xuICAgICAgYSA9IGEudG9TdHJpbmcoMTYpO1xuICAgICAgYSA9IChhLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYSkgOiBhO1xuXG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpICsgYS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAtMVxuICAgICAqL1xuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpWzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgQWxwaGEgdmFsdWUgMC0xXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBncmF5c2NhbGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0dyYXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gcGFyc2VJbnQoKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLCAxMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGJsYWNrIGFuZCB3aGl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0JsYWNrV2hpdGU6IGZ1bmN0aW9uKHRocmVzaG9sZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG5cbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMjc7XG5cbiAgICAgIGF2ZXJhZ2UgPSAoTnVtYmVyKGF2ZXJhZ2UpIDwgTnVtYmVyKHRocmVzaG9sZCkpID8gMCA6IDI1NTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5cyBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xmYWJyaWMuQ29sb3J9IG90aGVyQ29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBvdmVybGF5V2l0aDogZnVuY3Rpb24ob3RoZXJDb2xvcikge1xuICAgICAgaWYgKCEob3RoZXJDb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICBvdGhlckNvbG9yID0gbmV3IENvbG9yKG90aGVyQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgYWxwaGEgPSB0aGlzLmdldEFscGhhKCksXG4gICAgICAgICAgb3RoZXJBbHBoYSA9IDAuNSxcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIG90aGVyU291cmNlID0gb3RoZXJDb2xvci5nZXRTb3VyY2UoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLnJvdW5kKChzb3VyY2VbaV0gKiAoMSAtIG90aGVyQWxwaGEpKSArIChvdGhlclNvdXJjZVtpXSAqIG90aGVyQWxwaGEpKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2UocmVzdWx0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gUkdCIG9yIFJHQkEgZm9ybWF0cyAoZXg6IHJnYigwLCAwLCAwKSwgcmdiYSgyNTUsIDEwMCwgMTAsIDAuNSksIHJnYmEoIDI1NSAsIDEwMCAsIDEwICwgMC41ICksIHJnYigxLDEsMSksIHJnYmEoMTAwJSwgNjAlLCAxMCUsIDAuNSkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5Db2xvci5yZVJHQmEgPSAvXnJnYmE/XFwoXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyooPzpcXHMqLFxccyooKD86XFxkKlxcLj9cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIU0wgb3IgSFNMQSBmb3JtYXRzIChleDogaHNsKDIwMCwgODAlLCAxMCUpLCBoc2xhKDMwMCwgNTAlLCA4MCUsIDAuNSksIGhzbGEoIDMwMCAsIDUwJSAsIDgwJSAsIDAuNSApKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIU0xhID0gL15oc2xhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIRVggZm9ybWF0IChleDogI0ZGNTU0NENDLCAjRkY1NTU1LCAwMTAxNTUsIGFmZilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSGV4ID0gL14jPyhbMC05YS1mXXs4fXxbMC05YS1mXXs2fXxbMC05YS1mXXs0fXxbMC05YS1mXXszfSkkL2k7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiB0aGUgMTQ4IGNvbG9yIG5hbWVzIHdpdGggSEVYIGNvZGVcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IuY29sb3JOYW1lTWFwID0ge1xuICAgIGFsaWNlYmx1ZTogICAgICAgICAgICAnI0YwRjhGRicsXG4gICAgYW50aXF1ZXdoaXRlOiAgICAgICAgICcjRkFFQkQ3JyxcbiAgICBhcXVhOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGFxdWFtYXJpbmU6ICAgICAgICAgICAnIzdGRkZENCcsXG4gICAgYXp1cmU6ICAgICAgICAgICAgICAgICcjRjBGRkZGJyxcbiAgICBiZWlnZTogICAgICAgICAgICAgICAgJyNGNUY1REMnLFxuICAgIGJpc3F1ZTogICAgICAgICAgICAgICAnI0ZGRTRDNCcsXG4gICAgYmxhY2s6ICAgICAgICAgICAgICAgICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogICAgICAgJyNGRkVCQ0QnLFxuICAgIGJsdWU6ICAgICAgICAgICAgICAgICAnIzAwMDBGRicsXG4gICAgYmx1ZXZpb2xldDogICAgICAgICAgICcjOEEyQkUyJyxcbiAgICBicm93bjogICAgICAgICAgICAgICAgJyNBNTJBMkEnLFxuICAgIGJ1cmx5d29vZDogICAgICAgICAgICAnI0RFQjg4NycsXG4gICAgY2FkZXRibHVlOiAgICAgICAgICAgICcjNUY5RUEwJyxcbiAgICBjaGFydHJldXNlOiAgICAgICAgICAgJyM3RkZGMDAnLFxuICAgIGNob2NvbGF0ZTogICAgICAgICAgICAnI0QyNjkxRScsXG4gICAgY29yYWw6ICAgICAgICAgICAgICAgICcjRkY3RjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogICAgICAgJyM2NDk1RUQnLFxuICAgIGNvcm5zaWxrOiAgICAgICAgICAgICAnI0ZGRjhEQycsXG4gICAgY3JpbXNvbjogICAgICAgICAgICAgICcjREMxNDNDJyxcbiAgICBjeWFuOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGRhcmtibHVlOiAgICAgICAgICAgICAnIzAwMDA4QicsXG4gICAgZGFya2N5YW46ICAgICAgICAgICAgICcjMDA4QjhCJyxcbiAgICBkYXJrZ29sZGVucm9kOiAgICAgICAgJyNCODg2MEInLFxuICAgIGRhcmtncmF5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JlZW46ICAgICAgICAgICAgJyMwMDY0MDAnLFxuICAgIGRhcmtraGFraTogICAgICAgICAgICAnI0JEQjc2QicsXG4gICAgZGFya21hZ2VudGE6ICAgICAgICAgICcjOEIwMDhCJyxcbiAgICBkYXJrb2xpdmVncmVlbjogICAgICAgJyM1NTZCMkYnLFxuICAgIGRhcmtvcmFuZ2U6ICAgICAgICAgICAnI0ZGOEMwMCcsXG4gICAgZGFya29yY2hpZDogICAgICAgICAgICcjOTkzMkNDJyxcbiAgICBkYXJrcmVkOiAgICAgICAgICAgICAgJyM4QjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICAgICAgICAgICAnI0U5OTY3QScsXG4gICAgZGFya3NlYWdyZWVuOiAgICAgICAgICcjOEZCQzhGJyxcbiAgICBkYXJrc2xhdGVibHVlOiAgICAgICAgJyM0ODNEOEInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3NsYXRlZ3JleTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrdHVycXVvaXNlOiAgICAgICAgJyMwMENFRDEnLFxuICAgIGRhcmt2aW9sZXQ6ICAgICAgICAgICAnIzk0MDBEMycsXG4gICAgZGVlcHBpbms6ICAgICAgICAgICAgICcjRkYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogICAgICAgICAgJyMwMEJGRkYnLFxuICAgIGRpbWdyYXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAgICAgICAgICAgJyMxRTkwRkYnLFxuICAgIGZpcmVicmljazogICAgICAgICAgICAnI0IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICAgICAgICAgICcjRkZGQUYwJyxcbiAgICBmb3Jlc3RncmVlbjogICAgICAgICAgJyMyMjhCMjInLFxuICAgIGZ1Y2hzaWE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgZ2FpbnNib3JvOiAgICAgICAgICAgICcjRENEQ0RDJyxcbiAgICBnaG9zdHdoaXRlOiAgICAgICAgICAgJyNGOEY4RkYnLFxuICAgIGdvbGQ6ICAgICAgICAgICAgICAgICAnI0ZGRDcwMCcsXG4gICAgZ29sZGVucm9kOiAgICAgICAgICAgICcjREFBNTIwJyxcbiAgICBncmF5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICAgICAgICAgICAgICAgICcjMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogICAgICAgICAgJyNBREZGMkYnLFxuICAgIGhvbmV5ZGV3OiAgICAgICAgICAgICAnI0YwRkZGMCcsXG4gICAgaG90cGluazogICAgICAgICAgICAgICcjRkY2OUI0JyxcbiAgICBpbmRpYW5yZWQ6ICAgICAgICAgICAgJyNDRDVDNUMnLFxuICAgIGluZGlnbzogICAgICAgICAgICAgICAnIzRCMDA4MicsXG4gICAgaXZvcnk6ICAgICAgICAgICAgICAgICcjRkZGRkYwJyxcbiAgICBraGFraTogICAgICAgICAgICAgICAgJyNGMEU2OEMnLFxuICAgIGxhdmVuZGVyOiAgICAgICAgICAgICAnI0U2RTZGQScsXG4gICAgbGF2ZW5kZXJibHVzaDogICAgICAgICcjRkZGMEY1JyxcbiAgICBsYXduZ3JlZW46ICAgICAgICAgICAgJyM3Q0ZDMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogICAgICAgICAnI0ZGRkFDRCcsXG4gICAgbGlnaHRibHVlOiAgICAgICAgICAgICcjQUREOEU2JyxcbiAgICBsaWdodGNvcmFsOiAgICAgICAgICAgJyNGMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogICAgICAgICAgICAnI0UwRkZGRicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxcbiAgICBsaWdodGdyYXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JleTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmVlbjogICAgICAgICAgICcjOTBFRTkwJyxcbiAgICBsaWdodHBpbms6ICAgICAgICAgICAgJyNGRkI2QzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAgICAgICAgICAnI0ZGQTA3QScsXG4gICAgbGlnaHRzZWFncmVlbjogICAgICAgICcjMjBCMkFBJyxcbiAgICBsaWdodHNreWJsdWU6ICAgICAgICAgJyM4N0NFRkEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogICAgICAgJyNCMEM0REUnLFxuICAgIGxpZ2h0eWVsbG93OiAgICAgICAgICAnI0ZGRkZFMCcsXG4gICAgbGltZTogICAgICAgICAgICAgICAgICcjMDBGRjAwJyxcbiAgICBsaW1lZ3JlZW46ICAgICAgICAgICAgJyMzMkNEMzInLFxuICAgIGxpbmVuOiAgICAgICAgICAgICAgICAnI0ZBRjBFNicsXG4gICAgbWFnZW50YTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBtYXJvb246ICAgICAgICAgICAgICAgJyM4MDAwMDAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgICAnIzY2Q0RBQScsXG4gICAgbWVkaXVtYmx1ZTogICAgICAgICAgICcjMDAwMENEJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICAgICAgICAgJyNCQTU1RDMnLFxuICAgIG1lZGl1bXB1cnBsZTogICAgICAgICAnIzkzNzBEQicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgICcjM0NCMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgICAgJyM3QjY4RUUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAgICAnIzAwRkE5QScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAgICAgICcjNDhEMUNDJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICAgICAgJyNDNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogICAgICAgICAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAgICAgICAgICAgICcjRjVGRkZBJyxcbiAgICBtaXN0eXJvc2U6ICAgICAgICAgICAgJyNGRkU0RTEnLFxuICAgIG1vY2Nhc2luOiAgICAgICAgICAgICAnI0ZGRTRCNScsXG4gICAgbmF2YWpvd2hpdGU6ICAgICAgICAgICcjRkZERUFEJyxcbiAgICBuYXZ5OiAgICAgICAgICAgICAgICAgJyMwMDAwODAnLFxuICAgIG9sZGxhY2U6ICAgICAgICAgICAgICAnI0ZERjVFNicsXG4gICAgb2xpdmU6ICAgICAgICAgICAgICAgICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICAgICAgICAgICAgJyM2QjhFMjMnLFxuICAgIG9yYW5nZTogICAgICAgICAgICAgICAnI0ZGQTUwMCcsXG4gICAgb3JhbmdlcmVkOiAgICAgICAgICAgICcjRkY0NTAwJyxcbiAgICBvcmNoaWQ6ICAgICAgICAgICAgICAgJyNEQTcwRDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgICAnI0VFRThBQScsXG4gICAgcGFsZWdyZWVuOiAgICAgICAgICAgICcjOThGQjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAgICAgICAgJyNBRkVFRUUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICAgICAgICAnI0RCNzA5MycsXG4gICAgcGFwYXlhd2hpcDogICAgICAgICAgICcjRkZFRkQ1JyxcbiAgICBwZWFjaHB1ZmY6ICAgICAgICAgICAgJyNGRkRBQjknLFxuICAgIHBlcnU6ICAgICAgICAgICAgICAgICAnI0NEODUzRicsXG4gICAgcGluazogICAgICAgICAgICAgICAgICcjRkZDMENCJyxcbiAgICBwbHVtOiAgICAgICAgICAgICAgICAgJyNEREEwREQnLFxuICAgIHBvd2RlcmJsdWU6ICAgICAgICAgICAnI0IwRTBFNicsXG4gICAgcHVycGxlOiAgICAgICAgICAgICAgICcjODAwMDgwJyxcbiAgICByZWJlY2NhcHVycGxlOiAgICAgICAgJyM2NjMzOTknLFxuICAgIHJlZDogICAgICAgICAgICAgICAgICAnI0ZGMDAwMCcsXG4gICAgcm9zeWJyb3duOiAgICAgICAgICAgICcjQkM4RjhGJyxcbiAgICByb3lhbGJsdWU6ICAgICAgICAgICAgJyM0MTY5RTEnLFxuICAgIHNhZGRsZWJyb3duOiAgICAgICAgICAnIzhCNDUxMycsXG4gICAgc2FsbW9uOiAgICAgICAgICAgICAgICcjRkE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAgICAgICAgICAgJyNGNEE0NjAnLFxuICAgIHNlYWdyZWVuOiAgICAgICAgICAgICAnIzJFOEI1NycsXG4gICAgc2Vhc2hlbGw6ICAgICAgICAgICAgICcjRkZGNUVFJyxcbiAgICBzaWVubmE6ICAgICAgICAgICAgICAgJyNBMDUyMkQnLFxuICAgIHNpbHZlcjogICAgICAgICAgICAgICAnI0MwQzBDMCcsXG4gICAgc2t5Ymx1ZTogICAgICAgICAgICAgICcjODdDRUVCJyxcbiAgICBzbGF0ZWJsdWU6ICAgICAgICAgICAgJyM2QTVBQ0QnLFxuICAgIHNsYXRlZ3JheTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbm93OiAgICAgICAgICAgICAgICAgJyNGRkZBRkEnLFxuICAgIHNwcmluZ2dyZWVuOiAgICAgICAgICAnIzAwRkY3RicsXG4gICAgc3RlZWxibHVlOiAgICAgICAgICAgICcjNDY4MkI0JyxcbiAgICB0YW46ICAgICAgICAgICAgICAgICAgJyNEMkI0OEMnLFxuICAgIHRlYWw6ICAgICAgICAgICAgICAgICAnIzAwODA4MCcsXG4gICAgdGhpc3RsZTogICAgICAgICAgICAgICcjRDhCRkQ4JyxcbiAgICB0b21hdG86ICAgICAgICAgICAgICAgJyNGRjYzNDcnLFxuICAgIHR1cnF1b2lzZTogICAgICAgICAgICAnIzQwRTBEMCcsXG4gICAgdmlvbGV0OiAgICAgICAgICAgICAgICcjRUU4MkVFJyxcbiAgICB3aGVhdDogICAgICAgICAgICAgICAgJyNGNURFQjMnLFxuICAgIHdoaXRlOiAgICAgICAgICAgICAgICAnI0ZGRkZGRicsXG4gICAgd2hpdGVzbW9rZTogICAgICAgICAgICcjRjVGNUY1JyxcbiAgICB5ZWxsb3c6ICAgICAgICAgICAgICAgJyNGRkZGMDAnLFxuICAgIHllbGxvd2dyZWVuOiAgICAgICAgICAnIzlBQ0QzMidcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgdCAtPSAxO1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBSR0Igb3IgUkdCQSBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSksIHJnYigwJS0xMDAlLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlUkdCYSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsxXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMjU1IDogMSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTApLFxuICAgICAgICBwYXJzZUludChiLCAxMCksXG4gICAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2JhID0gQ29sb3IuZnJvbVJnYjtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMIGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTI2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSFNMIG9yIEhTTEEgZm9ybWF0LlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpIG9yIGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLCAwLTEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICogQHNlZSBodHRwOi8vaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHNsLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVIU0xhKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgbCA9IHBhcnNlRmxvYXQobWF0Y2hbM10pIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgciwgZywgYjtcblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgcCA9IGwgKiAyIC0gcTtcblxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5yb3VuZChyICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGIgKiAyNTUpLFxuICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0xBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbGEgPSBDb2xvci5mcm9tSHNsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IEZGNTU1NVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgZXg6IEZGNTU1NSBvciBGRjU1NDRDQyAoUkdCYSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIGlmIChjb2xvci5tYXRjaChDb2xvci5yZUhleCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbG9yLnNsaWNlKGNvbG9yLmluZGV4T2YoJyMnKSArIDEpLFxuICAgICAgICAgIGlzU2hvcnROb3RhdGlvbiA9ICh2YWx1ZS5sZW5ndGggPT09IDMgfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICBpc1JHQmEgPSAodmFsdWUubGVuZ3RoID09PSA4IHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgciA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMCkgKyB2YWx1ZS5jaGFyQXQoMCkpIDogdmFsdWUuc3Vic3RyaW5nKDAsIDIpLFxuICAgICAgICAgIGcgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDEpICsgdmFsdWUuY2hhckF0KDEpKSA6IHZhbHVlLnN1YnN0cmluZygyLCA0KSxcbiAgICAgICAgICBiID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgyKSArIHZhbHVlLmNoYXJBdCgyKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNCwgNiksXG4gICAgICAgICAgYSA9IGlzUkdCYSA/IChpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDMpICsgdmFsdWUuY2hhckF0KDMpKSA6IHZhbHVlLnN1YnN0cmluZyg2LCA4KSkgOiAnRkYnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBwYXJzZUZsb2F0KChwYXJzZUludChhLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGNvbG9yIGluIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzIwMCwgMTAwLCAxMDAsIDAuNV0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgb0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgb0NvbG9yLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIHJldHVybiBvQ29sb3I7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICBmdW5jdGlvbiBnZXRDb2xvclN0b3AoZWwpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgIG9mZnNldCA9IGVsLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykgfHwgMCxcbiAgICAgICAgY29sb3IsIGNvbG9yQWxwaGEsIG9wYWNpdHksIGk7XG5cbiAgICAvLyBjb252ZXJ0IHBlcmNlbnRzIHRvIGFic29sdXRlIHZhbHVlc1xuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KSAvICgvJSQvLnRlc3Qob2Zmc2V0KSA/IDEwMCA6IDEpO1xuICAgIG9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0ID4gMSA/IDEgOiBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIga2V5VmFsdWVQYWlycyA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgaWYgKGtleVZhbHVlUGFpcnNba2V5VmFsdWVQYWlycy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAga2V5VmFsdWVQYWlycy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0ga2V5VmFsdWVQYWlycy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0ga2V5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdLnRyaW0oKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnc3RvcC1jb2xvcicpIHtcbiAgICAgICAgICBjb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0b3Atb3BhY2l0eScpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8ICdyZ2IoMCwwLDApJztcbiAgICB9XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICBvcGFjaXR5ID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB9XG5cbiAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpO1xuICAgIGNvbG9yQWxwaGEgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgIG9wYWNpdHkgPSBpc05hTihwYXJzZUZsb2F0KG9wYWNpdHkpKSA/IDEgOiBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgKj0gY29sb3JBbHBoYTtcblxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lYXJDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgneDInKSB8fCAnMTAwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCd5MicpIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFkaWFsQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z4JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgnZnknKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMTogMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjI6IGVsLmdldEF0dHJpYnV0ZSgncicpIHx8ICc1MCUnXG4gICAgfTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICAvKipcbiAgICogR3JhZGllbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5HcmFkaWVudFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNncmFkaWVudHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5HcmFkaWVudCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyYWRpZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuR3JhZGllbnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIHR5cGUsIGNvb3JkcywgZ3JhZGllbnRVbml0cyBhbmQgY29sb3JTdG9wc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgY29vcmRzID0geyB9O1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8ICdsaW5lYXInO1xuXG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHgxOiBvcHRpb25zLmNvb3Jkcy54MSB8fCAwLFxuICAgICAgICB5MTogb3B0aW9ucy5jb29yZHMueTEgfHwgMCxcbiAgICAgICAgeDI6IG9wdGlvbnMuY29vcmRzLngyIHx8IDAsXG4gICAgICAgIHkyOiBvcHRpb25zLmNvb3Jkcy55MiB8fCAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMucjEgPSBvcHRpb25zLmNvb3Jkcy5yMSB8fCAwO1xuICAgICAgICBjb29yZHMucjIgPSBvcHRpb25zLmNvb3Jkcy5yMiB8fCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICB0aGlzLmNvbG9yU3RvcHMgPSBvcHRpb25zLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgIGlmIChvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPSBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgdGhpcy5vZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYIHx8IHRoaXMub2Zmc2V0WDtcbiAgICAgIHRoaXMub2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCB0aGlzLm9mZnNldFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBjb2xvclN0b3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29sb3JTdG9wIE9iamVjdCB3aXRoIG9mZnNldCBhbmQgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uKGNvbG9yU3RvcHMpIHtcbiAgICAgIGZvciAodmFyIHBvc2l0aW9uIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvclN0b3BzW3Bvc2l0aW9uXSk7XG4gICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IHBhcnNlRmxvYXQocG9zaXRpb24pLFxuICAgICAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgICAgIG9wYWNpdHk6IGNvbG9yLmdldEFscGhhKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogdGhpcy5jb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogdGhpcy5ncmFkaWVudFRyYW5zZm9ybVxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50IChsaW5lYXIvcmFkaWFsKVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBjb29yZHMgPSBjbG9uZSh0aGlzLmNvb3JkcywgdHJ1ZSksIGksIGxlbixcbiAgICAgICAgICBtYXJrdXAsIGNvbW1vbkF0dHJpYnV0ZXMsIGNvbG9yU3RvcHMgPSBjbG9uZSh0aGlzLmNvbG9yU3RvcHMsIHRydWUpLFxuICAgICAgICAgIG5lZWRzU3dhcCA9IGNvb3Jkcy5yMSA+IGNvb3Jkcy5yMixcbiAgICAgICAgICBvZmZzZXRYID0gb2JqZWN0LndpZHRoIC8gMiwgb2Zmc2V0WSA9IG9iamVjdC5oZWlnaHQgLyAyO1xuICAgICAgLy8gY29sb3JTdG9wcyBtdXN0IGJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIGNvbG9yU3RvcHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgfSk7XG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICBvZmZzZXRYIC09IG9iamVjdC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIG9mZnNldFkgLT0gb2JqZWN0LnBhdGhPZmZzZXQueTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gY29vcmRzKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicpIHtcbiAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRYIC0gb2Zmc2V0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgICBjb29yZHNbcHJvcF0gKz0gdGhpcy5vZmZzZXRZIC0gb2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb21tb25BdHRyaWJ1dGVzID0gJ2lkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgJ1wiIGdyYWRpZW50VW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiJztcbiAgICAgIGlmICh0aGlzLmdyYWRpZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgKz0gJyBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgnICsgdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5qb2luKCcgJykgKyAnKVwiICc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxsaW5lYXJHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyB4MT1cIicsIGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgeTE9XCInLCBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiIHgyPVwiJywgY29vcmRzLngyLFxuICAgICAgICAgICdcIiB5Mj1cIicsIGNvb3Jkcy55MixcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAvLyBzdmcgcmFkaWFsIGdyYWRpZW50IGhhcyBqdXN0IDEgcmFkaXVzLiB0aGUgYmlnZ2VzdC5cbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8cmFkaWFsR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgY3g9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDEgOiBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIGN5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkxIDogY29vcmRzLnkyLFxuICAgICAgICAgICdcIiByPVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnIxIDogY29vcmRzLnIyLFxuICAgICAgICAgICdcIiBmeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MiA6IGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgZnk9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTIgOiBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgaWYgKG5lZWRzU3dhcCkge1xuICAgICAgICAgIC8vIHN2ZyBnb2VzIGZyb20gaW50ZXJuYWwgdG8gZXh0ZXJuYWwgcmFkaXVzLiBpZiByYWRpdXMgYXJlIGludmVydGVkLCBzd2FwIGNvbG9yIHN0b3BzLlxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBjb2xvclN0b3BzLmNvbmNhdCgpO1xuICAgICAgICAgIGNvbG9yU3RvcHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ID0gMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUmFkaXVzID0gTWF0aC5taW4oY29vcmRzLnIxLCBjb29yZHMucjIpO1xuICAgICAgICBpZiAobWluUmFkaXVzID4gMCkge1xuICAgICAgICAgIC8vIGkgaGF2ZSB0byBzaGlmdCBhbGwgY29sb3JTdG9wcyBhbmQgYWRkIG5ldyBvbmUgaW4gMC5cbiAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5tYXgoY29vcmRzLnIxLCBjb29yZHMucjIpLFxuICAgICAgICAgICAgICBwZXJjZW50YWdlU2hpZnQgPSBtaW5SYWRpdXMgLyBtYXhSYWRpdXM7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgKz0gcGVyY2VudGFnZVNoaWZ0ICogKDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yU3RvcCA9IGNvbG9yU3RvcHNbaV07XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8c3RvcCAnLFxuICAgICAgICAgICdvZmZzZXQ9XCInLCAoY29sb3JTdG9wLm9mZnNldCAqIDEwMCkgKyAnJScsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwic3RvcC1jb2xvcjonLCBjb2xvclN0b3AuY29sb3IsXG4gICAgICAgICAgKHR5cGVvZiBjb2xvclN0b3Aub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyAnO3N0b3Atb3BhY2l0eTogJyArIGNvbG9yU3RvcC5vcGFjaXR5IDogJzsnKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicgPyAnPC9saW5lYXJHcmFkaWVudD5cXG4nIDogJzwvcmFkaWFsR3JhZGllbnQ+XFxuJykpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc0dyYWRpZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge0NhbnZhc0dyYWRpZW50fVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZ3JhZGllbnQsIGNvb3JkcyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLmNvb3JkcyksIGksIGxlbjtcblxuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLngyLCBjb29yZHMueTIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLnIxLCBjb29yZHMueDIsIGNvb3Jkcy55MiwgY29vcmRzLnIyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JTdG9wc1tpXS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcikuc2V0QWxwaGEob3BhY2l0eSkudG9SZ2JhKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5HcmFkaWVudCwge1xuXG4gICAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtTVkdHcmFkaWVudEVsZW1lbnR9IGVsIFNWRyBncmFkaWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gR3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjUmFkaWFsR3JhZGllbnRFbGVtZW50XG4gICAgICovXG4gICAgZnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBpbnN0YW5jZSkge1xuICAgICAgLyoqXG4gICAgICAgKiAgQGV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDI1NSwyNTUsMjU1KVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDAsMCwwKVwiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjUwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiIHN0b3Atb3BhY2l0eT1cIjAuNVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwLjVcIiBzdG9wLWNvbG9yPVwicmdiKDAsMCwwKVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHZhciBjb2xvclN0b3BFbHMgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3RvcCcpLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpIHx8ICdvYmplY3RCb3VuZGluZ0JveCcsXG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJyksXG4gICAgICAgICAgY29sb3JTdG9wcyA9IFtdLFxuICAgICAgICAgIGNvb3JkcywgZWxsaXBzZU1hdHJpeCwgaTtcblxuICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSAnbGluZWFyR3JhZGllbnQnIHx8IGVsLm5vZGVOYW1lID09PSAnTElORUFSR1JBRElFTlQnKSB7XG4gICAgICAgIHR5cGUgPSAnbGluZWFyJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gJ3JhZGlhbCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBjb29yZHMgPSBnZXRMaW5lYXJDb29yZHMoZWwpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgY29vcmRzID0gZ2V0UmFkaWFsQ29vcmRzKGVsKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgZWxsaXBzZU1hdHJpeCA9IF9jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3JkcywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBmYWJyaWMuR3JhZGllbnQoe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogY29sb3JTdG9wcyxcbiAgICAgICAgb2Zmc2V0WDogLWluc3RhbmNlLmxlZnQsXG4gICAgICAgIG9mZnNldFk6IC1pbnN0YW5jZS50b3BcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZWxsaXBzZU1hdHJpeCAhPT0gJycpIHtcbiAgICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoKGdyYWRpZW50VHJhbnNmb3JtIHx8ICcnKSArIGVsbGlwc2VNYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfSxcbiAgICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyYWRpZW50fSBpbnN0YW5jZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZm9yT2JqZWN0OiBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhvYmosIG9wdGlvbnMuY29vcmRzLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLkdyYWRpZW50KG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKG9iamVjdCwgb3B0aW9ucywgZ3JhZGllbnRVbml0cykge1xuICAgIHZhciBwcm9wVmFsdWUsIGFkZEZhY3RvciA9IDAsIG11bHRGYWN0b3IgPSAxLCBlbGxpcHNlTWF0cml4ID0gJyc7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9uc1twcm9wXSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnNbcHJvcF0gPT09ICctSW5maW5pdHknKSB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSAwO1xuICAgICAgfVxuICAgICAgcHJvcFZhbHVlID0gcGFyc2VGbG9hdChvcHRpb25zW3Byb3BdLCAxMCk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09ICdzdHJpbmcnICYmIC9eKFxcZCtcXC5cXGQrKSV8KFxcZCspJSQvLnRlc3Qob3B0aW9uc1twcm9wXSkpIHtcbiAgICAgICAgbXVsdEZhY3RvciA9IDAuMDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbXVsdEZhY3RvciA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ3gxJyB8fCBwcm9wID09PSAneDInIHx8IHByb3AgPT09ICdyMicpIHtcbiAgICAgICAgbXVsdEZhY3RvciAqPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LndpZHRoIDogMTtcbiAgICAgICAgYWRkRmFjdG9yID0gZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyA/IG9iamVjdC5sZWZ0IHx8IDAgOiAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgIG11bHRGYWN0b3IgKj0gZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94JyA/IG9iamVjdC5oZWlnaHQgOiAxO1xuICAgICAgICBhZGRGYWN0b3IgPSBncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gb2JqZWN0LnRvcCB8fCAwIDogMDtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNbcHJvcF0gPSBwcm9wVmFsdWUgKiBtdWx0RmFjdG9yICsgYWRkRmFjdG9yO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdlbGxpcHNlJyAmJlxuICAgICAgICBvcHRpb25zLnIyICE9PSBudWxsICYmXG4gICAgICAgIGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcgJiZcbiAgICAgICAgb2JqZWN0LnJ4ICE9PSBvYmplY3QucnkpIHtcblxuICAgICAgdmFyIHNjYWxlRmFjdG9yID0gb2JqZWN0LnJ5IC8gb2JqZWN0LnJ4O1xuICAgICAgZWxsaXBzZU1hdHJpeCA9ICcgc2NhbGUoMSwgJyArIHNjYWxlRmFjdG9yICsgJyknO1xuICAgICAgaWYgKG9wdGlvbnMueTEpIHtcbiAgICAgICAgb3B0aW9ucy55MSAvPSBzY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnkyKSB7XG4gICAgICAgIG9wdGlvbnMueTIgLz0gc2NhbGVGYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGxpcHNlTWF0cml4O1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIC8qKlxuICAgKiBQYXR0ZXJuIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0dGVyblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3BhdHRlcm5zfFBhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9keW5hbWljLXBhdHRlcm5zfER5bmFtaWNQYXR0ZXJuIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXR0ZXJuI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuXG5cbiAgZmFicmljLlBhdHRlcm4gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5QYXR0ZXJuLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVwZWF0OiAncmVwZWF0JyxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3NzT3JpZ2luOiAnJyxcblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSBtYXRyaXggdG8gY2hhbmdlIHRoZSBwYXR0ZXJuLCBpbXBvcnRlZCBmcm9tIHN2Z3MuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdHRlcm5UcmFuc2Zvcm06IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBjYWxsYmFjayBpbml0LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXR0ZXJufSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNvdXJjZSB8fCAob3B0aW9ucy5zb3VyY2UgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGZ1bmN0aW9uIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5zb3VyY2UpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG5ldyBGdW5jdGlvbihmYWJyaWMudXRpbC5nZXRGdW5jdGlvbkJvZHkob3B0aW9ucy5zb3VyY2UpKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1nIHNyYyBzdHJpbmdcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob3B0aW9ucy5zb3VyY2UsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgIF90aGlzLnNvdXJjZSA9IGltZztcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhfdGhpcyk7XG4gICAgICAgIH0sIG51bGwsIHRoaXMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuICAgICAgICAgIHNvdXJjZSwgb2JqZWN0O1xuXG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzb3VyY2UgPSBTdHJpbmcodGhpcy5zb3VyY2UpO1xuICAgICAgfVxuICAgICAgLy8gPGltZz4gZWxlbWVudFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlLnNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgLy8gPGNhbnZhcz4gZWxlbWVudFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0JyAmJiB0aGlzLnNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgcmVwZWF0OiB0aGlzLnJlcGVhdCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICAgIG9mZnNldFg6IHRvRml4ZWQodGhpcy5vZmZzZXRYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgb2Zmc2V0WTogdG9GaXhlZCh0aGlzLm9mZnNldFksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0gPyB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0uY29uY2F0KCkgOiBudWxsXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHBhdHRlcm5Tb3VyY2UgPSB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbicgPyB0aGlzLnNvdXJjZSgpIDogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgcGF0dGVybldpZHRoID0gcGF0dGVyblNvdXJjZS53aWR0aCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gcGF0dGVyblNvdXJjZS5oZWlnaHQgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRYID0gdGhpcy5vZmZzZXRYIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRZID0gdGhpcy5vZmZzZXRZIC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuSW1nU3JjID0gJyc7XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5IZWlnaHQgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuV2lkdGggPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHBhdHRlcm5Tb3VyY2Uuc3JjKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeD1cIicgKyBwYXR0ZXJuT2Zmc2V0WCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB5PVwiJyArIHBhdHRlcm5PZmZzZXRZICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyArIHBhdHRlcm5XaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVybkhlaWdodCArICdcIj5cXG4nICtcbiAgICAgICAgICAgICAgICc8aW1hZ2UgeD1cIjBcIiB5PVwiMFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBwYXR0ZXJuU291cmNlLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5Tb3VyY2UuaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgeGxpbms6aHJlZj1cIicgKyBwYXR0ZXJuSW1nU3JjICtcbiAgICAgICAgICAgICAgICdcIj48L2ltYWdlPlxcbicgK1xuICAgICAgICAgICAgICc8L3BhdHRlcm4+XFxuJztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc1BhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY3JlYXRlIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgc291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlO1xuXG4gICAgICAvLyBpZiB0aGUgaW1hZ2UgZmFpbGVkIHRvIGxvYWQsIHJldHVybiwgYW5kIGFsbG93IHJlc3QgdG8gY29udGludWUgbG9hZGluZ1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbWFnZVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLm5hdHVyYWxXaWR0aCA9PT0gMCB8fCBzb3VyY2UubmF0dXJhbEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHNvdXJjZSwgdGhpcy5yZXBlYXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5TaGFkb3cpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlNoYWRvdyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWRvdyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlNoYWRvd1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3NoYWRvd3N8U2hhZG93IGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TaGFkb3cjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5TaGFkb3cgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5TaGFkb3cucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBjb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBibHVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzaGFkb3cgc2hvdWxkIGFmZmVjdCBzdHJva2Ugb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFmZmVjdFN0cm9rZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIGFueSBvZiBjb2xvciwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSBwcm9wZXJ0aWVzIG9yIHN0cmluZyAoZS5nLiBcInJnYmEoMCwwLDAsMC4yKSAycHggMnB4IDEwcHhcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwLCBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG5cbiAgICAgIGlmIChvYmplY3Qud2lkdGggJiYgb2JqZWN0LmhlaWdodCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjRmlsdGVyRWZmZWN0c1JlZ2lvblxuICAgICAgICAvLyB3ZSBhZGQgc29tZSBleHRyYSBzcGFjZSB0byBmaWx0ZXIgYm94IHRvIGNvbnRhaW4gdGhlIGJsdXIgKCAyMCApXG4gICAgICAgIGZCb3hYID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LngpICsgdGhpcy5ibHVyKSAvIG9iamVjdC53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgICAgZkJveFkgPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueSkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFgpIHtcbiAgICAgICAgb2Zmc2V0LnggKj0gLTE7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBZKSB7XG4gICAgICAgIG9mZnNldC55ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGZpbHRlciBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICsgJ1wiIHk9XCItJyArIGZCb3hZICsgJyVcIiBoZWlnaHQ9XCInICsgKDEwMCArIDIgKiBmQm94WSkgKyAnJVwiICcgK1xuICAgICAgICAgICd4PVwiLScgKyBmQm94WCArICclXCIgd2lkdGg9XCInICsgKDEwMCArIDIgKiBmQm94WCkgKyAnJVwiICcgKyAnPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIicgK1xuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmJsdXIgPyB0aGlzLmJsdXIgLyAyIDogMCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCI+PC9mZUdhdXNzaWFuQmx1cj5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlT2Zmc2V0IGR4PVwiJyArIHRvRml4ZWQob2Zmc2V0LngsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAnXCIgZHk9XCInICsgdG9GaXhlZChvZmZzZXQueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgcmVzdWx0PVwib0JsdXJcIiA+PC9mZU9mZnNldD5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlRmxvb2QgZmxvb2QtY29sb3I9XCInICsgY29sb3IudG9SZ2IoKSArICdcIiBmbG9vZC1vcGFjaXR5PVwiJyArIGNvbG9yLmdldEFscGhhKCkgKyAnXCIvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlTWVyZ2U+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgJ1xcdDwvZmVNZXJnZT5cXG4nICtcbiAgICAgICAgJzwvZmlsdGVyPlxcbicpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93IGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBibHVyOiB0aGlzLmJsdXIsXG4gICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICBhZmZlY3RTdHJva2U6IHRoaXMuYWZmZWN0U3Ryb2tlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0geyB9LCBwcm90byA9IGZhYnJpYy5TaGFkb3cucHJvdG90eXBlO1xuXG4gICAgICBbJ2NvbG9yJywgJ2JsdXInLCAnb2Zmc2V0WCcsICdvZmZzZXRZJywgJ2FmZmVjdFN0cm9rZSddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gcHJvdG9bcHJvcF0pIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBzaGFkb3cgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1ciAoZXg6IFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiLCBcInJnYigwLDI1NSwwKSAycHggMnB4XCIpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuU2hhZG93XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIgPSAvKD86XFxzfF4pKC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oLT9cXGQrKD86cHgpPyg/Olxccz98JCkpPyhcXGQrKD86cHgpPyk/KD86XFxzP3wkKSg/OiR8XFxzKS87XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU3RhdGljQ2FudmFzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhbGlhc2VzIGZvciBmYXN0ZXIgcmVzb2x1dGlvblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGdldEVsZW1lbnRPZmZzZXQgPSBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0LFxuICAgICAgcmVtb3ZlRnJvbUFycmF5ID0gZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50LFxuICAgICAgaW52ZXJ0VHJhbnNmb3JtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtLFxuXG4gICAgICBDQU5WQVNfSU5JVF9FUlJPUiA9IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgYGNhbnZhc2AgZWxlbWVudCcpO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgY2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zdGF0aWNfY2FudmFzfFN0YXRpY0NhbnZhcyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXJcbiAgICogQGZpcmVzIGNhbnZhczpjbGVhcmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDpyZW1vdmVkXG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkNvbW1vbk1ldGhvZHMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kQ29sb3J9LlxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kSW1hZ2V9LlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoZSBcImJhY2tncm91bmRJbWFnZU9wYWNpdHlcIlxuICAgICAqIGFuZCBcImJhY2tncm91bmRJbWFnZVN0cmV0Y2hcIiBwcm9wZXJ0aWVzIGFyZSBkZXByZWNhdGVkIHNpbmNlIDEuMy45LlxuICAgICAqIFVzZSB7QGxpbmsgZmFicmljLkltYWdlI29wYWNpdHl9LCB7QGxpbmsgZmFicmljLkltYWdlI3dpZHRofSBhbmQge0BsaW5rIGZhYnJpYy5JbWFnZSNoZWlnaHR9LlxuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZEltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUNvbG9yfVxuICAgICAqIEBzaW5jZSAxLjMuOVxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRPdmVybGF5SW1hZ2V9LlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoZSBcIm92ZXJsYXlJbWFnZUxlZnRcIlxuICAgICAqIGFuZCBcIm92ZXJsYXlJbWFnZVRvcFwiIHByb3BlcnRpZXMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgMS4zLjkuXG4gICAgICogVXNlIHtAbGluayBmYWJyaWMuSW1hZ2UjbGVmdH0gYW5kIHtAbGluayBmYWJyaWMuSW1hZ2UjdG9wfS5cbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0L3RvRGF0YWxlc3NPYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMnIHN0YXRlIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0YXRlZnVsOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5hZGR9LCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uaW5zZXJ0QXR9IGFuZCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24ucmVtb3ZlfSxcbiAgICAgKiB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5tb3ZlVG99LCB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5jbGVhcn0gYW5kIG1hbnkgbW9yZSwgc2hvdWxkIGFsc28gcmUtcmVuZGVyIGNhbnZhcy5cbiAgICAgKiBEaXNhYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBub3QgZ2l2ZSBhIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gYWRkaW5nL3JlbW92aW5nIGEgbG90IG9mIG9iamVjdHMgdG8vZnJvbSBjYW52YXMgYXQgb25jZVxuICAgICAqIHNpbmNlIHRoZSByZW5kZXJzIGFyZSBxdWVxdWVkIGFuZCBleGVjdXRlZCBvbmUgcGVyIGZyYW1lLlxuICAgICAqIERpc2FibGluZyBpcyBzdWdnZXN0ZWQgYW55d2F5IGFuZCBtYW5hZ2luZyB0aGUgcmVuZGVycyBvZiB0aGUgYXBwIG1hbnVhbGx5IGlzIG5vdCBhIGJpZyBlZmZvcnQgKCBjYW52YXMucmVxdWVzdFJlbmRlckFsbCgpIClcbiAgICAgKiBMZWZ0IGRlZmF1bHQgdG8gdHJ1ZSB0byBkbyBub3QgYnJlYWsgZG9jdW1lbnRhdGlvbiBhbmQgb2xkIGFwcCwgZmlkZGxlcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZW5kZXJPbkFkZFJlbW92ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBjbGlwcGluZyBvZiBlbnRpcmUgY2FudmFzIGFyZWFcbiAgICAgKiBCZWluZyBwYXNzZWQgY29udGV4dCBhcyBmaXJzdCBhcmd1bWVudC4gU2VlIGNsaXBwaW5nIGNhbnZhcyBhcmVhIGluIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy93aWtpL0ZBUX1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjbGlwVG86IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3QgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpIGFyZSByZW5kZXJlZCBhYm92ZSBvdmVybGF5IGltYWdlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGJlIHNjcm9sbGVkIHdoZW4gdXNpbmcgYSB0b3VjaHNjcmVlbiBhbmQgZHJhZ2dpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsbG93VG91Y2hTY3JvbGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nLCB0aGlzIGlzIG9uIGJ5IGRlZmF1bHQgaW4gYnJvd3NlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtYXRpb24gKGluIHRoZSBmb3JtYXQgb2YgQ2FudmFzIHRyYW5zZm9ybSkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrOyBpbnZva2VkIHJpZ2h0IGJlZm9yZSBvYmplY3QgaXMgYWJvdXQgdG8gYmUgc2NhbGVkL3JvdGF0ZWRcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjMuMFxuICAgICAqIFVzZSBiZWZvcmU6dHJhbnNmb3JtIGV2ZW50XG4gICAgICovXG4gICAgb25CZWZvcmVTY2FsZVJvdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLyogTk9PUCAqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGNhbnZhcyBpcyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbyBmb3IgYmV0dGVyIHJlbmRlcmluZyBvbiByZXRpbmEgc2NyZWVuc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBjYW52YXMgZWxlbWVudCBleHRlbnNpb24gb3ZlciBkZXNpZ25cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxici5cbiAgICAgKiBpZiBjYW52YXMgaXMgbm90IHpvb21lZC9wYW5uZWQgdGhvc2UgcG9pbnRzIGFyZSB0aGUgZm91ciBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogaWYgY2FudmFzIGlzIHZpZXdwb3J0VHJhbnNmb3JtZWQgeW91IHRob3NlIHBvaW50cyBpbmRpY2F0ZSB0aGUgZXh0ZW5zaW9uXG4gICAgICogb2YgY2FudmFzIGVsZW1lbnQgaW4gcGxhaW4gdW50cmFzZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBjYWxjVmlld3BvcnRCb3VuZGFyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZwdENvb3JkczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdnB0Q29vcmRzIGFuZCBvYmplY3QuYUNvb3Jkcywgc2tpcCByZW5kZXJpbmcgb2Ygb2JqZWN0cyB0aGF0XG4gICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqIE1heSBncmVhdGx5IGhlbHAgaW4gYXBwbGljYXRpb25zIHdpdGggY3Jvd2RlZCBjYW52YXMgYW5kIHVzZSBvZiB6b29tL3BhblxuICAgICAqIElmIE9uZSBvZiB0aGUgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG9iamVjdCBpcyBvbiB0aGUgY2FudmFzXG4gICAgICogdGhlIG9iamVjdHMgZ2V0IHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBPZmZzY3JlZW46IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdFN0YXRpYzogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYiA9IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlTG93ZXJDYW52YXMoZWwpO1xuICAgICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRJbWFnZVNtb290aGluZygpO1xuICAgICAgLy8gb25seSBpbml0aWFsaXplIHJldGluYSBzY2FsaW5nIG9uY2VcbiAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5SW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5SW1hZ2Uob3B0aW9ucy5vdmVybGF5SW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRJbWFnZShvcHRpb25zLmJhY2tncm91bmRJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5Q29sb3Iob3B0aW9ucy5vdmVybGF5Q29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1JldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyLnNjYWxlKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvLCBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9kam5yOG83YS8yOC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZEltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdiYWNrZ3JvdW5kSW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxmb3JlZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBvdmVybGF5Q29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgZm9yZWdyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGZvcmVncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BCNTVoL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5Q29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG92ZXJsYXlDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ292ZXJsYXlDb2xvcicsIG92ZXJsYXlDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRDb2xvcnxiYWNrZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBiYWNrZ3JvdW5kQ29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgYmFja2dyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGJhY2tncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2hYenZrL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBiYWNrZ3JvdW5kQ29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ2JhY2tncm91bmRDb2xvcicsIGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWltYWdlc21vb3RoaW5nZW5hYmxlZHxXaGF0V0cgQ2FudmFzIFN0YW5kYXJkfVxuICAgICAqL1xuICAgIF9zZXRJbWFnZVNtb290aGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcbiAgICAgICAgfHwgY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdGhpcy5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmRJbWFnZX1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheUltYWdlfSlcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nfG51bGwpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2UsIFVSTCBvZiBhbiBpbWFnZSBvciBudWxsIHRvIHNldCBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kIG9yIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxpbWFnZX0uXG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24ocHJvcGVydHksIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGltYWdlLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICBpbWcgJiYgKHRoaXNbcHJvcGVydHldID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9wdGlvbnMpKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWcpO1xuICAgICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgJiYgaW1hZ2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbWFnZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1hZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZENvbG9yfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxvdmVybGF5Q29sb3J9KVxuICAgICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IGNvbG9yIE9iamVjdCB3aXRoIHBhdHRlcm4gaW5mb3JtYXRpb24sIGNvbG9yIHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBjb2xvciBpcyBzZXRcbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihwcm9wZXJ0eSwgY29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbG9yO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KGNvbG9yLCBwcm9wZXJ0eSk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihjb2xvciwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUgPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQodGhpcy5sb3dlckNhbnZhc0VsLmhlaWdodCwgMTApIHx8IDA7XG5cbiAgICAgIGlmICghdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICAvLyBjYW52YXNFbCA9PT0gJ0hUTUxDYW52YXNFbGVtZW50JyBkb2VzIG5vdCB3b3JrIG9uIGpzZG9tL25vZGVcbiAgICAgIGlmIChjYW52YXNFbCAmJiBjYW52YXNFbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGZhYnJpYy51dGlsLmdldEJ5SWQoY2FudmFzRWwpIHx8IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG5cbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgICB0aGlzLmhhc0xvc3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9zZXRCcnVzaFN0eWxlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuX3NldEltYWdlU21vb3RoaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRCYWNrc3RvcmVEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyBjc3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRDc3NEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXJFbCkge1xuICAgICAgICB0aGlzLndyYXBwZXJFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgem9vbSBsZXZlbFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2aWV3cG9ydCB0cmFuc2Zvcm0gb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2cHQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgZm9ybSBvZiBjb250ZXh0LnRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsIG9iamVjdCwgaWdub3JlVnB0ID0gZmFsc2UsIHNraXBBYnNvbHV0ZSA9IHRydWUsIGksIGxlbjtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cHQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIG9iamVjdC5ncm91cCB8fCBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVZwdCwgc2tpcEFic29sdXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5zZXRDb29yZHMoaWdub3JlVnB0LCBza2lwQWJzb2x1dGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZSwgem9vbSBjZW50ZXJlZCBhcm91bmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gem9vbSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgem9vbVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IGp1c3QgY2hhbmdlIHRoZSBzY2FsZSwgcHJlc2VydmUgb3RoZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICB2YXIgYmVmb3JlID0gcG9pbnQsIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpO1xuICAgICAgdnB0WzBdID0gdmFsdWU7XG4gICAgICB2cHRbM10gPSB2YWx1ZTtcbiAgICAgIHZhciBhZnRlciA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCB2cHQpO1xuICAgICAgdnB0WzRdICs9IGJlZm9yZS54IC0gYWZ0ZXIueDtcbiAgICAgIHZwdFs1XSArPSBiZWZvcmUueSAtIGFmdGVyLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnpvb21Ub1BvaW50KG5ldyBmYWJyaWMuUG9pbnQoMCwgMCksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdmlld3BvcnQgc28gYXMgdG8gcGxhY2UgcG9pbnQgYXQgdG9wIGxlZnQgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHZwdFs0XSA9IC1wb2ludC54O1xuICAgICAgdnB0WzVdID0gLXBvaW50Lnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHZpZXdwb2ludCByZWxhdGl2ZWx5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IChwb3NpdGlvbiB2ZWN0b3IpIHRvIG1vdmUgYnlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHJlbGF0aXZlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlUGFuKG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIC1wb2ludC54IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs0XSxcbiAgICAgICAgLXBvaW50LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIGFkZGVkXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiBvYmouc2V0dXBTdGF0ZSgpO1xuICAgICAgb2JqLl9zZXQoJ2NhbnZhcycsIHRoaXMpO1xuICAgICAgb2JqLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6YWRkZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ2FkZGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnJlbW92ZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ3JlbW92ZWQnKTtcbiAgICAgIGRlbGV0ZSBvYmouY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3BlY2lmaWVkIGNvbnRleHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xlYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdHMgYXJlIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgdGhpcy5vdmVybGF5Q29sb3IgPSAnJztcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZWQgdG8gYmUgaW5zdGFuY2UgYm91bmQgYXQgaW5pdGlhbGl6YXRpb25cbiAgICAgKiB1c2VkIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbmRSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIHJlbmRlckFsbCByZXF1ZXN0IHRvIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIGEgYm9vbGVhbiBmbGFnIHdpbGwgYXZvaWQgYXBwZW5kaW5nIG1vcmUuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVxdWVzdFJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgNCBjb3JuZXIgb2YgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBoZWxwcyB0byBkZXRlcm1pbmF0ZSB3aGVuIGFuIG9iamVjdCBpcyBpbiB0aGUgY3VycmVudCByZW5kZXJpbmcgdmlld3BvcnQgdXNpbmdcbiAgICAgKiBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXMgKCBhQ29vcmRzIClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50cy50bFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjVmlld3BvcnRCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSB7IH0sIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHBvaW50cy50bCA9IHRyYW5zZm9ybVBvaW50KHsgeDogMCwgeTogMCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy5iciA9IHRyYW5zZm9ybVBvaW50KHsgeDogd2lkdGgsIHk6IGhlaWdodCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy50ciA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLmJyLngsIHBvaW50cy50bC55KTtcbiAgICAgIHBvaW50cy5ibCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLnRsLngsIHBvaW50cy5ici55KTtcbiAgICAgIHRoaXMudnB0Q29vcmRzID0gcG9pbnRzO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBiYWNrZ3JvdW5kLCBvYmplY3RzLCBvdmVybGF5IGFuZCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uKGN0eCwgb2JqZWN0cykge1xuICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnJlbmRlcicpO1xuICAgICAgaWYgKHRoaXMuY2xpcFRvKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvL2FwcGx5IHZpZXdwb3J0IHRyYW5zZm9ybSBvbmNlIGZvciBhbGwgcmVuZGVyaW5nIHByb2Nlc3NcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyT2JqZWN0czogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgaSwgbGVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmplY3RzW2ldICYmIG9iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAnYmFja2dyb3VuZCcgb3IgJ292ZXJsYXknXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIHY7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvYmplY3QudG9MaXZlXG4gICAgICAgICAgPyBvYmplY3QudG9MaXZlKGN0eCwgdGhpcylcbiAgICAgICAgICA6IG9iamVjdDtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgb2JqZWN0Lm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvYmplY3Qub2Zmc2V0WSB8fCAwLFxuICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gdGhpc1twcm9wZXJ0eSArICdJbWFnZSddO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodGhpc1twcm9wZXJ0eSArICdWcHQnXSkge1xuICAgICAgICAgIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucmVuZGVyKGN0eCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHkgKyAnVnB0J10gJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdiYWNrZ3JvdW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnb3ZlcmxheScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgY2VudGVyIG9mIGNhbnZhcy5cbiAgICAgKiBSZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0b3AgYW5kIGxlZnQgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IHRoaXMud2lkdGggLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHRoaXMuZ2V0Q2VudGVyKCkubGVmdCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHRoaXMuZ2V0Q2VudGVyKCkudG9wKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQoY2VudGVyLmxlZnQsIGNlbnRlci50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCB2cENlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHZwQ2VudGVyLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBWZXJ0aWNhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUG9pbnQoeyB4OiBjZW50ZXIubGVmdCwgeTogY2VudGVyLnRvcCB9LCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVycyBkYXRhbGVzcyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9EYXRhbGVzc09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdE1ldGhvZDogZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHZlcnNpb246IGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICBvYmplY3RzOiB0aGlzLl90b09iamVjdHMobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgIH07XG5cbiAgICAgIGV4dGVuZChkYXRhLCB0aGlzLl9fc2VyaWFsaXplQmdPdmVybGF5KG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBkYXRhLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0czogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0cygpLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFvYmplY3QuZXhjbHVkZUZyb21FeHBvcnQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0KGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gaW5zdGFuY2VbbWV0aG9kTmFtZV0ocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3NlcmlhbGl6ZUJnT3ZlcmxheTogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGRhdGEgPSB7IH0sIGJnSW1hZ2UgPSB0aGlzLmJhY2tncm91bmRJbWFnZSwgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUltYWdlO1xuXG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9PYmplY3RcbiAgICAgICAgICA/IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICAgOiB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheSA9IHRoaXMub3ZlcmxheUNvbG9yLnRvT2JqZWN0XG4gICAgICAgICAgPyB0aGlzLm92ZXJsYXlDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgICAgIDogdGhpcy5vdmVybGF5Q29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoYmdJbWFnZSAmJiAhYmdJbWFnZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KGJnSW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXkgJiYgIW92ZXJsYXkuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5SW1hZ2UgPSB0aGlzLl90b09iamVjdChvdmVybGF5LCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBnZXRTdmdUcmFuc2Zvcm0oKSB3aWxsIGFwcGx5IHRoZSBTdGF0aWNDYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gdG8gdGhlIFNWRyB0cmFuc2Zvcm1hdGlvbi4gV2hlbiB0cnVlLFxuICAgICAqIGEgem9vbWVkIGNhbnZhcyB3aWxsIHRoZW4gcHJvZHVjZSB6b29tZWQgU1ZHIG91dHB1dC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBmb3IgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZT1mYWxzZV0gSWYgdHJ1ZSB4bWwgdGFnIGlzIG5vdCBpbmNsdWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52aWV3Qm94XSBTVkcgdmlld2JveCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC54XSB4LWNvb3JpZG5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnldIHktY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gud2lkdGhdIFdpZHRoIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC5oZWlnaHRdIEhlaWdodCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVVURi04XSBFbmNvZGluZyBvZiBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBkZXNpcmVkIHdpZHRoIG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGVpZ2h0XSBkZXNpcmVkIGhlaWdodCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjb252ZXJ0ZWQgaW50byBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgc3RyaW5nXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2pRM1paL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBTVkcgb3V0cHV0PC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGhvdXQgcHJlYW1ibGUgKHdpdGhvdXQgJmx0Oz94bWwgLi4vPik8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7c3VwcHJlc3NQcmVhbWJsZTogdHJ1ZX0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCB2aWV3Qm94IGF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtcbiAgICAgKiAgIHZpZXdCb3g6IHtcbiAgICAgKiAgICAgeDogMTAwLFxuICAgICAqICAgICB5OiAxMDAsXG4gICAgICogICAgIHdpZHRoOiAyMDAsXG4gICAgICogICAgIGhlaWdodDogMzAwXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIGRpZmZlcmVudCBlbmNvZGluZyAoZGVmYXVsdDogVVRGLTgpPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe2VuY29kaW5nOiAnSVNPLTg4NTktMSd9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Nb2RpZnkgU1ZHIG91dHB1dCB3aXRoIHJldml2ZXIgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyhudWxsLCBmdW5jdGlvbihzdmcpIHtcbiAgICAgKiAgIHJldHVybiBzdmcucmVwbGFjZSgnc3Ryb2tlLWRhc2hhcnJheTogOyBzdHJva2UtbGluZWNhcDogYnV0dDsgc3Ryb2tlLWxpbmVqb2luOiBtaXRlcjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyAnLCAnJyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIHRoaXMuX3NldFNWR1ByZWFtYmxlKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRTVkdIZWFkZXIobWFya3VwLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdiYWNrZ3JvdW5kSW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgdGhpcy5fc2V0U1ZHT2JqZWN0cyhtYXJrdXAsIHJldml2ZXIpO1xuXG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdvdmVybGF5Q29sb3InKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ292ZXJsYXlJbWFnZScsIHJldml2ZXIpO1xuXG4gICAgICBtYXJrdXAucHVzaCgnPC9zdmc+Jyk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR1ByZWFtYmxlOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzUHJlYW1ibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCInLCAob3B0aW9ucy5lbmNvZGluZyB8fCAnVVRGLTgnKSwgJ1wiIHN0YW5kYWxvbmU9XCJub1wiID8+XFxuJyxcbiAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiAnLFxuICAgICAgICAnXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIj5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdIZWFkZXI6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHZwdCwgdmlld0JveCA9ICd2aWV3Qm94PVwiMCAwICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHQgKyAnXCIgJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBpZiAob3B0aW9ucy52aWV3Qm94KSB7XG4gICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC54ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueSArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LndpZHRoICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3guaGVpZ2h0ICsgJ1wiICc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNF0gLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs1XSAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0IC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHN2ZyAnLFxuICAgICAgICAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcsXG4gICAgICAgICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnLFxuICAgICAgICAndmVyc2lvbj1cIjEuMVwiICcsXG4gICAgICAgICd3aWR0aD1cIicsIHdpZHRoLCAnXCIgJyxcbiAgICAgICAgJ2hlaWdodD1cIicsIGhlaWdodCwgJ1wiICcsXG4gICAgICAgIHZpZXdCb3gsXG4gICAgICAgICd4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbicsXG4gICAgICAgICc8ZGVzYz5DcmVhdGVkIHdpdGggRmFicmljLmpzICcsIGZhYnJpYy52ZXJzaW9uLCAnPC9kZXNjPlxcbicsXG4gICAgICAgICc8ZGVmcz5cXG4nLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwKCksXG4gICAgICAgICc8L2RlZnM+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgcmVmZXJlbmNlZCBlbGVtZW50cyBsaWtlIHBhdHRlcm5zLCBncmFkaWVudHMgZXRjLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIG1hcmt1cCA9IFsnYmFja2dyb3VuZENvbG9yJywgJ292ZXJsYXlDb2xvciddLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IF90aGlzW3Byb3BdO1xuICAgICAgICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGwudG9TVkcoX3RoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIGZvbnQgZmFjZXMsXG4gICAgICogZm9udCBVUkxzIGZvciBmb250IGZhY2VzIG11c3QgYmUgY29sbGVjdGVkIGJ5IGRldmVsb3BlcnNcbiAgICAgKiBhbmQgYXJlIG5vdCBleHRyYWN0ZWQgZnJvbSB0aGUgRE9NIGJ5IGZhYnJpY2pzXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBBcnJheSBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdGb250RmFjZXNNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmt1cCA9ICcnLCBmb250TGlzdCA9IHsgfSwgb2JqLCBmb250RmFtaWx5LFxuICAgICAgICAgIHN0eWxlLCByb3csIHJvd0luZGV4LCBfY2hhciwgY2hhckluZGV4LCBpLCBsZW4sXG4gICAgICAgICAgZm9udFBhdGhzID0gZmFicmljLmZvbnRQYXRocywgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgIGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseTtcbiAgICAgICAgaWYgKG9iai50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gLTEgfHwgZm9udExpc3RbZm9udEZhbWlseV0gfHwgIWZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFvYmouc3R5bGVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUgPSBvYmouc3R5bGVzO1xuICAgICAgICBmb3IgKHJvd0luZGV4IGluIHN0eWxlKSB7XG4gICAgICAgICAgcm93ID0gc3R5bGVbcm93SW5kZXhdO1xuICAgICAgICAgIGZvciAoY2hhckluZGV4IGluIHJvdykge1xuICAgICAgICAgICAgX2NoYXIgPSByb3dbY2hhckluZGV4XTtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfY2hhci5mb250RmFtaWx5O1xuICAgICAgICAgICAgaWYgKCFmb250TGlzdFtmb250RmFtaWx5XSAmJiBmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqIGluIGZvbnRMaXN0KSB7XG4gICAgICAgIG1hcmt1cCArPSBbXG4gICAgICAgICAgJ1xcdFxcdEBmb250LWZhY2Uge1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdGZvbnQtZmFtaWx5OiBcXCcnLCBqLCAnXFwnO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdHNyYzogdXJsKFxcJycsIGZvbnRQYXRoc1tqXSwgJ1xcJyk7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0fVxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJ1xcdDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nLFxuICAgICAgICAgICc8IVtDREFUQVtcXG4nLFxuICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAnXV0+JyxcbiAgICAgICAgICAnPC9zdHlsZT5cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdHM6IGZ1bmN0aW9uKG1hcmt1cCwgcmV2aXZlcikge1xuICAgICAgdmFyIGluc3RhbmNlLCBpLCBsZW4sIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmIHRoaXNbcHJvcGVydHldLnRvU1ZHKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXNbcHJvcGVydHldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsZXIgPSB0aGlzW3Byb3BlcnR5XSwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgZmluYWxXaWR0aCA9IHRoaXMud2lkdGggLyB2cHRbMF0sXG4gICAgICAgICAgZmluYWxIZWlnaHQgPSB0aGlzLmhlaWdodCAvIHZwdFszXTtcbiAgICAgIGlmICghZmlsbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBmaWxsZXIucmVwZWF0O1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCcsIGZpbmFsV2lkdGggLyAyLCAnLCcsIGZpbmFsSGVpZ2h0IC8gMiwgJylcIicsXG4gICAgICAgICAgJyB4PVwiJywgZmlsbGVyLm9mZnNldFggLSBmaW5hbFdpZHRoIC8gMiwgJ1wiIHk9XCInLCBmaWxsZXIub2Zmc2V0WSAtIGZpbmFsSGVpZ2h0IC8gMiwgJ1wiICcsXG4gICAgICAgICAgJ3dpZHRoPVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS53aWR0aFxuICAgICAgICAgICAgOiBmaW5hbFdpZHRoICksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2UuaGVpZ2h0XG4gICAgICAgICAgICA6IGZpbmFsSGVpZ2h0KSxcbiAgICAgICAgICAnXCIgZmlsbD1cInVybCgjU1ZHSURfJyArIGZpbGxlci5pZCArICcpXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiAnLFxuICAgICAgICAgICdmaWxsPVwiJywgdGhpc1twcm9wZXJ0eV0sICdcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmQgdG8gYmFja1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gb2Jqcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW10ZXIsIGludGVyc2VjdGluZyBhbGxvd2VzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBiZWhpbmRcbiAgICAgKiB0aGUgZmlyc3QgaW50ZXJzZWN0aW5nIG9iamVjdC4gV2hlcmUgaW50ZXJzZWN0aW9uIGlzIGNhbGN1bGF0ZWQgd2l0aFxuICAgICAqIGJvdW5kaW5nIGJveC4gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLCB0aGVyZSB3aWxsIG5vdCBiZSBjaGFuZ2UgaW4gdGhlXG4gICAgICogc3RhY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA+IDAgKyBvYmpzTW92ZWQpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Jqc01vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gMCkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdGhlIGJvdHRvbSBvZiBzdGFja1xuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdMb3dlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3TG93ZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaTtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgZG93biB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggLSAxOyBpID49IDA7IC0taSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4IC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIHVwIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBBbiBvcHRpb25hbCBwYXJhbXRlciwgaW50ZXJzZWN0aW5nIGFsbG93ZXMgdG8gbW92ZSB0aGUgb2JqZWN0IGluIGZyb250XG4gICAgICogb2YgdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGluIGZyb250IG9mIG5leHQgdXBwZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbiAob2JqZWN0LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzLCBvYmpzTW92ZWQgPSAwO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4IDwgdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxIC0gb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdG9wIG9mIHN0YWNrIChsYXN0IGl0ZW0gaW4gYW4gYXJyYXkpXG4gICAgICAgICAgbmV3SWR4ID0gdGhpcy5fZmluZE5ld1VwcGVySW5kZXgob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZyk7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmROZXdVcHBlckluZGV4OiBmdW5jdGlvbihvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICB2YXIgbmV3SWR4LCBpLCBsZW47XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIHVwIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAoaSA9IGlkeCArIDEsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG1vdmVUbzogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgpIHtcbiAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDAsIG9iamVjdCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIGRpc3Bvc2Ugb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2FuY2VsIGV2ZW50dWFsbHkgb25nb2luZyByZW5kZXJzXG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSAmJiBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5DYW52YXMgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpOiAnICtcbiAgICAgICAgICAgICAgICd7IG9iamVjdHM6ICcgKyB0aGlzLmdldE9iamVjdHMoKS5sZW5ndGggKyAnIH0+JztcbiAgICB9XG4gIH0pO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5Db2xsZWN0aW9uKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuRGF0YVVSTEV4cG9ydGVyKTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzICovIHtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIEVNUFRZX0pTT046ICd7XCJvYmplY3RzXCI6IFtdLCBcImJhY2tncm91bmRcIjogXCJ3aGl0ZVwifScsXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHdheSB0byBjaGVjayBzdXBwb3J0IG9mIHNvbWUgb2YgdGhlIGNhbnZhcyBtZXRob2RzXG4gICAgICogKGVpdGhlciB0aG9zZSBvZiBIVE1MQ2FudmFzRWxlbWVudCBpdHNlbGYsIG9yIHJlbmRlcmluZyBjb250ZXh0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIHRvIGNoZWNrIHN1cHBvcnQgZm9yO1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvdWxkIGJlIG9uZSBvZiBcImdldEltYWdlRGF0YVwiLCBcInRvRGF0YVVSTFwiLCBcInRvRGF0YVVSTFdpdGhRdWFsaXR5XCIgb3IgXCJzZXRMaW5lRGFzaFwiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbiB8IG51bGx9IGB0cnVlYCBpZiBtZXRob2QgaXMgc3VwcG9ydGVkIChvciBhdCBsZWFzdCBleGlzdHMpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBgbnVsbGAgaWYgY2FudmFzIGVsZW1lbnQgb3IgY29udGV4dCBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAgIGlmICghZWwgfHwgIWVsLmdldENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBlbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuXG4gICAgICAgIGNhc2UgJ2dldEltYWdlRGF0YSc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguZ2V0SW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBjYXNlICdzZXRMaW5lRGFzaCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGNhc2UgJ3RvRGF0YVVSTCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbC50b0RhdGFVUkwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGNhc2UgJ3RvRGF0YVVSTFdpdGhRdWFsaXR5JzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWwudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICogQHJldHVybiB7U3RyaW5nfSBKU09OIHN0cmluZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BlYzg2L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRlZDwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKFsnbG9ja01vdmVtZW50WCcsICdsb2NrTW92ZW1lbnRZJywgJ2xvY2tSb3RhdGlvbicsICdsb2NrU2NhbGluZ1gnLCAnbG9ja1NjYWxpbmdZJywgJ2xvY2tVbmlTY2FsaW5nJ10pO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgZGVmYXVsdCB2YWx1ZXM8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICovXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvSlNPTiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4gIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlUE5HU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1wbCA9IGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlUE5HU3RyZWFtKCk7XG4gICAgfTtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVKUEVHU3RyZWFtID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIGltcGwgPSBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZUpQRUdTdHJlYW0ob3B0cyk7XG4gICAgfTtcbiAgfVxufSkoKTtcblxuXG4vKipcbiAqIEJhc2VCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZnJlZWRyYXdpbmd8RnJlZWRyYXdpbmcgZGVtb31cbiAqL1xuZmFicmljLkJhc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBDb2xvciBvZiBhIGJydXNoXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgY29sb3I6ICdyZ2IoMCwgMCwgMCknLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoLCBoYXMgdG8gYmUgYSBOdW1iZXIsIG5vIHN0cmluZyBsaXRlcmFsc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcInNoYWRvd0NvbG9yXCIgKFN0cmluZyksIFwic2hhZG93T2Zmc2V0WFwiIChOdW1iZXIpLFxuICAgKiBcInNoYWRvd09mZnNldFlcIiAoTnVtYmVyKSBhbmQgXCJzaGFkb3dCbHVyXCIgKE51bWJlcikgc2luY2UgdjEuMi4xMlxuICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzaGFkb3c6IG51bGwsXG5cbiAgLyoqXG4gICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lQ2FwOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBDb3JuZXIgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUpvaW46ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYSBicnVzaCdzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICAxMCxcblxuICAvKipcbiAgICogU3Ryb2tlIERhc2ggQXJyYXkuXG4gICAqIEB0eXBlIEFycmF5XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHMgc2hhZG93IG9mIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0U2hhZG93OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyhvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjdHgubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcDtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICBjdHgubGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luO1xuICAgIGlmIChmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpKSB7XG4gICAgICBjdHguc2V0TGluZURhc2godGhpcy5zdHJva2VEYXNoQXJyYXkgfHwgW10pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gb24gZ2l2ZW4gY29udGV4dFxuICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZUFuZFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLFxuICAgICAgICB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpO1xuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3cuY29sb3I7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvdy5ibHVyICogem9vbTtcbiAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93Lm9mZnNldFggKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3cub2Zmc2V0WSAqIHpvb207XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcblxuICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogUGVuY2lsQnJ1c2ggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QZW5jaWxCcnVzaFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gICAqL1xuICBmYWJyaWMuUGVuY2lsQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QZW5jaWxCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QZW5jaWxCcnVzaH0gSW5zdGFuY2Ugb2YgYSBwZW5jaWwgYnJ1c2hcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIF9kcmF3U2VnbWVudDogZnVuY3Rpb24gKGN0eCwgcDEsIHAyKSB7XG4gICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSk7XG4gICAgICByZXR1cm4gbWlkUG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElub3Zva2VkIG9uIG1vdXNlIGRvd25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yRHJhd2luZyhwb2ludGVyKTtcbiAgICAgIC8vIGNhcHR1cmUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHRvIGRyYXcgZG90cyAod2hlbiBtb3ZlbWVudCBuZXZlciBvY2N1cnMpXG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5vdm9rZWQgb24gbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcikgJiYgdGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNGdWxsUmVuZGVyKSB7XG4gICAgICAgICAgLy8gcmVkcmF3IGN1cnZlXG4gICAgICAgICAgLy8gY2xlYXIgdG9wIGNhbnZhc1xuICAgICAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoLCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgICAgIC8vIGRyYXcgdGhlIGN1cnZlIHVwZGF0ZVxuICAgICAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICBpZiAodGhpcy5vbGRFbmQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5vbGRFbmQueCwgdGhpcy5vbGRFbmQueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub2xkRW5kID0gdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9sZEVuZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5kQWRkUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3ByZXBhcmVGb3JEcmF3aW5nOiBmdW5jdGlvbihwb2ludGVyKSB7XG5cbiAgICAgIHZhciBwID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwKTtcbiAgICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubW92ZVRvKHAueCwgcC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gYmUgYWRkZWQgdG8gcG9pbnRzIGFycmF5XG4gICAgICovXG4gICAgX2FkZFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPiAxICYmIHBvaW50LmVxKHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBwb2ludHMgYXJyYXkgYW5kIHNldCBjb250ZXh0VG9wIGNhbnZhcyBzdHlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9wb2ludHMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX3NldEJydXNoU3R5bGVzKCk7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuICAgICAgdGhpcy5uZWVkc0Z1bGxSZW5kZXIgPSAoY29sb3IuZ2V0QWxwaGEoKSA8IDEpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfY2FwdHVyZURyYXdpbmdQYXRoOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkUG9pbnQocG9pbnRlclBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNtb290aCBwYXRoIG9uIHRoZSB0b3BDYW52YXMgdXNpbmcgcXVhZHJhdGljQ3VydmVUb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ICA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbixcbiAgICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1swXSxcbiAgICAgICAgICBwMiA9IHRoaXMuX3BvaW50c1sxXTtcblxuICAgICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgLy9pZiB3ZSBvbmx5IGhhdmUgMiBwb2ludHMgaW4gdGhlIHBhdGggYW5kIHRoZXkgYXJlIHRoZSBzYW1lXG4gICAgICAvL2l0IG1lYW5zIHRoYXQgdGhlIHVzZXIgb25seSBjbGlja2VkIHRoZSBjYW52YXMgd2l0aG91dCBtb3ZpbmcgdGhlIG1vdXNlXG4gICAgICAvL3RoZW4gd2Ugc2hvdWxkIGJlIGRyYXdpbmcgYSBkb3QuIEEgcGF0aCBpc24ndCBkcmF3biBiZXR3ZWVuIHR3byBpZGVudGljYWwgZG90c1xuICAgICAgLy90aGF0J3Mgd2h5IHdlIHNldCB0aGVtIGFwYXJ0IGEgYml0XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA9PT0gMiAmJiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnkpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCAvIDEwMDA7XG4gICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwMS54LCBwMS55KTtcbiAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHAyLngsIHAyLnkpO1xuICAgICAgICBwMS54IC09IHdpZHRoO1xuICAgICAgICBwMi54ICs9IHdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcblxuICAgICAgZm9yIChpID0gMSwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIHdlIHBpY2sgdGhlIHBvaW50IGJldHdlZW4gcGkgKyAxICYgcGkgKyAyIGFzIHRoZVxuICAgICAgICAvLyBlbmQgcG9pbnQgYW5kIHAxIGFzIG91ciBjb250cm9sIHBvaW50LlxuICAgICAgICB0aGlzLl9kcmF3U2VnbWVudChjdHgsIHAxLCBwMik7XG4gICAgICAgIHAxID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICBwMiA9IHRoaXMuX3BvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBEcmF3IGxhc3QgbGluZSBhcyBhIHN0cmFpZ2h0IGxpbmUgd2hpbGVcbiAgICAgIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHBvaW50IHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlXG4gICAgICAvLyB0aGUgYmV6aWVyIGNvbnRyb2wgcG9pbnRcbiAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBwb2ludHMgdG8gU1ZHIHBhdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcGF0aFxuICAgICAqL1xuICAgIGNvbnZlcnRQb2ludHNUb1NWR1BhdGg6IGZ1bmN0aW9uKHBvaW50cykge1xuICAgICAgdmFyIHBhdGggPSBbXSwgaSwgd2lkdGggPSB0aGlzLndpZHRoIC8gMTAwMCxcbiAgICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzBdLngsIHBvaW50c1swXS55KSxcbiAgICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KSxcbiAgICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLCBtdWx0U2lnblggPSAxLCBtdWx0U2lnblkgPSAxLCBtYW55UG9pbnRzID0gbGVuID4gMjtcblxuICAgICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgICAgbXVsdFNpZ25YID0gcG9pbnRzWzJdLnggPCBwMi54ID8gLTEgOiBwb2ludHNbMl0ueCA9PT0gcDIueCA/IDAgOiAxO1xuICAgICAgICBtdWx0U2lnblkgPSBwb2ludHNbMl0ueSA8IHAyLnkgPyAtMSA6IHBvaW50c1syXS55ID09PSBwMi55ID8gMCA6IDE7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goJ00gJywgcDEueCAtIG11bHRTaWduWCAqIHdpZHRoLCAnICcsIHAxLnkgLSBtdWx0U2lnblkgKiB3aWR0aCwgJyAnKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIXAxLmVxKHAyKSkge1xuICAgICAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICAgICAgLy8gcDEgaXMgb3VyIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICAgICAgLy8gbWlkcG9pbnQgaXMgb3VyIGVuZHBvaW50XG4gICAgICAgICAgLy8gc3RhcnQgcG9pbnQgaXMgcChpLTEpIHZhbHVlLlxuICAgICAgICAgIHBhdGgucHVzaCgnUSAnLCBwMS54LCAnICcsIHAxLnksICcgJywgbWlkUG9pbnQueCwgJyAnLCBtaWRQb2ludC55LCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHAxID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAoKGkgKyAxKSA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBwMiA9IHBvaW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICAgIG11bHRTaWduWCA9IHAxLnggPiBwb2ludHNbaSAtIDJdLnggPyAxIDogcDEueCA9PT0gcG9pbnRzW2kgLSAyXS54ID8gMCA6IC0xO1xuICAgICAgICBtdWx0U2lnblkgPSBwMS55ID4gcG9pbnRzW2kgLSAyXS55ID8gMSA6IHAxLnkgPT09IHBvaW50c1tpIC0gMl0ueSA/IDAgOiAtMTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaCgnTCAnLCBwMS54ICsgbXVsdFNpZ25YICogd2lkdGgsICcgJywgcDEueSArIG11bHRTaWduWSAqIHdpZHRoKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGZhYnJpYy5QYXRoIG9iamVjdCB0byBhZGQgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhEYXRhIFBhdGggZGF0YVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSBQYXRoIHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgZmFicmljLlBhdGgocGF0aERhdGEsIHtcbiAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICBzdHJva2VNaXRlckxpbWl0OiB0aGlzLnN0cm9rZU1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZUxpbmVKb2luOiB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICBzdHJva2VEYXNoQXJyYXk6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBuZXcgZmFicmljLlBvaW50KHBhdGgubGVmdCArIHBhdGgud2lkdGggLyAyLCBwYXRoLnRvcCArIHBhdGguaGVpZ2h0IC8gMik7XG4gICAgICBwb3NpdGlvbiA9IHBhdGgudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb3NpdGlvbiwgJ2NlbnRlcicsICdjZW50ZXInLCBwYXRoLm9yaWdpblgsIHBhdGgub3JpZ2luWSk7XG4gICAgICBwYXRoLnRvcCA9IHBvc2l0aW9uLnk7XG4gICAgICBwYXRoLmxlZnQgPSBwb3NpdGlvbi54O1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLmNvbnZlcnRQb2ludHNUb1NWR1BhdGgodGhpcy5fcG9pbnRzKS5qb2luKCcnKTtcbiAgICAgIGlmIChwYXRoRGF0YSA9PT0gJ00gMCAwIFEgMCAwIDAgMCBMIDAgMCcpIHtcbiAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSAwIHdpZHRoL2hlaWdodCBwYXRocywgYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgaW5jb25zaXN0ZW50bHkgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIEZpcmVmb3ggNCwgZm9yIGV4YW1wbGUsIHJlbmRlcnMgYSBkb3QsXG4gICAgICAgIC8vIHdoZXJlYXMgQ2hyb21lIDEwIHJlbmRlcnMgbm90aGluZ1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSB0aGlzLmNyZWF0ZVBhdGgocGF0aERhdGEpO1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5jYW52YXMuYWRkKHBhdGgpO1xuICAgICAgdGhpcy5jYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICBwYXRoLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcblxuXG4gICAgICAvLyBmaXJlIGV2ZW50ICdwYXRoJyBjcmVhdGVkXG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuLyoqXG4gKiBDaXJjbGVCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5DaXJjbGVCcnVzaFxuICovXG5mYWJyaWMuQ2lyY2xlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGVCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEwLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlQnJ1c2h9IEluc3RhbmNlIG9mIGEgY2lyY2xlIGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBkcmF3RG90OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5hZGRQb2ludChwb2ludGVyKSxcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBvaW50LmZpbGw7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcG9pbnQucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBmdWxsIHN0YXRlIG9mIHRoZSBicnVzaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCAgPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW4sXG4gICAgICAgIHBvaW50cyA9IHRoaXMucG9pbnRzLCBwb2ludDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwb2ludC5maWxsO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUsIGksIGxlbjtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGNpcmNsZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1tpXSxcbiAgICAgICAgICBjaXJjbGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgICAgICByYWRpdXM6IHBvaW50LnJhZGl1cyxcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50LngsXG4gICAgICAgICAgICB0b3A6IHBvaW50LnksXG4gICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgICAgZmlsbDogcG9pbnQuZmlsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNoYWRvdyAmJiBjaXJjbGUuc2V0U2hhZG93KHRoaXMuc2hhZG93KTtcblxuICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZSk7XG4gICAgfVxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoY2lyY2xlcywgeyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ2NlbnRlcicgfSk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IEp1c3QgYWRkZWQgcG9pbnRlciBwb2ludFxuICAgKi9cbiAgYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG5cbiAgICAgICAgY2lyY2xlUmFkaXVzID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgIC5zZXRBbHBoYShmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMClcbiAgICAgICAgICAudG9SZ2JhKCk7XG5cbiAgICBwb2ludGVyUG9pbnQucmFkaXVzID0gY2lyY2xlUmFkaXVzO1xuICAgIHBvaW50ZXJQb2ludC5maWxsID0gY2lyY2xlQ29sb3I7XG5cbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50ZXJQb2ludCk7XG5cbiAgICByZXR1cm4gcG9pbnRlclBvaW50O1xuICB9XG59KTtcblxuXG4vKipcbiAqIFNwcmF5QnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuU3ByYXlCcnVzaFxuICovXG5mYWJyaWMuU3ByYXlCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKCBmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5TcHJheUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgc3ByYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogICAgICAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBEZW5zaXR5IG9mIGEgc3ByYXkgKG51bWJlciBvZiBkb3RzIHBlciBjaHVuaylcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkZW5zaXR5OiAgICAgICAgICAgIDIwLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGg6ICAgICAgICAgICAxLFxuXG4gIC8qKlxuICAgKiBXaWR0aCB2YXJpYW5jZSBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGhWYXJpYW5jZTogICAxLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9wYWNpdHkgb2YgYSBkb3Qgc2hvdWxkIGJlIHJhbmRvbVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICByYW5kb21PcGFjaXR5OiAgICAgICAgZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3ZlcmxhcHBpbmcgZG90cyAocmVjdGFuZ2xlcykgc2hvdWxkIGJlIHJlbW92ZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBvcHRpbWl6ZU92ZXJsYXBwaW5nOiAgdHJ1ZSxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLlNwcmF5QnJ1c2h9IEluc3RhbmNlIG9mIGEgc3ByYXkgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc3ByYXlDaHVua3MgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG5cbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciByZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFyIHNwcmF5Q2h1bmsgPSB0aGlzLnNwcmF5Q2h1bmtzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgICAgIHdpZHRoOiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBsZWZ0OiBzcHJheUNodW5rW2pdLnggKyAxLFxuICAgICAgICAgIHRvcDogc3ByYXlDaHVua1tqXS55ICsgMSxcbiAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGltaXplT3ZlcmxhcHBpbmcpIHtcbiAgICAgIHJlY3RzID0gdGhpcy5fZ2V0T3B0aW1pemVkUmVjdHMocmVjdHMpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAocmVjdHMsIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6ICdjZW50ZXInIH0pO1xuICAgIHRoaXMuc2hhZG93ICYmIGdyb3VwLnNldFNoYWRvdyh0aGlzLnNoYWRvdyk7XG4gICAgdGhpcy5jYW52YXMuYWRkKGdyb3VwKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmVjdHNcbiAgICovXG4gIF9nZXRPcHRpbWl6ZWRSZWN0czogZnVuY3Rpb24ocmVjdHMpIHtcblxuICAgIC8vIGF2b2lkIGNyZWF0aW5nIGR1cGxpY2F0ZSByZWN0cyBhdCB0aGUgc2FtZSBjb29yZGluYXRlc1xuICAgIHZhciB1bmlxdWVSZWN0cyA9IHsgfSwga2V5LCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0gcmVjdHNbaV0ubGVmdCArICcnICsgcmVjdHNbaV0udG9wO1xuICAgICAgaWYgKCF1bmlxdWVSZWN0c1trZXldKSB7XG4gICAgICAgIHVuaXF1ZVJlY3RzW2tleV0gPSByZWN0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuaXF1ZVJlY3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB1bmlxdWVSZWN0cykge1xuICAgICAgdW5pcXVlUmVjdHNBcnJheS5wdXNoKHVuaXF1ZVJlY3RzW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVSZWN0c0FycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgbmV3IGNodW5rIG9mIHNwcmF5IGJydXNoXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKHNwcmF5Q2h1bmspIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gc3ByYXlDaHVua1tpXTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnQub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcG9pbnQub3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsUmVjdChwb2ludC54LCBwb2ludC55LCBwb2ludC53aWR0aCwgcG9pbnQud2lkdGgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHNwcmF5IGNodW5rc1xuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGlsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua3NbaV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgYWRkU3ByYXlDaHVuazogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cyA9IFtdO1xuXG4gICAgdmFyIHgsIHksIHdpZHRoLCByYWRpdXMgPSB0aGlzLndpZHRoIC8gMiwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbnNpdHk7IGkrKykge1xuXG4gICAgICB4ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KHBvaW50ZXIueCAtIHJhZGl1cywgcG9pbnRlci54ICsgcmFkaXVzKTtcbiAgICAgIHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci55IC0gcmFkaXVzLCBwb2ludGVyLnkgKyByYWRpdXMpO1xuXG4gICAgICBpZiAodGhpcy5kb3RXaWR0aFZhcmlhbmNlKSB7XG4gICAgICAgIHdpZHRoID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIC8vIGJvdHRvbSBjbGFtcCB3aWR0aCB0byAxXG4gICAgICAgICAgTWF0aC5tYXgoMSwgdGhpcy5kb3RXaWR0aCAtIHRoaXMuZG90V2lkdGhWYXJpYW5jZSksXG4gICAgICAgICAgdGhpcy5kb3RXaWR0aCArIHRoaXMuZG90V2lkdGhWYXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmRvdFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgICAgcG9pbnQud2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKHRoaXMucmFuZG9tT3BhY2l0eSkge1xuICAgICAgICBwb2ludC5vcGFjaXR5ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KDAsIDEwMCkgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnNwcmF5Q2h1bmtzLnB1c2godGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBQYXR0ZXJuQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuUGF0dGVybkJydXNoXG4gKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gKi9cbmZhYnJpYy5QYXR0ZXJuQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUGVuY2lsQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm5CcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIGdldFBhdHRlcm5TcmM6IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGRvdFdpZHRoID0gMjAsXG4gICAgICAgIGRvdERpc3RhbmNlID0gNSxcbiAgICAgICAgcGF0dGVybkNhbnZhcyA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHBhdHRlcm5DYW52YXMud2lkdGggPSBwYXR0ZXJuQ2FudmFzLmhlaWdodCA9IGRvdFdpZHRoICsgZG90RGlzdGFuY2U7XG5cbiAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgcGF0dGVybkN0eC5iZWdpblBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmFyYyhkb3RXaWR0aCAvIDIsIGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIHBhdHRlcm5DdHguY2xvc2VQYXRoKCk7XG4gICAgcGF0dGVybkN0eC5maWxsKCk7XG5cbiAgICByZXR1cm4gcGF0dGVybkNhbnZhcztcbiAgfSxcblxuICBnZXRQYXR0ZXJuU3JjRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRQYXR0ZXJuU3JjKS5yZXBsYWNlKCd0aGlzLmNvbG9yJywgJ1wiJyArIHRoaXMuY29sb3IgKyAnXCInKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBcInBhdHRlcm5cIiBpbnN0YW5jZSBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0UGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuY3JlYXRlUGF0dGVybih0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmMoKSwgJ3JlcGVhdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbGxTdXBlcignX3NldEJydXNoU3R5bGVzJyk7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0UGF0dGVybigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHBhdGhcbiAgICovXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLmNhbGxTdXBlcignY3JlYXRlUGF0aCcsIHBhdGhEYXRhKSxcbiAgICAgICAgdG9wTGVmdCA9IHBhdGguX2dldExlZnRUb3BDb29yZHMoKS5zY2FsYXJBZGQocGF0aC5zdHJva2VXaWR0aCAvIDIpO1xuXG4gICAgcGF0aC5zdHJva2UgPSBuZXcgZmFicmljLlBhdHRlcm4oe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmNGdW5jdGlvbigpLFxuICAgICAgb2Zmc2V0WDogLXRvcExlZnQueCxcbiAgICAgIG9mZnNldFk6IC10b3BMZWZ0LnlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZXRQb2ludGVyID0gZmFicmljLnV0aWwuZ2V0UG9pbnRlcixcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgcmFkaWFuc1RvRGVncmVlcyA9IGZhYnJpYy51dGlsLnJhZGlhbnNUb0RlZ3JlZXMsXG4gICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgIHN1cHBvcnRMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG5cbiAgICAgIFNUUk9LRV9PRkZTRVQgPSAwLjU7XG5cbiAgLyoqXG4gICAqIENhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNhbnZhc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2NhbnZhc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkNhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgb2JqZWN0Om1vZGlmaWVkXG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRlZFxuICAgKiBAZmlyZXMgb2JqZWN0OnNjYWxlZFxuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2VkXG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRpbmdcbiAgICogQGZpcmVzIG9iamVjdDpzY2FsaW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6bW92aW5nXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2luZ1xuICAgKiBAZmlyZXMgb2JqZWN0OnNlbGVjdGVkIHRoaXMgZXZlbnQgaXMgZGVwcmVjYXRlZC4gdXNlIHNlbGVjdGlvbjpjcmVhdGVkXG4gICAqXG4gICAqIEBmaXJlcyBiZWZvcmU6dHJhbnNmb3JtXG4gICAqIEBmaXJlcyBiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246dXBkYXRlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNyZWF0ZWRcbiAgICpcbiAgICogQGZpcmVzIHBhdGg6Y3JlYXRlZFxuICAgKiBAZmlyZXMgbW91c2U6ZG93blxuICAgKiBAZmlyZXMgbW91c2U6bW92ZVxuICAgKiBAZmlyZXMgbW91c2U6dXBcbiAgICogQGZpcmVzIG1vdXNlOmRvd246YmVmb3JlXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlOmJlZm9yZVxuICAgKiBAZmlyZXMgbW91c2U6dXA6YmVmb3JlXG4gICAqIEBmaXJlcyBtb3VzZTpvdmVyXG4gICAqIEBmaXJlcyBtb3VzZTpvdXRcbiAgICogQGZpcmVzIG1vdXNlOmRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICpcbiAgICovXG4gIGZhYnJpYy5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlVHJhbnNmb3JtOiAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgdW5wcm9wb3J0aW9uYWwgc2NhbGluZ1xuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmlTY2FsZUtleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHNjYWxlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHJvdGF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgY2VudGVyZWQgVHJhbnNmb3JtXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkS2V5OiAgICAgICAgICAgJ2FsdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGUgYWN0aW9uIG9uIGNvcm5lclxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRBY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgY2FudmFzIGlzIGludGVyYWN0aXZlLiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnRlcmFjdGl2ZTogICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgZ3JvdXAgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgb3Iga2V5cyBlbmFibGUgbXVsdGlwbGUgY2xpY2sgc2VsZWN0aW9uXG4gICAgICogUGFzcyB2YWx1ZSBhcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciBlbXB0eSBvciBjb250YWluaW5nIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ3xBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0aXZlIHNlbGVjdGlvblxuICAgICAqIGluIGNhc2Ugb2YgdGFyZ2V0IG92ZXJsYXBwaW5nIHdpdGggYWN0aXZlIG9iamVjdFxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBGb3IgYSBzZXJpZXMgb2YgcmVhc29uIHRoYXQgY29tZSBmcm9tIHRoZSBnZW5lcmFsIGV4cGVjdGF0aW9ucyBvbiBob3dcbiAgICAgKiB0aGluZ3Mgc2hvdWxkIHdvcmssIHRoaXMgZmVhdHVyZSB3b3JrcyBvbmx5IGZvciBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIHRydWUuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAdHlwZSBudWxsfFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0U2VsZWN0aW9uS2V5OiAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICAgICAgICAgJ3JnYmEoMTAwLCAxMDAsIDI1NSwgMC4zKScsIC8vIGJsdWVcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGFzaCBhcnJheSBwYXR0ZXJuXG4gICAgICogSWYgbm90IGVtcHR5IHRoZSBzZWxlY3Rpb24gYm9yZGVyIGlzIGRhc2hlZFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc2VsZWN0aW9uRGFzaEFycmF5OiAgICAgW10sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0aGUgYm9yZGVyIG9mIHNlbGVjdGlvbiAodXN1YWxseSBzbGlnaHRseSBkYXJrZXIgdGhhbiBjb2xvciBvZiBzZWxlY3Rpb24gaXRzZWxmKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICAgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIGxpbmUgdXNlZCBpbiBvYmplY3QvZ3JvdXAgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25MaW5lV2lkdGg6ICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgc2hhcGVzIHRoYXQgYXJlIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgZHJhZ2dlZCBzZWxlY3Rpb24gcmVjdGFuZ2xlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhvdmVyQ3Vyc29yOiAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBtb3ZpbmcgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCBmb3IgdGhlIGVudGlyZSBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICAgICAgICAgICdkZWZhdWx0JyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGR1cmluZyBmcmVlIGRyYXdpbmdcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZyZWVEcmF3aW5nQ3Vyc29yOiAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZm9yIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByb3RhdGlvbkN1cnNvcjogICAgICAgICAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGZvciBkaXNhYmxlZCBlbGVtZW50cyAoIGNvcm5lcnMgd2l0aCBkaXNhYmxlZCBhY3Rpb24gKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm90QWxsb3dlZEN1cnNvcjogICAgICAgICAnbm90LWFsbG93ZWQnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBlbGVtZW50IGNsYXNzIHRoYXQncyBnaXZlbiB0byB3cmFwcGVyIChkaXYpIGVsZW1lbnQgb2YgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogICAgICAgICAnY2FudmFzLWNvbnRhaW5lcicsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCBkZXRlY3Rpb24gaGFwcGVucyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gb24gcGVyLWJvdW5kaW5nLWJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhcm91bmQgdGFyZ2V0IHBpeGVsIHRvIHRvbGVyYXRlIChjb25zaWRlciBhY3RpdmUpIGR1cmluZyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0YXJnZXRGaW5kVG9sZXJhbmNlOiAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0YXJnZXQgZGV0ZWN0aW9uIGlzIHNraXBwZWQgd2hlbiBob3ZlcmluZyBvdmVyIGNhbnZhcy4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBUYXJnZXRGaW5kOiAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBtb3VzZSBldmVudHMgb24gY2FudmFzIChtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXApIHJlc3VsdCBpbiBmcmVlIGRyYXdpbmcuXG4gICAgICogQWZ0ZXIgbW91c2Vkb3duLCBtb3VzZW1vdmUgY3JlYXRlcyBhIHNoYXBlLFxuICAgICAqIGFuZCB0aGVuIG1vdXNldXAgZmluYWxpemVzIGl0IGFuZCBhZGRzIGFuIGluc3RhbmNlIG9mIGBmYWJyaWMuUGF0aGAgb250byBjYW52YXMuXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTQjZnJlZV9kcmF3aW5nfVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRHJhd2luZ01vZGU6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyBzaG91bGQgcmVtYWluIGluIGN1cnJlbnQgc3RhY2sgcG9zaXRpb24gd2hlbiBzZWxlY3RlZC5cbiAgICAgKiBXaGVuIGZhbHNlIG9iamVjdHMgYXJlIGJyb3VnaHQgdG8gdG9wIGFuZCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgYW5nbGUgdGhhdCBhbiBvYmplY3Qgd2lsbCBsb2NrIHRvIHdoaWxlIHJvdGF0aW5nLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzbmFwQW5nbGUgdGhlIHJvdGF0aW9uIHdpbGwgbG9jayB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIFdoZW4gYG51bGxgLCB0aGUgc25hcFRocmVzaG9sZCB3aWxsIGRlZmF1bHQgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBAdHlwZSBudWxsfE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcFRocmVzaG9sZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgcmlnaHQgY2xpY2sgb24gY2FudmFzIGNhbiBvdXRwdXQgdGhlIGNvbnRleHQgbWVudSBvciBub3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdG9wQ29udGV4dE1lbnU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgcmlnaHQgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZVJpZ2h0Q2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgbWlkZGxlIGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS43LjhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVNaWRkbGVDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0SW50ZXJhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2luaXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY3JlYXRlVXBwZXJDYW52YXMoKTtcbiAgICAgIHRoaXMuX2luaXRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuXG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggPSBmYWJyaWMuUGVuY2lsQnJ1c2ggJiYgbmV3IGZhYnJpYy5QZW5jaWxCcnVzaCh0aGlzKTtcblxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgb2JqZWN0cyBpbiB0d28gZ3JvdXBzLCBvbmUgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICogYW5kIG9uZSB0byByZW5kZXIgYXMgYWN0aXZlR3JvdXAuXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGFuZCBwdXNoZXMgdGhlIG90aGVyIGluIHRoZSBhY3RpdmVHcm91cC5cbiAgICAgKi9cbiAgICBfY2hvb3NlT2JqZWN0c1RvUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgb2JqZWN0LCBvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cztcblxuICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMCAmJiAhdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IFtdO1xuICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEgKSB7XG4gICAgICAgICAgICBvYmpzVG9SZW5kZXIucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuX29iamVjdHMgPSBhY3RpdmVHcm91cE9iamVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2guYXBwbHkob2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb1JlbmRlciA9IHRoaXMuX29iamVjdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Jqc1RvUmVuZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvdGggdGhlIHRvcCBjYW52YXMgYW5kIHRoZSBzZWNvbmRhcnkgY29udGFpbmVyIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRUb3BEaXJ0eSAmJiAhdGhpcy5fZ3JvdXBTZWxlY3RvciAmJiAhdGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dFRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMb3N0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlclRvcExheWVyKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlclRvcExheWVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3JlbmRlcigpO1xuICAgICAgfVxuICAgICAgLy8gd2UgcmVuZGVyIHRoZSB0b3AgY29udGV4dCAtIGxhc3Qgb2JqZWN0XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byByZW5kZXIgb25seSB0aGUgdG9wIGNhbnZhcy5cbiAgICAgKiBBbHNvIHVzZWQgdG8gcmVuZGVyIHRoZSBncm91cCBzZWxlY3Rpb24gYm94LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJyk7XG4gICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB0byBpdHMgb3JpZ2luYWwgdmFsdWVzIGFuZCBjaG9vc2VzIHRoZSB0eXBlIG9mIHJlc2l6aW5nIGJhc2VkIG9uIHRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Q3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHQudGFyZ2V0LnNldCh7XG4gICAgICAgIHNjYWxlWDogdC5vcmlnaW5hbC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdC5vcmlnaW5hbC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0Lm9yaWdpbmFsLnNrZXdYLFxuICAgICAgICBza2V3WTogdC5vcmlnaW5hbC5za2V3WSxcbiAgICAgICAgbGVmdDogdC5vcmlnaW5hbC5sZWZ0LFxuICAgICAgICB0b3A6IHQub3JpZ2luYWwudG9wXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENlbnRlclRyYW5zZm9ybSh0LnRhcmdldCkpIHtcbiAgICAgICAgaWYgKHQub3JpZ2luWCAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAodC5vcmlnaW5YID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodC5vcmlnaW5ZICE9PSAnY2VudGVyJykge1xuICAgICAgICAgIGlmICh0Lm9yaWdpblkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Lm1vdXNlWVNpZ24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgICB0Lm9yaWdpblkgPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0Lm9yaWdpblggPSB0Lm9yaWdpbmFsLm9yaWdpblg7XG4gICAgICAgIHQub3JpZ2luWSA9IHQub3JpZ2luYWwub3JpZ2luWTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gYXJlYSBvZiBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50XSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKGUsIHRhcmdldCwgcG9pbnQpIHtcbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnQgfHwgdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIHh5O1xuXG4gICAgICBpZiAodGFyZ2V0Lmdyb3VwICYmIHRhcmdldC5ncm91cCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRhcmdldC5ncm91cC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB4eSA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0Lmdyb3VwLCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB4eSA9IHsgeDogcG9pbnRlci54LCB5OiBwb2ludGVyLnkgfTtcbiAgICAgIH1cbiAgICAgIC8vIGh0dHA6Ly93d3cuZ2VvZy51YmMuY2EvY291cnNlcy9rbGluay9naXMubm90ZXMvbmNnaWEvdTMyLmh0bWxcbiAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICByZXR1cm4gKHRhcmdldC5jb250YWluc1BvaW50KHh5KSB8fCB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdFBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgdHJhbnNwYXJlbnQgYXQgYSBjZXJ0YWluIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGFyZ2V0VHJhbnNwYXJlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpIHtcbiAgICAgIGlmICh0YXJnZXQuc2hvdWxkQ2FjaGUoKSAmJiB0YXJnZXQuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUG9pbnRlciA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0LCB7eDogeCwgeTogeX0pLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVYID0gdGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25YICsgKG5vcm1hbGl6ZWRQb2ludGVyLnggKiB0YXJnZXQuem9vbVgpLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gdGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25ZICsgKG5vcm1hbGl6ZWRQb2ludGVyLnkgKiB0YXJnZXQuem9vbVkpO1xuXG4gICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgICB0YXJnZXQuX2NhY2hlQ29udGV4dCwgdGFyZ2V0UmVsYXRpdmVYLCB0YXJnZXRSZWxhdGl2ZVksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRDYWNoZSxcbiAgICAgICAgICBvcmlnaW5hbENvbG9yID0gdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciwgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSAnJztcblxuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0YXJnZXQucmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0YXJnZXQuX3JlbmRlckNvbnRyb2xzKGN0eCwge1xuICAgICAgICBoYXNCb3JkZXJzOiBmYWxzZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBoYXNCb3JkZXJzOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gb3JpZ2luYWxDb2xvcjtcblxuICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICBjdHgsIHgsIHksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhbiBldmVudCBhbmQgZGV0ZXJtaW5zIGlmIHNlbGVjdGlvbiBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25LZXlQcmVzc2VkOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuc2VsZWN0aW9uS2V5KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBzZWxlY3Rpb25LZXlQcmVzc2VkID0gISF0aGlzLnNlbGVjdGlvbktleS5maW5kKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gZVtrZXldID09PSB0cnVlOyB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb25LZXlQcmVzc2VkID0gZVt0aGlzLnNlbGVjdGlvbktleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3Rpb25LZXlQcmVzc2VkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAhdGFyZ2V0XG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3RzLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldCAmJlxuICAgICAgICAgICF0aGlzLl9pc1NlbGVjdGlvbktleVByZXNzZWQoZSkpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiYgIXRhcmdldC5ldmVudGVkKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgIXRhcmdldC5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjZW50ZXJlZFNjYWxpbmcgZnJvbSBvYmplY3QgY2FuJ3Qgb3ZlcnJpZGUgY2VudGVyZWRTY2FsaW5nIGZyb20gY2FudmFzLlxuICAgICAqIHRoaXMgc2hvdWxkIGJlIGZpeGVkLCBzaW5jZSBvYmplY3Qgc2V0dGluZyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgY2FudmFzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBjZW50ZXJUcmFuc2Zvcm07XG5cbiAgICAgIGlmICh0LmFjdGlvbiA9PT0gJ3NjYWxlJyB8fCB0LmFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgdC5hY3Rpb24gPT09ICdzY2FsZVknKSB7XG4gICAgICAgIGNlbnRlclRyYW5zZm9ybSA9IHRoaXMuY2VudGVyZWRTY2FsaW5nIHx8IHRhcmdldC5jZW50ZXJlZFNjYWxpbmc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0LmFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIXQuYWx0S2V5IDogdC5hbHRLZXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE9yaWdpbkZyb21Db3JuZXI6IGZ1bmN0aW9uKHRhcmdldCwgY29ybmVyKSB7XG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiB0YXJnZXQub3JpZ2luWCxcbiAgICAgICAgeTogdGFyZ2V0Lm9yaWdpbllcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICdtbCcgfHwgY29ybmVyID09PSAndGwnIHx8IGNvcm5lciA9PT0gJ2JsJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtcicgfHwgY29ybmVyID09PSAndHInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdtdCcgfHwgY29ybmVyID09PSAndHInKSB7XG4gICAgICAgIG9yaWdpbi55ID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdibCcgfHwgY29ybmVyID09PSAnbWInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICd0b3AnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lciwgZSkge1xuICAgICAgaWYgKCFjb3JuZXIpIHtcbiAgICAgICAgcmV0dXJuICdkcmFnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICAgICAgY2FzZSAnbXRyJzpcbiAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSc7XG4gICAgICAgIGNhc2UgJ21sJzpcbiAgICAgICAgY2FzZSAnbXInOlxuICAgICAgICAgIHJldHVybiBlW3RoaXMuYWx0QWN0aW9uS2V5XSA/ICdza2V3WScgOiAnc2NhbGVYJztcbiAgICAgICAgY2FzZSAnbXQnOlxuICAgICAgICBjYXNlICdtYic6XG4gICAgICAgICAgcmV0dXJuIGVbdGhpcy5hbHRBY3Rpb25LZXldID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnc2NhbGUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIsIGUpLFxuICAgICAgICAgIG9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkZyb21Db3JuZXIodGFyZ2V0LCBjb3JuZXIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0ge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgLy8gdXNlZCBieSB0cmFuc2F0aW9uXG4gICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICBvZmZzZXRZOiBwb2ludGVyLnkgLSB0YXJnZXQudG9wLFxuICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgIGV5OiBwb2ludGVyLnksXG4gICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgIGxhc3RZOiBwb2ludGVyLnksXG4gICAgICAgIC8vIHVuc3VyZSB0aGV5IGFyZSB1c2VmdWxsIGFueW1vcmUuXG4gICAgICAgIC8vIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICAvLyB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgIHRoZXRhOiBkZWdyZWVzVG9SYWRpYW5zKHRhcmdldC5hbmdsZSksXG4gICAgICAgIC8vIGVuZCBvZiB1bnN1cmVcbiAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgIG1vdXNlWFNpZ246IDEsXG4gICAgICAgIG1vdXNlWVNpZ246IDEsXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBhbHRLZXk6IGVbdGhpcy5jZW50ZXJlZEtleV1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ub3JpZ2luYWwgPSB7XG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICBvcmlnaW5YOiBvcmlnaW4ueCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luLnlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3Jlc2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5fYmVmb3JlVHJhbnNmb3JtKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG9iamVjdCBieSBcInNldHRpbmdcIiBpdHMgbGVmdC90b3BcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvaW50ZXIncyB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBwb2ludGVyJ3MgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfdHJhbnNsYXRlT2JqZWN0OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgICBtb3ZlWCA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRYJykgJiYgdGFyZ2V0LmxlZnQgIT09IG5ld0xlZnQsXG4gICAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcblxuICAgICAgbW92ZVggJiYgdGFyZ2V0LnNldCgnbGVmdCcsIG5ld0xlZnQpO1xuICAgICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgYXJlIGluY3JlYXNpbmcgYSBwb3NpdGl2ZSBza2V3IG9yIGxvd2VyIGl0LFxuICAgICAqIGNoZWNraW5nIG1vdXNlIGRpcmVjdGlvbiBhbmQgcHJlc3NlZCBjb3JuZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbjogZnVuY3Rpb24obW91c2VNb3ZlLCB0LCBieSkge1xuICAgICAgdmFyIHByb3BlcnR5ID0gJ29yaWdpblgnLCBvcmlnaW5zID0geyAwOiAnY2VudGVyJyB9LFxuICAgICAgICAgIHNrZXcgPSB0LnRhcmdldC5za2V3WCwgb3JpZ2luQSA9ICdsZWZ0Jywgb3JpZ2luQiA9ICdyaWdodCcsXG4gICAgICAgICAgY29ybmVyID0gdC5jb3JuZXIgPT09ICdtdCcgfHwgdC5jb3JuZXIgPT09ICdtbCcgPyAxIDogLTEsXG4gICAgICAgICAgZmxpcFNpZ24gPSAxO1xuXG4gICAgICBtb3VzZU1vdmUgPSBtb3VzZU1vdmUgPiAwID8gMSA6IC0xO1xuICAgICAgaWYgKGJ5ID09PSAneScpIHtcbiAgICAgICAgc2tldyA9IHQudGFyZ2V0LnNrZXdZO1xuICAgICAgICBvcmlnaW5BID0gJ3RvcCc7XG4gICAgICAgIG9yaWdpbkIgPSAnYm90dG9tJztcbiAgICAgICAgcHJvcGVydHkgPSAnb3JpZ2luWSc7XG4gICAgICB9XG4gICAgICBvcmlnaW5zWy0xXSA9IG9yaWdpbkE7XG4gICAgICBvcmlnaW5zWzFdID0gb3JpZ2luQjtcblxuICAgICAgdC50YXJnZXQuZmxpcFggJiYgKGZsaXBTaWduICo9IC0xKTtcbiAgICAgIHQudGFyZ2V0LmZsaXBZICYmIChmbGlwU2lnbiAqPSAtMSk7XG5cbiAgICAgIGlmIChza2V3ID09PSAwKSB7XG4gICAgICAgIHQuc2tld1NpZ24gPSAtY29ybmVyICogbW91c2VNb3ZlICogZmxpcFNpZ247XG4gICAgICAgIHRbcHJvcGVydHldID0gb3JpZ2luc1stbW91c2VNb3ZlXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBza2V3ID0gc2tldyA+IDAgPyAxIDogLTE7XG4gICAgICAgIHQuc2tld1NpZ24gPSBza2V3O1xuICAgICAgICB0W3Byb3BlcnR5XSA9IG9yaWdpbnNbc2tldyAqIGNvcm5lciAqIGZsaXBTaWduXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2tldyBvYmplY3QgYnkgbW91c2UgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5J1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNrZXdpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2tld09iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWCA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWCcpLFxuICAgICAgICAgIGxvY2tTa2V3aW5nWSA9IHRhcmdldC5nZXQoJ2xvY2tTa2V3aW5nWScpO1xuXG4gICAgICBpZiAoKGxvY2tTa2V3aW5nWCAmJiBieSA9PT0gJ3gnKSB8fCAobG9ja1NrZXdpbmdZICYmIGJ5ID09PSAneScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgYWN0dWFsTW91c2VCeUNlbnRlciA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgJ2NlbnRlcicsICdjZW50ZXInKVtieV0sXG4gICAgICAgICAgbGFzdE1vdXNlQnlDZW50ZXIgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQodC5sYXN0WCwgdC5sYXN0WSksICdjZW50ZXInLCAnY2VudGVyJylbYnldLFxuICAgICAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4sIGNvbnN0cmFpbnRQb3NpdGlvbiwgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy5fY2hhbmdlU2tld1RyYW5zZm9ybU9yaWdpbihhY3R1YWxNb3VzZUJ5Q2VudGVyIC0gbGFzdE1vdXNlQnlDZW50ZXIsIHQsIGJ5KTtcbiAgICAgIGFjdHVhbE1vdXNlQnlPcmlnaW4gPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKVtieV07XG4gICAgICBjb25zdHJhaW50UG9zaXRpb24gPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIC8vIEFjdHVhbGx5IHNrZXcgdGhlIG9iamVjdFxuICAgICAgc2tld2VkID0gdGhpcy5fc2V0T2JqZWN0U2tldyhhY3R1YWxNb3VzZUJ5T3JpZ2luLCB0LCBieSwgZGltKTtcbiAgICAgIHQubGFzdFggPSB4O1xuICAgICAgdC5sYXN0WSA9IHk7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBza2V3ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBvYmplY3Qgc2tld1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2tld2luZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTa2V3OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sIGJ5LCBfZGltKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgbmV3VmFsdWUsIHNrZXdlZCA9IGZhbHNlLFxuICAgICAgICAgIHNrZXdTaWduID0gdHJhbnNmb3JtLnNrZXdTaWduLCBuZXdEaW0sIGRpbU5vU2tldyxcbiAgICAgICAgICBvdGhlckJ5LCBfb3RoZXJCeSwgX2J5LCBuZXdEaW1Nb3VzZSwgc2tld1gsIHNrZXdZO1xuXG4gICAgICBpZiAoYnkgPT09ICd4Jykge1xuICAgICAgICBvdGhlckJ5ID0gJ3knO1xuICAgICAgICBfb3RoZXJCeSA9ICdZJztcbiAgICAgICAgX2J5ID0gJ1gnO1xuICAgICAgICBza2V3WCA9IDA7XG4gICAgICAgIHNrZXdZID0gdGFyZ2V0LnNrZXdZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG90aGVyQnkgPSAneCc7XG4gICAgICAgIF9vdGhlckJ5ID0gJ1gnO1xuICAgICAgICBfYnkgPSAnWSc7XG4gICAgICAgIHNrZXdYID0gdGFyZ2V0LnNrZXdYO1xuICAgICAgICBza2V3WSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHNrZXdYLCBza2V3WSk7XG4gICAgICBuZXdEaW1Nb3VzZSA9IDIgKiBNYXRoLmFicyhsb2NhbE1vdXNlKSAtIGRpbU5vU2tld1tieV07XG4gICAgICBpZiAobmV3RGltTW91c2UgPD0gMikge1xuICAgICAgICBuZXdWYWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBza2V3U2lnbiAqIE1hdGguYXRhbigobmV3RGltTW91c2UgLyB0YXJnZXRbJ3NjYWxlJyArIF9ieV0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGltTm9Ta2V3W290aGVyQnldIC8gdGFyZ2V0WydzY2FsZScgKyBfb3RoZXJCeV0pKTtcbiAgICAgICAgbmV3VmFsdWUgPSBmYWJyaWMudXRpbC5yYWRpYW5zVG9EZWdyZWVzKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNrZXdlZCA9IHRhcmdldFsnc2tldycgKyBfYnldICE9PSBuZXdWYWx1ZTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXcnICsgX2J5LCBuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0Wydza2V3JyArIF9vdGhlckJ5XSAhPT0gMCkge1xuICAgICAgICBuZXdEaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICBuZXdWYWx1ZSA9IChfZGltW290aGVyQnldIC8gbmV3RGltW290aGVyQnldKSAqIHRhcmdldFsnc2NhbGUnICsgX290aGVyQnldO1xuICAgICAgICB0YXJnZXQuc2V0KCdzY2FsZScgKyBfb3RoZXJCeSwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNrZXdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIG9iamVjdCBieSBpbnZva2luZyBpdHMgc2NhbGVYL3NjYWxlWSBtZXRob2RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBwb2ludGVyJ3MgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgcG9pbnRlcidzIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBieSBFaXRoZXIgJ3gnIG9yICd5JyAtIHNwZWNpZmllcyBkaW1lbnNpb24gY29uc3RyYWludCBieSB3aGljaCB0byBzY2FsZSBhbiBvYmplY3QuXG4gICAgICogICAgICAgICAgICAgICAgICAgIFdoZW4gbm90IHByb3ZpZGVkLCBhbiBvYmplY3QgaXMgc2NhbGVkIGJ5IGJvdGggZGltZW5zaW9ucyBlcXVhbGx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zY2FsZU9iamVjdDogZnVuY3Rpb24gKHgsIHksIGJ5KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsXG4gICAgICAgICAgbG9ja1NjYWxpbmdYID0gdGFyZ2V0LmxvY2tTY2FsaW5nWCxcbiAgICAgICAgICBsb2NrU2NhbGluZ1kgPSB0YXJnZXQubG9ja1NjYWxpbmdZLFxuICAgICAgICAgIGxvY2tTY2FsaW5nRmxpcCA9IHRhcmdldC5sb2NrU2NhbGluZ0ZsaXA7XG5cbiAgICAgIGlmIChsb2NrU2NhbGluZ1ggJiYgbG9ja1NjYWxpbmdZKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBjb25zdHJhaW50IHBvaW50XG4gICAgICB2YXIgY29uc3RyYWludFBvc2l0aW9uID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKSxcbiAgICAgICAgICBsb2NhbE1vdXNlID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSksXG4gICAgICAgICAgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSwgc2NhbGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NldExvY2FsTW91c2UobG9jYWxNb3VzZSwgdCk7XG5cbiAgICAgIC8vIEFjdHVhbGx5IHNjYWxlIHRoZSBvYmplY3RcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NldE9iamVjdFNjYWxlKGxvY2FsTW91c2UsIHQsIGxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZLCBieSwgbG9ja1NjYWxpbmdGbGlwLCBkaW0pO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnN0cmFpbnRzIGFwcGx5XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50UG9zaXRpb24sIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBzY2FsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2NhbGluZyBvY2N1cnJlZFxuICAgICAqL1xuICAgIF9zZXRPYmplY3RTY2FsZTogZnVuY3Rpb24obG9jYWxNb3VzZSwgdHJhbnNmb3JtLCBsb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSwgYnksIGxvY2tTY2FsaW5nRmxpcCwgX2RpbSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGZvcmJpZFNjYWxpbmdYID0gZmFsc2UsIGZvcmJpZFNjYWxpbmdZID0gZmFsc2UsIHNjYWxlZCA9IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZVgsIGNoYW5nZVksIHNjYWxlWCwgc2NhbGVZO1xuXG4gICAgICBzY2FsZVggPSBsb2NhbE1vdXNlLnggKiB0YXJnZXQuc2NhbGVYIC8gX2RpbS54O1xuICAgICAgc2NhbGVZID0gbG9jYWxNb3VzZS55ICogdGFyZ2V0LnNjYWxlWSAvIF9kaW0ueTtcbiAgICAgIGNoYW5nZVggPSB0YXJnZXQuc2NhbGVYICE9PSBzY2FsZVg7XG4gICAgICBjaGFuZ2VZID0gdGFyZ2V0LnNjYWxlWSAhPT0gc2NhbGVZO1xuXG4gICAgICBpZiAobG9ja1NjYWxpbmdGbGlwICYmIHNjYWxlWCA8PSAwICYmIHNjYWxlWCA8IHRhcmdldC5zY2FsZVgpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggPSB0cnVlO1xuICAgICAgICBsb2NhbE1vdXNlLnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9ja1NjYWxpbmdGbGlwICYmIHNjYWxlWSA8PSAwICYmIHNjYWxlWSA8IHRhcmdldC5zY2FsZVkpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1kgPSB0cnVlO1xuICAgICAgICBsb2NhbE1vdXNlLnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnkgPT09ICdlcXVhbGx5JyAmJiAhbG9ja1NjYWxpbmdYICYmICFsb2NrU2NhbGluZ1kpIHtcbiAgICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVPYmplY3RFcXVhbGx5KGxvY2FsTW91c2UsIHRhcmdldCwgdHJhbnNmb3JtLCBfZGltKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFieSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWCB8fCBsb2NrU2NhbGluZ1ggfHwgKHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VYKSk7XG4gICAgICAgIGZvcmJpZFNjYWxpbmdZIHx8IGxvY2tTY2FsaW5nWSB8fCAodGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKSAmJiAoc2NhbGVkID0gc2NhbGVkIHx8IGNoYW5nZVkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJ5ID09PSAneCcgJiYgIXRhcmdldC5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcbiAgICAgICAgZm9yYmlkU2NhbGluZ1ggfHwgbG9ja1NjYWxpbmdYIHx8ICh0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpICYmIChzY2FsZWQgPSBzY2FsZWQgfHwgY2hhbmdlWCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYnkgPT09ICd5JyAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKSkge1xuICAgICAgICBmb3JiaWRTY2FsaW5nWSB8fCBsb2NrU2NhbGluZ1kgfHwgKHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSkgJiYgKHNjYWxlZCA9IHNjYWxlZCB8fCBjaGFuZ2VZKSk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ubmV3U2NhbGVYID0gc2NhbGVYO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZvcmJpZFNjYWxpbmdYIHx8IGZvcmJpZFNjYWxpbmdZIHx8IHRoaXMuX2ZsaXBPYmplY3QodHJhbnNmb3JtLCBieSk7XG4gICAgICByZXR1cm4gc2NhbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfc2NhbGVPYmplY3RFcXVhbGx5OiBmdW5jdGlvbihsb2NhbE1vdXNlLCB0YXJnZXQsIHRyYW5zZm9ybSwgX2RpbSkge1xuXG4gICAgICB2YXIgZGlzdCA9IGxvY2FsTW91c2UueSArIGxvY2FsTW91c2UueCxcbiAgICAgICAgICBsYXN0RGlzdCA9IF9kaW0ueSAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVkgLyB0YXJnZXQuc2NhbGVZICtcbiAgICAgICAgICAgICAgICAgICAgIF9kaW0ueCAqIHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggLyB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlZCwgc2lnblggPSBsb2NhbE1vdXNlLnggPCAwID8gLTEgOiAxLFxuICAgICAgICAgIHNpZ25ZID0gbG9jYWxNb3VzZS55IDwgMCA/IC0xIDogMTtcblxuICAgICAgLy8gV2UgdXNlIHRyYW5zZm9ybS5zY2FsZVgvWSBpbnN0ZWFkIG9mIHRhcmdldC5zY2FsZVgvWVxuICAgICAgLy8gYmVjYXVzZSB0aGUgb2JqZWN0IG1heSBoYXZlIGEgbWluIHNjYWxlIGFuZCB3ZSdsbCBsb29zZSB0aGUgcHJvcG9ydGlvbnNcbiAgICAgIHRyYW5zZm9ybS5uZXdTY2FsZVggPSBzaWduWCAqIE1hdGguYWJzKHRyYW5zZm9ybS5vcmlnaW5hbC5zY2FsZVggKiBkaXN0IC8gbGFzdERpc3QpO1xuICAgICAgdHJhbnNmb3JtLm5ld1NjYWxlWSA9IHNpZ25ZICogTWF0aC5hYnModHJhbnNmb3JtLm9yaWdpbmFsLnNjYWxlWSAqIGRpc3QgLyBsYXN0RGlzdCk7XG4gICAgICBzY2FsZWQgPSB0cmFuc2Zvcm0ubmV3U2NhbGVYICE9PSB0YXJnZXQuc2NhbGVYIHx8IHRyYW5zZm9ybS5uZXdTY2FsZVkgIT09IHRhcmdldC5zY2FsZVk7XG4gICAgICB0YXJnZXQuc2V0KCdzY2FsZVgnLCB0cmFuc2Zvcm0ubmV3U2NhbGVYKTtcbiAgICAgIHRhcmdldC5zZXQoJ3NjYWxlWScsIHRyYW5zZm9ybS5uZXdTY2FsZVkpO1xuICAgICAgcmV0dXJuIHNjYWxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmxpcE9iamVjdDogZnVuY3Rpb24odHJhbnNmb3JtLCBieSkge1xuICAgICAgaWYgKHRyYW5zZm9ybS5uZXdTY2FsZVggPCAwICYmIGJ5ICE9PSAneScpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtLm5ld1NjYWxlWSA8IDAgJiYgYnkgIT09ICd4Jykge1xuICAgICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblkgPT09ICd0b3AnKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSAnYm90dG9tJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExvY2FsTW91c2U6IGZ1bmN0aW9uKGxvY2FsTW91c2UsIHQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0LnRhcmdldCwgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIHBhZGRpbmcgPSB0YXJnZXQucGFkZGluZyAvIHpvb207XG5cbiAgICAgIGlmICh0Lm9yaWdpblggPT09ICdyaWdodCcpIHtcbiAgICAgICAgbG9jYWxNb3VzZS54ICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodC5vcmlnaW5YID09PSAnY2VudGVyJykge1xuICAgICAgICBsb2NhbE1vdXNlLnggKj0gdC5tb3VzZVhTaWduICogMjtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueCA8IDApIHtcbiAgICAgICAgICB0Lm1vdXNlWFNpZ24gPSAtdC5tb3VzZVhTaWduO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0Lm9yaWdpblkgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxvY2FsTW91c2UueSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQub3JpZ2luWSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbG9jYWxNb3VzZS55ICo9IHQubW91c2VZU2lnbiAqIDI7XG4gICAgICAgIGlmIChsb2NhbE1vdXNlLnkgPCAwKSB7XG4gICAgICAgICAgdC5tb3VzZVlTaWduID0gLXQubW91c2VZU2lnbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhZGp1c3QgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIHdoZW4gZGVhbGluZyB3aXRoIHBhZGRpbmdcbiAgICAgIGlmIChhYnMobG9jYWxNb3VzZS54KSA+IHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKGxvY2FsTW91c2UueCA8IDApIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnggKz0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb2NhbE1vdXNlLnggLT0gcGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIG1vdXNlIGlzIHdpdGhpbiB0aGUgcGFkZGluZywgc2V0IHRvIDBcbiAgICAgICAgbG9jYWxNb3VzZS54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFicyhsb2NhbE1vdXNlLnkpID4gcGFkZGluZykge1xuICAgICAgICBpZiAobG9jYWxNb3VzZS55IDwgMCkge1xuICAgICAgICAgIGxvY2FsTW91c2UueSArPSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxvY2FsTW91c2UueSAtPSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9jYWxNb3VzZS55ID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBvYmplY3QgYnkgaW52b2tpbmcgaXRzIHJvdGF0ZSBtZXRob2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHBvaW50ZXIncyB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBwb2ludGVyJ3MgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgcm90YXRpb24gb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfcm90YXRlT2JqZWN0OiBmdW5jdGlvbiAoeCwgeSkge1xuXG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsIGNvbnN0cmFpbnRQb3NpdGlvbixcbiAgICAgICAgICBjb25zdHJhaW50UG9zaXRpb24gPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSwgdC5vcmlnaW5YLCB0Lm9yaWdpblkpO1xuXG4gICAgICBpZiAodGFyZ2V0LmxvY2tSb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0QW5nbGUgPSBhdGFuMih0LmV5IC0gY29uc3RyYWludFBvc2l0aW9uLnksIHQuZXggLSBjb25zdHJhaW50UG9zaXRpb24ueCksXG4gICAgICAgICAgY3VyQW5nbGUgPSBhdGFuMih5IC0gY29uc3RyYWludFBvc2l0aW9uLnksIHggLSBjb25zdHJhaW50UG9zaXRpb24ueCksXG4gICAgICAgICAgYW5nbGUgPSByYWRpYW5zVG9EZWdyZWVzKGN1ckFuZ2xlIC0gbGFzdEFuZ2xlICsgdC50aGV0YSksXG4gICAgICAgICAgaGFzUm90YXRlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0YXJnZXQuc25hcEFuZ2xlID4gMCkge1xuICAgICAgICB2YXIgc25hcEFuZ2xlICA9IHRhcmdldC5zbmFwQW5nbGUsXG4gICAgICAgICAgICBzbmFwVGhyZXNob2xkICA9IHRhcmdldC5zbmFwVGhyZXNob2xkIHx8IHNuYXBBbmdsZSxcbiAgICAgICAgICAgIHJpZ2h0QW5nbGVMb2NrZWQgPSBNYXRoLmNlaWwoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlLFxuICAgICAgICAgICAgbGVmdEFuZ2xlTG9ja2VkID0gTWF0aC5mbG9vcihhbmdsZSAvIHNuYXBBbmdsZSkgKiBzbmFwQW5nbGU7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGFuZ2xlIC0gbGVmdEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICBhbmdsZSA9IGxlZnRBbmdsZUxvY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhhbmdsZSAtIHJpZ2h0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICAgIGFuZ2xlID0gcmlnaHRBbmdsZUxvY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpemUgYW5nbGUgdG8gcG9zaXRpdmUgdmFsdWVcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSAzNjAgKyBhbmdsZTtcbiAgICAgIH1cbiAgICAgIGFuZ2xlICU9IDM2MDtcblxuICAgICAgaWYgKHRhcmdldC5hbmdsZSA9PT0gYW5nbGUpIHtcbiAgICAgICAgaGFzUm90YXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJvdGF0aW9uIG9ubHkgaGFwcGVuIGhlcmVcbiAgICAgICAgdGFyZ2V0LmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29uc3RyYWludHMgYXBwbHlcbiAgICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uQnlPcmlnaW4oY29uc3RyYWludFBvc2l0aW9uLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNSb3RhdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBDdXJzb3IgdHlwZSBvZiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXVpLyNjdXJzb3JcbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlLmN1cnNvciA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCB0byByZXNldCB0cmFuc2Zvcm1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldE9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnNjYWxlWCA9IDE7XG4gICAgICB0YXJnZXQuc2NhbGVZID0gMTtcbiAgICAgIHRhcmdldC5za2V3WCA9IDA7XG4gICAgICB0YXJnZXQuc2tld1kgPSAwO1xuICAgICAgdGFyZ2V0LnJvdGF0ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIGRyYXcgdGhlIHNlbGVjdGlvbiBvblxuICAgICAqL1xuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsXG4gICAgICAgICAgbGVmdCA9IGdyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB0b3AgPSBncm91cFNlbGVjdG9yLnRvcCxcbiAgICAgICAgICBhbGVmdCA9IGFicyhsZWZ0KSxcbiAgICAgICAgICBhdG9wID0gYWJzKHRvcCk7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuXG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV4IC0gKChsZWZ0ID4gMCkgPyAwIDogLWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgLSAoKHRvcCA+IDApID8gMCA6IC10b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCB8fCAhdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yO1xuXG4gICAgICAvLyBzZWxlY3Rpb24gYm9yZGVyXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkubGVuZ3RoID4gMSAmJiAhc3VwcG9ydExpbmVEYXNoKSB7XG5cbiAgICAgICAgdmFyIHB4ID0gZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgICBweSA9IGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4ICsgYWxlZnQsIHB5LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5ICsgYXRvcCAtIDEsIHB4ICsgYWxlZnQsIHB5ICsgYXRvcCAtIDEsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4LCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCArIGFsZWZ0IC0gMSwgcHksIHB4ICsgYWxlZnQgLSAxLCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5fc2V0TGluZURhc2guY2FsbCh0aGlzLCBjdHgsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leSArIFNUUk9LRV9PRkZTRVQgLSAoKHRvcCA+IDApID8gMCA6IGF0b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IG9iamVjdCB3ZSBhcmUgY2xpY2tpbmcgb25cbiAgICAgKiB0aGUgc2tpcEdyb3VwIHBhcmFtZXRlciBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBuZWVkZWQgZm9yIHNoaWZ0K2NsaWNrIGFjdGlvblxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBHcm91cCB3aGVuIHRydWUsIGFjdGl2ZUdyb3VwIGlzIHNraXBwZWQgYW5kIG9ubHkgb2JqZWN0cyBhcmUgdHJhdmVyc2VkIHRocm91Z2hcbiAgICAgKi9cbiAgICBmaW5kVGFyZ2V0OiBmdW5jdGlvbiAoZSwgc2tpcEdyb3VwKSB7XG4gICAgICBpZiAodGhpcy5za2lwVGFyZ2V0RmluZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBhT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZVRhcmdldCwgYWN0aXZlVGFyZ2V0U3VicztcblxuICAgICAgLy8gZmlyc3QgY2hlY2sgY3VycmVudCBncm91cCAoaWYgb25lIGV4aXN0cylcbiAgICAgIC8vIGFjdGl2ZSBncm91cCBkb2VzIG5vdCBjaGVjayBzdWIgdGFyZ2V0cyBsaWtlIG5vcm1hbCBncm91cHMuXG4gICAgICAvLyBpZiBhY3RpdmUgZ3JvdXAganVzdCBleGl0cy5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwICYmIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPT09IDEgJiYgYWN0aXZlT2JqZWN0Ll9maW5kVGFyZ2V0Q29ybmVyKHBvaW50ZXIpKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0ID0gYWN0aXZlT2JqZWN0O1xuICAgICAgICAgIGFjdGl2ZVRhcmdldFN1YnMgPSB0aGlzLnRhcmdldHM7XG4gICAgICAgICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICBpZiAoZVt0aGlzLmFsdFNlbGVjdGlvbktleV0gJiYgdGFyZ2V0ICYmIGFjdGl2ZVRhcmdldCAmJiB0YXJnZXQgIT09IGFjdGl2ZVRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSBhY3RpdmVUYXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IGFjdGl2ZVRhcmdldFN1YnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1RhcmdldDogZnVuY3Rpb24ocG9pbnRlciwgb2JqKSB7XG4gICAgICBpZiAob2JqICYmXG4gICAgICAgICAgb2JqLnZpc2libGUgJiZcbiAgICAgICAgICBvYmouZXZlbnRlZCAmJlxuICAgICAgICAgIHRoaXMuY29udGFpbnNQb2ludChudWxsLCBvYmosIHBvaW50ZXIpKXtcbiAgICAgICAgaWYgKCh0aGlzLnBlclBpeGVsVGFyZ2V0RmluZCB8fCBvYmoucGVyUGl4ZWxUYXJnZXRGaW5kKSAmJiAhb2JqLmlzRWRpdGluZykge1xuICAgICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gdGhpcy5pc1RhcmdldFRyYW5zcGFyZW50KG9iaiwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIGlmICghaXNUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuXG4gICAgICAvLyBDYWNoZSBhbGwgdGFyZ2V0cyB3aGVyZSB0aGVpciBib3VuZGluZyBib3ggY29udGFpbnMgcG9pbnQuXG4gICAgICB2YXIgdGFyZ2V0LCBpID0gb2JqZWN0cy5sZW5ndGgsIG5vcm1hbGl6ZWRQb2ludGVyLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWwgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0byBzZWFyY2ggaW5zaWRlIHRoZSBhY3RpdmVHcm91cFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tUYXJnZXQocG9pbnRlciwgb2JqZWN0c1tpXSkpIHtcbiAgICAgICAgICB0YXJnZXQgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2sgJiYgdGFyZ2V0IGluc3RhbmNlb2YgZmFicmljLkdyb3VwKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUG9pbnRlciA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0LCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0YXJnZXQuX29iamVjdHMsIG5vcm1hbGl6ZWRQb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBDYW4gcmV0dXJuIGNvb3JkaW5hdGVzIHdpdGggb3Igd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBpZ25vcmVab29tIGZhbHNlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgdGhhdCByZXByZXNlbnRcbiAgICAgKiB0aGUgcG9pbnQgY2xpY2tlZCBvbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyBhZnRlciBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBieSB0aGUgdmlld3BvcnRUcmFuc2Zvcm0gKCBzb3J0IG9mIGNvb3JkaW5hdGVzIG9mIHdoYXQgaXMgZGlzcGxheWVkXG4gICAgICogb24gdGhlIGNhbnZhcyB3aGVyZSB5b3UgYXJlIGNsaWNraW5nLlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSA9IEhUTUxFbGVtZW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRvcCxsZWZ0XG4gICAgICogaWdub3JlWm9vbSBmYWxzZSwgZGVmYXVsdCA9IGZhYnJpYyBzcGFjZSBjb29yZGluYXRlcywgdGhlIHNhbWUgdXNlZCBmb3Igc2hhcGUgcG9zaXRpb25cbiAgICAgKiBUbyBpbnRlcmFjdCB3aXRoIHlvdXIgc2hhcGVzIHRvcCBhbmQgbGVmdCB5b3Ugd2FudCB0byB1c2UgaWdub3JlWm9vbSB0cnVlXG4gICAgICogbW9zdCBvZiB0aGUgdGltZSwgd2hpbGUgaWdub3JlWm9vbSBmYWxzZSB3aWxsIGdpdmUgeW91IGNvb3JkaW5hdGVzXG4gICAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBvYmplY3Qub0Nvb3JkcyBzeXN0ZW0uXG4gICAgICogb2YgdGhlIHRpbWUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSkge1xuICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZXMgaWYgd2UgYXJlIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG4gICAgICBpZiAodGhpcy5fYWJzb2x1dGVQb2ludGVyICYmICFpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9pbnRlciAmJiBpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKTtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgdXBwZXJDYW52YXMgZWxlbWVudCBpZiB3ZSBoYXZlIGFscmVhZHkgb25lLlxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuY2xhc3NOYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy51cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcblxuICAgICAgdGhpcy5fY29weUNhbnZhc1N0eWxlKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IHRoaXMudXBwZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gdGhpcy5jYWNoZUNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cmFwcGVyRWwgPSBmYWJyaWMudXRpbC53cmFwRWxlbWVudCh0aGlzLmxvd2VyQ2FudmFzRWwsICdkaXYnLCB7XG4gICAgICAgICdjbGFzcyc6IHRoaXMuY29udGFpbmVyQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUodGhpcy53cmFwcGVyRWwsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUodGhpcy53cmFwcGVyRWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgY2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgc3R5bGVzIG9uXG4gICAgICovXG4gICAgX2FwcGx5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICAndG91Y2gtYWN0aW9uJzogdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nID8gJ21hbmlwdWxhdGlvbicgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSB0aGUgZW50aXJlIGlubGluZSBzdHlsZSBmcm9tIG9uZSBlbGVtZW50IChmcm9tRWwpIHRvIGFub3RoZXIgKHRvRWwpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21FbCBFbGVtZW50IHN0eWxlIGlzIGNvcGllZCBmcm9tXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0b0VsIEVsZW1lbnQgY29waWVkIHN0eWxlIGlzIGFwcGxpZWQgdG9cbiAgICAgKi9cbiAgICBfY29weUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZnJvbUVsLCB0b0VsKSB7XG4gICAgICB0b0VsLnN0eWxlLmNzc1RleHQgPSBmcm9tRWwuc3R5bGUuY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IG9uIHdoaWNoIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25FbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cHBlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZS50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyAmJiBhY3RpdmUuX29iamVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbYWN0aXZlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyByZW1vdmluZyBhY3RpdmUgb2JqZWN0IHNob3VsZCBmaXJlIFwic2VsZWN0aW9uOmNsZWFyZWRcIiBldmVudHNcbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIG9iai5maXJlKCdkZXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faG92ZXJlZFRhcmdldCA9PT0gb2JqKSB7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19vbk9iamVjdFJlbW92ZWQnLCBvYmopO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENvbXBhcmVzIHRoZSBvbGQgYWN0aXZlT2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgb25lIGFuZCBmaXJlcyBjb3JyZWN0IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIG9sZCBhY3RpdmVPYmplY3RcbiAgICAgKi9cbiAgICBfZmlyZVNlbGVjdGlvbkV2ZW50czogZnVuY3Rpb24ob2xkT2JqZWN0cywgZSkge1xuICAgICAgdmFyIHNvbWV0aGluZ0NoYW5nZWQgPSBmYWxzZSwgb2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFkZGVkID0gW10sIHJlbW92ZWQgPSBbXSwgb3B0ID0geyBlOiBlIH07XG4gICAgICBvbGRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2xkT2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RzLmluZGV4T2Yob2xkT2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvbGRPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcsIG9wdCk7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKG9sZE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2xkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgb2JqZWN0LmZpcmUoJ3NlbGVjdGVkJywgb3B0KTtcbiAgICAgICAgICBhZGRlZC5wdXNoKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG9sZE9iamVjdHMubGVuZ3RoID4gMCAmJiBvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0LnNlbGVjdGVkID0gYWRkZWQ7XG4gICAgICAgIG9wdC5kZXNlbGVjdGVkID0gcmVtb3ZlZDtcbiAgICAgICAgLy8gYWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgb3B0LnVwZGF0ZWQgPSBhZGRlZFswXSB8fCByZW1vdmVkWzBdO1xuICAgICAgICBvcHQudGFyZ2V0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICBzb21ldGhpbmdDaGFuZ2VkICYmIHRoaXMuZmlyZSgnc2VsZWN0aW9uOnVwZGF0ZWQnLCBvcHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGRlcHJlY2F0ZWQgZXZlbnRcbiAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgb3B0LnRhcmdldCA9IGFkZGVkWzBdO1xuICAgICAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnNlbGVjdGVkJywgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICBvcHQuc2VsZWN0ZWQgPSBhZGRlZDtcbiAgICAgICAgLy8gYWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgb3B0LnRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIG9wdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0LmRlc2VsZWN0ZWQgPSByZW1vdmVkO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgb3B0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBnaXZlbiBvYmplY3QgYXMgdGhlIG9ubHkgYWN0aXZlIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2V0IGFzIGFuIGFjdGl2ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKTtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChvYmplY3QsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNldCBhcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNlbGVjdGlvbiBoYXBwZW5lZFxuICAgICAqL1xuICAgIF9zZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgZSkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlLCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG9iamVjdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbihlLCBvYmplY3QpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIC8vIG9uRGVzZWxlY3QgcmV0dXJuIFRSVUUgdG8gY2FuY2VsIHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9iai5vbkRlc2VsZWN0KHsgZTogZSwgb2JqZWN0OiBvYmplY3QgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkcyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdCBhbmQgZmlyZSBldmVudHMuIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgZmFicmljXG4gICAgICogYXMgYSBjb25zZXF1ZW5jZSBvZiBhIG1vdXNlIGV2ZW50LCB0aGUgZXZlbnQgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGFuZFxuICAgICAqIHNlbnQgdG8gdGhlIGZpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXN0b20gZXZlbnRzLiBXaGVuIHVzZWQgYXMgYSBtZXRob2QgdGhlXG4gICAgICogZSBwYXJhbSBkb2VzIG5vdCBoYXZlIGFueSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCk7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IGN1cnJlbnRBY3RpdmVzWzBdLCBlOiBlIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdGhpcy53cmFwcGVyRWw7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLnVwcGVyQ2FudmFzRWwpO1xuICAgICAgd3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgdGhpcy51cHBlckNhbnZhc0VsID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbCA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy53cmFwcGVyRWwpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMud3JhcHBlckVsO1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzLmRpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdjbGVhcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBvYmplY3RzJyBjb250cm9scyAoYm9yZGVycy9jb250cm9scylcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIGNvbnRyb2xzIG9uXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0Ll9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgdGhpcy5fYWN0aXZlT2JqZWN0ID09PSBpbnN0YW5jZS5ncm91cCkge1xuICAgICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2xlZnQnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdza2V3WCcsICdza2V3WScsICd0b3AnXTtcbiAgICAgICAgLy9Db3B5IGFsbCB0aGUgcG9zaXRpb25hbGx5IHJlbGV2YW50IHByb3BlcnRpZXMgYWNyb3NzIG5vd1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZXMgPSB7fTtcbiAgICAgICAgbGF5b3V0UHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZXNbcHJvcF0gPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5yZWFsaXplVHJhbnNmb3JtKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgY2hhbmdlZCBwcm9wZXJ0aWVzIG9mIGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFtpbnN0YW5jZV0gdGhlIG9iamVjdCB0byB1bi10cmFuc2Zvcm0gKGdldHMgbXV0YXRlZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29yaWdpbmFsVmFsdWVzXSB0aGUgb3JpZ2luYWwgdmFsdWVzIG9mIGluc3RhbmNlLCBhcyByZXR1cm5lZCBieSBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3RcbiAgICAgKi9cbiAgICBfdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICBpZiAob3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0KG9yaWdpbmFsVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldFNWR09iamVjdCcsIG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSwgb3JpZ2luYWxQcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNldFZpZXdwb3J0VHJhbnNmb3JtLmNhbGwodGhpcywgdnB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuX3NldEN1cnNvckZyb21FdmVudCA9IGZ1bmN0aW9uKCkgeyB9O1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY3Vyc29yT2Zmc2V0ID0ge1xuICAgICAgICBtdDogMCwgLy8gblxuICAgICAgICB0cjogMSwgLy8gbmVcbiAgICAgICAgbXI6IDIsIC8vIGVcbiAgICAgICAgYnI6IDMsIC8vIHNlXG4gICAgICAgIG1iOiA0LCAvLyBzXG4gICAgICAgIGJsOiA1LCAvLyBzd1xuICAgICAgICBtbDogNiwgLy8gd1xuICAgICAgICB0bDogNyAvLyBud1xuICAgICAgfSxcbiAgICAgIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyLFxuICAgICAgUklHSFRfQ0xJQ0sgPSAzLCBNSURETEVfQ0xJQ0sgPSAyLCBMRUZUX0NMSUNLID0gMSxcbiAgICAgIGFkZEV2ZW50T3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuICd3aGljaCcgaW4gZSA/IGUud2hpY2ggPT09IHZhbHVlIDogZS5idXR0b24gPT09IHZhbHVlIC0gMTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIGN1cnNvciBzdHlsZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIG9iamVjdCBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3Vyc29yTWFwOiBbXG4gICAgICAnbi1yZXNpemUnLFxuICAgICAgJ25lLXJlc2l6ZScsXG4gICAgICAnZS1yZXNpemUnLFxuICAgICAgJ3NlLXJlc2l6ZScsXG4gICAgICAncy1yZXNpemUnLFxuICAgICAgJ3N3LXJlc2l6ZScsXG4gICAgICAndy1yZXNpemUnLFxuICAgICAgJ253LXJlc2l6ZSdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbiBjYXNlIHdlIGluaXRpYWxpemVkIHRoZSBjbGFzcyB0d2ljZS4gVGhpcyBzaG91bGQgbm90IGhhcHBlbiBub3JtYWxseVxuICAgICAgLy8gYnV0IGluIHNvbWUga2luZCBvZiBhcHBsaWNhdGlvbnMgd2hlcmUgdGhlIGNhbnZhcyBlbGVtZW50IG1heSBiZSBjaGFuZ2VkXG4gICAgICAvLyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB0byBoYXZpbmcgZG91YmxlIGxpc3RlbmVycy5cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKGFkZExpc3RlbmVyLCAnYWRkJyk7XG4gICAgfSxcblxuICAgIGFkZE9yUmVtb3ZlOiBmdW5jdGlvbihmdW5jdG9yLCBldmVudGpzRnVuY3Rvcikge1xuICAgICAgZnVuY3RvcihmYWJyaWMud2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdtb3VzZWVudGVyJywgdGhpcy5fb25Nb3VzZUVudGVyKTtcbiAgICAgIGZ1bmN0b3IodGhpcy51cHBlckNhbnZhc0VsLCAnd2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2spO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Nb3VzZURvd24sIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkcmFnb3ZlcicsIHRoaXMuX29uRHJhZ092ZXIpO1xuICAgICAgZnVuY3Rvcih0aGlzLnVwcGVyQ2FudmFzRWwsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWdsZWF2ZScsIHRoaXMuX29uRHJhZ0xlYXZlKTtcbiAgICAgIGZ1bmN0b3IodGhpcy51cHBlckNhbnZhc0VsLCAnZHJvcCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0odGhpcy51cHBlckNhbnZhc0VsLCAnZ2VzdHVyZScsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKHRoaXMudXBwZXJDYW52YXNFbCwgJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdzaGFrZScsIHRoaXMuX29uU2hha2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXSh0aGlzLnVwcGVyQ2FudmFzRWwsICdsb25ncHJlc3MnLCB0aGlzLl9vbkxvbmdQcmVzcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKHJlbW92ZUxpc3RlbmVyLCAncmVtb3ZlJyk7XG4gICAgICAvLyBpZiB5b3UgZGlzcG9zZSBvbiBhIG1vdXNlRG93biwgYmVmb3JlIG1vdXNlIHVwLCB5b3UgbmVlZCB0byBjbGVhbiBkb2N1bWVudCB0by4uLlxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uTW91c2VVcCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzQm91bmQpIHtcbiAgICAgICAgLy8gZm9yIGFueSByZWFzb24gd2UgcGFzcyBoZXJlIHR3aWNlIHdlIGRvIG5vdCB3YW50IHRvIGJpbmQgZXZlbnRzIHR3aWNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR2VzdHVyZSA9IHRoaXMuX29uR2VzdHVyZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblNoYWtlID0gdGhpcy5fb25TaGFrZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Mb25nUHJlc3MgPSB0aGlzLl9vbkxvbmdQcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VXaGVlbCA9IHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU91dCA9IHRoaXMuX29uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Db250ZXh0TWVudSA9IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRG91YmxlQ2xpY2sgPSB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWdPdmVyID0gdGhpcy5fb25EcmFnT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnRW50ZXIgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2VudGVyJyk7XG4gICAgICB0aGlzLl9vbkRyYWdMZWF2ZSA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcmFnbGVhdmUnKTtcbiAgICAgIHRoaXMuX29uRHJvcCA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcm9wJyk7XG4gICAgICB0aGlzLmV2ZW50c0JvdW5kID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgICAgaWYgKHRoaXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2VlbnRlclxuICAgICAqL1xuICAgIF9vbk1vdXNlRW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5maW5kVGFyZ2V0KGUpKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiBudWxsLCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UgJiYgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25TaGFrZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uU2hha2UgJiYgdGhpcy5fX29uU2hha2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25Mb25nUHJlc3M6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkxvbmdQcmVzcyAmJiB0aGlzLl9fb25Mb25nUHJlc3MoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wIGV2ZW50IHRvIGJlIGZpcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICovXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLl9maXJlRW50ZXJMZWF2ZUV2ZW50cyh0YXJnZXQsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuc3RvcENvbnRleHRNZW51KSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2RibGNsaWNrJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXAsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcih0aGlzLnVwcGVyQ2FudmFzRWwsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIFVuYmluZCBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnMgZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXAsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIGFkZExpc3RlbmVyKHRoaXMudXBwZXJDYW52YXNFbCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIodGhpcy51cHBlckNhbnZhc0VsLCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCAnbW91c2Vkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBfc2hvdWxkUmVuZGVyOiBmdW5jdGlvbih0YXJnZXQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LmlzRWRpdGluZyAmJiB0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiB3ZSBtb3VzZSB1cC9kb3duIG92ZXIgYSBlZGl0aW5nIHRleHRib3ggYSBjdXJzb3IgY2hhbmdlLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIHJlIHJlbmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gISEoXG4gICAgICAgICh0YXJnZXQgJiYgKFxuICAgICAgICAgIHRhcmdldC5pc01vdmluZyB8fFxuICAgICAgICAgIHRhcmdldCAhPT0gYWN0aXZlT2JqZWN0KSlcbiAgICAgICAgfHxcbiAgICAgICAgKCF0YXJnZXQgJiYgISFhY3RpdmVPYmplY3QpXG4gICAgICAgIHx8XG4gICAgICAgICghdGFyZ2V0ICYmICFhY3RpdmVPYmplY3QgJiYgIXRoaXMuX2dyb3VwU2VsZWN0b3IpXG4gICAgICAgIHx8XG4gICAgICAgIChwb2ludGVyICYmXG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyICYmXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24gJiYgKFxuICAgICAgICAgICAgcG9pbnRlci54ICE9PSB0aGlzLl9wcmV2aW91c1BvaW50ZXIueCB8fFxuICAgICAgICAgIHBvaW50ZXIueSAhPT0gdGhpcy5fcHJldmlvdXNQb2ludGVyLnkpKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzLCBzdG9yZSB0aGUgaW1hZ2UgY29ybmVyXG4gICAgICogcG9zaXRpb24gaW4gdGhlIGltYWdlIG9iamVjdCBhbmQgcmVuZGVyIHRoZSBjYW52YXMgb24gdG9wLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldCwgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcixcbiAgICAgICAgICBpc0NsaWNrID0gKCFncm91cFNlbGVjdG9yIHx8IChncm91cFNlbGVjdG9yLmxlZnQgPT09IDAgJiYgZ3JvdXBTZWxlY3Rvci50b3AgPT09IDApKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwOmJlZm9yZScpO1xuICAgICAgLy8gaWYgcmlnaHQvbWlkZGxlIGNsaWNrIGp1c3QgZmlyZSBldmVudHMgYW5kIHJldHVyblxuICAgICAgLy8gdGFyZ2V0IHVuZGVmaW5lZCB3aWxsIG1ha2UgdGhlIF9oYW5kbGVFdmVudCBzZWFyY2ggdGhlIHRhcmdldFxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgUklHSFRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBNSURETEVfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZVVwSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybShlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHRoaXMuX2Fic29sdXRlUG9pbnRlcik7XG5cbiAgICAgIGlmICh0YXJnZXQgfHwgIWlzQ2xpY2spIHtcbiAgICAgICAgdGhpcy5fbWF5YmVHcm91cE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBMRUZUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgKHRhcmdldC5fX2Nvcm5lciA9IDApO1xuICAgICAgc2hvdWxkUmVuZGVyICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcmV0dXJuIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgcmV0dXJuIHRoZSB0aGUgdGFyZ2V0IGZvdW5kLCBmb3IgaW50ZXJuYWwgcmVhc29ucy5cbiAgICAgKi9cbiAgICBfc2ltcGxlRXZlbnRIYW5kbGVyOiBmdW5jdGlvbihldmVudFR5cGUsIGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSksXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICB9O1xuICAgICAgdGhpcy5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGlmICghdGFyZ2V0cykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRPYmogcmVjZWl2aW5nIGV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtidXR0b25dIGJ1dHRvbiB1c2VkIGluIHRoZSBldmVudCAxID0gbGVmdCwgMiA9IG1pZGRsZSwgMyA9IHJpZ2h0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBvbmx5LCBpbmRpY2F0ZXMgdGhhdCB0aGUgbW91c2UgdXAgaGFwcGVuZWQgd2l0aG91dCBtb3ZlLlxuICAgICAqL1xuICAgIF9oYW5kbGVFdmVudDogZnVuY3Rpb24oZSwgZXZlbnRUeXBlLCBidXR0b24sIGlzQ2xpY2spIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyB8fCBbXSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICAgIGJ1dHRvbjogYnV0dG9uIHx8IExFRlRfQ0xJQ0ssXG4gICAgICAgICAgICBpc0NsaWNrOiBpc0NsaWNrIHx8IGZhbHNlLFxuICAgICAgICAgICAgcG9pbnRlcjogdGhpcy5fcG9pbnRlcixcbiAgICAgICAgICAgIGFic29sdXRlUG9pbnRlcjogdGhpcy5fYWJzb2x1dGVQb2ludGVyLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtXG4gICAgICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6JyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgc2VuZCB0aGUgbW91c2UgZXZlbnQgdGhhdCBnZW5lcmF0ZSB0aGUgZmluYWxpemUgZG93biwgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlIGV2ZW50XG4gICAgICovXG4gICAgX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldC5fc2NhbGluZykge1xuICAgICAgICB0YXJnZXQuX3NjYWxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldENvb3JkcygpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCAodGhpcy5zdGF0ZWZ1bCAmJiB0YXJnZXQuaGFzU3RhdGVDaGFuZ2VkKCkpKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgICAgZXZlbnROYW1lID0gdGhpcy5fYWRkRXZlbnRPcHRpb25zKG9wdGlvbnMsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgdGhpcy5fZmlyZShldmVudE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpcmUoJ21vZGlmaWVkJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11dGF0ZSBvcHRpb24gb2JqZWN0IGluIG9yZGVyIHRvIGFkZCBieSBwcm9wZXJ0eSBhbmQgZ2l2ZSBiYWNrIHRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gbXV0YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB0byBpbnNwZWN0IGFjdGlvbiBmcm9tXG4gICAgICovXG4gICAgX2FkZEV2ZW50T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucywgdHJhbnNmb3JtKSB7XG4gICAgICAvLyB3ZSBjYW4gcHJvYmFibHkgYWRkIG1vcmUgZGV0YWlscyBhdCBsb3cgY29zdFxuICAgICAgLy8gc2NhbGUgY2hhbmdlLCByb3RhdGlvbiBjaGFuZ2VzLCB0cmFuc2xhdGlvbiBjaGFuZ2VzXG4gICAgICB2YXIgZXZlbnROYW1lLCBieTtcbiAgICAgIHN3aXRjaCAodHJhbnNmb3JtLmFjdGlvbikge1xuICAgICAgICBjYXNlICdzY2FsZVgnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ3gnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY2FsZVknOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ3knO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NrZXdlZCc7XG4gICAgICAgICAgYnkgPSAneCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2tld2VkJztcbiAgICAgICAgICBieSA9ICd5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ2VxdWFsbHknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdyb3RhdGVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZHJhZyc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ21vdmVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuYnkgPSBieTtcbiAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGlwVG8pIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xpcENvbnRleHQodGhpcywgdGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VEb3duKHBvaW50ZXIpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZU1vdmUocG9pbnRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmZyZWVEcmF3aW5nQ3Vyc29yKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmNsaXBUbykge1xuICAgICAgICB0aGlzLmNvbnRleHRUb3AucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VVcCgpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBjbGlja2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIGluaXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMgYW5kIHJlbmRlcnMgYWxsIHRoZVxuICAgICAqIGNhbnZhcyBzbyB0aGUgY3VycmVudCBpbWFnZSBjYW4gYmUgcGxhY2VkIG9uIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgcmVzdFxuICAgICAqIGluIG9uIHRoZSBjb250YWluZXIgb25lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX19vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd246YmVmb3JlJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgLy8gaWYgcmlnaHQgY2xpY2sganVzdCBmaXJlIGV2ZW50c1xuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBSSUdIVF9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgTUlERExFX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlnbm9yZSBpZiBzb21lIG9iamVjdCBpcyBiZWluZyB0cmFuc2Zvcm1lZCBhdCB0aGlzIG1vbWVudFxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuX3BvaW50ZXI7XG4gICAgICAvLyBzYXZlIHBvaW50ZXIgZm9yIGNoZWNrIGluIF9fb25Nb3VzZVVwIGV2ZW50XG4gICAgICB0aGlzLl9wcmV2aW91c1BvaW50ZXIgPSBwb2ludGVyO1xuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQsIHBvaW50ZXIpLFxuICAgICAgICAgIHNob3VsZEdyb3VwID0gdGhpcy5fc2hvdWxkR3JvdXAoZSwgdGFyZ2V0KTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhclNlbGVjdGlvbihlLCB0YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNob3VsZEdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUdyb3VwaW5nKGUsIHRhcmdldCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmICghdGFyZ2V0IHx8XG4gICAgICAgICghdGFyZ2V0LnNlbGVjdGFibGUgJiYgIXRhcmdldC5pc0VkaXRpbmcgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpKSkge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0ge1xuICAgICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRhcmdldCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmICh0YXJnZXQuX19jb3JuZXIgfHwgIXNob3VsZEdyb3VwKSkge1xuICAgICAgICAgIHRoaXMuX3NldHVwQ3VycmVudFRyYW5zZm9ybShlLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgICAgLy8gd2UgbXVzdCByZW5kZXJBbGwgc28gdGhhdCB3ZSB1cGRhdGUgdGhlIHZpc3VhbHNcbiAgICAgIHNob3VsZFJlbmRlciAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgY2FjaGUgZm9ybSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gZXZlbnRcbiAgICAgKi9cbiAgICBfY2FjaGVUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHJlc2V0IGluIG9yZGVyIHRvIGF2b2lkIHN0YWxlIGNhY2hpbmdcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB0aGlzLl9wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdCh0aGlzLl9wb2ludGVyKTtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPyB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCA6IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iZWZvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgdC50YXJnZXQuc2F2ZVN0YXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTp0cmFuc2Zvcm0nLCB7XG4gICAgICAgIGU6IGUsXG4gICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgIH0pO1xuICAgICAgLy8gZGV0ZXJtaW5lIGlmIGl0J3MgYSBkcmFnIG9yIHJvdGF0ZSBjYXNlXG4gICAgICBpZiAodC5jb3JuZXIpIHtcbiAgICAgICAgdGhpcy5vbkJlZm9yZVNjYWxlUm90YXRlKHQudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGhvdmVyaW5nIHRoZSBjYW52YXMuXG4gICAgICogVGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVyIHdpbGwgZGVmaW5kZSB3aGV0aGVyIHRoZSB1c2VyIGlzIHJvdGF0aW5nL3NjYWxpbmcvdHJhbnNsYXRpbmdcbiAgICAgKiBhbiBpbWFnZSBvciBuZWl0aGVyIG9mIHRoZW0gKG9ubHkgaG92ZXJpbmcpLiBBIGdyb3VwIHNlbGVjdGlvbiBpcyBhbHNvIHBvc3NpYmxlIGFuZCB3b3VsZCBjYW5jZWxcbiAgICAgKiBhbGwgYW55IG90aGVyIHR5cGUgb2YgYWN0aW9uLlxuICAgICAqIEluIGNhc2Ugb2YgYW4gaW1hZ2UgdHJhbnNmb3JtYXRpb24gb25seSB0aGUgdG9wIGNhbnZhcyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX19vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlOmJlZm9yZScpO1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB2YXIgdGFyZ2V0LCBwb2ludGVyO1xuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlLnRvdWNoZXMgIT09ICd1bmRlZmluZWQnICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yO1xuXG4gICAgICAvLyBXZSBpbml0aWFsbHkgY2xpY2tlZCBpbiBhbiBlbXB0eSBhcmVhLCBzbyB3ZSBkcmF3IGEgYm94IGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgIGlmIChncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLl9wb2ludGVyO1xuXG4gICAgICAgIGdyb3VwU2VsZWN0b3IubGVmdCA9IHBvaW50ZXIueCAtIGdyb3VwU2VsZWN0b3IuZXg7XG4gICAgICAgIGdyb3VwU2VsZWN0b3IudG9wID0gcG9pbnRlci55IC0gZ3JvdXBTZWxlY3Rvci5leTtcblxuICAgICAgICB0aGlzLnJlbmRlclRvcCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX3NldEN1cnNvckZyb21FdmVudChlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLl9maXJlT3Zlck91dEV2ZW50cyh0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9iamVjdChlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIG1vdXNlb3V0LCBtb3VzZW92ZXIgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdCBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVPdmVyT3V0RXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHRoaXMuZmlyZVN5bnRldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIHRhcmdldE5hbWU6ICdfaG92ZXJlZFRhcmdldCcsXG4gICAgICAgIGNhbnZhc0V2dE91dDogJ21vdXNlOm91dCcsXG4gICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgY2FudmFzRXZ0SW46ICdtb3VzZTpvdmVyJyxcbiAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgZHJhZ0VudGVyLCBkcmFnTGVhdmUgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBvbkRyYWcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBvbmRyYWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlRW50ZXJMZWF2ZUV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB0aGlzLmZpcmVTeW50ZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICB0YXJnZXROYW1lOiAnX2RyYWdnZWRvdmVyVGFyZ2V0JyxcbiAgICAgICAgZXZ0T3V0OiAnZHJhZ2xlYXZlJyxcbiAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgc3ludGV0aWMgaW4vb3V0IGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgc3VwcG9ydGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gdG8gd29ya1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGFyZ2V0TmFtZSBwcm9wZXJ0eSBvbiB0aGUgY2FudmFzIHdoZXJlIHRoZSBvbGQgdGFyZ2V0IGlzIHN0b3JlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dE91dF0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBhdCBjYW52YXMgbGV2ZWwgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0T3V0IG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dEluXSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3IgaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2dEluIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIGluXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlU3ludGV0aWNJbk91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlLCBjb25maWcpIHtcbiAgICAgIHZhciBpbk9wdCwgb3V0T3B0LCBvbGRUYXJnZXQgPSB0aGlzW2NvbmZpZy50YXJnZXROYW1lXSwgb3V0RmlyZXMsIGluRmlyZXMsXG4gICAgICAgICAgdGFyZ2V0Q2hhbmdlZCA9IG9sZFRhcmdldCAhPT0gdGFyZ2V0LCBjYW52YXNFdnRJbiA9IGNvbmZpZy5jYW52YXNFdnRJbiwgY2FudmFzRXZ0T3V0ID0gY29uZmlnLmNhbnZhc0V2dE91dDtcbiAgICAgIGlmICh0YXJnZXRDaGFuZ2VkKSB7XG4gICAgICAgIGluT3B0ID0geyBlOiBlLCB0YXJnZXQ6IHRhcmdldCwgcHJldmlvdXNUYXJnZXQ6IG9sZFRhcmdldCB9O1xuICAgICAgICBvdXRPcHQgPSB7IGU6IGUsIHRhcmdldDogb2xkVGFyZ2V0LCBuZXh0VGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgICAgdGhpc1tjb25maWcudGFyZ2V0TmFtZV0gPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBpbkZpcmVzID0gdGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBvdXRGaXJlcyA9IG9sZFRhcmdldCAmJiB0YXJnZXRDaGFuZ2VkO1xuICAgICAgaWYgKG91dEZpcmVzKSB7XG4gICAgICAgIGNhbnZhc0V2dE91dCAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0T3V0LCBvdXRPcHQpO1xuICAgICAgICBvbGRUYXJnZXQuZmlyZShjb25maWcuZXZ0T3V0LCBvdXRPcHQpO1xuICAgICAgfVxuICAgICAgaWYgKGluRmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0SW4gJiYgdGhpcy5maXJlKGNhbnZhc0V2dEluLCBpbk9wdCk7XG4gICAgICAgIHRhcmdldC5maXJlKGNvbmZpZy5ldnRJbiwgaW5PcHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIGFjdGlvbnMgd2hlbiBhbiBFdmVudCBNb3VzZSBXaGVlbFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfX29uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnd2hlZWwnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfdHJhbnNmb3JtT2JqZWN0OiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICB0cmFuc2Zvcm0ucmVzZXQgPSBmYWxzZTtcbiAgICAgIHRyYW5zZm9ybS50YXJnZXQuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgdHJhbnNmb3JtLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgICAgIHRyYW5zZm9ybS5hbHRLZXkgPSBlW3RoaXMuY2VudGVyZWRLZXldO1xuXG4gICAgICB0aGlzLl9iZWZvcmVTY2FsZVRyYW5zZm9ybShlLCB0cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5fcGVyZm9ybVRyYW5zZm9ybUFjdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpO1xuXG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRlci54LFxuICAgICAgICAgIHkgPSBwb2ludGVyLnksXG4gICAgICAgICAgYWN0aW9uID0gdHJhbnNmb3JtLmFjdGlvbixcbiAgICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBmYWxzZSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICAgIH07XG5cbiAgICAgIGlmIChhY3Rpb24gPT09ICdyb3RhdGUnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9yb3RhdGVPYmplY3QoeCwgeSkpICYmIHRoaXMuX2ZpcmUoJ3JvdGF0aW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzY2FsZScpIHtcbiAgICAgICAgKGFjdGlvblBlcmZvcm1lZCA9IHRoaXMuX29uU2NhbGUoZSwgdHJhbnNmb3JtLCB4LCB5KSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2NhbGVYJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSwgJ3gnKSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2NhbGVZJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fc2NhbGVPYmplY3QoeCwgeSwgJ3knKSkgJiYgdGhpcy5fZmlyZSgnc2NhbGluZycsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2tld1gnKSB7XG4gICAgICAgIChhY3Rpb25QZXJmb3JtZWQgPSB0aGlzLl9za2V3T2JqZWN0KHgsIHksICd4JykpICYmIHRoaXMuX2ZpcmUoJ3NrZXdpbmcnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3NrZXdZJykge1xuICAgICAgICAoYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fc2tld09iamVjdCh4LCB5LCAneScpKSAmJiB0aGlzLl9maXJlKCdza2V3aW5nJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gdGhpcy5fdHJhbnNsYXRlT2JqZWN0KHgsIHkpO1xuICAgICAgICBpZiAoYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZSgnbW92aW5nJywgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5zZXRDdXJzb3Iob3B0aW9ucy50YXJnZXQubW92ZUN1cnNvciB8fCB0aGlzLm1vdmVDdXJzb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6JyArIGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnRhcmdldC5maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JlZm9yZVNjYWxlVHJhbnNmb3JtOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uID09PSAnc2NhbGUnIHx8IHRyYW5zZm9ybS5hY3Rpb24gPT09ICdzY2FsZVgnIHx8IHRyYW5zZm9ybS5hY3Rpb24gPT09ICdzY2FsZVknKSB7XG4gICAgICAgIHZhciBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLl9zaG91bGRDZW50ZXJUcmFuc2Zvcm0odHJhbnNmb3JtLnRhcmdldCk7XG5cbiAgICAgICAgLy8gU3dpdGNoIGZyb20gYSBub3JtYWwgcmVzaXplIHRvIGNlbnRlci1iYXNlZFxuICAgICAgICBpZiAoKGNlbnRlclRyYW5zZm9ybSAmJiAodHJhbnNmb3JtLm9yaWdpblggIT09ICdjZW50ZXInIHx8IHRyYW5zZm9ybS5vcmlnaW5ZICE9PSAnY2VudGVyJykpIHx8XG4gICAgICAgICAgIC8vIFN3aXRjaCBmcm9tIGNlbnRlci1iYXNlZCByZXNpemUgdG8gbm9ybWFsIG9uZVxuICAgICAgICAgICAoIWNlbnRlclRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gJ2NlbnRlcicgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09ICdjZW50ZXInKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICB0cmFuc2Zvcm0ucmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGN1cnJlbnQgdHJhbmZvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBtb3VzZSBwb3NpdGlvbiB4IGZyb20gb3JpZ2luXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgbW91c2UgcG9pc3Rpb24geSBmcm9tIG9yaWdpblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNjYWxpbmcgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBfb25TY2FsZTogZnVuY3Rpb24oZSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICBpZiAodGhpcy5faXNVbmlzY2FsZVBvc3NpYmxlKGUsIHRyYW5zZm9ybS50YXJnZXQpKSB7XG4gICAgICAgIHRyYW5zZm9ybS5jdXJyZW50QWN0aW9uID0gJ3NjYWxlJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlT2JqZWN0KHgsIHkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFN3aXRjaCBmcm9tIGEgbm9ybWFsIHJlc2l6ZSB0byBwcm9wb3J0aW9uYWxcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0ucmVzZXQgJiYgdHJhbnNmb3JtLmN1cnJlbnRBY3Rpb24gPT09ICdzY2FsZScpIHtcbiAgICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybS5jdXJyZW50QWN0aW9uID0gJ3NjYWxlRXF1YWxseSc7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZU9iamVjdCh4LCB5LCAnZXF1YWxseScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgY3VycmVudCB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHVucHJvcG9ydGlvbmFsIHNjYWxpbmcgaXMgcG9zc2libGVcbiAgICAgKi9cbiAgICBfaXNVbmlzY2FsZVBvc3NpYmxlOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiAoZVt0aGlzLnVuaVNjYWxlS2V5XSB8fCB0aGlzLnVuaVNjYWxlVHJhbnNmb3JtKSAmJiAhdGFyZ2V0LmdldCgnbG9ja1VuaVNjYWxpbmcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3Vyc29yIGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgY2FudmFzIGlzIGJlaW5nIGhvdmVyZWQuXG4gICAgICogTm90ZTogdmVyeSBidWdneSBpbiBPcGVyYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgdGhhdCB0aGUgbW91c2UgaXMgaG92ZXJpbmcsIGlmIHNvLlxuICAgICAqL1xuICAgIF9zZXRDdXJzb3JGcm9tRXZlbnQ6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvdmVyQ3Vyc29yID0gdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgICAgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2FjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyA/XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgOiBudWxsLFxuICAgICAgICAgIC8vIG9ubHkgc2hvdyBwcm9wZXIgY29ybmVyIHdoZW4gZ3JvdXAgc2VsZWN0aW9uIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICBjb3JuZXIgPSAoIWFjdGl2ZVNlbGVjdGlvbiB8fCAhYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICYmIHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuXG4gICAgICBpZiAoIWNvcm5lcikge1xuICAgICAgICB0aGlzLnNldEN1cnNvcihob3ZlckN1cnNvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5nZXRDb3JuZXJDdXJzb3IoY29ybmVyLCB0YXJnZXQsIGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICBpZiAodGhpcy5hY3Rpb25Jc0Rpc2FibGVkKGNvcm5lciwgdGFyZ2V0LCBlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RBbGxvd2VkQ3Vyc29yO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyIGluIGN1cnNvck9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Um90YXRlZENvcm5lckN1cnNvcihjb3JuZXIsIHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtdHInICYmIHRhcmdldC5oYXNSb3RhdGluZ1BvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uQ3Vyc29yO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDdXJzb3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFjdGlvbklzRGlzYWJsZWQ6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICBpZiAoY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ21iJykge1xuICAgICAgICByZXR1cm4gZVt0aGlzLmFsdEFjdGlvbktleV0gPyB0YXJnZXQubG9ja1NrZXdpbmdYIDogdGFyZ2V0LmxvY2tTY2FsaW5nWTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvcm5lciA9PT0gJ21sJyB8fCBjb3JuZXIgPT09ICdtcicpIHtcbiAgICAgICAgcmV0dXJuIGVbdGhpcy5hbHRBY3Rpb25LZXldID8gdGFyZ2V0LmxvY2tTa2V3aW5nWSA6IHRhcmdldC5sb2NrU2NhbGluZ1g7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtdHInKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQubG9ja1JvdGF0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VuaXNjYWxlUG9zc2libGUoZSwgdGFyZ2V0KSA/XG4gICAgICAgICAgdGFyZ2V0LmxvY2tTY2FsaW5nWCAmJiB0YXJnZXQubG9ja1NjYWxpbmdZIDogdGFyZ2V0LmxvY2tTY2FsaW5nWCB8fCB0YXJnZXQubG9ja1NjYWxpbmdZO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yOiBmdW5jdGlvbihjb3JuZXIsIHRhcmdldCwgZSkge1xuICAgICAgdmFyIG4gPSBNYXRoLnJvdW5kKCh0YXJnZXQuYW5nbGUgJSAzNjApIC8gNDUpO1xuXG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgbiArPSA4OyAvLyBmdWxsIGNpcmNsZSBhaGVhZFxuICAgICAgfVxuICAgICAgbiArPSBjdXJzb3JPZmZzZXRbY29ybmVyXTtcbiAgICAgIGlmIChlW3RoaXMuYWx0QWN0aW9uS2V5XSAmJiBjdXJzb3JPZmZzZXRbY29ybmVyXSAlIDIgPT09IDApIHtcbiAgICAgICAgLy9pZiB3ZSBhcmUgaG9sZGluZyBzaGlmdCBhbmQgd2UgYXJlIG9uIGEgbXggY29ybmVyLi4uXG4gICAgICAgIG4gKz0gMjtcbiAgICAgIH1cbiAgICAgIC8vIG5vcm1hbGl6ZSBuIHRvIGJlIGZyb20gMCB0byA3XG4gICAgICBuICU9IDg7XG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnNvck1hcFtuXTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIG1pbiA9IE1hdGgubWluLFxuICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIF9zaG91bGRHcm91cDogZnVuY3Rpb24oZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICByZXR1cm4gYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCB8fCBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfaGFuZGxlR3JvdXBpbmc6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0Ll9fY29ybmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZ3JvdXAsIGZpbmQgdGFyZ2V0IGFnYWluLCB1c2luZyBhY3RpdmVHcm91cCBvYmplY3RzXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlLCB0cnVlKTtcbiAgICAgICAgLy8gaWYgZXZlbiBvYmplY3QgaXMgbm90IGZvdW5kIG9yIHdlIGFyZSBvbiBhY3RpdmVPYmplY3RDb3JuZXIsIGJhaWwgb3V0XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVBY3RpdmVTZWxlY3Rpb24odGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgY3VycmVudEFjdGl2ZU9iamVjdHMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLnJlbW92ZVdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAvLyBhY3RpdmF0ZSBsYXN0IHJlbWFpbmluZyBvYmplY3RcbiAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoYWN0aXZlU2VsZWN0aW9uLml0ZW0oMCksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLmFkZFdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZU9iamVjdHMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGdyb3VwID0gdGhpcy5fY3JlYXRlR3JvdXAodGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBncm91cDtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChncm91cCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX2NyZWF0ZUdyb3VwOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCksXG4gICAgICAgICAgaXNBY3RpdmVMb3dlciA9IG9iamVjdHMuaW5kZXhPZih0aGlzLl9hY3RpdmVPYmplY3QpIDwgb2JqZWN0cy5pbmRleE9mKHRhcmdldCksXG4gICAgICAgICAgZ3JvdXBPYmplY3RzID0gaXNBY3RpdmVMb3dlclxuICAgICAgICAgICAgPyBbdGhpcy5fYWN0aXZlT2JqZWN0LCB0YXJnZXRdXG4gICAgICAgICAgICA6IFt0YXJnZXQsIHRoaXMuX2FjdGl2ZU9iamVjdF07XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nICYmIHRoaXMuX2FjdGl2ZU9iamVjdC5leGl0RWRpdGluZygpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwT2JqZWN0cywge1xuICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBfZ3JvdXBTZWxlY3RlZE9iamVjdHM6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2NvbGxlY3RPYmplY3RzKCksXG4gICAgICAgICAgYUdyb3VwO1xuXG4gICAgICAvLyBkbyBub3QgY3JlYXRlIGdyb3VwIGZvciAxIGVsZW1lbnQgb25seVxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChncm91cFswXSwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFHcm91cCA9IG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwLnJldmVyc2UoKSwge1xuICAgICAgICAgIGNhbnZhczogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoYUdyb3VwLCBlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29sbGVjdE9iamVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwID0gW10sXG4gICAgICAgICAgY3VycmVudE9iamVjdCxcbiAgICAgICAgICB4MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXgsXG4gICAgICAgICAgeTEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV5LFxuICAgICAgICAgIHgyID0geDEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IudG9wLFxuICAgICAgICAgIHNlbGVjdGlvblgxWTEgPSBuZXcgZmFicmljLlBvaW50KG1pbih4MSwgeDIpLCBtaW4oeTEsIHkyKSksXG4gICAgICAgICAgc2VsZWN0aW9uWDJZMiA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KHgxLCB4MiksIG1heCh5MSwgeTIpKSxcbiAgICAgICAgICBhbGxvd0ludGVyc2VjdCA9ICF0aGlzLnNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkLFxuICAgICAgICAgIGlzQ2xpY2sgPSB4MSA9PT0geDIgJiYgeTEgPT09IHkyO1xuICAgICAgLy8gd2UgaXRlcmF0ZSByZXZlcnNlIG9yZGVyIHRvIGNvbGxlY3QgdG9wIGZpcnN0IGluIGNhc2Ugb2YgY2xpY2suXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuXG4gICAgICAgIGlmICghY3VycmVudE9iamVjdCB8fCAhY3VycmVudE9iamVjdC5zZWxlY3RhYmxlIHx8ICFjdXJyZW50T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5pbnRlcnNlY3RzV2l0aFJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMikpIHx8XG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0LmlzQ29udGFpbmVkV2l0aGluUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMVkxKSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDJZMikpXG4gICAgICAgICkge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudE9iamVjdCk7XG5cbiAgICAgICAgICAvLyBvbmx5IGFkZCBvbmUgb2JqZWN0IGlmIGl0J3MgYSBjbGlja1xuICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXliZUdyb3VwT2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RlZE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHN1cHBvcnRRdWFsaXR5ID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygndG9EYXRhVVJMV2l0aFF1YWxpdHknKTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2FudmFzIGVsZW1lbnQgdG8gYSBkYXRhdXJsIGltYWdlLiBOb3RlIHRoYXQgd2hlbiBtdWx0aXBsaWVyIGlzIHVzZWQsIGNyb3BwaW5nIGlzIHNjYWxlZCBhcHByb3ByaWF0ZWx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9cG5nXSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuIEVpdGhlciBcImpwZWdcIiBvciBcInBuZ1wiXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9MV0gUXVhbGl0eSBsZXZlbCAoMC4uMSkuIE9ubHkgdXNlZCBmb3IganBlZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5LCB0byBoYXZlIGNvbnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL05mWlZiL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGpwZWcgZGF0YVVSTCB3aXRoIGxvd2VyIHF1YWxpdHk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAqICAgcXVhbGl0eTogMC44XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgY3JvcHBlZCBwbmcgZGF0YVVSTCAoY2xpcHBpbmcgb2YgY2FudmFzKTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwLFxuICAgICAqICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgZG91YmxlIHNjYWxlZCBwbmcgZGF0YVVSTDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIG11bHRpcGxpZXI6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8ICdwbmcnLFxuICAgICAgICAgIHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgfHwgMSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gKG9wdGlvbnMubXVsdGlwbGllciB8fCAxKSAqIChvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmcgPyAxIDogMSAvIHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpKSxcbiAgICAgICAgICBjcm9wcGluZyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG9wdGlvbnMubGVmdCB8fCAwLFxuICAgICAgICAgICAgdG9wOiBvcHRpb25zLnRvcCB8fCAwLFxuICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX190b0RhdGFVUkxXaXRoTXVsdGlwbGllcihmb3JtYXQsIHF1YWxpdHksIGNyb3BwaW5nLCBtdWx0aXBsaWVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyOiBmdW5jdGlvbihmb3JtYXQsIHF1YWxpdHksIGNyb3BwaW5nLCBtdWx0aXBsaWVyKSB7XG5cbiAgICAgIHZhciBvcmlnV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIG9yaWdIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBzY2FsZWRXaWR0aCA9IChjcm9wcGluZy53aWR0aCB8fCB0aGlzLndpZHRoKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgc2NhbGVkSGVpZ2h0ID0gKGNyb3BwaW5nLmhlaWdodCB8fCB0aGlzLmhlaWdodCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBuZXdab29tID0gem9vbSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdnAgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zbGF0ZVggPSAodnBbNF0gLSBjcm9wcGluZy5sZWZ0KSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9ICh2cFs1XSAtIGNyb3BwaW5nLnRvcCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIG5ld1ZwID0gW25ld1pvb20sIDAsIDAsIG5ld1pvb20sIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldLFxuICAgICAgICAgIG9yaWdpbmFsSW50ZXJhY3RpdmUgPSB0aGlzLmludGVyYWN0aXZlLFxuICAgICAgICAgIG9yaWdpbmFsU2tpcE9mZlNjcmVlbiA9IHRoaXMuc2tpcE9mZnNjcmVlbixcbiAgICAgICAgICBuZWVkc1Jlc2l6ZSA9IG9yaWdXaWR0aCAhPT0gc2NhbGVkV2lkdGggfHwgb3JpZ0hlaWdodCAhPT0gc2NhbGVkSGVpZ2h0O1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gbmV3VnA7XG4gICAgICB0aGlzLnNraXBPZmZzY3JlZW4gPSBmYWxzZTtcbiAgICAgIC8vIHNldHRpbmcgaW50ZXJhY3RpdmUgdG8gZmFsc2UgYXZvaWQgZXhwb3J0aW5nIGNvbnRyb2xzXG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICBpZiAobmVlZHNSZXNpemUpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHsgd2lkdGg6IHNjYWxlZFdpZHRoLCBoZWlnaHQ6IHNjYWxlZEhlaWdodCB9LCB7IGJhY2tzdG9yZU9ubHk6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICAvLyBjYWxsIGEgcmVuZGVyQWxsIHRvIGZvcmNlIHN5bmMgdXBkYXRlLiBUaGlzIHdpbGwgY2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVxdWVzdFJlbmRlckFsbFxuICAgICAgLy8gZnJvbSBzZXREaW1lbnNpb25zXG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fdG9EYXRhVVJMKGZvcm1hdCwgcXVhbGl0eSwgY3JvcHBpbmcpO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9yaWdpbmFsSW50ZXJhY3RpdmU7XG4gICAgICB0aGlzLnNraXBPZmZzY3JlZW4gPSBvcmlnaW5hbFNraXBPZmZTY3JlZW47XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnA7XG4gICAgICAvL3NldERpbWVuc2lvbnMgd2l0aCBubyBvcHRpb24gb2JqZWN0IGlzIHRha2luZyBjYXJlIG9mOlxuICAgICAgLy90aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKClcbiAgICAgIGlmIChuZWVkc1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogb3JpZ1dpZHRoLCBoZWlnaHQ6IG9yaWdIZWlnaHQgfSwgeyBiYWNrc3RvcmVPbmx5OiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fdG9EYXRhVVJMOiBmdW5jdGlvbihmb3JtYXQsIHF1YWxpdHkpIHtcblxuICAgICAgdmFyIGNhbnZhc0VsID0gdGhpcy5jb250ZXh0Q29udGFpbmVyLmNhbnZhcztcbiAgICAgIC8vIHRvIGF2b2lkIGNvbW1vbiBjb25mdXNpb24gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvaXNzdWVzLzgwNlxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2pwZycpIHtcbiAgICAgICAgZm9ybWF0ID0gJ2pwZWcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHN1cHBvcnRRdWFsaXR5XG4gICAgICAgID8gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0LCBxdWFsaXR5KVxuICAgICAgICA6IGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvJyArIGZvcm1hdCk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgY2FudmFzIHdpdGggZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgZGF0YWxlc3MgSlNPTi5cbiAgICogSlNPTiBmb3JtYXQgbXVzdCBjb25mb3JtIHRvIHRoZSBvbmUgb2Yge0BsaW5rIGZhYnJpYy5DYW52YXMjdG9EYXRhbGVzc0pTT059XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDEuMi4yXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBKU09OIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2ssIGludm9rZWQgd2hlbiBqc29uIGlzIHBhcnNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29ycmVzcG9uZGluZyBvYmplY3RzIChlLmc6IHtAbGluayBmYWJyaWMuSW1hZ2V9KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgaW5pdGlhbGl6ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIEpTT04gZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICogQGNoYWluYWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNkZXNlcmlhbGl6YXRpb259XG4gICAqL1xuICBsb2FkRnJvbURhdGFsZXNzSlNPTjogZnVuY3Rpb24gKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZEZyb21KU09OKGpzb24sIGNhbGxiYWNrLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvSlNPTn1cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9mbWdYdC98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OIHdpdGggcmV2aXZlcjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwgZnVuY3Rpb24obywgb2JqZWN0KSB7XG4gICAqICAgLy8gYG9gID0ganNvbiBvYmplY3RcbiAgICogICAvLyBgb2JqZWN0YCA9IGZhYnJpYy5PYmplY3QgaW5zdGFuY2VcbiAgICogICAvLyAuLi4gZG8gc29tZSBzdHVmZiAuLi5cbiAgICogfSk7XG4gICAqL1xuICBsb2FkRnJvbUpTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlcmlhbGl6ZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIHZhciBzZXJpYWxpemVkID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoanNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbmxpdmVuZWRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqLCBpbmRleCkge1xuICAgICAgICAgIC8vIHdlIHNwbGljZSB0aGUgYXJyYXkganVzdCBpbiBjYXNlIHNvbWUgY3VzdG9tIGNsYXNzZXMgcmVzdG9yZWQgZnJvbSBKU09OXG4gICAgICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgICAgIF90aGlzLmluc2VydEF0KG9iaiwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMucmVuZGVyT25BZGRSZW1vdmUgPSByZW5kZXJPbkFkZFJlbW92ZTtcbiAgICAgICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLm9iamVjdHM7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZTtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZC5vdmVybGF5O1xuICAgICAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgICAgIC8vIGNhbGwgaXQuIE5vcm1hbGx5IGxvYWRpbmcgYW4gT2JqZWN0IGZyb20gSlNPTlxuICAgICAgICAvLyBjcmVhdGUgdGhlIE9iamVjdCBpbnN0YW5jZS4gSGVyZSB0aGUgQ2FudmFzIGlzXG4gICAgICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICAgICAgX3RoaXMuX3NldE9wdGlvbnMoc2VyaWFsaXplZCk7XG4gICAgICAgIF90aGlzLnJlbmRlckFsbCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSwgcmV2aXZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfc2V0QmdPdmVybGF5OiBmdW5jdGlvbihzZXJpYWxpemVkLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWQgPSB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhbHNlLFxuICAgICAgb3ZlcmxheUNvbG9yOiBmYWxzZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZTogZmFsc2UsXG4gICAgICBvdmVybGF5SW1hZ2U6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheUltYWdlICYmICFzZXJpYWxpemVkLmJhY2tncm91bmQgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2JJZkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkZWQuYmFja2dyb3VuZEltYWdlICYmIGxvYWRlZC5vdmVybGF5SW1hZ2UgJiYgbG9hZGVkLmJhY2tncm91bmRDb2xvciAmJiBsb2FkZWQub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRJbWFnZScsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlJbWFnZScsIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRDb2xvcicsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZCwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5Q29sb3InLCBzZXJpYWxpemVkLm92ZXJsYXksIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKGJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlLCBiYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvcilcbiAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZyl9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9hZGVkIFNldCBsb2FkZWQgcHJvcGVydHkgdG8gdHJ1ZSBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBwcm9wZXJ0eSBpcyBzZXRcbiAgICovXG4gIF9fc2V0QmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIGxvYWRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbdmFsdWVdLCBmdW5jdGlvbihlbmxpdmVkT2JqZWN0KXtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gZW5saXZlZE9iamVjdFswXTtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIW9iamVjdHMgfHwgb2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgZWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgY2xvbmUgPSBuZXcgZmFicmljLkNhbnZhcyhlbCk7XG4gICAgY2xvbmUuY2xpcFRvID0gdGhpcy5jbGlwVG87XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICBjbG9uZS5zZXRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2Uuc3JjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xvbmUucmVuZGVyQWxsKCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlT3BhY2l0eSA9IHRoaXMuYmFja2dyb3VuZEltYWdlT3BhY2l0eTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZVN0cmV0Y2ggPSB0aGlzLmJhY2tncm91bmRJbWFnZVN0cmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIGNhcGl0YWxpemUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG4gICAgICBvYmplY3RDYWNoaW5nID0gIWZhYnJpYy5pc0xpa2VseU5vZGUsXG4gICAgICBBTElBU0lOR19MSU1JVCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5PYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUm9vdCBvYmplY3QgY2xhc3MgZnJvbSB3aGljaCBhbGwgMmQgc2hhcGUgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAgICogQGNsYXNzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjb2JqZWN0c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgYWRkZWRcbiAgICogQGZpcmVzIHJlbW92ZWRcbiAgICpcbiAgICogQGZpcmVzIHNlbGVjdGVkXG4gICAqIEBmaXJlcyBkZXNlbGVjdGVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vdmVkXG4gICAqIEBmaXJlcyBzY2FsZWRcbiAgICogQGZpcmVzIHJvdGF0ZWRcbiAgICogQGZpcmVzIHNrZXdlZFxuICAgKlxuICAgKiBAZmlyZXMgcm90YXRpbmdcbiAgICogQGZpcmVzIHNjYWxpbmdcbiAgICogQGZpcmVzIG1vdmluZ1xuICAgKiBAZmlyZXMgc2tld2luZ1xuICAgKlxuICAgKiBAZmlyZXMgbW91c2Vkb3duXG4gICAqIEBmaXJlcyBtb3VzZXVwXG4gICAqIEBmaXJlcyBtb3VzZW92ZXJcbiAgICogQGZpcmVzIG1vdXNlb3V0XG4gICAqIEBmaXJlcyBtb3VzZXdoZWVsXG4gICAqIEBmaXJlcyBtb3VzZWRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgICd0b3AnLFxuXG4gICAgLyoqXG4gICAgICogVG9wIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgdG9wLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWT17dG9wL2NlbnRlci9ib3R0b219XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgbGVmdC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblg9e2xlZnQvY2VudGVyL3JpZ2h0fVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGVmdDogICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yIChob3Jpem9udGFsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAodmVydGljYWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIGhvcml6b250YWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHJvdGF0aW9uIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geCBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geSBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU2l6ZTogICAgICAgICAgICAgICAxMyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyBhcmUgcmVuZGVyZWQgYXMgdHJhbnNwYXJlbnQgaW5zaWRlIChpLmUuIHN0cm9rZSBpbnN0ZWFkIG9mIGZpbGwpXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHJhbnNwYXJlbnRDb3JuZXJzOiAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBiZXR3ZWVuIG9iamVjdCBhbmQgaXRzIGNvbnRyb2xsaW5nIGJvcmRlcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhZGRpbmc6ICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGJvcmRlcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyQ29sb3I6ICAgICAgICAgICAgICAncmdiYSgxMDIsMTUzLDI1NSwwLjc1KScsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBib3JkZXJzIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgYm9yZGVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJDb2xvcjogICAgICAgICAgICAgICdyZ2JhKDEwMiwxNTMsMjU1LDAuNSknLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUgYW5kIHRyYW5zcGFyZW50Q29ybmVycyBmYWxzZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclN0cm9rZUNvbG9yOiAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgc3R5bGUgb2YgY29udHJvbCwgJ3JlY3QnIG9yICdjaXJjbGUnXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgY29ybmVyU3R5bGU6ICAgICAgICAgICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIGNvbnRyb2wgKGhhc0JvcmRlciBtdXN0IGJlIHRydWUpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjb3JuZXJEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyBzY2FsZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyByb3RhdGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBvYmplY3QncyBmaWxsXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgcnVsZSB1c2VkIHRvIGZpbGwgYW4gb2JqZWN0XG4gICAgICogYWNjZXB0ZWQgdmFsdWVzIGFyZSBub256ZXJvLCBldmVub2RkXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgdXNlZCBmb3Igc2V0dGluZyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gdW50aWwgdjEuNC4xMiAodXNlIGBmYWJyaWMuT2JqZWN0I2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbmAgaW5zdGVhZClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgJ25vbnplcm8nLFxuXG4gICAgLyoqXG4gICAgICogQ29tcG9zaXRlIHJ1bGUgdXNlZCBmb3IgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiAnc291cmNlLW92ZXInLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LiBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0IHdoZW4gaXQgaXMgYWN0aXZlLlxuICAgICAqIGRvZXMgbm90IG1peCBnb29kIHdpdGggZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIG1ldGhvZHMuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZSB1c2VkIHRvIHJlbmRlciB0aGlzIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChzdHJva2UgbXVzdCBiZSBkZWZpbmVkKVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgICdidXR0JyxcblxuICAgIC8qKlxuICAgICAqIENvcm5lciBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJldmlsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICAnbWl0ZXInLFxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgNCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzIHdoZW4gb2JqZWN0IGlzIGFjdGl2ZSBhbmQgbW92aW5nXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogIDAuNCxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJTY2FsZUZhY3RvcjogICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gbWF0cml4IChzaW1pbGFyIHRvIFNWRydzIHRyYW5zZm9ybSBtYXRyaXgpXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1NYXRyaXg6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5TY2FsZUxpbWl0OiAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBzZWxlY3RlZCBmb3IgbW9kaWZpY2F0aW9uICh1c2luZyBlaXRoZXIgcG9pbnQtY2xpY2stYmFzZWQgb3IgZ3JvdXAtYmFzZWQgc2VsZWN0aW9uKS5cbiAgICAgKiBCdXQgZXZlbnRzIHN0aWxsIGZpcmUgb24gaXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0YWJsZTogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgYSB0YXJnZXQgb2YgZXZlbnRzLiBBbGwgZXZlbnRzIHByb3BhZ2F0ZSB0aHJvdWdoIGl0LiBJbnRyb2R1Y2VkIGluIHYxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV2ZW50ZWQ6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBpcyBub3QgcmVuZGVyZWQgb24gY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbHMgYXJlIG5vdCBkaXNwbGF5ZWQgYW5kIGNhbiBub3QgYmUgdXNlZCB0byBtYW5pcHVsYXRlIG9iamVjdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0NvbnRyb2xzOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgYXJlIG5vdCByZW5kZXJlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0JvcmRlcnM6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIHJvdGF0aW5nIHBvaW50IHdpbGwgbm90IGJlIHZpc2libGUgb3Igc2VsZWN0YWJsZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc1JvdGF0aW5nUG9pbnQ6ICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBmb3Igb2JqZWN0J3MgY29udHJvbGxpbmcgcm90YXRpbmcgcG9pbnQgKHdoZW4gZW5hYmxlZCB2aWEgYGhhc1JvdGF0aW5nUG9pbnRgKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpbmdQb2ludE9mZnNldDogICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0cyBhcmUgXCJmb3VuZFwiIG9uIGNhbnZhcyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gYWNjb3JkaW5nIHRvIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIGRlZmF1bHQgb2JqZWN0J3MgdmFsdWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gaXRzIHNlcmlhbGl6YXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgY2xpcHBpbmcgb2YgYW4gb2JqZWN0IChjb250ZXh0IGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KVxuICAgICAqIE5vdGUgdGhhdCBjb250ZXh0IG9yaWdpbiBpcyBhdCB0aGUgb2JqZWN0J3MgY2VudGVyIHBvaW50IChub3QgbGVmdC90b3AgY29ybmVyKVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKi9cbiAgICBjbGlwVG86ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgbm9uLXVuaWZvcm0gc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrVW5pU2NhbGluZzogICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIE9CSkVDVC9KU09OXG4gICAgICogc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBleGNsdWRlRnJvbUV4cG9ydDogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG9iamVjdENhY2hpbmc6ICAgICAgICAgICAgb2JqZWN0Q2FjaGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uLiBJbiBzb21lIHBhcnRpY3VsYXJcbiAgICAgKiBzaXR1YXRpb24geW91IG1heSB3YW50IHRoaXMgdG8gYmUgZGlzYWJsZWQgKCBzcHJheSBicnVzaCwgdmVyeSBiaWcsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkaXJ0eTogICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBob3ZlcmVkIGNvbmVyIGR1cmluZyBtb3VzZSBtb3ZlLlxuICAgICAqIDAgaXMgbm8gY29ybmVyLCBvciAnbXQnLCAnbWwnLCAnbXRyJyBldGMuLlxuICAgICAqIEl0IHNob3VsZCBiZSBwcml2YXRlLCBidXQgdGhlcmUgaXMgbm8gaGFybSBpbiB1c2luZyBpdCBhc1xuICAgICAqIGEgcmVhZC1vbmx5IHByb3BlcnR5LlxuICAgICAqIEB0eXBlIG51bWJlcnxzdHJpbmd8YW55XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIF9fY29ybmVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5zIGlmIHRoZSBmaWxsIG9yIHRoZSBzdHJva2UgaXMgZHJhd24gZmlyc3QgKG9uZSBvZiBcImZpbGxcIiBvciBcInN0cm9rZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGFpbnRGaXJzdDogICAgICAgICAgICdmaWxsJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlXG4gICAgICogb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkKVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogKFxuICAgICAgJ3RvcCBsZWZ0IHdpZHRoIGhlaWdodCBzY2FsZVggc2NhbGVZIGZsaXBYIGZsaXBZIG9yaWdpblggb3JpZ2luWSB0cmFuc2Zvcm1NYXRyaXggJyArXG4gICAgICAnc3Ryb2tlIHN0cm9rZVdpZHRoIHN0cm9rZURhc2hBcnJheSBzdHJva2VMaW5lQ2FwIHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgJyArXG4gICAgICAnYW5nbGUgb3BhY2l0eSBmaWxsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBzaGFkb3cgY2xpcFRvIHZpc2libGUgYmFja2dyb3VuZENvbG9yICcgK1xuICAgICAgJ3NrZXdYIHNrZXdZIGZpbGxSdWxlIHBhaW50Rmlyc3QnXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHdpZHRoIGhlaWdodCBwYWludEZpcnN0JyArXG4gICAgICAnIHN0cm9rZUxpbmVDYXAgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCBiYWNrZ3JvdW5kQ29sb3InXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aGUgY2FudmFzIHVzZWQgdG8ga2VlcCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlUHJvcGVydGllcyA9IHt9O1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKTtcbiAgICAgIC8vIGlmIGNhbnZhcyBnZXRzIGNyZWF0ZWQsIGlzIGVtcHR5LCBzbyBkaXJ0eS5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgY2FjaGUgZGltZW5zaW9ucyBzbyB0aGF0IFggKiBZIGRvIG5vdCBjcm9zcyBmYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsXG4gICAgICogYW5kIGVhY2ggc2lkZSBkbyBub3QgY3Jvc3MgZmFicmljLmNhY2hlU2lkZUxpbWl0XG4gICAgICogdGhvc2UgbnVtYmVycyBhcmUgY29uZmlndXJhYmxlIHNvIHRoYXQgeW91IGNhbiBnZXQgYXMgbXVjaCBkZXRhaWwgYXMgeW91IHdhbnRcbiAgICAgKiBtYWtpbmcgYmFyZ2FpbiB3aXRoIHBlcmZvcm1hbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2xpbWl0Q2FjaGVTaXplOiBmdW5jdGlvbihkaW1zKSB7XG4gICAgICB2YXIgcGVyZkxpbWl0U2l6ZVRvdGFsID0gZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LFxuICAgICAgICAgIG1heCA9IGZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCwgbWluID0gZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0O1xuICAgICAgaWYgKHdpZHRoIDw9IG1heCAmJiBoZWlnaHQgPD0gbWF4ICYmIHdpZHRoICogaGVpZ2h0IDw9IHBlcmZMaW1pdFNpemVUb3RhbCkge1xuICAgICAgICBpZiAod2lkdGggPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLndpZHRoID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCBtaW4pIHtcbiAgICAgICAgICBkaW1zLmhlaWdodCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltcztcbiAgICAgIH1cbiAgICAgIHZhciBhciA9IHdpZHRoIC8gaGVpZ2h0LCBsaW1pdGVkRGltcyA9IGZhYnJpYy51dGlsLmxpbWl0RGltc0J5QXJlYShhciwgcGVyZkxpbWl0U2l6ZVRvdGFsKSxcbiAgICAgICAgICBjYXBWYWx1ZSA9IGZhYnJpYy51dGlsLmNhcFZhbHVlLFxuICAgICAgICAgIHggPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLngsIG1heCksXG4gICAgICAgICAgeSA9IGNhcFZhbHVlKG1pbiwgbGltaXRlZERpbXMueSwgbWF4KTtcbiAgICAgIGlmICh3aWR0aCA+IHgpIHtcbiAgICAgICAgZGltcy56b29tWCAvPSB3aWR0aCAvIHg7XG4gICAgICAgIGRpbXMud2lkdGggPSB4O1xuICAgICAgICBkaW1zLmNhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0ID4geSkge1xuICAgICAgICBkaW1zLnpvb21ZIC89IGhlaWdodCAvIHk7XG4gICAgICAgIGRpbXMuaGVpZ2h0ID0geTtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGltZW5zaW9uIGFuZCB0aGUgem9vbSBsZXZlbCBuZWVkZWQgdG8gY3JlYXRlIGEgY2FjaGUgY2FudmFzXG4gICAgICogYmlnIGVub3VnaCB0byBob3N0IHRoZSBvYmplY3QgdG8gYmUgY2FjaGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS54IHdpZHRoIG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnkgaGVpZ2h0IG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHpvb20gPSB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5nZXRab29tKCkgfHwgMSxcbiAgICAgICAgICBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIHJldGluYSA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB6b29tWCA9IG9iamVjdFNjYWxlLnNjYWxlWCAqIHpvb20gKiByZXRpbmEsXG4gICAgICAgICAgem9vbVkgPSBvYmplY3RTY2FsZS5zY2FsZVkgKiB6b29tICogcmV0aW5hLFxuICAgICAgICAgIHdpZHRoID0gZGltLnggKiB6b29tWCxcbiAgICAgICAgICBoZWlnaHQgPSBkaW0ueSAqIHpvb21ZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gZm9yIHN1cmUgdGhpcyBBTElBU0lOR19MSU1JVCBpcyBzbGlnaHRseSBjcmF0aW5nIHByb2JsZW1cbiAgICAgICAgLy8gaW4gc2l0dWF0aW9uIGluIHdpY2ggdGhlIGNhY2hlIGNhbnZhcyBnZXRzIGFuIHVwcGVyIGxpbWl0XG4gICAgICAgIHdpZHRoOiB3aWR0aCArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICB6b29tWDogem9vbVgsXG4gICAgICAgIHpvb21ZOiB6b29tWSxcbiAgICAgICAgeDogZGltLngsXG4gICAgICAgIHk6IGRpbS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzIGZvciBjYWNoZVxuICAgICAqIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBjYW52YXMgbmVlZGVkIHJlc2l6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBoYXMgYmVlbiByZXNpemVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm5vU2NhbGVDYWNoZSAmJiB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5jYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5jYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0uYWN0aW9uO1xuICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIGFjdGlvbi5zbGljZSAmJiBhY3Rpb24uc2xpY2UoMCwgNSkgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYWNoZUNhbnZhcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIG1pbkNhY2hlU2l6ZSA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LCBkcmF3aW5nV2lkdGgsIGRyYXdpbmdIZWlnaHQsXG4gICAgICAgICAgem9vbVggPSBkaW1zLnpvb21YLCB6b29tWSA9IGRpbXMuem9vbVksXG4gICAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gdGhpcy5jYWNoZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5jYWNoZUhlaWdodCxcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRoaXMuem9vbVggIT09IHpvb21YIHx8IHRoaXMuem9vbVkgIT09IHpvb21ZLFxuICAgICAgICAgIHNob3VsZFJlZHJhdyA9IGRpbWVuc2lvbnNDaGFuZ2VkIHx8IHpvb21DaGFuZ2VkLFxuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IDAsIGFkZGl0aW9uYWxIZWlnaHQgPSAwLCBzaG91bGRSZXNpemVDYW52YXMgPSBmYWxzZTtcbiAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9jYWNoZUNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IHRoaXMuX2NhY2hlQ2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHNpemVHcm93aW5nID0gd2lkdGggPiBjYW52YXNXaWR0aCB8fCBoZWlnaHQgPiBjYW52YXNIZWlnaHQsXG4gICAgICAgICAgICBzaXplU2hyaW5raW5nID0gKHdpZHRoIDwgY2FudmFzV2lkdGggKiAwLjkgfHwgaGVpZ2h0IDwgY2FudmFzSGVpZ2h0ICogMC45KSAmJlxuICAgICAgICAgICAgICBjYW52YXNXaWR0aCA+IG1pbkNhY2hlU2l6ZSAmJiBjYW52YXNIZWlnaHQgPiBtaW5DYWNoZVNpemU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHNpemVHcm93aW5nIHx8IHNpemVTaHJpbmtpbmc7XG4gICAgICAgIGlmIChzaXplR3Jvd2luZyAmJiAhZGltcy5jYXBwZWQgJiYgKHdpZHRoID4gbWluQ2FjaGVTaXplIHx8IGhlaWdodCA+IG1pbkNhY2hlU2l6ZSkpIHtcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSB3aWR0aCAqIDAuMTtcbiAgICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ID0gaGVpZ2h0ICogMC4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVkcmF3KSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNpemVDYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKyBhZGRpdGlvbmFsV2lkdGgpO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICsgYWRkaXRpb25hbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2luZ1dpZHRoID0gZGltcy54ICogem9vbVggLyAyO1xuICAgICAgICBkcmF3aW5nSGVpZ2h0ID0gZGltcy55ICogem9vbVkgLyAyO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25YID0gTWF0aC5yb3VuZChjYW52YXMud2lkdGggLyAyIC0gZHJhd2luZ1dpZHRoKSArIGRyYXdpbmdXaWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoY2FudmFzLmhlaWdodCAvIDIgLSBkcmF3aW5nSGVpZ2h0KSArIGRyYXdpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQudHJhbnNsYXRlKHRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy56b29tWCA9IHpvb21YO1xuICAgICAgICB0aGlzLnpvb21ZID0gem9vbVk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgICB0aGlzLl9pbml0Q2xpcHBpbmcob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbnRleHQgd2hlbiByZW5kZXJpbmcgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gICAgICovXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG0gPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIH1cbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuXG4gICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgdHlwZTogICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAgICAgICAgICAgICAgIGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZU1pdGVyTGltaXQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5hbmdsZSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmbGlwWDogICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcFgsXG4gICAgICAgICAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcFksXG4gICAgICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5vcGFjaXR5LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgKHRoaXMuc2hhZG93ICYmIHRoaXMuc2hhZG93LnRvT2JqZWN0KSA/IHRoaXMuc2hhZG93LnRvT2JqZWN0KCkgOiB0aGlzLnNoYWRvdyxcbiAgICAgICAgICAgIHZpc2libGU6ICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlLFxuICAgICAgICAgICAgY2xpcFRvOiAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBUbyAmJiBTdHJpbmcodGhpcy5jbGlwVG8pLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgdGhpcy5maWxsUnVsZSxcbiAgICAgICAgICAgIHBhaW50Rmlyc3Q6ICAgICAgICAgICAgICAgdGhpcy5wYWludEZpcnN0LFxuICAgICAgICAgICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeDogICAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPyB0aGlzLnRyYW5zZm9ybU1hdHJpeC5jb25jYXQoKSA6IG51bGwsXG4gICAgICAgICAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUylcbiAgICAgICAgICB9O1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIChkYXRhbGVzcykgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBzdWJjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3JlbW92ZURlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHByb3RvdHlwZSA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG9iamVjdC50eXBlKS5wcm90b3R5cGUsXG4gICAgICAgICAgc3RhdGVQcm9wZXJ0aWVzID0gcHJvdG90eXBlLnN0YXRlUHJvcGVydGllcztcbiAgICAgIHN0YXRlUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKG9iamVjdFtwcm9wXSA9PT0gcHJvdG90eXBlW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3RbcHJvcF0pID09PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb3RvdHlwZVtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgICAgLy8gYmFzaWNhbGx5IGEgY2hlY2sgZm9yIFtdID09PSBbXVxuICAgICAgICBpZiAoaXNBcnJheSAmJiBvYmplY3RbcHJvcF0ubGVuZ3RoID09PSAwICYmIHByb3RvdHlwZVtwcm9wXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLicgKyBjYXBpdGFsaXplKHRoaXMudHlwZSkgKyAnPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGVYID0gdGhpcy5zY2FsZVgsIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLmdyb3VwLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHNjYWxpbmcuc2NhbGVYO1xuICAgICAgICBzY2FsZVkgKj0gc2NhbGluZy5zY2FsZVk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgb3BhY2l0eSBjb3VudGluZyBhbHNvIHRoZSBncm91cCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRPYmplY3RPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgb3BhY2l0eSAqPSB0aGlzLmdyb3VwLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzaG91bGRDb25zdHJhaW5WYWx1ZSA9IChrZXkgPT09ICdzY2FsZVgnIHx8IGtleSA9PT0gJ3NjYWxlWScpLFxuICAgICAgICAgIGlzQ2hhbmdlZCA9IHRoaXNba2V5XSAhPT0gdmFsdWUsIGdyb3VwTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZENvbnN0cmFpblZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fY29uc3RyYWluU2NhbGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NjYWxlWCcgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMuZmxpcFggPSAhdGhpcy5mbGlwWDtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdzY2FsZVknICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBZID0gIXRoaXMuZmxpcFk7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2hhZG93JyAmJiB2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgZmFicmljLlNoYWRvdykpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgZmFicmljLlNoYWRvdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdkaXJ0eScgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgIGdyb3VwTmVlZHNVcGRhdGUgPSB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdyb3VwTmVlZHNVcGRhdGUgJiYgdGhpcy5zdGF0ZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIHBhcmVudCBncm91cCBvZiBhbiBvYmplY3QgZXZlcnlcbiAgICAgKiB0aW1lIGEgbm9uLWRlbGVnYXRlZCBwcm9wZXJ0eSBjaGFuZ2VzIG9uIHRoZSBncm91cC4gSXQgaXMgcGFzc2VkIHRoZSBrZXlcbiAgICAgKiBhbmQgdmFsdWUgYXMgcGFyYW1ldGVycy4gTm90IGFkZGluZyBpbiB0aGlzIGZ1bmN0aW9uJ3Mgc2lnbmF0dXJlIHRvIGF2b2lkXG4gICAgICogVHJhdmlzIGJ1aWxkIGVycm9yIGFib3V0IHVudXNlZCB2YXJpYWJsZXMuXG4gICAgICovXG4gICAgc2V0T25Hcm91cDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdmlld3BvcnRUcmFuc2Zvcm0gZnJvbSBPYmplY3QncyBjYW52YXMgaWYgcG9zc2libGVcbiAgICAgKiBAbWV0aG9kIGdldFZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIGlmIHRoZSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpbiByZW5kZXJpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm90VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8ICh0aGlzLndpZHRoID09PSAwICYmIHRoaXMuaGVpZ2h0ID09PSAwKSB8fCAhdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIHdpZHRoL2hlaWdodCBhcmUgemVyb3Mgb3Igb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uKGN0eCk7XG4gICAgICB0aGlzLmRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpcFRvICYmIGZhYnJpYy51dGlsLmNsaXBDb250ZXh0KHRoaXMsIGN0eCk7XG4gICAgICBpZiAodGhpcy5zaG91bGRDYWNoZSgpKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVDYW52YXMpIHtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDYWNoZURpcnR5KCkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICAgIHRoaXMuZHJhd09iamVjdCh0aGlzLl9jYWNoZUNvbnRleHQpO1xuICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdDYWNoZU9uQ2FudmFzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2FjaGVDYW52YXMoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYXdPYmplY3QoY3R4KTtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0Q2FjaGluZyAmJiB0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpcFRvICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY2FjaGVDYW52YXMgYW5kIGl0cyBkaW1lbnNpb25zIGZyb20gdGhlIG9iamVjdHNcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jYWNoZVdpZHRoID0gMDtcbiAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIGZvcmNlIHRoZSBvYmplY3QgdG8gaGF2ZSBpdHMgb3duIGNhY2hlLCBldmVuIGlmIGl0IGlzIGluc2lkZSBhIGdyb3VwXG4gICAgICogaXQgbWF5IGJlIG5lZWRlZCB3aGVuIHlvdXIgb2JqZWN0IGJlaGF2ZSBpbiBhIHBhcnRpY3VsYXIgd2F5IG9uIHRoZSBjYWNoZSBhbmQgYWx3YXlzIG5lZWRzXG4gICAgICogaXRzIG93biBpc29sYXRlZCBjYW52YXMgdG8gcmVuZGVyIGNvcnJlY3RseS5cbiAgICAgKiBDcmVhdGVkIHRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKiBzaW5jZSAxLjcuMTJcbiAgICAgKiBAcmV0dXJucyBmYWxzZVxuICAgICAqL1xuICAgIG5lZWRzSXRzT3duQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScgJiYgdHlwZW9mIHRoaXMuc2hhZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gdGhpcy5vYmplY3RDYWNoaW5nICYmXG4gICAgICAoIXRoaXMuZ3JvdXAgfHwgdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgIXRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpKTtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIHVzZWQgYnkgR3JvdXAuc2hvdWxkQ2FjaGUgdG8ga25vdyBpZiBjaGlsZCBoYXMgYSBzaGFkb3cgcmVjdXJzaXZlbHlcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2hhZG93ICYmICh0aGlzLnNoYWRvdy5vZmZzZXRYICE9PSAwIHx8IHRoaXMuc2hhZG93Lm9mZnNldFkgIT09IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX3JlbmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdCBvbiB0aGUgdGFyZ2V0IGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDYWNoZU9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdGhpcy56b29tWCwgMSAvIHRoaXMuem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9jYWNoZUNhbnZhcywgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIC10aGlzLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBDYW52YXMgc2tpcCBjYW52YXMgY2hlY2tzIGJlY2F1c2UgdGhpcyBvYmplY3QgaXMgcGFpbnRlZFxuICAgICAqIG9uIHBhcmVudCBjYW52YXMuXG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbihza2lwQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgIXNraXBDYW52YXMgJiYgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKSkge1xuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgdGhlIGNvbnRleHQgaXMgYWxyZWFkeSBjbGVhcmVkLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSB8fCAodGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnY2FjaGVQcm9wZXJ0aWVzJykpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzICYmICFza2lwQ2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FjaGVIZWlnaHQgLyB0aGlzLnpvb21ZO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgYmFja2dyb3VuZCBmb3IgdGhlIG9iamVjdCBiaWcgYXMgaXRzIHVudHJhc2Zvcm1lZCBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLWRpbS54IC8gMixcbiAgICAgICAgLWRpbS55IC8gMixcbiAgICAgICAgZGltLngsXG4gICAgICAgIGRpbS55XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBpZiAoZGVjbC5zdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gZGVjbC5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZUpvaW4gPSBkZWNsLnN0cm9rZUxpbmVKb2luO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IGRlY2wuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGVjbC5zdHJva2UudG9MaXZlXG4gICAgICAgICAgPyBkZWNsLnN0cm9rZS50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogZGVjbC5zdHJva2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRGaWxsU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIGlmIChkZWNsLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRlY2wuZmlsbC50b0xpdmVcbiAgICAgICAgICA/IGRlY2wuZmlsbC50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogZGVjbC5maWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldHMgbGluZSBkYXNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHNldCB0aGUgZGFzaCBsaW5lIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGFzaEFycmF5IGFycmF5IHJlcHJlc2VudGluZyBkYXNoZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhbHRlcm5hdGl2ZSBmdW5jdGlvbiB0byBjYWxsIGlmIGJyb3dhc2VyIGRvZXMgbm90IHN1cHBvcnQgbGluZURhc2hcbiAgICAgKi9cbiAgICBfc2V0TGluZURhc2g6IGZ1bmN0aW9uKGN0eCwgZGFzaEFycmF5LCBhbHRlcm5hdGl2ZSkge1xuICAgICAgaWYgKCFkYXNoQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gY29waWVzIHRoZSBkYXNoIGxpc3Qgd2hlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIG9kZFxuICAgICAgaWYgKDEgJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGRhc2hBcnJheS5wdXNoLmFwcGx5KGRhc2hBcnJheSwgZGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFsdGVybmF0aXZlICYmIGFsdGVybmF0aXZlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zLCBkcmF3Qm9yZGVycywgZHJhd0NvbnRyb2xzO1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgZHJhd0JvcmRlcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQm9yZGVycyA6IHRoaXMuaGFzQm9yZGVycztcbiAgICAgIGRyYXdDb250cm9scyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzO1xuICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh2cHQsIG1hdHJpeCk7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxICogdGhpcy5ib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGlmICghdGhpcy5ncm91cCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVPdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24pIHtcbiAgICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuYW5nbGUpKTtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVyc0luR3JvdXAoY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBkcmF3Q29udHJvbHMgJiYgdGhpcy5kcmF3Q29udHJvbHMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0WCA9ICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVswXSkgfHwgMSxcbiAgICAgICAgICBtdWx0WSA9ICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVszXSkgfHwgMSxcbiAgICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIG11bHRYICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBtdWx0WSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93LmNvbG9yO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvdy5ibHVyICogZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgKlxuICAgICAgICAobXVsdFggKyBtdWx0WSkgKiAoc2NhbGluZy5zY2FsZVggKyBzY2FsaW5nLnNjYWxlWSkgLyA0O1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3cub2Zmc2V0WSAqIG11bHRZICogc2NhbGluZy5zY2FsZVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGxlciBmYWJyaWMuUGF0dGVybiBvciBmYWJyaWMuR3JhZGllbnRcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICBpZiAoIWZpbGxlciB8fCAhZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgICB9XG4gICAgICB2YXIgdCA9IGZpbGxlci5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgIHZhciBvZmZzZXRYID0gLXRoaXMud2lkdGggLyAyICsgZmlsbGVyLm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMiArIGZpbGxlci5vZmZzZXRZIHx8IDA7XG4gICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhaW50SW5PcmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgdGhpcy5maWxsKTtcbiAgICAgIGlmICh0aGlzLmZpbGxSdWxlID09PSAnZXZlbm9kZCcpIHtcbiAgICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXksIHRoaXMuX3JlbmRlckRhc2hlZFN0cm9rZSk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIHRoaXMuc3Ryb2tlKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgeTogdGhpcy50b3AgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IGRlY29vbXBvc2UgdGhlIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIGFuZCBhc3NpZ24gcHJvcGVydGllcyB0byBvYmplY3QuXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZSh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuZmxpcFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgICAgdGhpcy5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICAgIHRoaXMuc2tld1kgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmVtb3ZlcyB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIGFuZCBzZXQgdG8gb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBmYWJyaWNqcyBjYW4gaGFuZGxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfVxuICAgICAqL1xuICAgIF9yZW1vdmVUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZmluZENlbnRlckZyb21FbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHMoKTtcbiAgICAgICAgY2VudGVyID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoY2VudGVyLCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zY2FsZVggKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVYO1xuICAgICAgICB0aGlzLnNjYWxlWSAqPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5zY2FsZVk7XG4gICAgICAgIHRoaXMuY3JvcFggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWDtcbiAgICAgICAgdGhpcy5jcm9wWSA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmNyb3BZO1xuICAgICAgICBjZW50ZXIueCArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRMZWZ0O1xuICAgICAgICBjZW50ZXIueSArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRUb3A7XG4gICAgICAgIHRoaXMud2lkdGggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gaW5zdGFuY2UsIHVzaW5nIGEgY2FsbGJhY2sgbWV0aG9kIHdpbGwgd29yayBmb3IgZXZlcnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlzIGludm9rZWQgd2l0aCBhIGNsb25lIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2JqZWN0Rm9ybSA9IHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdChvYmplY3RGb3JtLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnT2JqZWN0Jywgb2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBvdXQgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIGVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgdGhlIGNsb25lZCBpbWFnZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjbG9uZUFzSW1hZ2U6IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGF0YVVybCA9IHRoaXMudG9EYXRhVVJMKG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGRhdGFVcmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICBlbC53aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICAgIGVsLmhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC53cmFwRWxlbWVudChlbCwgJ2RpdicpO1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBmYWJyaWMuU3RhdGljQ2FudmFzKGVsLCB7XG4gICAgICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmU6IGZhbHNlLFxuICAgICAgICBza2lwT2Zmc2NyZWVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgLy8gdG8gYXZvaWQgY29tbW9uIGNvbmZ1c2lvbiBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9pc3N1ZXMvODA2XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGcnKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gJ2pwZWcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGVnJykge1xuICAgICAgICBjYW52YXMuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ1BhcmFtcyA9IHtcbiAgICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgICB0b3A6IHRoaXMudG9wXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4obmV3IGZhYnJpYy5Qb2ludChjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiksICdjZW50ZXInLCAnY2VudGVyJyk7XG5cbiAgICAgIHZhciBvcmlnaW5hbENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLmFkZCh0aGlzKTtcbiAgICAgIHZhciBkYXRhID0gY2FudmFzLnRvRGF0YVVSTChvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5jYW52YXMgPSBvcmlnaW5hbENhbnZhcztcbiAgICAgIC8vIGNhbnZhcy5kaXNwb3NlIHdpbGwgY2FsbCBpbWFnZS5kaXNwb3NlIHRoYXQgd2lsbCBudWxsaWZ5IHRoZSBlbGVtZW50c1xuICAgICAgLy8gc2luY2UgdGhpcyBjYW52YXMgaXMgYSBzaW1wbGUgZWxlbWVudCBmb3IgdGhlIHByb2Nlc3MsIHdlIHJlbW92ZSByZWZlcmVuY2VzXG4gICAgICAvLyB0byBvYmplY3RzIGluIHRoaXMgd2F5IGluIG9yZGVyIHRvIGF2b2lkIG9iamVjdCB0cmFzaGluZy5cbiAgICAgIGNhbnZhcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgY2FudmFzLmRpc3Bvc2UoKTtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlIChpcyAxIHVubGVzcyBzdWJjbGFzc2VkKVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ3JhZGllbnQgKGZpbGwgb3Igc3Ryb2tlKSBvZiBhbiBvYmplY3RcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIG1ldGhvZCB3YXMgbmFtZWQgXCJzZXRHcmFkaWVudEZpbGxcIiB1bnRpbCB2MS4xLjBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSAnc3Ryb2tlJyBvciAnZmlsbCdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGVdIFR5cGUgb2YgZ3JhZGllbnQgJ3JhZGlhbCcgb3IgJ2xpbmVhcidcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueDE9MF0geC1jb29yZGluYXRlIG9mIHN0YXJ0IHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkxPTBdIHktY29vcmRpbmF0ZSBvZiBzdGFydCBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy54Mj0wXSB4LWNvb3JkaW5hdGUgb2YgZW5kIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnkyPTBdIHktY29vcmRpbmF0ZSBvZiBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucjE9MF0gUmFkaXVzIG9mIHN0YXJ0IHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yMj0wXSBSYWRpdXMgb2YgZW5kIHBvaW50IChvbmx5IGZvciByYWRpYWwgZ3JhZGllbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xvclN0b3BzXSBDb2xvciBzdG9wcyBvYmplY3QgZWcuIHswOiAnZmYwMDAwJywgMTogJzAwMDAwMCd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtXSB0cmFuc2Zvck1hdHJpeCBmb3IgZ3JhZGllbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvNTh5OGIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IGxpbmVhciBncmFkaWVudDwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0R3JhZGllbnQoJ2ZpbGwnLCB7XG4gICAgICogICB0eXBlOiAnbGluZWFyJyxcbiAgICAgKiAgIHgxOiAtb2JqZWN0LndpZHRoIC8gMixcbiAgICAgKiAgIHkxOiAwLFxuICAgICAqICAgeDI6IG9iamVjdC53aWR0aCAvIDIsXG4gICAgICogICB5MjogMCxcbiAgICAgKiAgIGNvbG9yU3RvcHM6IHtcbiAgICAgKiAgICAgMDogJ3JlZCcsXG4gICAgICogICAgIDAuNTogJyMwMDU1NTUnLFxuICAgICAqICAgICAxOiAncmdiYSgwLDAsMjU1LDAuNSknXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCByYWRpYWwgZ3JhZGllbnQ8L2NhcHRpb24+XG4gICAgICogb2JqZWN0LnNldEdyYWRpZW50KCdmaWxsJywge1xuICAgICAqICAgdHlwZTogJ3JhZGlhbCcsXG4gICAgICogICB4MTogMCxcbiAgICAgKiAgIHkxOiAwLFxuICAgICAqICAgeDI6IDAsXG4gICAgICogICB5MjogMCxcbiAgICAgKiAgIHIxOiBvYmplY3Qud2lkdGggLyAyLFxuICAgICAqICAgcjI6IDEwLFxuICAgICAqICAgY29sb3JTdG9wczoge1xuICAgICAqICAgICAwOiAncmVkJyxcbiAgICAgKiAgICAgMC41OiAnIzAwNTU1NScsXG4gICAgICogICAgIDE6ICdyZ2JhKDAsMCwyNTUsMC41KSdcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICovXG4gICAgc2V0R3JhZGllbnQ6IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGdyYWRpZW50ID0geyBjb2xvclN0b3BzOiBbXSB9O1xuXG4gICAgICBncmFkaWVudC50eXBlID0gb3B0aW9ucy50eXBlIHx8IChvcHRpb25zLnIxIHx8IG9wdGlvbnMucjIgPyAncmFkaWFsJyA6ICdsaW5lYXInKTtcbiAgICAgIGdyYWRpZW50LmNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMueDEsXG4gICAgICAgIHkxOiBvcHRpb25zLnkxLFxuICAgICAgICB4Mjogb3B0aW9ucy54MixcbiAgICAgICAgeTI6IG9wdGlvbnMueTJcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zLnIxIHx8IG9wdGlvbnMucjIpIHtcbiAgICAgICAgZ3JhZGllbnQuY29vcmRzLnIxID0gb3B0aW9ucy5yMTtcbiAgICAgICAgZ3JhZGllbnQuY29vcmRzLnIyID0gb3B0aW9ucy5yMjtcbiAgICAgIH1cblxuICAgICAgZ3JhZGllbnQuZ3JhZGllbnRUcmFuc2Zvcm0gPSBvcHRpb25zLmdyYWRpZW50VHJhbnNmb3JtO1xuICAgICAgZmFicmljLkdyYWRpZW50LnByb3RvdHlwZS5hZGRDb2xvclN0b3AuY2FsbChncmFkaWVudCwgb3B0aW9ucy5jb2xvclN0b3BzKTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHByb3BlcnR5LCBmYWJyaWMuR3JhZGllbnQuZm9yT2JqZWN0KHRoaXMsIGdyYWRpZW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcGF0dGVybiBmaWxsIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHsoU3RyaW5nfEhUTUxJbWFnZUVsZW1lbnQpfSBvcHRpb25zLnNvdXJjZSBQYXR0ZXJuIHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBlYXQ9cmVwZWF0XSBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYPTBdIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WT0wXSBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9RVDNwYS98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgcGF0dGVybjwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgKiAgIG9iamVjdC5zZXRQYXR0ZXJuRmlsbCh7XG4gICAgICogICAgIHNvdXJjZTogaW1nLFxuICAgICAqICAgICByZXBlYXQ6ICdyZXBlYXQnXG4gICAgICogICB9KTtcbiAgICAgKiAgIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRQYXR0ZXJuRmlsbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCdmaWxsJywgbmV3IGZhYnJpYy5QYXR0ZXJuKG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLk9iamVjdCNzaGFkb3d8c2hhZG93fSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcgKGUuZy4gXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yPXJnYigwLDAsMCldIFNoYWRvdyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ibHVyPTBdIFNoYWRvdyBibHVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFg9MF0gU2hhZG93IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFk9MF0gU2hhZG93IHZlcnRpY2FsIG9mZnNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy83Z3ZKRy98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgc2hhZG93IHdpdGggc3RyaW5nIG5vdGF0aW9uPC9jYXB0aW9uPlxuICAgICAqIG9iamVjdC5zZXRTaGFkb3coJzJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMiknKTtcbiAgICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHNoYWRvdyB3aXRoIG9iamVjdCBub3RhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBvYmplY3Quc2V0U2hhZG93KHtcbiAgICAgKiAgIGNvbG9yOiAncmVkJyxcbiAgICAgKiAgIGJsdXI6IDEwLFxuICAgICAqICAgb2Zmc2V0WDogMjAsXG4gICAgICogICBvZmZzZXRZOiAyMFxuICAgICAqIH0pO1xuICAgICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICAgKi9cbiAgICBzZXRTaGFkb3c6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldCgnc2hhZG93Jywgb3B0aW9ucyA/IG5ldyBmYWJyaWMuU2hhZG93KG9wdGlvbnMpIDogbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJjb2xvclwiIG9mIGFuIGluc3RhbmNlIChhbGlhcyBvZiBgc2V0KCdmaWxsJywgJmhlbGxpcDspYClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdGhpcy5zZXQoJ2ZpbGwnLCBjb2xvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBcImFuZ2xlXCIgb2YgYW4gaW5zdGFuY2Ugd2l0aCBjZW50ZXJlZCByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBBbmdsZSB2YWx1ZSAoaW4gZGVncmVlcylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIHZhciBzaG91bGRDZW50ZXJPcmlnaW4gPSAodGhpcy5vcmlnaW5YICE9PSAnY2VudGVyJyB8fCB0aGlzLm9yaWdpblkgIT09ICdjZW50ZXInKSAmJiB0aGlzLmNlbnRlcmVkUm90YXRpb247XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fc2V0T3JpZ2luVG9DZW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQoJ2FuZ2xlJywgYW5nbGUpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0T3JpZ2luKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpcyB3YXMgYWRkZWQgbGFzdFxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyIHJlbGF0aXZlIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgdG8gb3BlcmF0ZSB1cG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSBQb2ludGVyIHRvIG9wZXJhdGUgdXBvbiAoaW5zdGVhZCBvZiBldmVudClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciAoeCwgeSlcbiAgICAgKi9cbiAgICBnZXRMb2NhbFBvaW50ZXI6IGZ1bmN0aW9uKGUsIHBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyIHx8IHRoaXMuY2FudmFzLmdldFBvaW50ZXIoZSk7XG4gICAgICB2YXIgcENsaWNrZWQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcbiAgICAgICAgICBvYmplY3RMZWZ0VG9wID0gdGhpcy5fZ2V0TGVmdFRvcENvb3JkcygpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcENsaWNrZWQgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChcbiAgICAgICAgICBwQ2xpY2tlZCwgb2JqZWN0TGVmdFRvcCwgZGVncmVlc1RvUmFkaWFucygtdGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcENsaWNrZWQueCAtIG9iamVjdExlZnRUb3AueCxcbiAgICAgICAgeTogcENsaWNrZWQueSAtIG9iamVjdExlZnRUb3AueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIGZvciBzcGVjaWZpYyBvYmplY3RcbiAgICAgKiBjdXN0b20gY29tcG9zaXRpb24gb3BlcmF0aW9uIGZvciB0aGUgcGFydGljdWxhciBvYmplY3QgY2FuIGJlIHNwZWNpZmVkIHVzaW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNhbnZhcyBjb250ZXh0XG4gICAgICovXG4gICAgX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzICYmIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuT2JqZWN0KTtcblxuICBleHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byB1c2Ugd2hlbiBzZXJpYWxpemluZyBvYmplY3QgdmFsdWVzLlxuICAgKiBZb3UgY2FuIHVzZSBpdCB0byBpbmNyZWFzZS9kZWNyZWFzZSBwcmVjaXNpb24gb2Ygc3VjaCB2YWx1ZXMgbGlrZSBsZWZ0LCB0b3AsIHNjYWxlWCwgc2NhbGVZLCBldGMuXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTID0gMjtcblxuICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0ID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBvYmplY3QsIGNhbGxiYWNrLCBleHRyYVBhcmFtKSB7XG4gICAgdmFyIGtsYXNzID0gZmFicmljW2NsYXNzTmFtZV07XG4gICAgb2JqZWN0ID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuUGF0dGVybnMoW29iamVjdC5maWxsLCBvYmplY3Quc3Ryb2tlXSwgZnVuY3Rpb24ocGF0dGVybnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5maWxsID0gcGF0dGVybnNbMF07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm5zWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3Quc3Ryb2tlID0gcGF0dGVybnNbMV07XG4gICAgICB9XG4gICAgICB2YXIgaW5zdGFuY2UgPSBleHRyYVBhcmFtID8gbmV3IGtsYXNzKG9iamVjdFtleHRyYVBhcmFtXSwgb2JqZWN0KSA6IG5ldyBrbGFzcyhvYmplY3QpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmlxdWUgaWQgdXNlZCBpbnRlcm5hbGx5IHdoZW4gY3JlYXRpbmcgU1ZHIGVsZW1lbnRzXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Ll9fdWlkID0gMDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvcmlnaW5YT2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIHJpZ2h0OiAwLjVcbiAgICAgIH0sXG4gICAgICBvcmlnaW5ZT2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgYm90dG9tOiAwLjVcbiAgICAgIH07XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGEgc2V0IG9mIG9yaWdpbiB0byBhbm90aGVyIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0dpdmVuT3JpZ2luOiBmdW5jdGlvbihwb2ludCwgZnJvbU9yaWdpblgsIGZyb21PcmlnaW5ZLCB0b09yaWdpblgsIHRvT3JpZ2luWSkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgIG9mZnNldFgsIG9mZnNldFksIGRpbTtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblggPSBvcmlnaW5YT2Zmc2V0W2Zyb21PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblggPSBvcmlnaW5YT2Zmc2V0W3RvT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WCA9IHRvT3JpZ2luWCAtIGZyb21PcmlnaW5YO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbZnJvbU9yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbdG9PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRZID0gdG9PcmlnaW5ZIC0gZnJvbU9yaWdpblk7XG5cbiAgICAgIGlmIChvZmZzZXRYIHx8IG9mZnNldFkpIHtcbiAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHggPSBwb2ludC54ICsgb2Zmc2V0WCAqIGRpbS54O1xuICAgICAgICB5ID0gcG9pbnQueSArIG9mZnNldFkgKiBkaW0ueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9DZW50ZXJQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIHBvaW50LCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGNlbnRlciB0byBvcmlnaW4gY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIGNlbnRlciBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIGNlbnRlciwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVhbCBjZW50ZXIgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVmdFRvcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KGxlZnRUb3AsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBjZW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyBnZXRPcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGFzIGlmIGl0IGhhcyBhIGRpZmZlcmVudCBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0UG9pbnRCeU9yaWdpbjogZnVuY3Rpb24ob3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdG9Mb2NhbFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBwLCBwMjtcblxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5YICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3JpZ2luWSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHAgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgfVxuXG4gICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwMiA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAyLCBjZW50ZXIsIC1kZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwMi5zdWJ0cmFjdEVxdWFscyhwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gdG9HbG9iYWxQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAvLyAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwb2ludCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKS5hZGRFcXVhbHMobmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgb2JqZWN0J3Mgb3JpZ2luXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvcyBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uQnlPcmlnaW46IGZ1bmN0aW9uKHBvcywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChwb3MsIG9yaWdpblgsIG9yaWdpblkpLFxuICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0U2NhbGVkV2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IGZhYnJpYy51dGlsLmNvcyhhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgeUZ1bGwgPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIG9mZnNldEZyb20sIG9mZnNldFRvO1xuXG4gICAgICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29uc2lkZXIgbWl4ZWQgc2l0dWF0aW9uIGxpa2UgdG9wLCBjZW50ZXIuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IG9yaWdpblhPZmZzZXRbdGhpcy5vcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRGcm9tID0gdGhpcy5vcmlnaW5YIC0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0VG8gPSBvcmlnaW5YT2Zmc2V0W3RvXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRUbyA9IHRvIC0gMC41O1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0ICs9IHhGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnRvcCArPSB5RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMub3JpZ2luWCA9IHRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIGNlbnRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gdGhpcy5vcmlnaW5YO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gdGhpcy5vcmlnaW5ZO1xuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRoaXMub3JpZ2luWSA9ICdjZW50ZXInO1xuXG4gICAgICB0aGlzLmxlZnQgPSBjZW50ZXIueDtcbiAgICAgIHRoaXMudG9wID0gY2VudGVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBvcmlnaW5hbCBvcmlnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3Jlc2V0T3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChcbiAgICAgICAgdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblgsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWDtcbiAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWTtcblxuICAgICAgdGhpcy5sZWZ0ID0gb3JpZ2luUG9pbnQueDtcbiAgICAgIHRoaXMudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExlZnRUb3BDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0aGlzLmdldENlbnRlclBvaW50KCksICdsZWZ0JywgJ3RvcCcpO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBnZXRDb29yZHMoY29vcmRzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRsLngsIGNvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRyLngsIGNvb3Jkcy50ci55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJyLngsIGNvb3Jkcy5ici55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJsLngsIGNvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBtdWx0aXBseU1hdHJpY2VzID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsbXQsdHIsbWwsbXIsYmwsbWIsYnIsbXRyIGZvciB0aGUgbWFpbiBjb250cm9scy5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHkgYW5kIGNvcm5lci5cbiAgICAgKiBUaGUgYGNvcm5lcmAgcHJvcGVydHkgY29udGFpbnMgaW4gYSBzaW1pbGFyIG1hbm5lciB0aGUgNCBwb2ludHMgb2YgdGhlXG4gICAgICogaW50ZXJhY3RpdmUgYXJlYSBvZiB0aGUgY29ybmVyLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhpcyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWVxuICAgICAqIHNrZXdYLCBza2V3WSwgYW5nbGUsIHN0cm9rZVdpZHRoLCB2aWV3cG9ydFRyYW5zZm9ybSwgdG9wLCBsZWZ0LCBwYWRkaW5nLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBnZXQgdXBkYXRlZCB3aXRoIEBtZXRob2Qgc2V0Q29vcmRzLlxuICAgICAqIFlvdSBjYW4gY2FsY3VsYXRlIHRoZW0gd2l0aG91dCB1cGRhdGluZyB3aXRoIEBtZXRob2QgY2FsY0Nvb3JkcztcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxiciBhbmQgZGVzY3JpYmUgdGhlIGZvdXIgbWFpbiBjb3JuZXIuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5LCBpbnN0YW5jZSBvZiBGYWJyaWMuUG9pbnQuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGlzIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHQsIHNjYWxlWCwgc2NhbGVZXG4gICAgICogc2tld1gsIHNrZXdZLCBhbmdsZSwgc3Ryb2tlV2lkdGgsIHRvcCwgbGVmdC5cbiAgICAgKiBUaG9zZSBjb29yZGluYXRlcyBhcmUgdXNlZnVsbCB0byB1bmRlcnN0YW5kIHdoZXJlIGFuIG9iamVjdCBpcy4gVGhleSBnZXQgdXBkYXRlZFxuICAgICAqIHdpdGggb0Nvb3JkcyBidXQgdGhleSBkbyBub3QgbmVlZCB0byBiZSB1cGRhdGVkIHdoZW4gem9vbSBvciBwYW5uaW5nIGNoYW5nZS5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIHNldENvb3Jkcy5cbiAgICAgKiBZb3UgY2FuIGNhbGN1bGF0ZSB0aGVtIHdpdGhvdXQgdXBkYXRpbmcgd2l0aCBAbWV0aG9kIGNhbGNDb29yZHModHJ1ZSk7XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgYUNvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHN0b3JhZ2UgZm9yIG9iamVjdCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgb3duTWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgZnVsbCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgbWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gY29ycmVjdCBzZXQgb2YgY29vcmRpbmF0ZXMgZm9yIGludGVyc2VjdGlvblxuICAgICAqL1xuICAgIGdldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLm9Db29yZHMpIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29yZHMgPSBhYnNvbHV0ZSA/IHRoaXMuYUNvb3JkcyA6IHRoaXMub0Nvb3JkcztcbiAgICAgIHJldHVybiBnZXRDb29yZHMoY2FsY3VsYXRlID8gdGhpcy5jYWxjQ29vcmRzKGFic29sdXRlKSA6IGNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhSZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgcG9pbnRUTCxcbiAgICAgICAgICAgIHBvaW50QlJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24oXG4gICAgICAgIHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICBvdGhlci5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJ1xuICAgICAgICB8fCBvdGhlci5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgICB8fCB0aGlzLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpbk9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBpID0gMCwgbGluZXMgPSBvdGhlci5fZ2V0SW1hZ2VMaW5lcyhcbiAgICAgICAgICAgIGNhbGN1bGF0ZSA/IG90aGVyLmNhbGNDb29yZHMoYWJzb2x1dGUpIDogYWJzb2x1dGUgPyBvdGhlci5hQ29vcmRzIDogb3RoZXIub0Nvb3Jkc1xuICAgICAgICAgICk7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZiAoIW90aGVyLmNvbnRhaW5zUG9pbnQocG9pbnRzW2ldLCBsaW5lcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5SZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ID49IHBvaW50VEwueCAmJlxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCArIGJvdW5kaW5nUmVjdC53aWR0aCA8PSBwb2ludEJSLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCA+PSBwb2ludFRMLnkgJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQgPD0gcG9pbnRCUi55XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGluZXNdIG9iamVjdCByZXR1cm5lZCBmcm9tIEBtZXRob2QgX2dldEltYWdlTGluZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQsIGxpbmVzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgbGluZXMgPSBsaW5lcyB8fCB0aGlzLl9nZXRJbWFnZUxpbmVzKFxuICAgICAgICAgICAgY2FsY3VsYXRlID8gdGhpcy5jYWxjQ29vcmRzKGFic29sdXRlKSA6IGFic29sdXRlID8gdGhpcy5hQ29vcmRzIDogdGhpcy5vQ29vcmRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHBvaW50LCBsaW5lcyk7XG5cbiAgICAgIC8vIGlmIHhQb2ludHMgaXMgb2RkIHRoZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgIHJldHVybiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIHRoZSBjaGVjayBpcyBkb25lIHN0b3BwaW5nIGF0IGZpcnN0IHBvaW50IHRoYXQgYXBwZWFycyBvbiBzY3JlZW5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBvciBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiBjYW52YXNcbiAgICAgKi9cbiAgICBpc09uU2NyZWVuOiBmdW5jdGlvbihjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50VEwgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMudGwsIHBvaW50QlIgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMuYnI7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHModHJ1ZSwgY2FsY3VsYXRlKSwgcG9pbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgaWYgKHBvaW50LnggPD0gcG9pbnRCUi54ICYmIHBvaW50LnggPj0gcG9pbnRUTC54ICYmIHBvaW50LnkgPD0gcG9pbnRCUi55ICYmIHBvaW50LnkgPj0gcG9pbnRUTC55KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vIHBvaW50cyBvbiBzY3JlZW4sIGNoZWNrIGludGVyc2VjdGlvbiB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QocG9pbnRUTCwgcG9pbnRCUiwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluc0NlbnRlck9mQ2FudmFzKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBtaWRwb2ludCBiZXR3ZWVuIGNhbnZhcyBleHRyZW1pdGllc1xuICAgICAqIERvZXMgbm90IG1ha2Ugc2Vuc2Ugb3V0c2lkZSB0aGUgY29udGV4dCBvZiBpc09uU2NyZWVuIGFuZCBpc1BhcnRpYWxseU9uU2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRUTCBUb3AgTGVmdCBwb2ludFxuICAgICAqIEBwYXJhbSB7RmFicmljLlBvaW50fSBwb2ludEJSIFRvcCBSaWdodCBwb2ludFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FsY3VsYXRlIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3RzIGNvbnRhaW5lIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9jb250YWluc0NlbnRlck9mQ2FudmFzOiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpIHtcbiAgICAgIC8vIHdvcnN0IGNhc2Ugc2NlbmFyaW8gdGhlIG9iamVjdCBpcyBzbyBiaWcgdGhhdCBjb250YWlucyB0aGUgc2NyZWVuXG4gICAgICB2YXIgY2VudGVyUG9pbnQgPSB7IHg6IChwb2ludFRMLnggKyBwb2ludEJSLngpIC8gMiwgeTogKHBvaW50VEwueSArIHBvaW50QlIueSkgLyAyIH07XG4gICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KGNlbnRlclBvaW50LCBudWxsLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNQYXJ0aWFsbHlPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudHJcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50cixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJyXG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbWxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYmxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJlaW5nIGV2YWx1YXRlZFxuICAgICAqL1xuICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgbGluZXMpIHtcbiAgICAgIHZhciBiMSwgYjIsIGExLCBhMiwgeGksIC8vIHlpLFxuICAgICAgICAgIHhjb3VudCA9IDAsXG4gICAgICAgICAgaUxpbmU7XG5cbiAgICAgIGZvciAodmFyIGxpbmVLZXkgaW4gbGluZXMpIHtcbiAgICAgICAgaUxpbmUgPSBsaW5lc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogdGhlIGJveCBpcyBpbnRlbnRlZCBhcyBhbGlnbmVkIHRvIGF4aXMgb2YgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3JkcyAvIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMoY29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldFdpZHRoKCk7XG4gICAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlaWdodCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldEhlaWdodCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2NhbGVkSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBzY2FsZSBpcyB2YWxpZCBhbmQgbW9kaWZpZXMgaXQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgX2NvbnN0cmFpblNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IHRoaXMubWluU2NhbGVMaW1pdCkge1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCAoZXF1YWxseSBieSB4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBTY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVgnLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9zZXQoJ3NjYWxlWScsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gd2lkdGgsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyB3aWR0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvV2lkdGg6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkud2lkdGggLyB0aGlzLmdldFNjYWxlZFdpZHRoKCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMud2lkdGggLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gaGVpZ2h0LCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgaGVpZ2h0IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSBpZ25vcmUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9IZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkuaGVpZ2h0IC8gdGhpcy5nZXRTY2FsZWRIZWlnaHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy5oZWlnaHQgLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYW5kIHJldHVybnMgdGhlIC5jb29yZHMgb2YgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggdGwsIHRyLCBiciwgYmwgLi4uLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjQ29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSkge1xuICAgICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgc3RhcnRNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRyYW5zbGF0ZU1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBhYnNvbHV0ZSA/IHN0YXJ0TWF0cml4IDogbXVsdGlwbHlNYXRyaWNlcyh2cHQsIHN0YXJ0TWF0cml4KSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3ID0gZGltLnggLyAyLCBoID0gZGltLnkgLyAyLFxuICAgICAgICAgIHRsID0gdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICAgIHRyID0gdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgICAgYmwgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiBoIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgICBiciA9IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogaCB9LCBmaW5hbE1hdHJpeCk7XG4gICAgICBpZiAoIWFic29sdXRlKSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5wYWRkaW5nLCBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYW5nbGUpLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgY29zUCA9IGNvcyAqIHBhZGRpbmcsIHNpblAgPSBzaW4gKiBwYWRkaW5nLCBjb3NQU2luUCA9IGNvc1AgKyBzaW5QLFxuICAgICAgICAgICAgY29zUE1pbnVzU2luUCA9IGNvc1AgLSBzaW5QO1xuICAgICAgICBpZiAocGFkZGluZykge1xuICAgICAgICAgIHRsLnggLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgICB0bC55IC09IGNvc1BTaW5QO1xuICAgICAgICAgIHRyLnggKz0gY29zUFNpblA7XG4gICAgICAgICAgdHIueSAtPSBjb3NQTWludXNTaW5QO1xuICAgICAgICAgIGJsLnggLT0gY29zUFNpblA7XG4gICAgICAgICAgYmwueSArPSBjb3NQTWludXNTaW5QO1xuICAgICAgICAgIGJyLnggKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgICBici55ICs9IGNvc1BTaW5QO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtbCAgPSBuZXcgZmFicmljLlBvaW50KCh0bC54ICsgYmwueCkgLyAyLCAodGwueSArIGJsLnkpIC8gMiksXG4gICAgICAgICAgICBtdCAgPSBuZXcgZmFicmljLlBvaW50KCh0ci54ICsgdGwueCkgLyAyLCAodHIueSArIHRsLnkpIC8gMiksXG4gICAgICAgICAgICBtciAgPSBuZXcgZmFicmljLlBvaW50KChici54ICsgdHIueCkgLyAyLCAoYnIueSArIHRyLnkpIC8gMiksXG4gICAgICAgICAgICBtYiAgPSBuZXcgZmFicmljLlBvaW50KChici54ICsgYmwueCkgLyAyLCAoYnIueSArIGJsLnkpIC8gMiksXG4gICAgICAgICAgICBtdHIgPSBuZXcgZmFicmljLlBvaW50KG10LnggKyBzaW4gKiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQsIG10LnkgLSBjb3MgKiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiAoIWFic29sdXRlKSB7XG4gICAgICAvLyAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIC8vICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgICBjYW52YXMuY29udGV4dFRvcC5jbGVhclJlY3QoMCwgMCwgNzAwLCA3MDApO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobWIueCwgbWIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoYmwueCwgYmwueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoYnIueCwgYnIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QodGwueCwgdGwueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QodHIueCwgdHIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobWwueCwgbWwueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXIueCwgbXIueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXQueCwgbXQueSwgMywgMyk7XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobXRyLngsIG10ci55LCAzLCAzKTtcbiAgICAgIC8vICAgfSwgNTApO1xuICAgICAgLy8gfVxuXG4gICAgICB2YXIgY29vcmRzID0ge1xuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHRsOiB0bCwgdHI6IHRyLCBicjogYnIsIGJsOiBibCxcbiAgICAgIH07XG4gICAgICBpZiAoIWFic29sdXRlKSB7XG4gICAgICAgIC8vIG1pZGRsZVxuICAgICAgICBjb29yZHMubWwgPSBtbDtcbiAgICAgICAgY29vcmRzLm10ID0gbXQ7XG4gICAgICAgIGNvb3Jkcy5tciA9IG1yO1xuICAgICAgICBjb29yZHMubWIgPSBtYjtcbiAgICAgICAgLy8gcm90YXRpbmcgcG9pbnRcbiAgICAgICAgY29vcmRzLm10ciA9IG10cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29ybmVyIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGN1cnJlbnQgYW5nbGUsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvd2lraS9XaGVuLXRvLWNhbGwtc2V0Q29vcmRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlWm9vbV0gc2V0IG9Db29yZHMgd2l0aCBvciB3aXRob3V0IHRoZSB2aWV3cG9ydCB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEFic29sdXRlXSBza2lwIGNhbGN1bGF0aW9uIG9mIGFDb29yZHMsIHVzZWZ1bGwgaW4gc2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvb3JkczogZnVuY3Rpb24oaWdub3JlWm9vbSwgc2tpcEFic29sdXRlKSB7XG4gICAgICB0aGlzLm9Db29yZHMgPSB0aGlzLmNhbGNDb29yZHMoaWdub3JlWm9vbSk7XG4gICAgICBpZiAoIXNraXBBYnNvbHV0ZSkge1xuICAgICAgICB0aGlzLmFDb29yZHMgPSB0aGlzLmNhbGNDb29yZHModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIHVzZWQgdG8gc2NhbGUvcm90YXRlIHRoZSBpbWFnZVxuICAgICAgaWdub3JlWm9vbSB8fCAodGhpcy5fc2V0Q29ybmVyQ29vcmRzICYmIHRoaXMuX3NldENvcm5lckNvb3JkcygpKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSByb3RhdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksIGNvcyA9IGZhYnJpYy51dGlsLmNvcyh0aGV0YSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbih0aGV0YSk7XG4gICAgICAgIHJldHVybiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb24gbWF0cml4IGZvciBhbiBvYmplY3QgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjVHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIGNlbnRlci54LCBjZW50ZXIueV07XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hdHJpeEtleTogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgc2VwID0gJ18nLCBwcmVmaXggPSAnJztcbiAgICAgIGlmICghc2tpcEdyb3VwICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSArIHNlcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHJlZml4ICsgdGhpcy50b3AgKyBzZXAgKyB0aGlzLmxlZnQgKyBzZXAgKyB0aGlzLnNjYWxlWCArIHNlcCArIHRoaXMuc2NhbGVZICtcbiAgICAgICAgc2VwICsgdGhpcy5za2V3WCArIHNlcCArIHRoaXMuc2tld1kgKyBzZXAgKyB0aGlzLmFuZ2xlICsgc2VwICsgdGhpcy5vcmlnaW5YICsgc2VwICsgdGhpcy5vcmlnaW5ZICtcbiAgICAgICAgc2VwICsgdGhpcy53aWR0aCArIHNlcCArIHRoaXMuaGVpZ2h0ICsgc2VwICsgdGhpcy5zdHJva2VXaWR0aCArIHRoaXMuZmxpcFggKyB0aGlzLmZsaXBZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhc2Zvcm0gTWF0cml4IHRoYXQgcmVwcmVzZW50IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gZnJvbVxuICAgICAqIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBHcm91cF0gcmV0dXJuIHRyYW5zZm9ybU1hdHJpeCBmb3Igb2JqZWN0IGFuZCBub3QgZ28gdXB3YXJkIHdpdGggcGFyZW50c1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBtYXRyaXggVHJhbnNmb3JtIE1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgaWYgKHNraXBHcm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkoKSwgY2FjaGUgPSB0aGlzLm1hdHJpeENhY2hlIHx8ICh0aGlzLm1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCksIG1hdHJpeCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIGNhbGNPd25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHRydWUpLCBjYWNoZSA9IHRoaXMub3duTWF0cml4Q2FjaGUgfHwgKHRoaXMub3duTWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICByb3RhdGVNYXRyaXgsXG4gICAgICAgICAgZGltZW5zaW9uTWF0cml4ID0gdGhpcy5fY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXgodGhpcy5za2V3WCwgdGhpcy5za2V3WSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCk7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMobWF0cml4LCByb3RhdGVNYXRyaXgpO1xuICAgICAgfVxuICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGRpbWVuc2lvbk1hdHJpeCk7XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIF9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oc2tld1gsIHNrZXdZLCBmbGlwcGluZykge1xuICAgICAgdmFyIHNrZXdNYXRyaXgsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVggKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWCA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVkgKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWSA/IC0xIDogMSksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIDAsIDBdO1xuICAgICAgaWYgKHNrZXdYKSB7XG4gICAgICAgIHNrZXdNYXRyaXggPSBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhza2V3WCkpLCAxXTtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHNjYWxlTWF0cml4LCBza2V3TWF0cml4LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChza2V3WSkge1xuICAgICAgICBza2V3TWF0cml4ID0gWzEsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMoc2tld1kpKSwgMCwgMV07XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhzY2FsZU1hdHJpeCwgc2tld01hdHJpeCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGVNYXRyaXg7XG4gICAgfSxcblxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2dldFRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG4gICAgICBpZiAodHlwZW9mIHNrZXdYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNrZXdZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WSA9IHRoaXMuc2tld1k7XG4gICAgICB9XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgaWYgKHNrZXdYID09PSAwICYmIHNrZXdZID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IGRpbWVuc2lvbnMueCAqIHRoaXMuc2NhbGVYLCB5OiBkaW1lbnNpb25zLnkgKiB0aGlzLnNjYWxlWSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRpbVggPSBkaW1lbnNpb25zLnggLyAyLCBkaW1ZID0gZGltZW5zaW9ucy55IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICBpLCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeChza2V3WCwgc2tld1ksIGZhbHNlKSxcbiAgICAgICAgICBiYm94O1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICBiYm94ID0gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhwb2ludHMpO1xuICAgICAgcmV0dXJuIHsgeDogYmJveC53aWR0aCwgeTogYmJveC5oZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZm9yIGNvbnRyb2xzLiBpbmNsdWRlIHBhZGRpbmcgYW5kIGNhbnZhcyB6b29tXG4gICAgICogcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSAge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoZGltLCB2cHQsIHRydWUpO1xuXG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuc2VuZFRvQmFjayh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdUb0Zyb250LmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ0ZvcndhcmQodGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggTmV3IHBvc2l0aW9uIG9mIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIG1vdmVUbzogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgIT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5tb3ZlVG8uY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuXG4gICAgICB2YXIgZmlsbFJ1bGUgPSB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCA/IHRoaXMuc3Ryb2tlV2lkdGggOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gdGhpcy5zdHJva2VEYXNoQXJyYXkgPyB0aGlzLnN0cm9rZURhc2hBcnJheS5qb2luKCcgJykgOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6ICdidXR0JyxcbiAgICAgICAgICBzdHJva2VMaW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4gPyB0aGlzLnN0cm9rZUxpbmVKb2luIDogJ21pdGVyJyxcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0ID8gdGhpcy5zdHJva2VNaXRlckxpbWl0IDogJzQnLFxuICAgICAgICAgIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3BhY2l0eSA6ICcxJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuICAgICAgICAgIGZpbHRlciA9IHNraXBTaGFkb3cgPyAnJyA6IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgZmlsbCA9IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgdGhpcy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgdGhpcy5zdHJva2UpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgICdzdHJva2Utd2lkdGg6ICcsIHN0cm9rZVdpZHRoLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheTogJywgc3Ryb2tlRGFzaEFycmF5LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXA6ICcsIHN0cm9rZUxpbmVDYXAsICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW46ICcsIHN0cm9rZUxpbmVKb2luLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQ6ICcsIHN0cm9rZU1pdGVyTGltaXQsICc7ICcsXG4gICAgICAgIGZpbGwsXG4gICAgICAgICdmaWxsLXJ1bGU6ICcsIGZpbGxSdWxlLCAnOyAnLFxuICAgICAgICAnb3BhY2l0eTogJywgb3BhY2l0eSwgJzsnLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlV2hpdGVTcGFjZSBhIGJvb2xlYW4gdG8gaW5jbHVkZSBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBpbiB0aGUgc3R5bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1NwYW5TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlLCB1c2VXaGl0ZVNwYWNlKSB7XG4gICAgICB2YXIgdGVybSA9ICc7ICc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgP1xuICAgICAgICAnZm9udC1mYW1pbHk6ICcgKyAoKChzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1xcJycpID09PSAtMSAmJiBzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1wiJykgPT09IC0xKSA/XG4gICAgICAgICAgJ1xcJycgKyBzdHlsZS5mb250RmFtaWx5ICArICdcXCcnIDogc3R5bGUuZm9udEZhbWlseSkpICsgdGVybSA6ICcnO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGggPyAnc3Ryb2tlLXdpZHRoOiAnICsgc3R5bGUuc3Ryb2tlV2lkdGggKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSA/ICdmb250LXNpemU6ICcgKyBzdHlsZS5mb250U2l6ZSArICdweCcgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU6ICcgKyBzdHlsZS5mb250U3R5bGUgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ6ICcgKyBzdHlsZS5mb250V2VpZ2h0ICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZpbGwgPSBzdHlsZS5maWxsID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCBzdHlsZS5maWxsKSA6ICcnLFxuICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLnN0cm9rZSA/IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCBzdHlsZS5zdHJva2UpIDogJycsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHN0eWxlKSxcbiAgICAgICAgICBkZWx0YVkgPSBzdHlsZS5kZWx0YVkgPyAnYmFzZWxpbmUtc2hpZnQ6ICcgKyAoLXN0eWxlLmRlbHRhWSkgKyAnOyAnIDogJyc7XG4gICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgdGV4dERlY29yYXRpb24gPSAndGV4dC1kZWNvcmF0aW9uOiAnICsgdGV4dERlY29yYXRpb24gKyB0ZXJtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0LFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZGVsdGFZLFxuICAgICAgICB1c2VXaGl0ZVNwYWNlID8gJ3doaXRlLXNwYWNlOiBwcmU7ICcgOiAnJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0LWRlY29yYXRpb24gcHJvcGVydHkgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICBpZiAoJ292ZXJsaW5lJyBpbiBzdHlsZSB8fCAndW5kZXJsaW5lJyBpbiBzdHlsZSB8fCAnbGluZXRocm91Z2gnIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiAoc3R5bGUub3ZlcmxpbmUgPyAnb3ZlcmxpbmUgJyA6ICcnKSArXG4gICAgICAgICAgKHN0eWxlLnVuZGVybGluZSA/ICd1bmRlcmxpbmUgJyA6ICcnKSArIChzdHlsZS5saW5ldGhyb3VnaCA/ICdsaW5lLXRocm91Z2ggJyA6ICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWx0ZXIgZm9yIHN2ZyBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRvdyA/ICdmaWx0ZXI6IHVybCgjU1ZHSURfJyArIHRoaXMuc2hhZG93LmlkICsgJyk7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlkIGF0dHJpYnV0ZSBmb3Igc3ZnIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdJZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZCA/ICdpZD1cIicgKyB0aGlzLmlkICsgJ1wiICcgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cmFuc2Zvcm0tc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1RyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlLFxuICAgICAgICAgIHNrZXdYID0gKHRoaXMuc2tld1ggJSAzNjApLFxuICAgICAgICAgIHNrZXdZID0gKHRoaXMuc2tld1kgJSAzNjApLFxuICAgICAgICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcblxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG5cbiAgICAgICAgICB0cmFuc2xhdGVQYXJ0ID0gJ3RyYW5zbGF0ZSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKGNlbnRlci54LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKGNlbnRlci55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICAgIGFuZ2xlUGFydCA9IGFuZ2xlICE9PSAwXG4gICAgICAgICAgICA/ICgnIHJvdGF0ZSgnICsgdG9GaXhlZChhbmdsZSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnKScpXG4gICAgICAgICAgICA6ICcnLFxuXG4gICAgICAgICAgc2NhbGVQYXJ0ID0gKHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxKVxuICAgICAgICAgICAgPyAnJyA6XG4gICAgICAgICAgICAoJyBzY2FsZSgnICtcbiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgICAnKScpLFxuXG4gICAgICAgICAgc2tld1hQYXJ0ID0gc2tld1ggIT09IDAgPyAnIHNrZXdYKCcgKyB0b0ZpeGVkKHNrZXdYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcpJyA6ICcnLFxuXG4gICAgICAgICAgc2tld1lQYXJ0ID0gc2tld1kgIT09IDAgPyAnIHNrZXdZKCcgKyB0b0ZpeGVkKHNrZXdZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcpJyA6ICcnLFxuXG4gICAgICAgICAgZmxpcFhQYXJ0ID0gdGhpcy5mbGlwWCA/ICcgbWF0cml4KC0xIDAgMCAxIDAgMCkgJyA6ICcnLFxuXG4gICAgICAgICAgZmxpcFlQYXJ0ID0gdGhpcy5mbGlwWSA/ICcgbWF0cml4KDEgMCAwIC0xIDAgMCknIDogJyc7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zbGF0ZVBhcnQsIGFuZ2xlUGFydCwgc2NhbGVQYXJ0LCBmbGlwWFBhcnQsIGZsaXBZUGFydCwgc2tld1hQYXJ0LCBza2V3WVBhcnRcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhbnNmb3JtLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCBmcm9tIHRoZSB0cmFuc2Zvcm0gbWF0cml4IG9mIHNpbmdsZSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWF0cml4ID8gJyBtYXRyaXgoJyArIHRoaXMudHJhbnNmb3JtTWF0cml4LmpvaW4oJyAnKSArICcpICcgOiAnJztcbiAgICB9LFxuXG4gICAgX3NldFNWR0JnOiBmdW5jdGlvbih0ZXh0QmdSZWN0cykge1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKHRoaXMuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICAnIHg9XCInLFxuICAgICAgICAgIHRvRml4ZWQoLXRoaXMud2lkdGggLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5oZWlnaHQgLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZVNWR01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIGlmICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvTGl2ZSkge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLmZpbGwudG9TVkcodGhpcywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpcy5zdHJva2UudG9TVkcodGhpcywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzLnNoYWRvdy50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICBhZGRQYWludE9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJyA/ICcgcGFpbnQtb3JkZXI9XCInICsgdGhpcy5wYWludEZpcnN0ICsgJ1wiICcgOiAnJztcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmIChvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdHMgYXJlIGlkZW50aWNhbCwgcmV0dXJuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnVmFsdWUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSB8fCBvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVbaV0sIGN1cnJlbnRWYWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgJiYgdHlwZW9mIG9yaWdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3JpZ1ZhbHVlKSwga2V5O1xuICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHxcbiAgICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICghZmlyc3RQYXNzICYmIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjdXJyZW50VmFsdWUpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtrZXldLCBjdXJyZW50VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHN0YXRlIChvbmUgb2YgaXRzIHN0YXRlIHByb3BlcnRpZXMpIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eVNldF0gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHNldCBvZiBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNhdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGluc3RhbmNlJyBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSBge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2F2ZVN0YXRlfWAgd2FzIGNhbGxlZFxuICAgICAqL1xuICAgIGhhc1N0YXRlQ2hhbmdlZDogZnVuY3Rpb24ocHJvcGVydHlTZXQpIHtcbiAgICAgIHByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICB2YXIgZGFzaGVkUHJvcGVydHlTZXQgPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSkubGVuZ3RoIDwgdGhpc1twcm9wZXJ0eVNldF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFfaXNFcXVhbCh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uID0gJ18nICsgcHJvcGVydHlTZXQ7XG4gICAgICBpZiAoIXRoaXNbZGVzdGluYXRpb25dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwU3RhdGUob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIHRoaXNbcHJvcGVydHlTZXRdKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXR1cFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgb3B0aW9ucy5wcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0O1xuICAgICAgdGhpc1snXycgKyBwcm9wZXJ0eVNldF0gPSB7IH07XG4gICAgICB0aGlzLnNhdmVTdGF0ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IGludGVyYWN0aXZpdHkgY29udHJvbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29udHJvbHNWaXNpYmlsaXR5OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGljaCBjb3JuZXIgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgVGhlIHBvaW50ZXIgaW5kaWNhdGluZyB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn0gY29ybmVyIGNvZGUgKHRsLCB0ciwgYmwsIGJyLCBldGMuKSwgb3IgZmFsc2UgaWYgbm90aGluZyBpcyBmb3VuZFxuICAgICAqL1xuICAgIF9maW5kVGFyZ2V0Q29ybmVyOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICAvLyBvYmplY3RzIGluIGdyb3VwLCBhbnlraW5kLCBhcmUgbm90IHNlbGYgbW9kaWZpY2FibGUsXG4gICAgICAvLyBtdXN0IG5vdCByZXR1cm4gYW4gaG92ZXJlZCBjb3JuZXIuXG4gICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMgfHwgdGhpcy5ncm91cCB8fCAoIXRoaXMuY2FudmFzIHx8IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ID0gcG9pbnRlci54LFxuICAgICAgICAgIGV5ID0gcG9pbnRlci55LFxuICAgICAgICAgIHhQb2ludHMsXG4gICAgICAgICAgbGluZXM7XG4gICAgICB0aGlzLl9fY29ybmVyID0gMDtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vQ29vcmRzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udHJvbFZpc2libGUoaSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09PSAnbXRyJyAmJiAhdGhpcy5oYXNSb3RhdGluZ1BvaW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nZXQoJ2xvY2tVbmlTY2FsaW5nJykgJiZcbiAgICAgICAgICAgKGkgPT09ICdtdCcgfHwgaSA9PT0gJ21yJyB8fCBpID09PSAnbWInIHx8IGkgPT09ICdtbCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IHRoaXMuX2dldEltYWdlTGluZXModGhpcy5vQ29vcmRzW2ldLmNvcm5lcik7XG5cbiAgICAgICAgLy8gZGVidWdnaW5nXG5cbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLm8ueCwgbGluZXMubGVmdGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLmQueCwgbGluZXMudG9wbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIC8vIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHsgeDogZXgsIHk6IGV5IH0sIGxpbmVzKTtcbiAgICAgICAgaWYgKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fY29ybmVyID0gaTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIG9mXG4gICAgICogdGhlIGltYWdlIHVzZWQgdG8gc2NhbGUvcm90YXRlIGl0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldENvcm5lckNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5vQ29vcmRzLFxuICAgICAgICAgIG5ld1RoZXRhID0gZGVncmVlc1RvUmFkaWFucyg0NSAtIHRoaXMuYW5nbGUpLFxuICAgICAgICAgIC8qIE1hdGguc3FydCgyICogTWF0aC5wb3codGhpcy5jb3JuZXJTaXplLCAyKSkgLyAyLCAqL1xuICAgICAgICAgIC8qIDAuNzA3MTA2IHN0YW5kcyBmb3Igc3FydCgyKS8yICovXG4gICAgICAgICAgY29ybmVySHlwb3RlbnVzZSA9IHRoaXMuY29ybmVyU2l6ZSAqIDAuNzA3MTA2LFxuICAgICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKSxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YSksXG4gICAgICAgICAgeCwgeTtcblxuICAgICAgZm9yICh2YXIgcG9pbnQgaW4gY29vcmRzKSB7XG4gICAgICAgIHggPSBjb29yZHNbcG9pbnRdLng7XG4gICAgICAgIHkgPSBjb29yZHNbcG9pbnRdLnk7XG4gICAgICAgIGNvb3Jkc1twb2ludF0uY29ybmVyID0ge1xuICAgICAgICAgIHRsOiB7XG4gICAgICAgICAgICB4OiB4IC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgLSBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cjoge1xuICAgICAgICAgICAgeDogeCArIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgICB5OiB5IC0gc2luSGFsZk9mZnNldFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmw6IHtcbiAgICAgICAgICAgIHg6IHggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgICAgeTogeSArIHNpbkhhbGZPZmZzZXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJyOiB7XG4gICAgICAgICAgICB4OiB4ICsgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICAgIHk6IHkgKyBjb3NIYWxmT2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3QsIGluc2lkZSBpdHMgc2VsZWN0aW9uIGJvcmRlcnMuXG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgdHJhbnNmb3JtZWRcbiAgICAgKiBoYXMgY2hlY2tzIHRvIGJlIHNraXBwZWQgd2hlbiB0aGUgb2JqZWN0IGlzIG9uIGEgc3RhdGljQ2FudmFzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmICF0aGlzLmNhbnZhcy5pbnRlcmFjdGl2ZSkgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB2cHRbMF0sIDEgLyB2cHRbM10pO1xuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgtd2gueCAvIDIsIC13aC55IC8gMiwgd2gueCwgd2gueSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gMSAvIHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPSB3aC54ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGRyYXdSb3RhdGluZ1BvaW50ID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzUm90YXRpbmdQb2ludCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZS5oYXNSb3RhdGluZ1BvaW50IDogdGhpcy5oYXNSb3RhdGluZ1BvaW50LFxuICAgICAgICAgIGhhc0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICAgIHJvdGF0aW5nUG9pbnRPZmZzZXQgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5yb3RhdGluZ1BvaW50T2Zmc2V0ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLnJvdGF0aW5nUG9pbnRPZmZzZXQgOiB0aGlzLnJvdGF0aW5nUG9pbnRPZmZzZXQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuYm9yZGVyRGFzaEFycmF5IHx8IHRoaXMuYm9yZGVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAoZHJhd1JvdGF0aW5nUG9pbnQgJiYgdGhpcy5pc0NvbnRyb2xWaXNpYmxlKCdtdHInKSAmJiBoYXNDb250cm9scykge1xuXG4gICAgICAgIHZhciByb3RhdGVIZWlnaHQgPSAtaGVpZ2h0IC8gMjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgcm90YXRlSGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCByb3RhdGVIZWlnaHQgLSByb3RhdGluZ1BvaW50T2Zmc2V0KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyc0luR3JvdXA6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgcCA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIG1hdHJpeCA9IGZhYnJpYy51dGlsLmN1c3RvbVRyYW5zZm9ybU1hdHJpeChvcHRpb25zLnNjYWxlWCwgb3B0aW9ucy5zY2FsZVksIG9wdGlvbnMuc2tld1gpLFxuICAgICAgICAgIHdoID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbWF0cml4KSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IDEgLyB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHdoLnkgKyBzdHJva2VXaWR0aDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXksIG51bGwpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuXG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29ybmVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogY29ybmVyU2l6ZSwgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciB3aCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgd2lkdGggPSB3aC54LFxuICAgICAgICAgIGhlaWdodCA9IHdoLnksXG4gICAgICAgICAgc2NhbGVPZmZzZXQgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgdGhpcy5jb3JuZXJTaXplLFxuICAgICAgICAgIGxlZnQgPSAtKHdpZHRoICsgc2NhbGVPZmZzZXQpIC8gMixcbiAgICAgICAgICB0b3AgPSAtKGhlaWdodCArIHNjYWxlT2Zmc2V0KSAvIDIsXG4gICAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyA6IHRoaXMudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICAgIGhhc1JvdGF0aW5nUG9pbnQgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNSb3RhdGluZ1BvaW50ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgOiB0aGlzLmhhc1JvdGF0aW5nUG9pbnQsXG4gICAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgdGhpcy5jb3JuZXJDb2xvcjtcbiAgICAgIGlmICghdGhpcy50cmFuc3BhcmVudENvcm5lcnMpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCB0aGlzLmNvcm5lclN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmNvcm5lckRhc2hBcnJheSB8fCB0aGlzLmNvcm5lckRhc2hBcnJheSwgbnVsbCk7XG5cbiAgICAgIC8vIHRvcC1sZWZ0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgndGwnLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIC8vIHRvcC1yaWdodFxuICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ3RyJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICBsZWZ0ICsgd2lkdGgsXG4gICAgICAgIHRvcCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIC8vIGJvdHRvbS1sZWZ0XG4gICAgICB0aGlzLl9kcmF3Q29udHJvbCgnYmwnLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcCArIGhlaWdodCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIC8vIGJvdHRvbS1yaWdodFxuICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ2JyJywgY3R4LCBtZXRob2ROYW1lLFxuICAgICAgICBsZWZ0ICsgd2lkdGgsXG4gICAgICAgIHRvcCArIGhlaWdodCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgIGlmICghdGhpcy5nZXQoJ2xvY2tVbmlTY2FsaW5nJykpIHtcblxuICAgICAgICAvLyBtaWRkbGUtdG9wXG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtdCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCwgc3R5bGVPdmVycmlkZSk7XG5cbiAgICAgICAgLy8gbWlkZGxlLWJvdHRvbVxuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbWInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCArIHdpZHRoIC8gMixcbiAgICAgICAgICB0b3AgKyBoZWlnaHQsIHN0eWxlT3ZlcnJpZGUpO1xuXG4gICAgICAgIC8vIG1pZGRsZS1yaWdodFxuICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCgnbXInLCBjdHgsIG1ldGhvZE5hbWUsXG4gICAgICAgICAgbGVmdCArIHdpZHRoLFxuICAgICAgICAgIHRvcCArIGhlaWdodCAvIDIsIHN0eWxlT3ZlcnJpZGUpO1xuXG4gICAgICAgIC8vIG1pZGRsZS1sZWZ0XG4gICAgICAgIHRoaXMuX2RyYXdDb250cm9sKCdtbCcsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCArIGhlaWdodCAvIDIsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBtaWRkbGUtdG9wLXJvdGF0ZVxuICAgICAgaWYgKGhhc1JvdGF0aW5nUG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2woJ210cicsIGN0eCwgbWV0aG9kTmFtZSxcbiAgICAgICAgICBsZWZ0ICsgd2lkdGggLyAyLFxuICAgICAgICAgIHRvcCAtIHRoaXMucm90YXRpbmdQb2ludE9mZnNldCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmF3Q29udHJvbDogZnVuY3Rpb24oY29udHJvbCwgY3R4LCBtZXRob2ROYW1lLCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgaWYgKCF0aGlzLmlzQ29udHJvbFZpc2libGUoY29udHJvbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNpemUgPSB0aGlzLmNvcm5lclNpemUsIHN0cm9rZSA9ICF0aGlzLnRyYW5zcGFyZW50Q29ybmVycyAmJiB0aGlzLmNvcm5lclN0cm9rZUNvbG9yO1xuICAgICAgc3dpdGNoIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0eWxlIHx8IHRoaXMuY29ybmVyU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgc2l6ZSAvIDIsIHRvcCArIHNpemUgLyAyLCBzaXplIC8gMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICBjdHhbbWV0aG9kTmFtZV0oKTtcbiAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnRDb3JuZXJzIHx8IGN0eC5jbGVhclJlY3QobGVmdCwgdG9wLCBzaXplLCBzaXplKTtcbiAgICAgICAgICBjdHhbbWV0aG9kTmFtZSArICdSZWN0J10obGVmdCwgdG9wLCBzaXplLCBzaXplKTtcbiAgICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChsZWZ0LCB0b3AsIHNpemUsIHNpemUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xOYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0NvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRyb2xzVmlzaWJpbGl0eSgpW2NvbnRyb2xOYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xOYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSB0cnVlIHRvIHNldCB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbE5hbWUsIHZpc2libGUpIHtcbiAgICAgIHRoaXMuX2dldENvbnRyb2xzVmlzaWJpbGl0eSgpW2NvbnRyb2xOYW1lXSA9IHZpc2libGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiBvYmplY3QgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmxdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5icl0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1ib3R0b20gY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWxdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tcl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3AgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGxdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cl0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdHJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wLXJvdGF0ZSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRDb250cm9sVmlzaWJsZShwLCBvcHRpb25zW3BdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgY29udHJvbCB2aXNpYmlsaXR5IHNldCBmb3IgdGhpcyBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5ID0ge1xuICAgICAgICAgIHRsOiB0cnVlLFxuICAgICAgICAgIHRyOiB0cnVlLFxuICAgICAgICAgIGJyOiB0cnVlLFxuICAgICAgICAgIGJsOiB0cnVlLFxuICAgICAgICAgIG1sOiB0cnVlLFxuICAgICAgICAgIG10OiB0cnVlLFxuICAgICAgICAgIG1yOiB0cnVlLFxuICAgICAgICAgIG1iOiB0cnVlLFxuICAgICAgICAgIG10cjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIGRlc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIHNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25TZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQW5pbWF0aW9uIGR1cmF0aW9uIChpbiBtcykgZm9yIGZ4KiBtZXRob2RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRlhfRFVSQVRJT046IDUwMCxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeENlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QubGVmdCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLmxlZnQsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdsZWZ0JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0VjogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC50b3AsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXIoKS50b3AsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCd0b3AnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgZmFicmljLkNhbnZhcyNyZW1vdmVgIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFJlbW92ZTogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5vcGFjaXR5LFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEFuaW1hdGVzIG9iamVjdCdzIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlIChpZiBzdHJpbmcpIG9yIHByb3BlcnRpZXMgdG8gYW5pbWF0ZSAoaWYgb2JqZWN0KVxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGFuaW1hdGUgcHJvcGVydHkgdG8gKGlmIHN0cmluZyB3YXMgZ2l2ZW4gZmlyc3QpIG9yIG9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjYW5pbWF0aW9ufVxuICAgKiBAY2hhaW5hYmxlXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcHJvcHNUb0FuaW1hdGUgPSBbXSwgcHJvcCwgc2tpcENhbGxiYWNrcztcbiAgICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgcHJvcHNUb0FuaW1hdGUucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wc1RvQW5pbWF0ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wID0gcHJvcHNUb0FuaW1hdGVbaV07XG4gICAgICAgIHNraXBDYWxsYmFja3MgPSBpICE9PSBsZW4gLSAxO1xuICAgICAgICB0aGlzLl9hbmltYXRlKHByb3AsIGFyZ3VtZW50c1swXVtwcm9wXSwgYXJndW1lbnRzWzFdLCBza2lwQ2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9hbmltYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gVmFsdWUgdG8gYW5pbWF0ZSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDYWxsYmFja3NdIFdoZW4gdHJ1ZSwgY2FsbGJhY2tzIGxpa2Ugb25jaGFuZ2UgYW5kIG9uY29tcGxldGUgYXJlIG5vdCBpbnZva2VkXG4gICAqL1xuICBfYW5pbWF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHRvLCBvcHRpb25zLCBza2lwQ2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcHJvcFBhaXI7XG5cbiAgICB0byA9IHRvLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoJy4nKSkge1xuICAgICAgcHJvcFBhaXIgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSBwcm9wUGFpclxuICAgICAgPyB0aGlzLmdldChwcm9wUGFpclswXSlbcHJvcFBhaXJbMV1dXG4gICAgICA6IHRoaXMuZ2V0KHByb3BlcnR5KTtcblxuICAgIGlmICghKCdmcm9tJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mcm9tID0gY3VycmVudFZhbHVlO1xuICAgIH1cblxuICAgIGlmICh+dG8uaW5kZXhPZignPScpKSB7XG4gICAgICB0byA9IGN1cnJlbnRWYWx1ZSArIHBhcnNlRmxvYXQodG8ucmVwbGFjZSgnPScsICcnKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdG8gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9wdGlvbnMuZnJvbSxcbiAgICAgIGVuZFZhbHVlOiB0byxcbiAgICAgIGJ5VmFsdWU6IG9wdGlvbnMuYnksXG4gICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICBhYm9ydDogb3B0aW9ucy5hYm9ydCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWJvcnQuY2FsbChfdGhpcyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHByb3BQYWlyKSB7XG4gICAgICAgICAgX3RoaXNbcHJvcFBhaXJbMF1dW3Byb3BQYWlyWzFdXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNldChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMub25DaGFuZ2UgJiYgb3B0aW9ucy5vbkNoYW5nZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbih2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgY29vcmRQcm9wcyA9IHsgeDE6IDEsIHgyOiAxLCB5MTogMSwgeTI6IDEgfSxcbiAgICAgIHN1cHBvcnRzTGluZURhc2ggPSBmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpO1xuXG4gIGlmIChmYWJyaWMuTGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuTGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTGluZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuTGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkxpbmUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5MaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MjogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTI6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3gxJywgJ3gyJywgJ3kxJywgJ3kyJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb2ludHNdIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuTGluZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcG9pbnRzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnNldCgneDEnLCBwb2ludHNbMF0pO1xuICAgICAgdGhpcy5zZXQoJ3kxJywgcG9pbnRzWzFdKTtcbiAgICAgIHRoaXMuc2V0KCd4MicsIHBvaW50c1syXSk7XG4gICAgICB0aGlzLnNldCgneTInLCBwb2ludHNbM10pO1xuXG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmFicyh0aGlzLnkyIC0gdGhpcy55MSk7XG5cbiAgICAgIHRoaXMubGVmdCA9ICdsZWZ0JyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy5sZWZ0XG4gICAgICAgIDogdGhpcy5fZ2V0TGVmdFRvT3JpZ2luWCgpO1xuXG4gICAgICB0aGlzLnRvcCA9ICd0b3AnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLnRvcFxuICAgICAgICA6IHRoaXMuX2dldFRvcFRvT3JpZ2luWSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgY29vcmRQcm9wc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBsZWZ0VG9PcmlnaW5YIERpc3RhbmNlIGZyb20gbGVmdCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5YIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldExlZnRUb09yaWdpblg6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblgnLFxuICAgICAgICBheGlzMTogJ3gxJyxcbiAgICAgICAgYXhpczI6ICd4MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ3dpZHRoJ1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAnbGVmdCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAncmlnaHQnXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0b3BUb09yaWdpblkgRGlzdGFuY2UgZnJvbSB0b3AgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWSBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRUb3BUb09yaWdpblk6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblknLFxuICAgICAgICBheGlzMTogJ3kxJyxcbiAgICAgICAgYXhpczI6ICd5MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ2hlaWdodCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ3RvcCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAnYm90dG9tJ1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKCF0aGlzLnN0cm9rZURhc2hBcnJheSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSAmJiBzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIC8vIG1vdmUgZnJvbSBjZW50ZXIgKG9mIHZpcnR1YWwgYm94KSB0byBpdHMgbGVmdC90b3AgY29ybmVyXG4gICAgICAgIC8vIHdlIGNhbid0IGFzc3VtZSB4MSwgeTEgaXMgdG9wIGxlZnQgYW5kIHgyLCB5MiBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocC54MSwgcC55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocC54MiwgcC55Mik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuXG4gICAgICAvLyBUT0RPOiB0ZXN0IHRoaXNcbiAgICAgIC8vIG1ha2Ugc3VyZSBzZXR0aW5nIFwiZmlsbFwiIGNoYW5nZXMgY29sb3Igb2YgYSBsaW5lXG4gICAgICAvLyAoYnkgY29weWluZyBmaWxsU3R5bGUgdG8gc3Ryb2tlU3R5bGUsIHNpbmNlIGxpbmUgaXMgc3Ryb2tlZCwgbm90IGZpbGxlZClcbiAgICAgIHZhciBvcmlnU3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZSB8fCBjdHguZmlsbFN0eWxlO1xuICAgICAgdGhpcy5zdHJva2UgJiYgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnU3Ryb2tlU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcC54MSwgcC55MSwgcC54MiwgcC55MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QgaW4gdGhlIHN2Z1xuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIHBvaW50IGZyb20gZWxlbWVudCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKHRoaXMueDEgKyB0aGlzLngyKSAvIDIsXG4gICAgICAgIHk6ICh0aGlzLnkxICsgdGhpcy55MikgLyAyLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aGQgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwgdGhpcy5jYWxjTGluZVBvaW50cygpKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltID0gdGhpcy5jYWxsU3VwZXIoJ19nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMnKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZUxpbmVDYXAgPT09ICdidXR0Jykge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCkge1xuICAgICAgICAgIGRpbS55IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgZGltLnggLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGxpbmUgcG9pbnRzIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhbGNMaW5lUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4TXVsdCA9IHRoaXMueDEgPD0gdGhpcy54MiA/IC0xIDogMSxcbiAgICAgICAgICB5TXVsdCA9IHRoaXMueTEgPD0gdGhpcy55MiA/IC0xIDogMSxcbiAgICAgICAgICB4MSA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAwLjUpLFxuICAgICAgICAgIHkxID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAwLjUpLFxuICAgICAgICAgIHgyID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIC0wLjUpLFxuICAgICAgICAgIHkyID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAtMC41KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLFxuICAgICAgICAgIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxsaW5lICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgJ3gxPVwiJywgcC54MSxcbiAgICAgICAgJ1wiIHkxPVwiJywgcC55MSxcbiAgICAgICAgJ1wiIHgyPVwiJywgcC54MixcbiAgICAgICAgJ1wiIHkyPVwiJywgcC55MixcbiAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICdcIi8+XFxuJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngyIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MiB8fCAwXG4gICAgICAgIF07XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0xpbmUnLCBvcHRpb25zLCBfY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgZGlzdGFuY2UgZnJvbSBjYW52YXMgZWRnZSB0byBMaW5lIG9yaWdpbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIocHJvcGVydHlOYW1lcywgb3JpZ2luVmFsdWVzKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3BlcnR5TmFtZXMub3JpZ2luLFxuICAgICAgICBheGlzMSA9IHByb3BlcnR5TmFtZXMuYXhpczEsXG4gICAgICAgIGF4aXMyID0gcHJvcGVydHlOYW1lcy5heGlzMixcbiAgICAgICAgZGltZW5zaW9uID0gcHJvcGVydHlOYW1lcy5kaW1lbnNpb24sXG4gICAgICAgIG5lYXJlc3QgPSBvcmlnaW5WYWx1ZXMubmVhcmVzdCxcbiAgICAgICAgY2VudGVyID0gb3JpZ2luVmFsdWVzLmNlbnRlcixcbiAgICAgICAgZmFydGhlc3QgPSBvcmlnaW5WYWx1ZXMuZmFydGhlc3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0KG9yaWdpbikpIHtcbiAgICAgICAgY2FzZSBuZWFyZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICAgIGNhc2UgY2VudGVyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSkgKyAoMC41ICogdGhpcy5nZXQoZGltZW5zaW9uKSk7XG4gICAgICAgIGNhc2UgZmFydGhlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGkgPSBNYXRoLlBJO1xuXG4gIGlmIChmYWJyaWMuQ2lyY2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5DaXJjbGUgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DaXJjbGVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2lyY2xlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAvKipcbiAgICAgKiBSYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJhZGl1czogMCxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuZ2xlIG9mIHRoZSBjaXJjbGUsIG1vdmluZyBjbG9ja3dpc2VcbiAgICAgKiBkZXByZWN0YXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBkZXByZWN0YXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDJQaVxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiBwaSAqIDIsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgIGFuZ2xlID0gKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpICUgKCAyICogcGkpO1xuXG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxjaXJjbGUgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAgICdjeD1cIicgKyB4ICsgJ1wiIGN5PVwiJyArIHkgKyAnXCIgJyxcbiAgICAgICAgICAncj1cIicsIHRoaXMucmFkaXVzLFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgJyAnLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAgICcvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gZmFicmljLnV0aWwuY29zKHRoaXMuc3RhcnRBbmdsZSkgKiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IGZhYnJpYy51dGlsLnNpbih0aGlzLnN0YXJ0QW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRYID0gZmFicmljLnV0aWwuY29zKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gZmFicmljLnV0aWwuc2luKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IHBpID8gJzEnIDogJzAnO1xuXG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgdGhpcy5yYWRpdXMgKyAnICcgKyB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnIDAgJywgK2xhcmdlRmxhZyArICcgMScsICcgJyArIGVuZFggKyAnICcgKyBlbmRZLFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgICAgJyAnLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICB0aGlzLmVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFuZCB1cGRhdGVzIHdpZHRoIGFjY29yZGluZ2x5KVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMikuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0NpcmNsZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgaWYgKCFpc1ZhbGlkUmFkaXVzKHBhcnNlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIGNhbiBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkNpcmNsZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkUmFkaXVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKCgncmFkaXVzJyBpbiBhdHRyaWJ1dGVzKSAmJiAoYXR0cmlidXRlcy5yYWRpdXMgPj0gMCkpO1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgZmFicmljLkNpcmNsZVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIC13aWR0aEJ5MiwgaGVpZ2h0QnkyLCAwLCAtaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIDAsIC1oZWlnaHRCeTIsIHdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgd2lkdGhCeTIsIGhlaWdodEJ5MiwgLXdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICAtd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTIsXG4gICAgICAgICAgICAnMCAnICsgLWhlaWdodEJ5MixcbiAgICAgICAgICAgIHdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyXG4gICAgICAgICAgXVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8cG9seWdvbiAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMsXG4gICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCAnXCInLFxuICAgICAgICB0aGlzLmFkZFBhaW50T3JkZXIoKSxcbiAgICAgICAgJy8+J1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5UcmlhbmdsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RyaWFuZ2xlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHBpQnkyICAgPSBNYXRoLlBJICogMjtcblxuICBpZiAoZmFicmljLkVsbGlwc2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkVsbGlwc2UgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGxpcHNlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuRWxsaXBzZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5FbGxpcHNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkVsbGlwc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZWxsaXBzZScsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcng6ICAgMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KCdyeCcsIG9wdGlvbnMgJiYgb3B0aW9ucy5yeCB8fCAwKTtcbiAgICAgIHRoaXMuc2V0KCdyeScsIG9wdGlvbnMgJiYgb3B0aW9ucy5yeSB8fCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG5cbiAgICAgICAgY2FzZSAncngnOlxuICAgICAgICAgIHRoaXMucnggPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnd2lkdGgnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3J5JzpcbiAgICAgICAgICB0aGlzLnJ5ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSeDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3J4JykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgVmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3J5JykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKTtcbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGVsbGlwc2UgJywgdGhpcy5nZXRTdmdJZCgpLFxuICAgICAgICAnY3g9XCIwXCIgY3k9XCIwXCIgJyxcbiAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksICdcIicsXG4gICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAnLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNFbGxpcHNlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcnggcnknLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuRWxsaXBzZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfVxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yeDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucnk7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5FbGxpcHNlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0VsbGlwc2UnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoZmFicmljLlJlY3QpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlJlY3QgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3RhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlJlY3RcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUmVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlJlY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5SZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UnhSeSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByeC9yeSBhdHRyaWJ1dGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJ4Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucnggJiYgIXRoaXMucnkpIHtcbiAgICAgICAgdGhpcy5yeSA9IHRoaXMucng7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJ5ICYmICF0aGlzLnJ4KSB7XG4gICAgICAgIHRoaXMucnggPSB0aGlzLnJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgLy8gb3B0aW1pemUgMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpXG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMSAmJiB0aGlzLmhlaWdodCA9PT0gMSkge1xuICAgICAgICBjdHguZmlsbFJlY3QoLTAuNSwgLTAuNSwgMSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeCArIHcsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHkgKyBoLCB4LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDI7XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxyZWN0ICcsIHRoaXMuZ2V0U3ZnSWQoKSxcbiAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICdcIiByeD1cIicsIHRoaXMuZ2V0KCdyeCcpLCAnXCIgcnk9XCInLCB0aGlzLmdldCgncnknKSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAnXCIgdHJhbnNmb3JtPVwiJywgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oKSxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiJyxcbiAgICAgICAgdGhpcy5hZGRQYWludE9yZGVyKCksXG4gICAgICAgICcvPlxcbicpO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjYWxsYmFjayhyZWN0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUmVjdCcsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5bGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BvaW50cycpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzICh3aGVyZSBlYWNoIHBvaW50IGlzIGFuIG9iamVjdCB3aXRoIHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5bGluZX0gdGhpc0FyZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHkgPSBuZXcgZmFicmljLlBvbHlsaW5lKFtcbiAgICAgKiAgICAgeyB4OiAxMCwgeTogMTAgfSxcbiAgICAgKiAgICAgeyB4OiA1MCwgeTogMzAgfSxcbiAgICAgKiAgICAgeyB4OiA0MCwgeTogNzAgfSxcbiAgICAgKiAgICAgeyB4OiA2MCwgeTogNTAgfSxcbiAgICAgKiAgICAgeyB4OiAxMDAsIHk6IDE1MCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiAxMDAgfVxuICAgICAqICAgXSwge1xuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHZhciBjYWxjRGltID0gdGhpcy5fY2FsY0RpbWVuc2lvbnMoKTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxlZnQgPSBjYWxjRGltLmxlZnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IGNhbGNEaW0udG9wO1xuICAgICAgfVxuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0O1xuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0ge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9seWdvbiBtaW4gYW5kIG1heCBwb2ludCBmcm9tIHBvaW50cyBhcnJheSxcbiAgICAgKiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWRodCwgaGVpZ2h0IHRvIG1lYXN1cmUgdGhlXG4gICAgICogcG9seWdvbiBzaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QubGVmdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC50b3AgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCBkaXN0YW5jZSBiZXR3ZWVuIFggY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmhlaWdodCBkaXN0YW5jZSBiZXR3ZWVuIFkgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgIG1pblggPSBtaW4ocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWluWSA9IG1pbihwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICBtYXhYID0gbWF4KHBvaW50cywgJ3gnKSB8fCAwLFxuICAgICAgICAgIG1heFkgPSBtYXgocG9pbnRzLCAneScpIHx8IDAsXG4gICAgICAgICAgd2lkdGggPSAobWF4WCAtIG1pblgpLFxuICAgICAgICAgIGhlaWdodCA9IChtYXhZIC0gbWluWSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLmNvbmNhdCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHBvaW50cyA9IFtdLCBkaWZmWCA9IHRoaXMucGF0aE9mZnNldC54LCBkaWZmWSA9IHRoaXMucGF0aE9mZnNldC55LFxuICAgICAgICAgIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS54IC0gZGlmZlgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnLCcsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS55IC0gZGlmZlksIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnICdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPCcsIHRoaXMudHlwZSwgJyAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMuam9pbignJyksXG4gICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICdcIiB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLFxuICAgICAgICAnICcsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksICdcIicsXG4gICAgICAgIHRoaXMuYWRkUGFpbnRPcmRlcigpLFxuICAgICAgICAnLz5cXG4nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBjb21tb25SZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBvaW50LCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgeCA9IHRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHkgPSB0aGlzLnBhdGhPZmZzZXQueTtcblxuICAgICAgaWYgKCFsZW4gfHwgaXNOYU4odGhpcy5wb2ludHNbbGVuIC0gMV0ueSkpIHtcbiAgICAgICAgLy8gZG8gbm90IGRyYXcgaWYgbm8gcG9pbnRzIG9yIG9kZCBwb2ludHNcbiAgICAgICAgLy8gTmFOIGNvbWVzIGZyb20gcGFyc2VGbG9hdCBvZiBhIGVtcHR5IHN0cmluZyBpbiBwYXJzZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLnBvaW50c1swXS54IC0geCwgdGhpcy5wb2ludHNbMF0ueSAtIHkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LnggLSB4LCBwb2ludC55IC0geSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAxLCBwMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbaSArIDFdIHx8IHAxO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHAxLngsIHAxLnksIHAyLngsIHAyLnksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBvbHlsaW5lKHBvaW50cywgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5bGluZSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWxpbmUnLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5Z29uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5Z29uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5Z29uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWdvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBvbHlnb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBvbHlsaW5lLCAvKiogQGxlbmRzIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJEYXNoZWRTdHJva2UnLCBjdHgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWdvbkVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlBvbHlnb259IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBvbHlnb24uQVRUUklCVVRFX05BTUVTKTtcblxuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuUG9seWdvbihwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5Z29uIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWdvbicsIG9iamVjdCwgY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBkcmF3QXJjID0gZmFicmljLnV0aWwuZHJhd0FyYyxcbiAgICAgIGNvbW1hbmRMZW5ndGhzID0ge1xuICAgICAgICBtOiAyLFxuICAgICAgICBsOiAyLFxuICAgICAgICBoOiAxLFxuICAgICAgICB2OiAxLFxuICAgICAgICBjOiA2LFxuICAgICAgICBzOiA0LFxuICAgICAgICBxOiA0LFxuICAgICAgICB0OiAyLFxuICAgICAgICBhOiA3XG4gICAgICB9LFxuICAgICAgcmVwZWF0ZWRDb21tYW5kcyA9IHtcbiAgICAgICAgbTogJ2wnLFxuICAgICAgICBNOiAnTCdcbiAgICAgIH07XG5cbiAgaWYgKGZhYnJpYy5QYXRoKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5QYXRoIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0aFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI3BhdGhfYW5kX3BhdGhncm91cH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdGgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5QYXRoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0aC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwYXRoJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBhdGggcG9pbnRzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGg6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnLCAnZmlsbFJ1bGUnKSxcblxuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcGF0aCBQYXRoIGRhdGEgKHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIGFuZCBjb3JyZXNwb25kaW5nIFwiY29tbWFuZFwiIHRva2VucylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbUFycmF5ID0gX3RvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgIHRoaXMucGF0aCA9IGZyb21BcnJheVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgLy8gb25lIG9mIGNvbW1hbmRzIChtLE0sbCxMLHEsUSxjLEMsZXRjLikgZm9sbG93ZWQgYnkgbm9uLWNvbW1hbmQgY2hhcmFjdGVycyAoaS5lLiBjb21tYW5kIHZhbHVlcylcbiAgICAgICAgOiBwYXRoLm1hdGNoICYmIHBhdGgubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb21BcnJheSkge1xuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLl9wYXJzZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX3NldFBvc2l0aW9uRGltZW5zaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9wYXJzZURpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gY2FsY0RpbS5sZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IGNhbGNEaW0udG9wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhdGhPZmZzZXQgPSB0aGlzLnBhdGhPZmZzZXQgfHwge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhdGhDb21tYW5kczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsIC8vIHgyXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICAgICAgeSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW0NjU3NdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAvLyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb25cbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcblxuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBkcmF3QXJjKGN0eCwgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyB4ICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBkcmF3QXJjKGN0eCwgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJQYXRoQ29tbWFuZHMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRvcFwiOiAnICsgdGhpcy50b3AgKyAnLCBcImxlZnRcIjogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xpY2UoKTsgfSksXG4gICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KFsnc291cmNlUGF0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgICBpZiAoby5zb3VyY2VQYXRoKSB7XG4gICAgICAgIGRlbGV0ZSBvLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGNodW5rcyA9IFtdLFxuICAgICAgICAgIG1hcmt1cCA9IHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoKSwgYWRkVHJhbnNmb3JtID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wYXRoW2ldLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aCA9IGNodW5rcy5qb2luKCcgJyk7XG4gICAgICBhZGRUcmFuc2Zvcm0gPSAnIHRyYW5zbGF0ZSgnICsgKC10aGlzLnBhdGhPZmZzZXQueCkgKyAnLCAnICsgKC10aGlzLnBhdGhPZmZzZXQueSkgKyAnKSAnO1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8cGF0aCAnLCB0aGlzLmdldFN2Z0lkKCksXG4gICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgJ1wiIHRyYW5zZm9ybT1cIicsIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksIGFkZFRyYW5zZm9ybSxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm1NYXRyaXgoKSwgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICB0aGlzLmFkZFBhaW50T3JkZXIoKSxcbiAgICAgICAgJy8+XFxuJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29vcmRzID0gW10sXG4gICAgICAgICAgY3VycmVudFBhdGgsXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIHJlID0gLyhbLStdPygoXFxkK1xcLlxcZCspfCgoXFxkKyl8KFxcLlxcZCspKSkoPzplWy0rXT9cXGQrKT8pL2lnLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGNvb3Jkc1N0cjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGNvb3Jkc1BhcnNlZCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRQYXRoID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIGNvb3Jkc1N0ciA9IGN1cnJlbnRQYXRoLnNsaWNlKDEpLnRyaW0oKTtcbiAgICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoY29vcmRzU3RyKSkpIHtcbiAgICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZHNQYXJzZWQgPSBbY3VycmVudFBhdGguY2hhckF0KDApXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KGNvb3Jkc1tqXSk7XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgICBjb29yZHNQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21tYW5kID0gY29vcmRzUGFyc2VkWzBdLFxuICAgICAgICAgICAgY29tbWFuZExlbmd0aCA9IGNvbW1hbmRMZW5ndGhzW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgICByZXBlYXRlZENvbW1hbmQgPSByZXBlYXRlZENvbW1hbmRzW2NvbW1hbmRdIHx8IGNvbW1hbmQ7XG5cbiAgICAgICAgaWYgKGNvb3Jkc1BhcnNlZC5sZW5ndGggLSAxID4gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY29vcmRzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2NvbW1hbmRdLmNvbmNhdChjb29yZHNQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICAgICAgICBjb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChjb29yZHNQYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgdGVtcFksXG4gICAgICAgICAgYm91bmRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdLCAvLyB4MVxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSwgLy8geTFcbiAgICAgICAgICAgICAgY29udHJvbFgsIC8vIHgyXG4gICAgICAgICAgICAgIGNvbnRyb2xZLCAvLyB5MlxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIHggKyBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICB5ICsgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvblxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tDY1NzXS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgLy8gdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY29udHJvbFgsXG4gICAgICAgICAgICAgIGNvbnRyb2xZLFxuICAgICAgICAgICAgICB0ZW1wWCxcbiAgICAgICAgICAgICAgdGVtcFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjb250cm9sWCxcbiAgICAgICAgICAgICAgY29udHJvbFksXG4gICAgICAgICAgICAgIGNvbnRyb2xYLFxuICAgICAgICAgICAgICBjb250cm9sWSxcbiAgICAgICAgICAgICAgdGVtcFgsXG4gICAgICAgICAgICAgIHRlbXBZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQXJjKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl0gKyB4LFxuICAgICAgICAgICAgICBjdXJyZW50WzddICsgeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkFyYyh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdLFxuICAgICAgICAgICAgICBjdXJyZW50WzddXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICBhWC5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIGFZLnB1c2gocG9pbnQueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhWC5wdXNoKHgpO1xuICAgICAgICBhWS5wdXNoKHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWCA9IG1pbihhWCkgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKGFZKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgoYVgpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChhWSkgfHwgMCxcbiAgICAgICAgICBkZWx0YVggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICBkZWx0YVkgPSBtYXhZIC0gbWluWSxcblxuICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICAgICAgd2lkdGg6IGRlbHRhWCxcbiAgICAgICAgICAgIGhlaWdodDogZGVsdGFZXG4gICAgICAgICAgfTtcblxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhdGhVcmwgPSBvYmplY3Quc291cmNlUGF0aDtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChwYXRoVXJsLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgcGF0aC5zZXRPcHRpb25zKG9iamVjdCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUGF0aCcsIG9iamVjdCwgY2FsbGJhY2ssICdwYXRoJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBhdGguZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFsnZCddKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIFNWRyA8cGF0aD4gZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTKTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBhdGgocGFyc2VkQXR0cmlidXRlcy5kLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heDtcblxuICBpZiAoZmFicmljLkdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JvdXBcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JvdXAjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Hcm91cCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIGZhYnJpYy5Db2xsZWN0aW9uLCAvKiogQGxlbmRzIGZhYnJpYy5Hcm91cC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGNsaWNrIGV2ZW50cyBzaG91bGQgYWxzbyBjaGVjayBmb3Igc3VidGFyZ2V0c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1YlRhcmdldENoZWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhcmUgY29udGFpbmVyLCBkbyBub3QgcmVuZGVyIGFueXRoaW5nIG9uIHRoZXlyIG93biwgZW5jZSBubyBjYWNoZSBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogW10sXG5cbiAgICAvKipcbiAgICAgKiBzZXRPbkdyb3VwIGlzIGEgbWV0aG9kIHVzZWQgZm9yIFRleHRCb3ggdGhhdCBpcyBubyBtb3JlIHVzZWQgc2luY2UgMi4wLjAgVGhlIGJlaGF2aW9yIGlzIHN0aWxsXG4gICAgICogYXZhaWxhYmxlIHNldHRpbmcgdGhpcyBib29sZWFuIHRvIHRydWUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdXNlU2V0T25Hcm91cDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEdyb3VwIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNBbHJlYWR5R3JvdXBlZF0gaWYgdHJ1ZSwgb2JqZWN0cyBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMsIGlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgLy8gaWYgb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHksXG4gICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAgICAgIC8vIFRodXMgd2UgbmVlZCB0byBzZXQgb3B0aW9ucyB0byBncm91cCB3aXRob3V0IG9iamVjdHMsXG4gICAgICBpc0FscmVhZHlHcm91cGVkICYmIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSkge1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICB2YXIgY2VudGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICAvLyBpZiBjb21pbmcgZnJvbSBzdmcgaSBkbyBub3Qgd2FudCB0byBjYWxjIGJvdW5kcy5cbiAgICAgICAgLy8gaSBhc3N1bWUgd2lkdGggYW5kIGhlaWdodCBhcmUgcGFzc2VkIGFsb25nIG9wdGlvbnNcbiAgICAgICAgY2VudGVyIHx8IHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcyhjZW50ZXIpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQUNvb3JkcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNBQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSwgc2tpcEFic29sdXRlID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldENvb3JkcyhpZ25vcmVab29tLCBza2lwQWJzb2x1dGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgdmFyIGNlbnRlciA9IGNlbnRlciB8fCB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0Q29vcmRzKHRoaXMuX29iamVjdHNbaV0sIGNlbnRlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIsIGN1cnJlbnQgY2VudGVyIG9mIGdyb3VwLlxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RDb29yZHM6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICB2YXIgb2JqZWN0TGVmdCA9IG9iamVjdC5sZWZ0LFxuICAgICAgICAgIG9iamVjdFRvcCA9IG9iamVjdC50b3AsXG4gICAgICAgICAgaWdub3JlWm9vbSA9IHRydWUsIHNraXBBYnNvbHV0ZSA9IHRydWU7XG5cbiAgICAgIG9iamVjdC5zZXQoe1xuICAgICAgICBsZWZ0OiBvYmplY3RMZWZ0IC0gY2VudGVyLngsXG4gICAgICAgIHRvcDogb2JqZWN0VG9wIC0gY2VudGVyLnlcbiAgICAgIH0pO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoaWdub3JlWm9vbSwgc2tpcEFic29sdXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuR3JvdXA6ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbW92ZVdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy51c2VTZXRPbkdyb3VwKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldE9uR3JvdXAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCA9IHRoaXMuZ2V0T2JqZWN0cygpLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9iai5ncm91cC5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIG9iamVjdHM6IG9ianNUb09iamVjdFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlLCBpbiBkYXRhbGVzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmpzVG9PYmplY3QsIHNvdXJjZVBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICBpZiAoc291cmNlUGF0aCkge1xuICAgICAgICBvYmpzVG9PYmplY3QgPSBzb3VyY2VQYXRoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHRoaXMuZ2V0T2JqZWN0cygpLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvYmouZ3JvdXAuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvRGF0YWxlc3NPYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBvYmplY3RzOiBvYmpzVG9PYmplY3RcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGluc3RhbmNlIG9uIGEgZ2l2ZW4gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgaW5zdGFuY2Ugb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG93bkNhY2hlID0gdGhpcy5vYmplY3RDYWNoaW5nICYmICghdGhpcy5ncm91cCB8fCB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKSB8fCAhdGhpcy5ncm91cC5pc09uQUNhY2hlKCkpO1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gb3duQ2FjaGU7XG4gICAgICBpZiAob3duQ2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS53aWxsRHJhd1NoYWRvdygpKSB7XG4gICAgICAgICAgICB0aGlzLm93bkNhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25DYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3Qgb3IgYSBjaGlsZCBvYmplY3Qgd2lsbCBjYXN0IGEgc2hhZG93XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd3aWxsRHJhd1NoYWRvdycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZyB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxTdXBlcignaXNDYWNoZURpcnR5JykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0uaXNDYWNoZURpcnR5KHRydWUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGhhcyBub3QgYSBjYWNoZSBjYW52YXMgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhblxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YLCB5ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC14IC8gMiwgLXkgLyAyLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBlYWNoIG9mIGdyb3VwIG9iamVjdHMgKG9yaWdpbmFsIHN0YXRlIGlzIHRoYXQgd2hpY2ggd2FzIGJlZm9yZSBncm91cCB3YXMgY3JlYXRlZCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RzU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKHRoaXMuX3Jlc3RvcmVPYmplY3RTdGF0ZSwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgdGhlIHRyYW5zZm9ybSBmcm9tIHRoaXMgZ3JvdXAgb250byB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gICAgICogaS5lLiBpdCB0ZWxscyB5b3Ugd2hhdCB3b3VsZCBoYXBwZW4gaWYgdGhlIHN1cHBsaWVkIG9iamVjdCB3YXMgaW5cbiAgICAgKiB0aGUgZ3JvdXAsIGFuZCB0aGVuIHRoZSBncm91cCB3YXMgZGVzdHJveWVkLiBJdCBtdXRhdGVzIHRoZSBzdXBwbGllZFxuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRyYW5zZm9ybWVkT2JqZWN0XG4gICAgICovXG4gICAgcmVhbGl6ZVRyYW5zZm9ybTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbWF0cml4ID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KSxcbiAgICAgICAgICBjZW50ZXIgPSBuZXcgZmFicmljLlBvaW50KG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIG9iamVjdC5mbGlwWCA9IGZhbHNlO1xuICAgICAgb2JqZWN0LmZsaXBZID0gZmFsc2U7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBvYmplY3Quc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgb2JqZWN0LnNrZXdZID0gb3B0aW9ucy5za2V3WTtcbiAgICAgIG9iamVjdC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBhIHNwZWNpZmllZCBvYmplY3QgaW4gZ3JvdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RTdGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLnJlYWxpemVUcmFuc2Zvcm0ob2JqZWN0KTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHdoZW4gZ3JvdXAgaXMgZGVzdHJveWVkIG9iamVjdHMgbmVlZHMgdG8gZ2V0IGEgcmVwYWludCB0byBiZSBldmVudHVhbGx5XG4gICAgICAvLyBkaXNwbGF5ZWQgb24gY2FudmFzLlxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZ3JvdXAgYW4gYWN0aXZlIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBncm91cCBmcm9tIGNhbnZhc1xuICAgICAqIHRoZSBncm91cCBoYXMgdG8gYmUgb24gY2FudmFzIGZvciB0aGlzIHRvIHdvcmsuXG4gICAgICogQHJldHVybiB7ZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB0b0FjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cywgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oW10pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldChvcHRpb25zKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi50eXBlID0gJ2FjdGl2ZVNlbGVjdGlvbic7XG4gICAgICBjYW52YXMucmVtb3ZlKHRoaXMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIG9iamVjdC5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGNhbnZhcy5hZGQob2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBhY3RpdmVTZWxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdW5ncm91cE9uQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29vcmRpbmF0ZXMgb2YgYWxsIG9iamVjdHMgaW5zaWRlIGdyb3VwXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldE9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLCBza2lwQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKGlnbm9yZVpvb20sIHNraXBBYnNvbHV0ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjQm91bmRzOiBmdW5jdGlvbihvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgbywgcHJvcCxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgaWdub3JlWm9vbSA9IHRydWU7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgby5zZXRDb29yZHMoaWdub3JlWm9vbSk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICBwcm9wID0gcHJvcHNbal07XG4gICAgICAgICAgYVgucHVzaChvLm9Db29yZHNbcHJvcF0ueCk7XG4gICAgICAgICAgYVkucHVzaChvLm9Db29yZHNbcHJvcF0ueSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQodGhpcy5fZ2V0Qm91bmRzKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBtaW5YWSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKGFYKSwgbWluKGFZKSksXG4gICAgICAgICAgbWF4WFkgPSBuZXcgZmFicmljLlBvaW50KG1heChhWCksIG1heChhWSkpLFxuICAgICAgICAgIG9iaiA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAobWF4WFkueCAtIG1pblhZLngpIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IChtYXhYWS55IC0gbWluWFkueSkgfHwgMFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICghb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICAgIG9iai5sZWZ0ID0gbWluWFkueCB8fCAwO1xuICAgICAgICBvYmoudG9wID0gbWluWFkueSB8fCAwO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5YID09PSAnY2VudGVyJykge1xuICAgICAgICAgIG9iai5sZWZ0ICs9IG9iai53aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3JpZ2luWCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIG9iai5sZWZ0ICs9IG9iai53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW5ZID09PSAnY2VudGVyJykge1xuICAgICAgICAgIG9iai50b3AgKz0gb2JqLmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3JpZ2luWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBvYmoudG9wICs9IG9iai5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKCk7XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxnICcsIHRoaXMuZ2V0U3ZnSWQoKSwgJ3RyYW5zZm9ybT1cIicsXG4gICAgICAgIC8qIGF2b2lkaW5nIHN0eWxlcyBpbnRlbnRpb25hbGx5ICovXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKCksXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICdcIiBzdHlsZT1cIicsXG4gICAgICAgIHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICdcIj5cXG4nXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXJrdXAucHVzaCgnXFx0JywgdGhpcy5fb2JqZWN0c1tpXS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JvdXB9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Hcm91cFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZ3JvdXAgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5Hcm91cChlbmxpdmVuZWRPYmplY3RzLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkFjdGl2ZVNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkFjdGl2ZVNlbGVjdGlvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuR3JvdXBcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkdyb3VwLCAvKiogQGxlbmRzIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnYWN0aXZlU2VsZWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgQWN0aXZlU2VsZWN0aW9uIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSkge1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGUgYWN0aXZlU2VsZWN0aW9uIHRvIGEgbm9ybWFsIGdyb3VwLFxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBhdXRvbWF0aWNhbGx5IGFkZHMgaXQgdG8gY2FudmFzIGFzXG4gICAgICogYWN0aXZlIG9iamVjdC4gbm8gZXZlbnRzIGZpcmVkLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICB0b0dyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgdmFyIG5ld0dyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChbXSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgbmV3R3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgbmV3R3JvdXAudHlwZSA9ICdncm91cCc7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IG5ld0dyb3VwO1xuICAgICAgICBvYmplY3QuY2FudmFzLnJlbW92ZShvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICBuZXdHcm91cC5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQobmV3R3JvdXApO1xuICAgICAgY2FudmFzLl9hY3RpdmVPYmplY3QgPSBuZXdHcm91cDtcbiAgICAgIG5ld0dyb3VwLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIG5ld0dyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiByZXR1cm5zIHRydWUsIGRlc2VsZWN0aW9uIGlzIGNhbmNlbGxlZC5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbY2FuY2VsXVxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5BY3RpdmVTZWxlY3Rpb246ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAoa2V5ID09PSAnY2FudmFzJykge1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZVNldE9uR3JvdXApIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0T25Hcm91cChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG9iamVjdENhY2hpbmcgaXMgYSBnbG9iYWwgZmxhZywgd2lucyBvdmVyIGV2ZXJ5dGhpbmdcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgd2lsbERyYXdTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignd2lsbERyYXdTaGFkb3cnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hpbGRyZW5PdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY2hpbGRyZW4gb3ZlcnJpZGVzXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUsIGNoaWxkcmVuT3ZlcnJpZGUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNvbnRyb2xzJywgY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUgPSBjaGlsZHJlbk92ZXJyaWRlIHx8IHsgfTtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGRyZW5PdmVycmlkZS5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbk92ZXJyaWRlLmhhc1JvdGF0aW5nUG9pbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuaGFzUm90YXRpbmdQb2ludCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW5PdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5fcmVuZGVyQ29udHJvbHMoY3R4LCBjaGlsZHJlbk92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIEFjdGl2ZVNlbGVjdGlvbiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3Qub2JqZWN0cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoIWdsb2JhbC5mYWJyaWMpIHtcbiAgICBnbG9iYWwuZmFicmljID0geyB9O1xuICB9XG5cbiAgaWYgKGdsb2JhbC5mYWJyaWMuSW1hZ2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkltYWdlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW1hZ2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2ltYWdlc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9zc09yaWdpbjogJycsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZS5cbiAgICAgKiBGb3IgaW1hZ2UgcXVhbGl0eSBhIHN0cm9rZSBtdWx0aXBsZSBvZiAyIGdpdmVzIGJldHRlciByZXN1bHRzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVggdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVZIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWTogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1k6IDEsXG5cbiAgICAvKipcbiAgICAgKiBtaW5pbXVtIHNjYWxlIGZhY3RvciB1bmRlciB3aGljaCBhbnkgcmVzaXplRmlsdGVyIGlzIHRyaWdnZXJlZCB0byByZXNpemUgdGhlIGltYWdlXG4gICAgICogMCB3aWxsIGRpc2FibGUgdGhlIGF1dG9tYXRpYyByZXNpemUuIDEgd2lsbCB0cmlnZ2VyIGF1dG9tYXRpY2FsbHkgYWx3YXlzLlxuICAgICAqIG51bWJlciBiaWdnZXIgdGhhbiAxIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIG1pbmltdW1TY2FsZVRyaWdnZXI6IDAuNSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZSBmb3IgaW1hZ2VzXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGtleSB1c2VkIHRvIHJldHJpZXZlIHRoZSB0ZXh0dXJlIHJlcHJlc2VudGluZyB0aGlzIGltYWdlXG4gICAgICogc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlS2V5OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBjcm9wIGluIHBpeGVscyBmcm9tIG9yaWdpbmFsIGltYWdlIHNpemUuXG4gICAgICogc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBTdHJpbmd9IGVsZW1lbnQgSW1hZ2UgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZXZlbnR1YWwgZmlsdGVycyBhcHBsaWVkLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgICB0aGlzLmNhY2hlS2V5ID0gJ3RleHR1cmUnICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGltYWdlIGVsZW1lbnQgd2hpY2ggdGhpcyBpbnN0YW5jZSBpZiBiYXNlZCBvblxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgaW5zdGFuY2UgdG8gYSBzcGVjaWZpZWQgb25lLlxuICAgICAqIElmIGZpbHRlcnMgZGVmaW5lZCB0aGV5IGFyZSBhcHBsaWVkIHRvIG5ldyBpbWFnZS5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBjYW52YXMucmVuZGVyQWxsYCBhbmQgYG9iamVjdC5zZXRDb29yZHNgIGFmdGVyIHJlcGxhY2luZywgdG8gcmVuZGVyIG5ldyBpbWFnZSBhbmQgdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYmFja2VuZCA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kO1xuICAgICAgaWYgKGJhY2tlbmQgJiYgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSkge1xuICAgICAgICBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KHRoaXMuY2FjaGVLZXkpO1xuICAgICAgICBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMucmVzaXplRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuYXBwbHlSZXNpemVGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjYWNoZUtleSBpZiB3ZSBoYXZlIGEgd2ViR2xCYWNrZW5kXG4gICAgICogZGVsZXRlIHJlZmVyZW5jZSB0byBpbWFnZSBlbGVtZW50c1xuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJhY2tlbmQgPSBmYWJyaWMuZmlsdGVyQmFja2VuZDtcbiAgICAgIGlmIChiYWNrZW5kICYmIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkpIHtcbiAgICAgICAgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgICAgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ZpbHRlcmVkRWwgPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY3Jvc3NPcmlnaW4gdmFsdWUgKG9uIGFuIGluc3RhbmNlIGFuZCBjb3JyZXNwb25kaW5nIGltYWdlIGVsZW1lbnQpXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBzaXplIG9mIGFuIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9yaWdpbmFsU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCAvIDIsIGggPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4ICsgdywgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSwgeCArIHcsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5ICsgaCwgeCwgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSArIGgsIHgsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlck9iaikge1xuICAgICAgICBpZiAoZmlsdGVyT2JqKSB7XG4gICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlck9iai50b09iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb2JqZWN0ID0gZXh0ZW5kKFxuICAgICAgICB0aGlzLmNhbGxTdXBlcihcbiAgICAgICAgICAndG9PYmplY3QnLFxuICAgICAgICAgIFsnY3Jvc3NPcmlnaW4nLCAnY3JvcFgnLCAnY3JvcFknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgKSwge1xuICAgICAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbWFnZSBoYXMgY3JvcCBhcHBsaWVkLCBpbnNwZWN0aW5nIHZhbHVlcyBvZiBjcm9wWCxjcm9wWSx3aWR0aCxoaWdodC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0Nyb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JvcFggfHwgdGhpcy5jcm9wWSB8fCB0aGlzLndpZHRoIDwgdGhpcy5fZWxlbWVudC53aWR0aCB8fCB0aGlzLmhlaWdodCA8IHRoaXMuX2VsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLCB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMiwgY2xpcFBhdGggPSAnJztcbiAgICAgIGlmICh0aGlzLmhhc0Nyb3AoKSkge1xuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxjbGlwUGF0aCBpZD1cImltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICdcIj5cXG4nLFxuICAgICAgICAgICdcXHQ8cmVjdCB4PVwiJyArIHggKyAnXCIgeT1cIicgKyB5ICsgJ1wiIHdpZHRoPVwiJyArIHRoaXMud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIHRoaXMuaGVpZ2h0ICsgJ1wiIC8+XFxuJyxcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nXG4gICAgICAgICk7XG4gICAgICAgIGNsaXBQYXRoID0gJyBjbGlwLXBhdGg9XCJ1cmwoI2ltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICcpXCIgJztcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKCc8ZyB0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCI+XFxuJyk7XG4gICAgICB2YXIgaW1hZ2VNYXJrdXAgPSBbJ1xcdDxpbWFnZSAnLCB0aGlzLmdldFN2Z0lkKCksICd4bGluazpocmVmPVwiJywgdGhpcy5nZXRTdmdTcmModHJ1ZSksXG4gICAgICAgICdcIiB4PVwiJywgeCAtIHRoaXMuY3JvcFgsICdcIiB5PVwiJywgeSAtIHRoaXMuY3JvcFksXG4gICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgIC8vIHdlJ3JlIGVzc2VudGlhbGx5IG1vdmluZyBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gZnJvbSB0b3AvbGVmdCBjb3JuZXIgdG8gdGhlIGNlbnRlciBvZiB0aGUgc2hhcGVcbiAgICAgICAgLy8gYnkgd3JhcHBpbmcgaXQgaW4gY29udGFpbmVyIDxnPiBlbGVtZW50IHdpdGggYWN0dWFsIHRyYW5zZm9ybWF0aW9uLCB0aGVuIG9mZnNldHRpbmcgb2JqZWN0IHRvIHRoZSB0b3AvbGVmdFxuICAgICAgICAvLyBzbyB0aGF0IG9iamVjdCdzIGNlbnRlciBhbGlnbnMgd2l0aCBjb250YWluZXIncyBsZWZ0L3RvcFxuICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLl9lbGVtZW50LndpZHRoIHx8IHRoaXMuX2VsZW1lbnQubmF0dXJhbFdpZHRoLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJywgdGhpcy5fZWxlbWVudC5oZWlnaHQgfHwgdGhpcy5fZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICdcIicsIGNsaXBQYXRoLFxuICAgICAgICAnPjwvaW1hZ2U+XFxuJ107XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnZmlsbCcpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWFya3VwLCBpbWFnZU1hcmt1cCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcbiAgICAgICAgdmFyIG9yaWdGaWxsID0gdGhpcy5maWxsO1xuICAgICAgICB0aGlzLmZpbGwgPSBudWxsO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnXFx0PHJlY3QgJyxcbiAgICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5maWxsID0gb3JpZ0ZpbGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ICE9PSAnZmlsbCcpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWFya3VwLCBpbWFnZU1hcmt1cCk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuXG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbHRlcmVkIGluZGljYXRlcyBpZiB0aGUgc3JjIGlzIG5lZWRlZCBmb3Igc3ZnXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRTcmM6IGZ1bmN0aW9uKGZpbHRlcmVkKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGZpbHRlcmVkID8gdGhpcy5fZWxlbWVudCA6IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LnRvRGF0YVVSTCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcmMgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBTb3VyY2Ugc3RyaW5nIChVUkwpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIChhbmQgYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTcmM6IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShzcmMsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkltYWdlOiB7IHNyYzogXCInICsgdGhpcy5nZXRTcmMoKSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIGFwcGx5UmVzaXplRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIsXG4gICAgICAgICAgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzID8gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSxcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVggKiByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZICogcmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBlbGVtZW50VG9GaWx0ZXIgPSB0aGlzLl9maWx0ZXJlZEVsIHx8IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWx0ZXIgfHwgKHNjYWxlWCA+IG1pbmltdW1TY2FsZSAmJiBzY2FsZVkgPiBtaW5pbXVtU2NhbGUpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50VG9GaWx0ZXI7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gMTtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSAxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZhYnJpYy5maWx0ZXJCYWNrZW5kKSB7XG4gICAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kID0gZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgY2FjaGVLZXkgPSB0aGlzLl9maWx0ZXJlZEVsID8gdGhpcy5jYWNoZUtleSA6ICh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpLFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gZWxlbWVudFRvRmlsdGVyLndpZHRoLCBzb3VyY2VIZWlnaHQgPSBlbGVtZW50VG9GaWx0ZXIuaGVpZ2h0O1xuICAgICAgY2FudmFzRWwud2lkdGggPSBzb3VyY2VXaWR0aDtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNvdXJjZUhlaWdodDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgIGZpbHRlci5zY2FsZVggPSBzY2FsZVg7XG4gICAgICBmaWx0ZXIuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBbZmlsdGVyXSwgZWxlbWVudFRvRmlsdGVyLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCBjYWNoZUtleSk7XG4gICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IGNhbnZhc0VsLndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSBjYW52YXNFbC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSkgb3IgZnJvbSBmaWx0ZXIgcGFyYW1cbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yUmVzaXppbmcgc3BlY2lmeSBpZiB0aGUgZmlsdGVyIG9wZXJhdGlvbiBpcyBhIHJlc2l6ZSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfSByZXR1cm4gdGhlIGZhYnJpYy5JbWFnZSBvYmplY3RcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlcjsgfSk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGltZ0VsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGltZ0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gaW1nRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGltZ0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBleGlzdGluZyBlbGVtZW50IHRvIGdldCBuZXcgZmlsdGVyIGRhdGFcbiAgICAgICAgdGhpcy5fZWxlbWVudC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgZmlsdGVycywgdGhpcy5fb3JpZ2luYWxFbGVtZW50LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCB0aGlzLmNhY2hlS2V5KTtcbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGggIT09IHRoaXMuX2VsZW1lbnQud2lkdGggfHxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodCAhPT0gdGhpcy5fZWxlbWVudC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSB0aGlzLl9lbGVtZW50LndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IHRoaXMuX2VsZW1lbnQuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nID09PSBmYWxzZSAmJiB0aGlzLnJlc2l6ZUZpbHRlciAmJiB0aGlzLl9uZWVkc1Jlc2l6ZSgpKSB7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSB0aGlzLnNjYWxlWDtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3Ryb2tlKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQsIHNXID0gdyAqIHRoaXMuX2ZpbHRlclNjYWxpbmdYLCBzSCA9IGggKiB0aGlzLl9maWx0ZXJTY2FsaW5nWSxcbiAgICAgICAgICB4ID0gLXcgLyAyLCB5ID0gLWggLyAyLCBlbGVtZW50VG9EcmF3ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgIGVsZW1lbnRUb0RyYXcgJiYgY3R4LmRyYXdJbWFnZShlbGVtZW50VG9EcmF3LFxuICAgICAgICB0aGlzLmNyb3BYICogdGhpcy5fZmlsdGVyU2NhbGluZ1gsXG4gICAgICAgIHRoaXMuY3JvcFkgKiB0aGlzLl9maWx0ZXJTY2FsaW5nWSxcbiAgICAgICAgc1csXG4gICAgICAgIHNILFxuICAgICAgICB4LCB5LCB3LCBoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGUsIG5lZWRlZCB0byBjaGVjayBpZiBpbWFnZSBuZWVkcyByZXNpemVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnNjYWxlWCAhPT0gdGhpcy5fbGFzdFNjYWxlWCB8fCB0aGlzLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblxuICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgZWxlbWVudC53aWR0aCk7XG4gICAgICB0aGlzLnNldCgnaGVpZ2h0JywgZWxlbWVudC5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgSW1hZ2UgY2xhc3MncyBpbml0aWFsaXphdGlvbiBtZXRob2QuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fFN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRFbGVtZW50KGZhYnJpYy51dGlsLmdldEJ5SWQoZWxlbWVudCksIG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5nZXRFbGVtZW50KCksIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRDb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgZmFicmljLkltYWdlLmZpbHRlcnMgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gICAgICovXG4gICAgX2luaXRGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZmlsdGVycywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICB9LCAnZmFicmljLkltYWdlLmZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zICYmICgnd2lkdGgnIGluIG9wdGlvbnMpXG4gICAgICAgID8gb3B0aW9ucy53aWR0aFxuICAgICAgICA6ICh0aGlzLmdldEVsZW1lbnQoKVxuICAgICAgICAgID8gdGhpcy5nZXRFbGVtZW50KCkud2lkdGggfHwgMFxuICAgICAgICAgIDogMCk7XG5cbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucyAmJiAoJ2hlaWdodCcgaW4gb3B0aW9ucylcbiAgICAgICAgPyBvcHRpb25zLmhlaWdodFxuICAgICAgICA6ICh0aGlzLmdldEVsZW1lbnQoKVxuICAgICAgICAgID8gdGhpcy5nZXRFbGVtZW50KCkuaGVpZ2h0IHx8IDBcbiAgICAgICAgICA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QpO1xuICAgICAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBudWxsLCBvYmplY3QuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGFuIFVSTCBzdHJpbmdcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjcmVhdGUgYW4gaW1hZ2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGNyZWF0ZWQgKG5ld2x5IGNyZWF0ZWQgaW1hZ2UgaXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1nT3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgaW1nT3B0aW9ucykge1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZSh1cmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShpbWcsIGltZ09wdGlvbnMpKTtcbiAgICB9LCBudWxsLCBpbWdPcHRpb25zICYmIGltZ09wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkltYWdlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjSW1hZ2VFbGVtZW50fVxuICAgKi9cbiAgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyA9XG4gICAgZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgneCB5IHdpZHRoIGhlaWdodCBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHhsaW5rOmhyZWYgY3Jvc3NPcmlnaW4nLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuSW1hZ2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBmYWJyaWMuSW1hZ2Ugb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tVVJMKHBhcnNlZEF0dHJpYnV0ZXNbJ3hsaW5rOmhyZWYnXSwgY2FsbGJhY2ssXG4gICAgICBleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZSB2YWx1ZVxuICAgKi9cbiAgX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlICUgMzYwO1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbmdsZSAtIDEpIC8gOTApICogOTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGFuZ2xlIC8gOTApICogOTA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIGFuIG9iamVjdCAocm90YXRpbmcgaXQgZnJvbSBjdXJyZW50IGFuZ2xlIHRvIG9uZSBvZiAwLCA5MCwgMTgwLCAyNzAsIGV0Yy4gZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGNsb3NlcilcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJvdGF0ZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW46IGZ1bmN0aW9uKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiB0aGlzLmdldCgnYW5nbGUnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgX3RoaXMucm90YXRlKHZhbHVlKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBvYmplY3QsIHRoZW4gcmVyZW5kZXJzIGNhbnZhc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3Quc3RyYWlnaHRlbigpO1xuICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhTdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LmZ4U3RyYWlnaHRlbih7XG4gICAgICBvbkNoYW5nZTogdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGVzdHMgaWYgd2ViZ2wgc3VwcG9ydHMgY2VydGFpbiBwcmVjaXNpb25cbiAgICogQHBhcmFtIHtXZWJHTH0gQ2FudmFzIFdlYkdMIGNvbnRleHQgdG8gdGVzdCBvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gUHJlY2lzaW9uIHRvIHRlc3QgY2FuIGJlIGFueSBvZiBmb2xsb3dpbmc6ICdsb3dwJywgJ21lZGl1bXAnLCAnaGlnaHAnXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBXZWJHTCBzdXBwb3J0cyBnaXZlbiBwcmVjaXNpb24uXG4gICAqL1xuICBmdW5jdGlvbiB0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb24pe1xuICAgIHZhciBmcmFnbWVudFNvdXJjZSA9ICdwcmVjaXNpb24gJyArIHByZWNpc2lvbiArICcgZmxvYXQ7XFxudm9pZCBtYWluKCl7fSc7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZmlsdGVyaW5nIGJhY2tlbmQgaXMgc3VwcG9ydGVkIGJ5IHRoZSB1c2VyJ3MgYnJvd3Nlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVTaXplIGNoZWNrIGlmIHRoZSB0aWxlU2l6ZSBpcyBzdXBwb3J0ZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIHN1cHBvcnRzIFdlYkdMLlxuICAgKi9cbiAgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgPSBmdW5jdGlvbih0aWxlU2l6ZSkge1xuICAgIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRpbGVTaXplID0gdGlsZVNpemUgfHwgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUudGlsZVNpemU7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICAgIGlzU3VwcG9ydGVkID0gZmFicmljLm1heFRleHR1cmVTaXplID49IHRpbGVTaXplO1xuICAgICAgdmFyIHByZWNpc2lvbnMgPSBbJ2hpZ2hwJywgJ21lZGl1bXAnLCAnbG93cCddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspe1xuICAgICAgICBpZiAodGVzdFByZWNpc2lvbihnbCwgcHJlY2lzaW9uc1tpXSkpe1xuICAgICAgICAgIGZhYnJpYy53ZWJHbFByZWNpc2lvbiA9IHByZWNpc2lvbnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH07XG5cbiAgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCA9IFdlYmdsRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogV2ViR0wgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBXZWJnbEZpbHRlckJhY2tlbmQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGlsZVNpemUpIHtcbiAgICAgIHRoaXMudGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplO1xuICAgIH1cbiAgICB0aGlzLnNldHVwR0xDb250ZXh0KHRoaXMudGlsZVNpemUsIHRoaXMudGlsZVNpemUpO1xuICAgIHRoaXMuY2FwdHVyZUdQVUluZm8oKTtcbiAgfTtcblxuICBXZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0aWxlU2l6ZTogMjA0OCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9ibGFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgYSBXZWJHTCBjb250ZXh0IHN1aXRhYmxlIGZvciBmaWx0ZXJpbmcsIGFuZCBiaW5kIGFueSBuZWVkZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICovXG4gICAgc2V0dXBHTENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jcmVhdGVXZWJHTENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdGhpcy5hUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSk7XG4gICAgICB0aGlzLmNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGEgbWV0aG9kIHRvIGNvcHkgZGF0YSBmcm9tIEdMIGNvbnRleHQgdG8gMmQgY2FudmFzLiAgSW4gc29tZSBicm93c2VycyB1c2luZ1xuICAgICAqIHB1dEltYWdlRGF0YSBpcyBmYXN0ZXIgdGhhbiBkcmF3SW1hZ2UgZm9yIHRoYXQgc3BlY2lmaWMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FuTWVhc3VyZVBlcmYgPSB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcbiAgICAgIHZhciBjYW5Vc2VJbWFnZURhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgSW1hZ2VEYXRhKDEsIDEpO1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FuVXNlSW1hZ2VEYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VVaW50OENsYW1wZWQgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICBpZiAoIShjYW5NZWFzdXJlUGVyZiAmJiBjYW5Vc2VJbWFnZURhdGEgJiYgY2FuVXNlQXJyYXlCdWZmZXIgJiYgY2FuVXNlVWludDhDbGFtcGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBpbWFnZUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgdmFyIHRlc3RDb250ZXh0ID0ge1xuICAgICAgICBpbWFnZUJ1ZmZlcjogaW1hZ2VCdWZmZXIsXG4gICAgICAgIGRlc3RpbmF0aW9uV2lkdGg6IHdpZHRoLFxuICAgICAgICBkZXN0aW5hdGlvbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhc1xuICAgICAgfTtcbiAgICAgIHZhciBzdGFydFRpbWUsIGRyYXdJbWFnZVRpbWUsIHB1dEltYWdlRGF0YVRpbWU7XG4gICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvcHlHTFRvMkREcmF3SW1hZ2UuY2FsbCh0ZXN0Q29udGV4dCwgdGhpcy5nbCwgdGVzdENvbnRleHQpO1xuICAgICAgZHJhd0ltYWdlVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRFB1dEltYWdlRGF0YS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBwdXRJbWFnZURhdGFUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBpZiAoZHJhd0ltYWdlVGltZSA+IHB1dEltYWdlRGF0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkREcmF3SW1hZ2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNhbnZhcyBlbGVtZW50IGFuZCBhc3NvY2lhdGVkIFdlYkdMIGNvbnRleHQgYW5kIGF0dGFjaGVzIHRoZW0gYXNcbiAgICAgKiBjbGFzcyBwcm9wZXJ0aWVzIHRvIHRoZSBHTEZpbHRlckJhY2tlbmQgY2xhc3MuXG4gICAgICovXG4gICAgY3JlYXRlV2ViR0xDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgZ2xPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAvLyB0aGlzIGNhbnZhcyBjYW4gZmlyZSB3ZWJnbGNvbnRleHRsb3N0IGFuZCB3ZWJnbGNvbnRleHRyZXN0b3JlZFxuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGFwcGx5IHRoZSByZXF1ZXN0ZWQgZmlsdGVycyB0byB0aGUgc291cmNlIHByb3ZpZGVkLCBkcmF3aW5nIHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgdGFyZ2V0IGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2UgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfHVuZGVmaW5lZH0gY2FjaGVLZXkgQSBrZXkgdXNlZCB0byBjYWNoZSByZXNvdXJjZXMgcmVsYXRlZCB0byB0aGUgc291cmNlLiBJZlxuICAgICAqIG9taXR0ZWQsIGNhY2hpbmcgd2lsbCBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlLCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDYW52YXMsIGNhY2hlS2V5KSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIGNhY2hlZFRleHR1cmU7XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkVGV4dHVyZSA9IHRoaXMuZ2V0Q2FjaGVkVGV4dHVyZShjYWNoZUtleSwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBvcmlnaW5hbFdpZHRoOiBzb3VyY2Uud2lkdGggfHwgc291cmNlLm9yaWdpbmFsV2lkdGgsXG4gICAgICAgIG9yaWdpbmFsSGVpZ2h0OiBzb3VyY2UuaGVpZ2h0IHx8IHNvdXJjZS5vcmlnaW5hbEhlaWdodCxcbiAgICAgICAgc291cmNlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgICBzb3VyY2VUZXh0dXJlOiB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsICFjYWNoZWRUZXh0dXJlICYmIHNvdXJjZSksXG4gICAgICAgIHRhcmdldFRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgIG9yaWdpbmFsVGV4dHVyZTogY2FjaGVkVGV4dHVyZSB8fFxuICAgICAgICAgIHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgcGFzc2VzOiBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgd2ViZ2w6IHRydWUsXG4gICAgICAgIGFQb3NpdGlvbjogdGhpcy5hUG9zaXRpb24sXG4gICAgICAgIHByb2dyYW1DYWNoZTogdGhpcy5wcm9ncmFtQ2FjaGUsXG4gICAgICAgIHBhc3M6IDAsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBGYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZW1wRmJvKTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyICYmIGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpO1xuICAgICAgdGhpcy5jb3B5R0xUbzJEKGdsLCBwaXBlbGluZVN0YXRlKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnNvdXJjZVRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnRhcmdldFRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGVtcEZibyk7XG4gICAgICB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgdGhlIGFwcGx5RmlsdGVyIG1ldGhvZCBidXQgd2l0aCBhZGRpdGlvbmFsIGxvZ2dpbmcgb2YgV2ViR0xcbiAgICAgKiBlcnJvcnMuXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzRGVidWc6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q2FudmFzLCBjYWNoZUtleSkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIHVzZWZ1bCB3aGVuIGRlYnVnZ2luZyBhIHNwZWNpZmljIGlzc3VlIGJ1dCBhZGRzIH4xMHggc2xvd2Rvd24uXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIHJldCA9IHRoaXMuYXBwbHlGaWx0ZXJzKGZpbHRlcnMsIHNvdXJjZSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q2FudmFzLCBjYWNoZUtleSk7XG4gICAgICB2YXIgZ2xFcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgICBpZiAoZ2xFcnJvciAhPT0gZ2wuTk9fRVJST1IpIHtcbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gdGhpcy5nbEVycm9yVG9TdHJpbmcoZ2wsIGdsRXJyb3IpO1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1dlYkdMIEVycm9yICcgKyBlcnJvclN0cmluZyk7XG4gICAgICAgIGVycm9yLmdsRXJyb3JDb2RlID0gZ2xFcnJvcjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBnbEVycm9yVG9TdHJpbmc6IGZ1bmN0aW9uKGNvbnRleHQsIGVycm9yQ29kZSkge1xuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAnQ29udGV4dCB1bmRlZmluZWQgZm9yIGVycm9yIGNvZGU6ICcgKyBlcnJvckNvZGU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZXJyb3JDb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJ0Vycm9yIGNvZGUgaXMgbm90IGEgbnVtYmVyJztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXJyb3JDb2RlKSB7XG4gICAgICAgIGNhc2UgY29udGV4dC5OT19FUlJPUjpcbiAgICAgICAgICByZXR1cm4gJ05PX0VSUk9SJztcbiAgICAgICAgY2FzZSBjb250ZXh0LklOVkFMSURfRU5VTTpcbiAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgIGNhc2UgY29udGV4dC5JTlZBTElEX1ZBTFVFOlxuICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgIGNhc2UgY29udGV4dC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBjb250ZXh0LklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGNvbnRleHQuT1VUX09GX01FTU9SWTpcbiAgICAgICAgICByZXR1cm4gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICBjYXNlIGNvbnRleHQuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgICAgIHJldHVybiAnQ09OVEVYVF9MT1NUX1dFQkdMJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ1VOS05PV05fRVJST1InO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgcmVmZXJlbmNlcywgYW5kIGNsZWFuIHVwIGNhY2hlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhcldlYkdMQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpcGUgb3V0IFdlYkdMLXJlbGF0ZWQgY2FjaGVzLlxuICAgICAqL1xuICAgIGNsZWFyV2ViR0xDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBzcGVjaWZpYyBkaW1lbnNpb25zIHRvIGluaXRpYWxpemUgdGhlIHRleHR1ZXIgdG8gb3IgYSBzb3VyY2UgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNvbnRleHQgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlIGRhdGEuXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGlmICh0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIG9wdGlvbmFsbHkgdXNlZCB0byBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIGNhY2hlIGFycmF5XG4gICAgICpcbiAgICAgKiBJZiBhbiBleGlzdGluZyB0ZXh0dXJlIGlzIG5vdCBmb3VuZCwgYSBuZXcgdGV4dHVyZSBpcyBjcmVhdGVkIGFuZCBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdW5pcXVlSWQgQSBjYWNoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYW4gZXhpc3RpbmcgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSB0byB1c2UgdG8gY3JlYXRlIHRoZVxuICAgICAqIHRleHR1cmUgY2FjaGUgZW50cnkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVGV4dHVyZTogZnVuY3Rpb24odW5pcXVlSWQsIHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZ2wsIHRleHR1cmVJbWFnZVNvdXJjZS53aWR0aCwgdGV4dHVyZUltYWdlU291cmNlLmhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdID0gdGV4dHVyZTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIG91dCBjYWNoZWQgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gYSBzb3VyY2UgaW1hZ2UgdGhhdCBoYXMgYmVlblxuICAgICAqIGZpbHRlcmVkIHByZXZpb3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FjaGVLZXkgVGhlIGNhY2hlIGtleSBwcm92aWRlZCB3aGVuIHRoZSBzb3VyY2UgaW1hZ2Ugd2FzIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBmdW5jdGlvbihjYWNoZUtleSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weUdMVG8yRDogY29weUdMVG8yRERyYXdJbWFnZSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZXh0cmFjdCBHUFUgaW5mb3JtYXRpb24gc3RyaW5ncyBmcm9tIGEgV2ViR0wgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBpbmZvcm1hdGlvbiB3aGVuIGRlYnVnZ2luZyBvciBibGFja2xpc3Rpbmcgc3BlY2lmaWMgR1BVcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgR1BVIGluZm8gb2JqZWN0IHdpdGggcmVuZGVyZXIgYW5kIHZlbmRvciBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNhcHR1cmVHUFVJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdwdUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyk7XG4gICAgICB2YXIgZ3B1SW5mbyA9IHsgcmVuZGVyZXI6ICcnLCB2ZW5kb3I6ICcnIH07XG4gICAgICBpZiAoZXh0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpO1xuICAgICAgICB2YXIgdmVuZG9yID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9WRU5ET1JfV0VCR0wpO1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBncHVJbmZvLnJlbmRlcmVyID0gcmVuZGVyZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVuZG9yKSB7XG4gICAgICAgICAgZ3B1SW5mby52ZW5kb3IgPSB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ncHVJbmZvID0gZ3B1SW5mbztcbiAgICAgIHJldHVybiBncHVJbmZvO1xuICAgIH0sXG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiByZXNpemVDYW52YXNJZk5lZWRlZChwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIHdpZHRoID0gdGFyZ2V0Q2FudmFzLndpZHRoLCBoZWlnaHQgPSB0YXJnZXRDYW52YXMuaGVpZ2h0LFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQ7XG5cbiAgaWYgKHdpZHRoICE9PSBkV2lkdGggfHwgaGVpZ2h0ICE9PSBkSGVpZ2h0KSB7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gZFdpZHRoO1xuICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBkSGVpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcy5cbiAqXG4gKiBUaGUgV2ViR0wgY2FudmFzIGlzIGFzc3VtZWQgdG8gYmUgdXBzaWRlIGRvd24sIHdpdGggdGhlIHRvcC1sZWZ0IHBpeGVsIG9mIHRoZVxuICogZGVzaXJlZCBvdXRwdXQgaW1hZ2UgYXBwZWFyaW5nIGluIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIFdlYkdMIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkREcmF3SW1hZ2UoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIGdsQ2FudmFzID0gZ2wuY2FudmFzLCB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHgudHJhbnNsYXRlKDAsIHRhcmdldENhbnZhcy5oZWlnaHQpOyAvLyBtb3ZlIGl0IGRvd24gYWdhaW5cbiAgY3R4LnNjYWxlKDEsIC0xKTsgLy8gdmVydGljYWwgZmxpcFxuICAvLyB3aGVyZSBpcyBteSBpbWFnZSBvbiB0aGUgYmlnIGdsY2FudmFzP1xuICB2YXIgc291cmNlWSA9IGdsQ2FudmFzLmhlaWdodCAtIHRhcmdldENhbnZhcy5oZWlnaHQ7XG4gIGN0eC5kcmF3SW1hZ2UoZ2xDYW52YXMsIDAsIHNvdXJjZVksIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCwgMCwgMCxcbiAgICB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQpO1xufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMgdXNpbmcgMmQgY2FudmFzJyBwdXRJbWFnZURhdGFcbiAqIEFQSS4gTWVhc3VyYWJseSBmYXN0ZXIgdGhhbiB1c2luZyBjdHguZHJhd0ltYWdlIGluIEZpcmVmb3ggKHZlcnNpb24gNTQgb24gT1NYIFNpZXJyYSkuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcywgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodCxcbiAgICAgIG51bUJ5dGVzID0gZFdpZHRoICogZEhlaWdodCAqIDQ7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OENsYW1wZWQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuXG4gIGdsLnJlYWRQaXhlbHMoMCwgMCwgZFdpZHRoLCBkSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB1OCk7XG4gIHZhciBpbWdEYXRhID0gbmV3IEltYWdlRGF0YSh1OENsYW1wZWQsIGRXaWR0aCwgZEhlaWdodCk7XG4gIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCA9IENhbnZhczJkRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogQ2FudmFzIDJEIGZpbHRlciBiYWNrZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkge307XG5cbiAgQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBub29wLFxuICAgIGRpc3Bvc2U6IG5vb3AsXG4gICAgY2xlYXJXZWJHTENhY2hlczogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9iYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBmaWx0ZXJzIGFnYWluc3QgYSBzb3VyY2UgaW1hZ2UgYW5kIGRyYXcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCBkZXN0aW5hdGlvbiBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuaGFuY2VkRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXIgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2VFbGVtZW50IFRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VIZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgZGVzdGluYXRpb24gZm9yIGZpbHRlcmVkIG91dHB1dCB0byBiZSBkcmF3bi5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZUVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldENhbnZhcykge1xuICAgICAgdmFyIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzb3VyY2VFbGVtZW50LCAwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIG9yaWdpbmFsSW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBzb3VyY2VXaWR0aDogc291cmNlV2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogc291cmNlSGVpZ2h0LFxuICAgICAgICBpbWFnZURhdGE6IGltYWdlRGF0YSxcbiAgICAgICAgb3JpZ2luYWxFbDogc291cmNlRWxlbWVudCxcbiAgICAgICAgb3JpZ2luYWxJbWFnZURhdGE6IG9yaWdpbmFsSW1hZ2VEYXRhLFxuICAgICAgICBjYW52YXNFbDogdGFyZ2V0Q2FudmFzLFxuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7IGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIGlmIChwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aCAhPT0gc291cmNlV2lkdGggfHwgcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0ICE9PSBzb3VyY2VIZWlnaHQpIHtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGg7XG4gICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlXG4gKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNpbWFnZV9maWx0ZXJzfVxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzIHx8IHsgfTtcblxuLyoqXG4gKiBSb290IGZpbHRlciBjbGFzcyBmcm9tIHdoaWNoIGFsbCBmaWx0ZXIgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqL1xuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlciA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgdHlwZTogJ0Jhc2VGaWx0ZXInLFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHNlbmQgd2l0aCBidWZmZXJzLiBkbyBub3QgbW9kaWZ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAnfScsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBmaWx0ZXIncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB0byB1c2UgZm9yIHNoYWRlciBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U291cmNlIGZyYWdtZW50U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNvdXJjZSB2ZXJ0ZXhTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKi9cbiAgY3JlYXRlUHJvZ3JhbTogZnVuY3Rpb24oZ2wsIGZyYWdtZW50U291cmNlLCB2ZXJ0ZXhTb3VyY2UpIHtcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IHRoaXMuZnJhZ21lbnRTb3VyY2U7XG4gICAgdmVydGV4U291cmNlID0gdmVydGV4U291cmNlIHx8IHRoaXMudmVydGV4U291cmNlO1xuICAgIGlmIChmYWJyaWMud2ViR2xQcmVjaXNpb24gIT09ICdoaWdocCcpe1xuICAgICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZS5yZXBsYWNlKFxuICAgICAgICAvcHJlY2lzaW9uIGhpZ2hwIGZsb2F0L2csXG4gICAgICAgICdwcmVjaXNpb24gJyArIGZhYnJpYy53ZWJHbFByZWNpc2lvbiArICcgZmxvYXQnXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1ZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdGcmFnbWVudCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnU2hhZGVyIGxpbmsgZXJyb3IgZm9yIFwiJHt0aGlzLnR5cGV9XCIgJyArXG4gICAgICAgIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB0aGlzLmdldEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoZ2wsIHByb2dyYW0pIHx8IHsgfTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwVyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyk7XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcEggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBXZWJHTEF0dHJpYnV0ZUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYVBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uJyksXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbiAoLyogZ2wsIHByb2dyYW0gKi8pIHtcbiAgICAvLyBpbiBjYXNlIGkgZG8gbm90IG5lZWQgYW55IHNwZWNpYWwgdW5pZm9ybSBpIG5lZWQgdG8gcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxuICAgIHJldHVybiB7IH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYXR0cmlidXRlIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZEF0dHJpYnV0ZURhdGE6IGZ1bmN0aW9uKGdsLCBhdHRyaWJ1dGVMb2NhdGlvbnMsIGFQb3NpdGlvbkRhdGEpIHtcbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb24gPSBhdHRyaWJ1dGVMb2NhdGlvbnMuYVBvc2l0aW9uO1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYVBvc2l0aW9uRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICB9LFxuXG4gIF9zZXR1cEZyYW1lQnVmZmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEpIHtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoICE9PSB3aWR0aCB8fCBvcHRpb25zLnNvdXJjZUhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUob3B0aW9ucy50YXJnZXRUZXh0dXJlKTtcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELFxuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRyYXcgbGFzdCBmaWx0ZXIgb24gY2FudmFzIGFuZCBub3QgdG8gZnJhbWVidWZmZXIuXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuZmluaXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIF9zd2FwVGV4dHVyZXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnBhc3Nlcy0tO1xuICAgIG9wdGlvbnMucGFzcysrO1xuICAgIHZhciB0ZW1wID0gb3B0aW9ucy50YXJnZXRUZXh0dXJlO1xuICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuc291cmNlVGV4dHVyZTtcbiAgICBvcHRpb25zLnNvdXJjZVRleHR1cmUgPSB0ZW1wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlbnRpb25hbGx5IGxlZnQgYmxhbmssIHRvIGJlIG92ZXJyaWRkZW4gaW4gY3VzdG9tIGZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICoqL1xuICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oLyogb3B0aW9ucyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXNzZXMgPiAxICYmIHRoaXMuaXNOZXV0cmFsU3RhdGUob3B0aW9ucykpIHtcbiAgICAgICAgLy8gYXZvaWQgZG9pbmcgc29tZXRoaW5nIHRoYXQgd2UgZG8gbm90IG5lZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGhpcy5pc05ldXRyYWxTdGF0ZSgpKSB7XG4gICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KHRoaXMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHVzaW5nIHdlYmdsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSBUaGUgdGV4dHVyZSBvZiB0aGUgb3JpZ2luYWwgaW5wdXQgaW1hZ2UuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIHNoYWRlciA9IHRoaXMucmV0cmlldmVTaGFkZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMucGFzcyA9PT0gMCAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSkge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMuc291cmNlVGV4dHVyZSk7XG4gICAgfVxuICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2VuZEF0dHJpYnV0ZURhdGEoZ2wsIHNoYWRlci5hdHRyaWJ1dGVMb2NhdGlvbnMsIG9wdGlvbnMuYVBvc2l0aW9uKTtcblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcFcsIDEgLyBvcHRpb25zLnNvdXJjZVdpZHRoKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBILCAxIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQpO1xuXG4gICAgdGhpcy5zZW5kVW5pZm9ybURhdGEoZ2wsIHNoYWRlci51bmlmb3JtTG9jYXRpb25zKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGgsIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9LFxuXG4gIGJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gcmVzZXQgYWN0aXZlIHRleHR1cmUgdG8gMCBhcyB1c3VhbFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIHVuYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICBnZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdO1xuICB9LFxuXG4gIHNldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgdW5pZm9ybSBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzaGFkZXIgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKC8qIGdsLCB1bmlmb3JtTG9jYXRpb25zICovKSB7XG4gICAgLy8gSW50ZW50aW9uYWxseSBsZWZ0IGJsYW5rLiAgT3ZlcnJpZGUgbWUgaW4gc3ViY2xhc3Nlcy5cbiAgfSxcblxuICAvKipcbiAgICogSWYgbmVlZGVkIGJ5IGEgMmQgZmlsdGVyLCB0aGlzIGZ1bmN0aW9ucyBjYW4gY3JlYXRlIGFuIGhlbHBlciBjYW52YXMgdG8gYmUgdXNlZFxuICAgKiByZW1lbWJlciB0aGF0IG9wdGlvbnMudGFyZ2V0Q2FudmFzIGlzIGF2YWlsYWJsZSBmb3IgdXNlIHRpbGwgZW5kIG9mIGNoYWluLlxuICAgKi9cbiAgY3JlYXRlSGVscExheWVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmhlbHBMYXllcikge1xuICAgICAgdmFyIGhlbHBMYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgaGVscExheWVyLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgIGhlbHBMYXllci5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgIG9wdGlvbnMuaGVscExheWVyID0gaGVscExheWVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICovXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0ID0geyB0eXBlOiB0aGlzLnR5cGUgfSwgbWFpblAgPSB0aGlzLm1haW5QYXJhbWV0ZXI7XG4gICAgaWYgKG1haW5QKSB7XG4gICAgICBvYmplY3RbbWFpblBdID0gdGhpc1ttYWluUF07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgKi9cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxufSk7XG5cbmZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZmlsdGVyKTtcbiAgcmV0dXJuIGZpbHRlcjtcbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgTWF0cml4IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vd3d3LndlYndhc3AuY28udWsvdHV0b3JpYWxzLzIxOS9Db2xvcl9NYXRyaXhfRmlsdGVyLnBocH1cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3Bob2Jvc2xhYi5vcmcvbG9nLzIwMTMvMTEvZmFzdC1pbWFnZS1maWx0ZXJzLXdpdGgtd2ViZ2x9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPktvZGFjaHJvbWUgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4KHtcbiAgICogIG1hdHJpeDogW1xuICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsXG4gICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbG9yTWF0cml4ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29sb3JNYXRyaXgnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvciAqPSB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAgICdjb2xvciArPSB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvcm1hdHJpeCBmb3IgcGl4ZWxzLlxuICAgICAqIGFycmF5IG9mIDIwIGZsb2F0cy4gTnVtYmVycyBpbiBwb3NpdGlvbnMgNCwgOSwgMTQsIDE5IGxvb3NlIG1lYW5pbmdcbiAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgKiAwLjAwMzkyMTU2ODYgaXMgdGhlIHBhcnQgb2YgMSB0aGF0IGdldCB0cmFuc2xhdGVkIHRvIDEgaW4gMmRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1hdHJpeDogW1xuICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbWF0cml4JyxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIGNvbG9ybWF0cml4IG9uIHRoZSBjb2xvciBwYXJ0LCBza2lwcGluZyBhbHBoYSwgbWFubHkgZm9yIG5vbiB3ZWJnbCBzY2VuYXJpb1xuICAgICAqIHRvIHNhdmUgc29tZSBjYWxjdWxhdGlvblxuICAgICAqL1xuICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IGluc3RlYWQgbXV0YXRpbmcgdGhlIHByb3RvdHlwZSB3aXRoIHB1c2hcbiAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5tYXRyaXguc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVudGlvbmFsbHkgbGVmdCBibGFuaywgdG8gYmUgb3ZlcnJpZGRlbiBpbiBjdXN0b20gZmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigvKiBvcHRpb25zICovKSB7XG4gICAgICB2YXIgX2NsYXNzID0gZmlsdGVycy5Db2xvck1hdHJpeDtcbiAgICAgIGZvciAodmFyIGkgPSAyMDsgaS0tOykge1xuICAgICAgICBpZiAodGhpcy5tYXRyaXhbaV0gIT09IF9jbGFzcy5wcm90b3R5cGUubWF0cml4W2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIENvbG9yTWF0cml4IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBpLCBjb2xvcnNPbmx5ID0gdGhpcy5jb2xvcnNPbmx5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWYgKGNvbG9yc09ubHkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhID0gZGF0YVtpICsgM107XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIGEgKiBtWzNdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIGEgKiBtWzhdICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIGEgKiBtWzEzXSArIG1bMTRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gciAqIG1bMTVdICsgZyAqIG1bMTZdICsgYiAqIG1bMTddICsgYSAqIG1bMThdICsgbVsxOV0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvck1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3JNYXRyaXgnKSxcbiAgICAgICAgdUNvbnN0YW50czogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29uc3RhbnRzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sXG4gICAgICAgICAgICBtWzVdLCBtWzZdLCBtWzddLCBtWzhdLFxuICAgICAgICAgICAgbVsxMF0sIG1bMTFdLCBtWzEyXSwgbVsxM10sXG4gICAgICAgICAgICBtWzE1XSwgbVsxNl0sIG1bMTddLCBtWzE4XVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29uc3RhbnRzID0gW21bNF0sIG1bOV0sIG1bMTRdLCBtWzE5XV07XG4gICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29uc3RhbnRzLCBjb25zdGFudHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQnJpZ2h0bmVzcyBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyh7XG4gICAqICAgYnJpZ2h0bmVzczogMC4wNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJyaWdodG5lc3MgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEJyaWdodG5lc3MgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0cmFuc2xhdGVkIHRvIC0yNTUgdG8gMjU1IGZvciAyZFxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBicmlnaHRuZXNzOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuYnJpZ2h0bmVzcyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBicmlnaHRuZXNzID0gTWF0aC5yb3VuZCh0aGlzLmJyaWdodG5lc3MgKiAyNTUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKyBicmlnaHRuZXNzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJyaWdodG5lc3M6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJyaWdodG5lc3MnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCcmlnaHRuZXNzLCB0aGlzLmJyaWdodG5lc3MpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cIj5odG1sNXJvY2tzIGFydGljbGU8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2hhcnBlbiBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMCwgLTEsICAwLFxuICAgKiAgICAgICAgICAgIC0xLCAgNSwgLTEsXG4gICAqICAgICAgICAgICAgIDAsIC0xLCAgMCBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5CbHVyIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85IF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyIHdpdGggb3BhcXVlbmVzczwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG9wYXF1ZTogdHJ1ZSxcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Db252b2x1dGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udm9sdXRlJyxcblxuICAgIC8qXG4gICAgICogT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqL1xuICAgIG9wYXF1ZTogZmFsc2UsXG5cbiAgICAvKlxuICAgICAqIG1hdHJpeCBmb3IgdGhlIGZpbHRlciwgbWF4IDl4OVxuICAgICAqL1xuICAgIG1hdHJpeDogWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIENvbnZvbHV0ZV8zXzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMSksIHVTdGVwSCAqIChoIC0gMSkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV8zXzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMS4wKSwgdVN0ZXBIICogKGggLSAxLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wYXF1ZT1mYWxzZV0gT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1hdHJpeF0gRmlsdGVyIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KHRoaXMubWF0cml4Lmxlbmd0aCk7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBzaXplICsgJ18nICsgKHRoaXMub3BhcXVlID8gMSA6IDApO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICB3ZWlnaHRzID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSksXG4gICAgICAgICAgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKSxcbiAgICAgICAgICBzdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBzaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKHN3LCBzaCksXG4gICAgICAgICAgZHN0ID0gb3V0cHV0LmRhdGEsXG4gICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXG4gICAgICAgICAgYWxwaGFGYWMgPSB0aGlzLm9wYXF1ZSA/IDEgOiAwLFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGRzdE9mZixcbiAgICAgICAgICBzY3gsIHNjeSwgc3JjT2ZmLCB3dCxcbiAgICAgICAgICB4LCB5LCBjeCwgY3k7XG5cbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgICAgZHN0T2ZmID0gKHkgKiBzdyArIHgpICogNDtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICByID0gMDsgZyA9IDA7IGIgPSAwOyBhID0gMDtcblxuICAgICAgICAgIGZvciAoY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgIGZvciAoY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKHNjeSA8IDAgfHwgc2N5ID4gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPiBzdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgciArPSBkYXRhW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgZyArPSBkYXRhW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgICAgICAgIGIgKz0gZGF0YVtzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgICAgICBhICs9IGRhdGFbc3JjT2ZmICsgM10gKiB3dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gZGF0YVtkc3RPZmYgKyAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TWF0cml4JyksXG4gICAgICAgIHVPcGFxdWU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU9wYXF1ZScpLFxuICAgICAgICB1SGFsZlNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhhbGZTaXplJyksXG4gICAgICAgIHVTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTaXplJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudU1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBvcGFxdWU6IHRoaXMub3BhcXVlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR3JheXNjYWxlIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdyYXlzY2FsZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHcmF5c2NhbGUnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIGF2ZXJhZ2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmIgKyBjb2xvci5nKSAvIDMuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbGlnaHRuZXNzOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKG1heChtYXgoY29sLnIsIGNvbC5nKSxjb2wuYikgKyBtaW4obWluKGNvbC5yLCBjb2wuZyksY29sLmIpKSAvIDIuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGx1bWlub3NpdHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAwLjIxICogY29sLnIgKyAwLjcyICogY29sLmcgKyAwLjA3ICogY29sLmI7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIG1vZGUsIGJldHdlZW4gJ2F2ZXJhZ2UnLCAnbGlnaHRuZXNzJywgJ2x1bWlub3NpdHknXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vZGU6ICdhdmVyYWdlJyxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtb2RlJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHcmF5c2NhbGUgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCwgdmFsdWUsXG4gICAgICAgICAgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbGlnaHRuZXNzJykge1xuICAgICAgICAgIHZhbHVlID0gKE1hdGgubWluKGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkgK1xuICAgICAgICAgICAgTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsdW1pbm9zaXR5Jykge1xuICAgICAgICAgIHZhbHVlID0gMC4yMSAqIGRhdGFbaV0gKyAwLjcyICogZGF0YVtpICsgMV0gKyAwLjA3ICogZGF0YVtpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TW9kZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TW9kZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgLy8gZGVmYXVsdCBhdmVyYWdlIG1vZGUuXG4gICAgICB2YXIgbW9kZSA9IDE7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51TW9kZSwgbW9kZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydCgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5JbnZlcnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSW52ZXJ0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gaW50IHVJbnZlcnQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnaWYgKHVJbnZlcnQgPT0gMSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCAtIGNvbG9yLnIsMS4wIC1jb2xvci5nLDEuMCAtY29sb3IuYixjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGludmVydC4gaWYgZmFsc2UsIGRvZXMgbm90aGluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnZlcnQ6IHRydWUsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnaW52ZXJ0JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBJbnZlcnQgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmludmVydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUludmVydDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW52ZXJ0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW52ZXJ0LCB0aGlzLmludmVydCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnR9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBOb2lzZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSh7XG4gICAqICAgbm9pc2U6IDcwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuTm9pc2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdOb2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBub2lzZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Tm9pc2U7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2VlZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmQodmVjMiBjbywgZmxvYXQgc2VlZCwgZmxvYXQgdlNjYWxlKSB7XFxuJyArXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSAqIHZTY2FsZSAsdmVjMigxMi45ODk4ICwgNzguMjMzKSkpICogNDM3NTguNTQ1MyAqIChzZWVkICsgMC4wMSkgLyAyLjApO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiICs9ICgwLjUgLSByYW5kKHZUZXhDb29yZCwgdVNlZWQsIDAuMSAvIHVTdGVwSCkpICogdU5vaXNlO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnbm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogTm9pc2UgdmFsdWUsIGZyb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vaXNlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5ub2lzZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBub2lzZSA9IHRoaXMubm9pc2UsIHJhbmQ7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcblxuICAgICAgICByYW5kID0gKDAuNSAtIE1hdGgucmFuZG9tKCkpICogbm9pc2U7XG5cbiAgICAgICAgZGF0YVtpXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSByYW5kO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU5vaXNlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VOb2lzZScpLFxuICAgICAgICB1U2VlZDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2VlZCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudU5vaXNlLCB0aGlzLm5vaXNlIC8gMjU1KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTZWVkLCBNYXRoLnJhbmRvbSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgbm9pc2U6IHRoaXMubm9pc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSh7XG4gICAqICAgYmxvY2tzaXplOiA4XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuUGl4ZWxhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdQaXhlbGF0ZScsXG5cbiAgICBibG9ja3NpemU6IDQsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmxvY2tzaXplJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIFBpeGVsYXRlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCbG9ja3NpemU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja1cgPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tIID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2ludCBwb3NYID0gaW50KHZUZXhDb29yZC54IC8gYmxvY2tXKTtcXG4nICtcbiAgICAgICAgJ2ludCBwb3NZID0gaW50KHZUZXhDb29yZC55IC8gYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NYID0gZmxvYXQocG9zWCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWSA9IGZsb2F0KHBvc1kpO1xcbicgK1xuICAgICAgICAndmVjMiBzcXVhcmVDb29yZHMgPSB2ZWMyKGZwb3NYICogYmxvY2tXLCBmcG9zWSAqIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBzcXVhcmVDb29yZHMpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgUGl4ZWxhdGUgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5ibG9ja3NpemUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBqTGVuID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGluZGV4LCBpLCBqLCByLCBnLCBiLCBhLFxuICAgICAgICAgIF9pLCBfaiwgX2lMZW4sIF9qTGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuXG4gICAgICAgICAgaW5kZXggPSAoaSAqIDQpICogakxlbiArIChqICogNCk7XG5cbiAgICAgICAgICByID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICAgICAgICBfaUxlbiA9IE1hdGgubWluKGkgKyB0aGlzLmJsb2Nrc2l6ZSwgaUxlbik7XG4gICAgICAgICAgX2pMZW4gPSBNYXRoLm1pbihqICsgdGhpcy5ibG9ja3NpemUsIGpMZW4pO1xuICAgICAgICAgIGZvciAoX2kgPSBpOyBfaSA8IF9pTGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmb3IgKF9qID0gajsgX2ogPCBfakxlbjsgX2orKykge1xuICAgICAgICAgICAgICBpbmRleCA9IChfaSAqIDQpICogakxlbiArIChfaiAqIDQpO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGc7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHdoZW4gdGhlIGZpbHRlciBpcyBub3QgZ29ubmEgYXBwbHkgY2hhbmdlcyB0byB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzaXplID09PSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJsb2Nrc2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QmxvY2tzaXplJyksXG4gICAgICAgIHVTdGVwVzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKSxcbiAgICAgICAgdVN0ZXBIOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aGl0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcih7XG4gICAqICAgdGhyZXNob2xkOiAwLjIsXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5SZW1vdmVDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1JlbW92ZUNvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIHJlbW92ZSwgaW4gYW55IGZvcm1hdCB1bmRlcnN0b29kIGJ5IGZhYnJpYy5Db2xvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICcjRkZGRkZGJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1TG93O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1SGlnaDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmKGFsbChncmVhdGVyVGhhbihnbF9GcmFnQ29sb3IucmdiLHVMb3cucmdiKSkgJiYgYWxsKGdyZWF0ZXJUaGFuKHVIaWdoLnJnYixnbF9GcmFnQ29sb3IucmdiKSkpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSAwLjA7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBkaXN0YW5jZSB0byBhY3R1YWwgY29sb3IsIGFzIHZhbHVlIHVwIG9yIGRvd24gZnJvbSBlYWNoIHIsZyxiXG4gICAgICogYmV0d2VlbiAwIGFuZCAxXG4gICAgICoqL1xuICAgIGRpc3RhbmNlOiAwLjAyLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbG9yIHRvIHJlbW92ZSBpbnNpZGUgZGlzdGFuY2UsIHVzZSBhbHBoYSBjaGFubmVsIGZvciBhIHNtb290aGVyIGRlbGV0aW9uXG4gICAgICogTk9UIElNUExFTUVOVEVEIFlFVFxuICAgICAqKi9cbiAgICB1c2VBbHBoYTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbG9yPSNSUkdHQkJdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0xMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UgKiAyNTUsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gKyBkaXN0YW5jZSxcbiAgICAgICAgICBdO1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBpZiAociA+IGxvd0NbMF0gJiZcbiAgICAgICAgICAgIGcgPiBsb3dDWzFdICYmXG4gICAgICAgICAgICBiID4gbG93Q1syXSAmJlxuICAgICAgICAgICAgciA8IGhpZ2hDWzBdICYmXG4gICAgICAgICAgICBnIDwgaGlnaENbMV0gJiZcbiAgICAgICAgICAgIGIgPCBoaWdoQ1syXSkge1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUxvdzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TG93JyksXG4gICAgICAgIHVIaWdoOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIaWdoJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHBhcnNlRmxvYXQodGhpcy5kaXN0YW5jZSksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMF0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMV0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMl0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF07XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUxvdywgbG93Qyk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUhpZ2gsIGhpZ2hDKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICB2YXIgbWF0cmljZXMgPSB7XG4gICAgQnJvd25pZTogW1xuICAgICAgMC41OTk3MCwwLjM0NTUzLC0wLjI3MDgyLDAsMC4xODYsXG4gICAgICAtMC4wMzc3MCwwLjg2MDk1LDAuMTUwNTksMCwtMC4xNDQ5LFxuICAgICAgMC4yNDExMywtMC4wNzQ0MSwwLjQ0OTcyLDAsLTAuMDI5NjUsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFZpbnRhZ2U6IFtcbiAgICAgIDAuNjI3OTMsMC4zMjAyMSwtMC4wMzk2NSwwLDAuMDM3ODQsXG4gICAgICAwLjAyNTc4LDAuNjQ0MTEsMC4wMzI1OSwwLDAuMDI5MjYsXG4gICAgICAwLjA0NjYwLC0wLjA4NTEyLDAuNTI0MTYsMCwwLjAyMDIzLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBLb2RhY2hyb21lOiBbXG4gICAgICAxLjEyODU1LC0wLjM5NjczLC0wLjAzOTkyLDAsMC4yNDk5MSxcbiAgICAgIC0wLjE2NDA0LDEuMDgzNTIsLTAuMDU0OTgsMCwwLjA5Njk4LFxuICAgICAgLTAuMTY3ODYsLTAuNTYwMzQsMS42MDE0OCwwLDAuMTM5NzIsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFRlY2huaWNvbG9yOiBbXG4gICAgICAxLjkxMjUyLC0wLjg1NDUzLC0wLjA5MTU1LDAsMC4wNDYyNCxcbiAgICAgIC0wLjMwODc4LDEuNzY1ODksLTAuMTA2MDEsMCwtMC4yNzU4OSxcbiAgICAgIC0wLjIzMTEwLC0wLjc1MDE4LDEuODQ3NTksMCwwLjEyMTM3LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBQb2xhcm9pZDogW1xuICAgICAgMS40MzgsLTAuMDYyLC0wLjA2MiwwLDAsXG4gICAgICAtMC4xMjIsMS4zNzgsLTAuMTIyLDAsMCxcbiAgICAgIC0wLjAxNiwtMC4wMTYsMS40ODMsMCwwLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBTZXBpYTogW1xuICAgICAgMC4zOTMsIDAuNzY5LCAwLjE4OSwgMCwgMCxcbiAgICAgIDAuMzQ5LCAwLjY4NiwgMC4xNjgsIDAsIDAsXG4gICAgICAwLjI3MiwgMC41MzQsIDAuMTMxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG4gICAgQmxhY2tXaGl0ZTogW1xuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICBdXG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG1hdHJpY2VzKSB7XG4gICAgZmlsdGVyc1trZXldID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlciB0eXBlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgdHlwZToga2V5LFxuXG4gICAgICAvKipcbiAgICAgICAqIENvbG9ybWF0cml4IGZvciB0aGUgZWZmZWN0XG4gICAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgbWF0cml4OiBtYXRyaWNlc1trZXldLFxuXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIG1hdHJpeCBleHBvcnQgZm9yIHRoaXMga2luZCBvZiBzdGF0aWMsIHBhcmFtZXRlciBsZXNzIGZpbHRlcnMuXG4gICAgICAgKi9cbiAgICAgIG1haW5QYXJhbWV0ZXI6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGFcbiAgICAgICAqL1xuICAgICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIH0pO1xuICAgIGZhYnJpYy5JbWFnZS5maWx0ZXJzW2tleV0uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZC5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZENvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBjb2xvcjogJyNGOTVDNjMnLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlcjogb25lIG9mIG11bHRpcGx5LCBhZGQsIGRpZmYsIHNjcmVlbiwgc3VidHJhY3QsXG4gICAgICogZGFya2VuLCBsaWdodGVuLCBvdmVybGF5LCBleGNsdXNpb24sIHRpbnQuXG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgY29sb3Igb3BlcmF0aW9uLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdnbF9GcmFnQ29sb3IucmdiICo9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIHNjcmVlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSAxLjAgLSAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGFkZDogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgZGlmZjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBhYnMoZ2xfRnJhZ0NvbG9yLnJnYiAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBzdWJ0cmFjdDogJ2dsX0ZyYWdDb2xvci5yZ2IgLT0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgbGlnaHRlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtYXgoZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGRhcmtlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtaW4oZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGV4Y2x1c2lvbjogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYiAtIDIuMCAqICh1Q29sb3IucmdiICogZ2xfRnJhZ0NvbG9yLnJnYik7XFxuJyxcbiAgICAgIG92ZXJsYXk6ICdpZiAodUNvbG9yLnIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgKj0gMi4wICogdUNvbG9yLnI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IucikgKiAoMS4wIC0gdUNvbG9yLnIpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5nIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nICo9IDIuMCAqIHVDb2xvci5nO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmcpICogKDEuMCAtIHVDb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuYiA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiAqPSAyLjAgKiB1Q29sb3IuYjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5iKSAqICgxLjAgLSB1Q29sb3IuYik7XFxuJyArXG4gICAgICAgICd9XFxuJyxcbiAgICAgIHRpbnQ6ICdnbF9GcmFnQ29sb3IucmdiICo9ICgxLjAgLSB1Q29sb3IuYSk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYnVpbGQgdGhlIGZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGZpbHRlcnMsIGpvaW5pbmcgdGhlIGNvbW1vbiBwYXJ0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWMgb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBtb2RlIG9mIHRoZSBmaWx0ZXIsIGEga2V5IG9mIHRoaXMuZnJhZ21lbnRTb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkU291cmNlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdpZiAoY29sb3IuYSA+IDAuMCkge1xcbicgK1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNvdXJjZVttb2RlXSArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ30nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlLCBzaGFkZXJTb3VyY2U7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBzaGFkZXJTb3VyY2UgPSB0aGlzLmJ1aWxkU291cmNlKHRoaXMubW9kZSk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgdHIsIHRnLCB0YixcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSwgYWxwaGExID0gMSAtIHRoaXMuYWxwaGE7XG5cbiAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICB0ciA9IHNvdXJjZVswXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0ZyA9IHNvdXJjZVsxXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0YiA9IHNvdXJjZVsyXSAqIHRoaXMuYWxwaGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IDI1NSAtICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKyB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyArIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICsgdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICBjYXNlICdkaWZmZXJlbmNlJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLmFicyhyIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLmFicyhnIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLmFicyhiIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VidHJhY3QnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgLSB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAtIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiIC0gdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbihiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1heChyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3ZlcmxheSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgPCAxMjggPyAoMiAqIHIgKiB0ciAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyA8IDEyOCA/ICgyICogZyAqIHRnIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiIDwgMTI4ID8gKDIgKiBiICogdGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V4Y2x1c2lvbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByIC0gKCgyICogdHIgKiByKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAtICgoMiAqIHRnICogZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgLSAoKDIgKiB0YiAqIGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RpbnQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgKiBhbHBoYTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3InKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzBdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVswXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsxXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMV0gLyAyNTU7XG4gICAgICBzb3VyY2VbMl0gPSB0aGlzLmFscGhhICogc291cmNlWzJdIC8gMjU1O1xuICAgICAgc291cmNlWzNdID0gdGhpcy5hbHBoYTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3IsIHNvdXJjZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEltYWdlIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZEltYWdlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kSW1hZ2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZEltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBpbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGNvbG9yIG9wZXJhdGlvbi5cbiAgICAgKiovXG4gICAgYWxwaGE6IDEsXG5cbiAgICB2ZXJ0ZXhTb3VyY2U6ICdhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDMgdVRyYW5zZm9ybU1hdHJpeDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2VGV4Q29vcmQgPSBhUG9zaXRpb247XFxuJyArXG4gICAgICAgICd2VGV4Q29vcmQyID0gKHVUcmFuc2Zvcm1NYXRyaXggKiB2ZWMzKGFQb3NpdGlvbiwgMS4wKSkueHk7XFxuJyArXG4gICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBNdWx0aXBseSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIG11bHRpcGx5OiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1SW1hZ2U7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1SW1hZ2UsIHZUZXhDb29yZDIpO1xcbicgK1xuICAgICAgICAgICdjb2xvci5yZ2JhICo9IGNvbG9yMi5yZ2JhO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbWFzazogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IuYSA9IGNvbG9yMi5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIGxvYWQgdGV4dHVyZSB0byBibGVuZC5cbiAgICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgICB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKG9wdGlvbnMuZmlsdGVyQmFja2VuZCwgdGhpcy5pbWFnZSk7XG4gICAgICB0aGlzLmJpbmRBZGRpdGlvbmFsVGV4dHVyZShnbCwgdGV4dHVyZSwgZ2wuVEVYVFVSRTEpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2FwcGx5VG9XZWJHTCcsIG9wdGlvbnMpO1xuICAgICAgdGhpcy51bmJpbmRBZGRpdGlvbmFsVGV4dHVyZShnbCwgZ2wuVEVYVFVSRTEpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihiYWNrZW5kLCBpbWFnZSkge1xuICAgICAgcmV0dXJuIGJhY2tlbmQuZ2V0Q2FjaGVkVGV4dHVyZShpbWFnZS5jYWNoZUtleSwgaW1hZ2UuX2VsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYSB0cmFuc2Zvcm1NYXRyaXggdG8gYWRhcHQgdGhlIGltYWdlIHRvIGJsZW5kIG92ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2UuX2VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuX2VsZW1lbnQuaGVpZ2h0O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMSAvIGltYWdlLnNjYWxlWCwgMCwgMCxcbiAgICAgICAgMCwgMSAvIGltYWdlLnNjYWxlWSwgMCxcbiAgICAgICAgLWltYWdlLmxlZnQgLyB3aWR0aCwgLWltYWdlLnRvcCAvIGhlaWdodCwgMVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJsZW5kIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHJlc291cmNlcyA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5yZXNvdXJjZXMsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgd2lkdGggPSBvcHRpb25zLmltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgdHIsIHRnLCB0YiwgdGEsXG4gICAgICAgICAgciwgZywgYiwgYSxcbiAgICAgICAgICBjYW52YXMxLCBjb250ZXh0LCBpbWFnZSA9IHRoaXMuaW1hZ2UsIGJsZW5kRGF0YTtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmxlbmRJbWFnZSkge1xuICAgICAgICByZXNvdXJjZXMuYmxlbmRJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfVxuICAgICAgY2FudmFzMSA9IHJlc291cmNlcy5ibGVuZEltYWdlO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShpbWFnZS5zY2FsZVgsIDAsIDAsIGltYWdlLnNjYWxlWSwgaW1hZ2UubGVmdCwgaW1hZ2UudG9wKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLl9lbGVtZW50LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJsZW5kRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgIHRyID0gYmxlbmREYXRhW2ldO1xuICAgICAgICB0ZyA9IGJsZW5kRGF0YVtpICsgMV07XG4gICAgICAgIHRiID0gYmxlbmREYXRhW2kgKyAyXTtcbiAgICAgICAgdGEgPSBibGVuZERhdGFbaSArIDNdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGEgKiB0YSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hc2snOlxuICAgICAgICAgICAgZGF0YVtpICsgM10gPSB0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1VHJhbnNmb3JtTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VUcmFuc2Zvcm1NYXRyaXgnKSxcbiAgICAgICAgdUltYWdlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VJbWFnZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW1hZ2UsIDEpOyAvLyB0ZXh0dXJlIHVuaXQgMS5cbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodW5pZm9ybUxvY2F0aW9ucy51VHJhbnNmb3JtTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgaW1hZ2U6IHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS50b09iamVjdCgpLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tT2JqZWN0KG9iamVjdC5pbWFnZSwgZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCk7XG4gICAgICBvcHRpb25zLmltYWdlID0gaW1hZ2U7XG4gICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZShvcHRpb25zKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksIHBvdyA9IE1hdGgucG93LCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicywgcm91bmQgPSBNYXRoLnJvdW5kLCBzaW4gPSBNYXRoLnNpbixcbiAgICAgIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgaW1hZ2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZSgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5SZXNpemUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVzaXplJyxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc2l6ZVR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlc2l6ZVR5cGU6ICdoZXJtaXRlJyxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBmb3IgcmVzaXppbmcsIHggYXhpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWDogMCxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBmb3IgcmVzaXppbmcsIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWTogMCxcblxuICAgIC8qKlxuICAgICAqIExhbmN6b3NMb2JlcyBwYXJhbWV0ZXIgZm9yIGxhbmN6b3MgZmlsdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxhbmN6b3NMb2Jlc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGFuY3pvc0xvYmVzOiAzLFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdURlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgICB1VGFwczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VGFwcycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLnVEZWx0YSwgdGhpcy5ob3Jpem9udGFsID8gWzEgLyB0aGlzLndpZHRoLCAwXSA6IFswLCAxIC8gdGhpcy5oZWlnaHRdKTtcbiAgICAgIGdsLnVuaWZvcm0xZnYodW5pZm9ybUxvY2F0aW9ucy51VGFwcywgdGhpcy50YXBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWx0ZXJXaW5kb3cgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpLCBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIGZpbHRlcldpbmRvdztcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRoaXMuZ2VuZXJhdGVTaGFkZXIoZmlsdGVyV2luZG93KTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsdGVyV2luZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMudGVtcFNjYWxlO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmxhbmN6b3NMb2JlcyAvIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgZ2V0VGFwczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbG9iZUZ1bmN0aW9uID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSwgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZSxcbiAgICAgICAgICBmaWx0ZXJXaW5kb3cgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpLCB0YXBzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmaWx0ZXJXaW5kb3c7IGkrKykge1xuICAgICAgICB0YXBzW2kgLSAxXSA9IGxvYmVGdW5jdGlvbihpICogc2NhbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHZlcnRleCBhbmQgc2hhZGVyIHNvdXJjZXMgZnJvbSB0aGUgbmVjZXNzYXJ5IHN0ZXBzIG51bWJlcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyV2luZG93XG4gICAgICovXG4gICAgZ2VuZXJhdGVTaGFkZXI6IGZ1bmN0aW9uKGZpbHRlcldpbmRvdykge1xuICAgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoZmlsdGVyV2luZG93KSxcbiAgICAgICAgICBmcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTb3VyY2VUT1AsIGZpbHRlcldpbmRvdztcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpIC0gMV0gPSBpICsgJy4wICogdURlbHRhJztcbiAgICAgIH1cblxuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3VuaWZvcm0gZmxvYXQgdVRhcHNbJyArIGZpbHRlcldpbmRvdyArICddO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAndm9pZCBtYWluKCkge1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBmbG9hdCBzdW0gPSAxLjA7XFxuJztcblxuICAgICAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKG9mZnNldCwgaSkge1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArICcgKyBvZmZzZXQgKyAnKSAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgLSAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIHN1bSArPSAyLjAgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICB9KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yIC8gc3VtO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnfSc7XG4gICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgfSxcblxuICAgIGZyYWdtZW50U291cmNlVE9QOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMiB1RGVsdGE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHJlc2l6ZSBmaWx0ZXIgdG8gdGhlIGltYWdlXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEgJiYgdGhpcy5pc05ldXRyYWxTdGF0ZShvcHRpb25zKSkge1xuICAgICAgICAgIC8vIGF2b2lkIGRvaW5nIHNvbWV0aGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmRXID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogdGhpcy5zY2FsZVgpO1xuICAgICAgICB0aGlzLmRIID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kVyAvIHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpO1xuICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGggPSB0aGlzLmRXO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNvdXJjZVdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRIID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRIIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpO1xuICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0ID0gdGhpcy5kSDtcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VIZWlnaHQgPSBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRoaXMuaXNOZXV0cmFsU3RhdGUob3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2NhbGVYID0gb3B0aW9ucy5zY2FsZVggfHwgdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gb3B0aW9ucy5zY2FsZVkgfHwgdGhpcy5zY2FsZVk7XG4gICAgICByZXR1cm4gc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMTtcbiAgICB9LFxuXG4gICAgbGFuY3pvc0NyZWF0ZTogZnVuY3Rpb24obG9iZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID49IGxvYmVzIHx8IHggPD0gLWxvYmVzKSB7XG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3ICYmIHggPiAtMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgIHggKj0gTWF0aC5QSTtcbiAgICAgICAgdmFyIHh4ID0geCAvIGxvYmVzO1xuICAgICAgICByZXR1cm4gKHNpbih4KSAvIHgpICogc2luKHh4KSAvIHh4O1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuXG4gICAgICB0aGlzLnJjcFNjYWxlWCA9IDEgLyBzY2FsZVg7XG4gICAgICB0aGlzLnJjcFNjYWxlWSA9IDEgLyBzY2FsZVk7XG5cbiAgICAgIHZhciBvVyA9IGltYWdlRGF0YS53aWR0aCwgb0ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGRXID0gcm91bmQob1cgKiBzY2FsZVgpLCBkSCA9IHJvdW5kKG9IICogc2NhbGVZKSxcbiAgICAgICAgICBuZXdEYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnc2xpY2VIYWNrJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5zbGljZUJ5VHdvKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2hlcm1pdGUnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmhlcm1pdGVGYXN0UmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2JpbGluZWFyJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5iaWxpbmVhckZpbHRlcmluZyhvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdsYW5jem9zJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5sYW5jem9zUmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gbmV3RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNsaWNlQnlUd29cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIHNsaWNlQnlUd286IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgbXVsdCA9IDAuNSwgZG9uZVcgPSBmYWxzZSwgZG9uZUggPSBmYWxzZSwgc3RlcFcgPSBvVyAqIG11bHQsXG4gICAgICAgICAgc3RlcEggPSBvSCAqIG11bHQsIHJlc291cmNlcyA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICB0bXBDYW52YXMsIGN0eCwgc1ggPSAwLCBzWSA9IDAsIGRYID0gb1csIGRZID0gMDtcbiAgICAgIGlmICghcmVzb3VyY2VzLnNsaWNlQnlUd28pIHtcbiAgICAgICAgcmVzb3VyY2VzLnNsaWNlQnlUd28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHJlc291cmNlcy5zbGljZUJ5VHdvO1xuICAgICAgaWYgKHRtcENhbnZhcy53aWR0aCA8IG9XICogMS41IHx8IHRtcENhbnZhcy5oZWlnaHQgPCBvSCkge1xuICAgICAgICB0bXBDYW52YXMud2lkdGggPSBvVyAqIDEuNTtcbiAgICAgICAgdG1wQ2FudmFzLmhlaWdodCA9IG9IO1xuICAgICAgfVxuICAgICAgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9XICogMS41LCBvSCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGRXID0gZmxvb3IoZFcpO1xuICAgICAgZEggPSBmbG9vcihkSCk7XG5cbiAgICAgIHdoaWxlICghZG9uZVcgfHwgIWRvbmVIKSB7XG4gICAgICAgIG9XID0gc3RlcFc7XG4gICAgICAgIG9IID0gc3RlcEg7XG4gICAgICAgIGlmIChkVyA8IGZsb29yKHN0ZXBXICogbXVsdCkpIHtcbiAgICAgICAgICBzdGVwVyA9IGZsb29yKHN0ZXBXICogbXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcFcgPSBkVztcbiAgICAgICAgICBkb25lVyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRIIDwgZmxvb3Ioc3RlcEggKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBIID0gZmxvb3Ioc3RlcEggKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwSCA9IGRIO1xuICAgICAgICAgIGRvbmVIID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgc1gsIHNZLCBvVywgb0gsIGRYLCBkWSwgc3RlcFcsIHN0ZXBIKTtcbiAgICAgICAgc1ggPSBkWDtcbiAgICAgICAgc1kgPSBkWTtcbiAgICAgICAgZFkgKz0gc3RlcEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YShzWCwgc1ksIGRXLCBkSCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBsYW5jem9zUmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBsYW5jem9zUmVzaXplOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKHUpIHtcbiAgICAgICAgdmFyIHYsIGksIHdlaWdodCwgaWR4LCBhLCByZWQsIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSwgYWxwaGEsIGZYLCBmWTtcbiAgICAgICAgY2VudGVyLnggPSAodSArIDAuNSkgKiByYXRpb1g7XG4gICAgICAgIGljZW50ZXIueCA9IGZsb29yKGNlbnRlci54KTtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGRIOyB2KyspIHtcbiAgICAgICAgICBjZW50ZXIueSA9ICh2ICsgMC41KSAqIHJhdGlvWTtcbiAgICAgICAgICBpY2VudGVyLnkgPSBmbG9vcihjZW50ZXIueSk7XG4gICAgICAgICAgYSA9IDA7IHJlZCA9IDA7IGdyZWVuID0gMDsgYmx1ZSA9IDA7IGFscGhhID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBpY2VudGVyLnggLSByYW5nZTJYOyBpIDw9IGljZW50ZXIueCArIHJhbmdlMlg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gb1cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmWCA9IGZsb29yKDEwMDAgKiBhYnMoaSAtIGNlbnRlci54KSk7XG4gICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF0pIHtcbiAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXSA9IHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpY2VudGVyLnkgLSByYW5nZTJZOyBqIDw9IGljZW50ZXIueSArIHJhbmdlMlk7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBvSCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZZID0gZmxvb3IoMTAwMCAqIGFicyhqIC0gY2VudGVyLnkpKTtcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdW2ZZXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF1bZlldID0gbGFuY3pvcyhzcXJ0KHBvdyhmWCAqIHJjcFJhdGlvWCwgMikgKyBwb3coZlkgKiByY3BSYXRpb1ksIDIpKSAvIDEwMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdlaWdodCA9IGNhY2hlTGFuY1tmWF1bZlldO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IChqICogb1cgKyBpKSAqIDQ7XG4gICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmVkICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICBncmVlbiArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgICAgIGJsdWUgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBhbHBoYSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9ICh2ICogZFcgKyB1KSAqIDQ7XG4gICAgICAgICAgZGVzdERhdGFbaWR4XSA9IHJlZCAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMV0gPSBncmVlbiAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMl0gPSBibHVlIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAzXSA9IGFscGhhIC8gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3UgPCBkVykge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzKHUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0SW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBkZXN0SW1nID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdERhdGEgPSBkZXN0SW1nLmRhdGEsXG4gICAgICAgICAgbGFuY3pvcyA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksXG4gICAgICAgICAgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJjcFJhdGlvWCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgcmNwUmF0aW9ZID0gMiAvIHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhbmdlMlggPSBjZWlsKHJhdGlvWCAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgcmFuZ2UyWSA9IGNlaWwocmF0aW9ZICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICBjYWNoZUxhbmMgPSB7IH0sIGNlbnRlciA9IHsgfSwgaWNlbnRlciA9IHsgfTtcblxuICAgICAgcmV0dXJuIHByb2Nlc3MoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbGluZWFyRmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBiaWxpbmVhckZpbHRlcmluZzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBhLCBiLCBjLCBkLCB4LCB5LCBpLCBqLCB4RGlmZiwgeURpZmYsIGNobmwsXG4gICAgICAgICAgY29sb3IsIG9mZnNldCA9IDAsIG9yaWdQaXgsIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLFxuICAgICAgICAgIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHc0ID0gNCAqIChvVyAtIDEpLCBpbWcgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBwaXhlbHMgPSBpbWcuZGF0YSwgZGVzdEltYWdlID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdFBpeGVscyA9IGRlc3RJbWFnZS5kYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGRIOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRXOyBqKyspIHtcbiAgICAgICAgICB4ID0gZmxvb3IocmF0aW9YICogaik7XG4gICAgICAgICAgeSA9IGZsb29yKHJhdGlvWSAqIGkpO1xuICAgICAgICAgIHhEaWZmID0gcmF0aW9YICogaiAtIHg7XG4gICAgICAgICAgeURpZmYgPSByYXRpb1kgKiBpIC0geTtcbiAgICAgICAgICBvcmlnUGl4ID0gNCAqICh5ICogb1cgKyB4KTtcblxuICAgICAgICAgIGZvciAoY2hubCA9IDA7IGNobmwgPCA0OyBjaG5sKyspIHtcbiAgICAgICAgICAgIGEgPSBwaXhlbHNbb3JpZ1BpeCArIGNobmxdO1xuICAgICAgICAgICAgYiA9IHBpeGVsc1tvcmlnUGl4ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgYyA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyBjaG5sXTtcbiAgICAgICAgICAgIGQgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgY29sb3IgPSBhICogKDEgLSB4RGlmZikgKiAoMSAtIHlEaWZmKSArIGIgKiB4RGlmZiAqICgxIC0geURpZmYpICtcbiAgICAgICAgICAgICAgICAgICAgYyAqIHlEaWZmICogKDEgLSB4RGlmZikgKyBkICogeERpZmYgKiB5RGlmZjtcbiAgICAgICAgICAgIGRlc3RQaXhlbHNbb2Zmc2V0KytdID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdEltYWdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZXJtaXRlRmFzdFJlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgaGVybWl0ZUZhc3RSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgcmF0aW9XID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvSCA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhdGlvV0hhbGYgPSBjZWlsKHJhdGlvVyAvIDIpLFxuICAgICAgICAgIHJhdGlvSEhhbGYgPSBjZWlsKHJhdGlvSCAvIDIpLFxuICAgICAgICAgIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1nLmRhdGEsXG4gICAgICAgICAgaW1nMiA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLCBkYXRhMiA9IGltZzIuZGF0YTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZEg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRXOyBpKyspIHtcbiAgICAgICAgICB2YXIgeDIgPSAoaSArIGogKiBkVykgKiA0LCB3ZWlnaHQgPSAwLCB3ZWlnaHRzID0gMCwgd2VpZ2h0c0FscGhhID0gMCxcbiAgICAgICAgICAgICAgZ3hSID0gMCwgZ3hHID0gMCwgZ3hCID0gMCwgZ3hBID0gMCwgY2VudGVyWSA9IChqICsgMC41KSAqIHJhdGlvSDtcbiAgICAgICAgICBmb3IgKHZhciB5eSA9IGZsb29yKGogKiByYXRpb0gpOyB5eSA8IChqICsgMSkgKiByYXRpb0g7IHl5KyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGFicyhjZW50ZXJZIC0gKHl5ICsgMC41KSkgLyByYXRpb0hIYWxmLFxuICAgICAgICAgICAgICAgIGNlbnRlclggPSAoaSArIDAuNSkgKiByYXRpb1csIHcwID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAodmFyIHh4ID0gZmxvb3IoaSAqIHJhdGlvVyk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvVzsgeHgrKykge1xuICAgICAgICAgICAgICB2YXIgZHggPSBhYnMoY2VudGVyWCAtICh4eCArIDAuNSkpIC8gcmF0aW9XSGFsZixcbiAgICAgICAgICAgICAgICAgIHcgPSBzcXJ0KHcwICsgZHggKiBkeCk7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICBpZiAodyA+IDEgJiYgdyA8IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9oZXJtaXRlIGZpbHRlclxuICAgICAgICAgICAgICB3ZWlnaHQgPSAyICogdyAqIHcgKiB3IC0gMyAqIHcgKiB3ICsgMTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9XKTtcbiAgICAgICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICAgICAgZ3hBICs9IHdlaWdodCAqIGRhdGFbZHggKyAzXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIC8vY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZHggKyAzXSA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0ICogZGF0YVtkeCArIDNdIC8gMjUwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBneFIgKz0gd2VpZ2h0ICogZGF0YVtkeF07XG4gICAgICAgICAgICAgICAgZ3hHICs9IHdlaWdodCAqIGRhdGFbZHggKyAxXTtcbiAgICAgICAgICAgICAgICBneEIgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgIHdlaWdodHMgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEyW3gyXSA9IGd4UiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAxXSA9IGd4RyAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAyXSA9IGd4QiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAzXSA9IGd4QSAvIHdlaWdodHNBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZzI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHJlc2l6ZVR5cGU6IHRoaXMucmVzaXplVHlwZSxcbiAgICAgICAgbGFuY3pvc0xvYmVzOiB0aGlzLmxhbmN6b3NMb2Jlc1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29udHJhc3QgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qoe1xuICAgKiAgIGNvbnRyYXN0OiA0MFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnRyYXN0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udHJhc3QnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Q29udHJhc3Q7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgY29udHJhc3RGID0gMS4wMTUgKiAodUNvbnRyYXN0ICsgMS4wKSAvICgxLjAgKiAoMS4wMTUgLSB1Q29udHJhc3QpKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiA9IGNvbnRyYXN0RiAqIChjb2xvci5yZ2IgLSAwLjUpICsgMC41O1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICBjb250cmFzdDogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdjb250cmFzdCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0PTBdIFZhbHVlIHRvIGNvbnRyYXN0IHRoZSBpbWFnZSB1cCAoLTEuLi4xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICAqIEFwcGx5IHRoZSBDb250cmFzdCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuY29udHJhc3QgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBpLCBsZW4sXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBjb250cmFzdCA9IE1hdGguZmxvb3IodGhpcy5jb250cmFzdCAqIDI1NSksXG4gICAgICAgICAgY29udHJhc3RGID0gMjU5ICogKGNvbnRyYXN0ICsgMjU1KSAvICgyNTUgKiAoMjU5IC0gY29udHJhc3QpKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBjb250cmFzdEYgKiAoZGF0YVtpXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDFdID0gY29udHJhc3RGICogKGRhdGFbaSArIDFdIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMl0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMl0gLSAxMjgpICsgMTI4O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbnRyYXN0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb250cmFzdCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUNvbnRyYXN0LCB0aGlzLmNvbnRyYXN0KTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFNhdHVyYXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uKHtcbiAgICogICBzYXR1cmF0aW9uOiAxMDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5TYXR1cmF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTYXR1cmF0aW9uJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNhdHVyYXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgcmdNYXggPSBtYXgoY29sb3IuciwgY29sb3IuZyk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ2JNYXggPSBtYXgocmdNYXgsIGNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnY29sb3IuciArPSByZ2JNYXggIT0gY29sb3IuciA/IChyZ2JNYXggLSBjb2xvci5yKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgKz0gcmdiTWF4ICE9IGNvbG9yLmcgPyAocmdiTWF4IC0gY29sb3IuZykgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5iICs9IHJnYk1heCAhPSBjb2xvci5iID8gKHJnYk1heCAtIGNvbG9yLmIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICBzYXR1cmF0aW9uOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ3NhdHVyYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYXR1cmF0ZT0wXSBWYWx1ZSB0byBzYXR1cmF0ZSB0aGUgaW1hZ2UgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBTYXR1cmF0aW9uIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBhZGp1c3QgPSAtdGhpcy5zYXR1cmF0aW9uLCBpLCBtYXg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pO1xuICAgICAgICBkYXRhW2ldICs9IG1heCAhPT0gZGF0YVtpXSA/IChtYXggLSBkYXRhW2ldKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IG1heCAhPT0gZGF0YVtpICsgMV0gPyAobWF4IC0gZGF0YVtpICsgMV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gbWF4ICE9PSBkYXRhW2kgKyAyXSA/IChtYXggLSBkYXRhW2kgKyAyXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVNhdHVyYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhdHVyYXRpb24nKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTYXR1cmF0aW9uLCAtdGhpcy5zYXR1cmF0aW9uKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCbHVyIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1clxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyKHtcbiAgICogICBibHVyOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJsdXIgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ci5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ0JsdXInLFxuXG4gICAgLypcbidnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC03ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC02ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0xICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICAgICAgICAgICAgICApKjAuMTU5NTc2OTEyMTYxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAxICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA1ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnY29uc3QgZmxvYXQgblNhbXBsZXMgPSAxNS4wO1xcbicgK1xuICAgICAgJ3ZlYzMgdjNvZmZzZXQgPSB2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlKSB7XFxuJyArXG4gICAgICAgIC8qIHVzZSB0aGUgZnJhZ21lbnQgcG9zaXRpb24gZm9yIGEgZGlmZmVyZW50IHNlZWQgcGVyLXBpeGVsICovXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6LCBzY2FsZSkpICogNDM3NTguNTQ1Myk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuJyArXG4gICAgICAgICdmbG9hdCB0b3RhbCA9IDAuMDtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IG9mZnNldCA9IHJhbmRvbSh2M29mZnNldCk7XFxuJyArXG4gICAgICAgICdmb3IgKGZsb2F0IHQgPSAtblNhbXBsZXM7IHQgPD0gblNhbXBsZXM7IHQrKykge1xcbicgK1xuICAgICAgICAgICdmbG9hdCBwZXJjZW50ID0gKHQgKyBvZmZzZXQgLSAwLjUpIC8gblNhbXBsZXM7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4nICtcbiAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyB1RGVsdGEgKiBwZXJjZW50KSAqIHdlaWdodDtcXG4nICtcbiAgICAgICAgICAndG90YWwgKz0gd2VpZ2h0O1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4nICtcbiAgICAgICd9JyxcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAgIC8qKlxuICAgICAqIGJsdXIgdmFsdWUsIGluIHBlcmNlbnRhZ2Ugb2YgaW1hZ2UgZGltZW5zaW9ucy5cbiAgICAgKiBzcGVjaWZpYyB0byBrZWVwIHRoZSBpbWFnZSBibHVyIGNvbnN0YW50IGF0IGRpZmZlcmVudCByZXNvbHV0aW9uc1xuICAgICAqIHJhbmdlIGJld3RlZW4gMCBhbmQgMS5cbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2JsdXInLFxuXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgLy8gdGhpcyBhc3BlY3RSYXRpbyBpcyB1c2VkIHRvIGdpdmUgdGhlIHNhbWUgYmx1ciB0byB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbFxuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gb3B0aW9ucy5zb3VyY2VXaWR0aCAvIG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBwYWludCBjYW52YXNFbCB3aXRoIGN1cnJlbnQgaW1hZ2UgZGF0YS5cbiAgICAgIC8vb3B0aW9ucy5jdHgucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gdGhpcy5zaW1wbGVCbHVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBzaW1wbGVCbHVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcywgY2FudmFzMSwgY2FudmFzMixcbiAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMuaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmx1ckxheWVyMSkge1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgcmVzb3VyY2VzLmJsdXJMYXllcjIgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsdXJMYXllcjE7XG4gICAgICBjYW52YXMyID0gcmVzb3VyY2VzLmJsdXJMYXllcjI7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMyLndpZHRoID0gY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMyLmhlaWdodCA9IGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIGN0eDEgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgY3R4MiA9IGNhbnZhczIuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBuU2FtcGxlcyA9IDE1LFxuICAgICAgICAgIHJhbmRvbSwgcGVyY2VudCwgaiwgaSxcbiAgICAgICAgICBibHVyID0gdGhpcy5ibHVyICogMC4wNiAqIDAuNTtcblxuICAgICAgLy8gbG9hZCBmaXJzdCBjYW52YXNcbiAgICAgIGN0eDEucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiB3aWR0aCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgaiwgcmFuZG9tKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiBoZWlnaHQgKyByYW5kb207XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxIC0gTWF0aC5hYnMocGVyY2VudCk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhczEsIHJhbmRvbSwgaik7XG4gICAgICAgIGN0eDEuZHJhd0ltYWdlKGNhbnZhczIsIDAsIDApO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgY2FudmFzMi53aWR0aCwgY2FudmFzMi5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5jdHguZHJhd0ltYWdlKGNhbnZhczEsIDAsIDApO1xuICAgICAgdmFyIG5ld0ltYWdlRGF0YSA9IG9wdGlvbnMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICBjdHgxLmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eDEuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBuZXdJbWFnZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuY2hvb3NlUmlnaHREZWx0YSgpO1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLmRlbHRhLCBkZWx0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNob29zZSByaWdodCB2YWx1ZSBvZiBpbWFnZSBwZXJjZW50YWdlIHRvIGJsdXIgd2l0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYSBudW1lcmljIGFycmF5IHdpdGggZGVsdGEgdmFsdWVzXG4gICAgICovXG4gICAgY2hvb3NlUmlnaHREZWx0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmx1clNjYWxlID0gMSwgZGVsdGEgPSBbMCwgMF0sIGJsdXI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvID4gMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHdpZGUsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIGhvcml6b250YWxcbiAgICAgICAgICBibHVyU2NhbGUgPSAxIC8gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvIDwgMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHRhbGwsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIHZlcnRpY2FsXG4gICAgICAgICAgYmx1clNjYWxlID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmx1ciA9IGJsdXJTY2FsZSAqIHRoaXMuYmx1ciAqIDAuMTI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGRlbHRhWzBdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWx0YVsxXSA9IGJsdXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQmx1ckZpbHRlciBpbnRvIGEgY29uY3JldGUgaW5zdGFuY2UuXG4gICAqL1xuICBmaWx0ZXJzLkJsdXIuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdhbW1hIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hKHtcbiAgICogICBicmlnaHRuZXNzOiAyMDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HYW1tYSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dhbW1hJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMyB1R2FtbWE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAndmVjMyBjb3JyZWN0aW9uID0gKDEuMCAvIHVHYW1tYSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yID0gcG93KGNvbG9yLnIsIGNvcnJlY3Rpb24ucik7XFxuJyArXG4gICAgICAgICdjb2xvci5nID0gcG93KGNvbG9yLmcsIGNvcnJlY3Rpb24uZyk7XFxuJyArXG4gICAgICAgICdjb2xvci5iID0gcG93KGNvbG9yLmIsIGNvcnJlY3Rpb24uYik7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3IuYTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEdhbW1hIGFycmF5IHZhbHVlLCBmcm9tIDAuMDEgdG8gMi4yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdhbW1hXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnYW1tYTogWzEsIDEsIDFdLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2dhbW1hJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHYW1tYSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBnYW1tYSA9IHRoaXMuZ2FtbWEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHJJbnYgPSAxIC8gZ2FtbWFbMF0sIGdJbnYgPSAxIC8gZ2FtbWFbMV0sXG4gICAgICAgICAgYkludiA9IDEgLyBnYW1tYVsyXSwgaTtcblxuICAgICAgaWYgKCF0aGlzLnJWYWxzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuZ1ZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5iVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIC0gcHJlLWNvbXB1dGUgYSBsb29rLXVwIHRhYmxlIGZvciBlYWNoIGNvbG9yIGNoYW5uZWxcbiAgICAgIC8vIGluc3RlYWQgb2YgcGVyZm9ybWluZyB0aGVzZSBwb3cgY2FsbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGltYWdlLlxuICAgICAgZm9yIChpID0gMCwgbGVuID0gMjU2OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5yVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIHJJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmdWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgZ0ludikgKiAyNTU7XG4gICAgICAgIHRoaXMuYlZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBiSW52KSAqIDI1NTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IHRoaXMuclZhbHNbZGF0YVtpXV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gdGhpcy5nVmFsc1tkYXRhW2kgKyAxXV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gdGhpcy5iVmFsc1tkYXRhW2kgKyAyXV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1R2FtbWE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUdhbW1hJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtM2Z2KHVuaWZvcm1Mb2NhdGlvbnMudUdhbW1hLCB0aGlzLmdhbW1hKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEEgY29udGFpbmVyIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIGFwcGx5IGEgc2VxdWVuY2Ugb2YgZmlsdGVycyB0byBhbiBpbnB1dCBpbWFnZS5cbiAgICovXG4gIGZpbHRlcnMuQ29tcG9zZWQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdDb21wb3NlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIG5vbiBzcGFyc2UgYXJyYXkgb2YgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIHN1YkZpbHRlcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLnN1YkZpbHRlcnMgPSB0aGlzLnN1YkZpbHRlcnMuc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgY29udGFpbmVyJ3MgZmlsdGVycyB0byB0aGUgaW5wdXQgaW1hZ2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5wYXNzZXMgKz0gdGhpcy5zdWJGaWx0ZXJzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLnN1YkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyLmFwcGx5VG8ob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgZmlsdGVyIGludG8gSlNPTi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZpbHRlci5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBzdWJGaWx0ZXJzOiB0aGlzLnN1YkZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyLnRvT2JqZWN0KCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQ29tcG9zZWRGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlsdGVycyA9IG9iamVjdC5zdWJGaWx0ZXJzIHx8IFtdLFxuICAgICAgICBzdWJGaWx0ZXJzID0gZmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tmaWx0ZXIudHlwZV0oZmlsdGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkKHsgc3ViRmlsdGVyczogc3ViRmlsdGVycyB9KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEh1ZVJvdGF0aW9uIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uKHtcbiAgICogICByb3RhdGlvbjogLTAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkh1ZVJvdGF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0h1ZVJvdGF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdGhlIHVuaXQgaXMgcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBteVBhcmFtZXRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAncm90YXRpb24nLFxuXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYWQgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSwgY29zID0gZmFicmljLnV0aWwuY29zKHJhZCksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWQpLFxuICAgICAgICAgIGFUaGlyZCA9IDEgLyAzLCBhVGhpcmRTcXRTaW4gPSBNYXRoLnNxcnQoYVRoaXJkKSAqIHNpbiwgT25lTWludXNDb3MgPSAxIC0gY29zO1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF07XG4gICAgICB0aGlzLm1hdHJpeFswXSA9IGNvcyArIE9uZU1pbnVzQ29zIC8gMztcbiAgICAgIHRoaXMubWF0cml4WzFdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsyXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzZdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgICB0aGlzLm1hdHJpeFs3XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTBdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEyXSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuYXBwbHlUby5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGlmIChmYWJyaWMuVGV4dCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuVGV4dCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVGV4dCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiN0ZXh0fVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IFtcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAndGV4dEFsaWduJyxcbiAgICAgICdzdHlsZXMnLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZU5ld2xpbmU6IC9cXHI/XFxuLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgZm9yIHdoaXRlc3BhY2VzIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VzQW5kVGFiczogL1sgXFx0XFxyXS9nLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZSB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlQW5kVGFiOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgY29uc2VjdXRpdmUgZ3JvdXBzIG9mIG5vbiBzcGFjZXMuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlV29yZHM6IC9cXFMrL2csXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICd0ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFNpemU6ICAgICAgICAgICAgIDQwLFxuXG4gICAgLyoqXG4gICAgICogRm9udCB3ZWlnaHQgKGUuZy4gYm9sZCwgbm9ybWFsLCA0MDAsIDYwMCwgODAwKVxuICAgICAqIEB0eXBlIHsoTnVtYmVyfFN0cmluZyl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250V2VpZ2h0OiAgICAgICAgICAgJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGZhbWlseVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udEZhbWlseTogICAgICAgICAgICdUaW1lcyBOZXcgUm9tYW4nLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIHVuZGVybGluZS5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuZGVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gb3ZlcmxpbmUuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gbGluZXRocm91Z2guXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5ldGhyb3VnaDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGFsaWdubWVudC4gUG9zc2libGUgdmFsdWVzOiBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIixcbiAgICAgKiBcImp1c3RpZnktbGVmdFwiLCBcImp1c3RpZnktY2VudGVyXCIgb3IgXCJqdXN0aWZ5LXJpZ2h0XCIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QWxpZ246ICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSAuIFBvc3NpYmxlIHZhbHVlczogXCJcIiwgXCJub3JtYWxcIiwgXCJpdGFsaWNcIiBvciBcIm9ibGlxdWVcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTdHlsZTogICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIExpbmUgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5lSGVpZ2h0OiAgICAgICAgICAgMS4xNixcblxuICAgIC8qKlxuICAgICAqIFN1cGVyc2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3VwZXJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogLTAuMzUgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAodXB3YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Vic2NyaXB0OiB7XG4gICAgICBzaXplOiAgICAgIDAuNjAsIC8vIGZvbnRTaXplIGZhY3RvclxuICAgICAgYmFzZWxpbmU6ICAwLjExICAvLyBiYXNlbGluZS1zaGlmdCBmYWN0b3IgKGRvd253YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiB0ZXh0IGxpbmVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgJycsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgnZm9udEZhbWlseScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ3VuZGVybGluZScsXG4gICAgICAnb3ZlcmxpbmUnLFxuICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgJ3N0eWxlcycpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdmb250RmFtaWx5JyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAndGV4dCcsXG4gICAgICAndW5kZXJsaW5lJyxcbiAgICAgICdvdmVybGluZScsXG4gICAgICAnbGluZXRocm91Z2gnLFxuICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAnc3R5bGVzJyksXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3IuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJzdHJva2VTdHlsZVwiIHVudGlsIHYxLjEuNlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInRleHRTaGFkb3dcIiAoU3RyaW5nKSB1bnRpbCB2MS4yLjExXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb250U2l6ZUZyYWN0aW9uOiAwLjIyMixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb2Zmc2V0czoge1xuICAgICAgdW5kZXJsaW5lOiAwLjEwLFxuICAgICAgbGluZXRocm91Z2g6IC0wLjMxNSxcbiAgICAgIG92ZXJsaW5lOiAtMC44OFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IExpbmUgcHJvcG9ydGlvbiB0byBmb250IFNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9mb250U2l6ZU11bHQ6ICAgICAgICAgICAgIDEuMTMsXG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbmFsIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVyc1xuICAgICAqIGV4cHJlc3NlZCBpbiB0aG91c2FuZHMgb2YgZW0gdW5pdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2hhclNwYWNpbmc6ICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgY29udGFpbmluZyBjaGFyYWN0ZXIgc3R5bGVzIC0gdG9wLWxldmVsIHByb3BlcnRpZXMgLT4gbGluZSBudW1iZXJzLFxuICAgICAqIDJuZC1sZXZlbCBwcm9wZXJ0aWVzIC0gY2hhcmF0ZXIgbnVtYmVyc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGEgY29udGV4dCB0byBtZWFzdXJlIHRleHQgY2hhciBvciBjb3VwbGUgb2YgY2hhcnNcbiAgICAgKiB0aGUgY2FjaGVDb250ZXh0IG9mIHRoZSBjYW52YXMgd2lsbCBiZSB1c2VkIG9yIGEgZnJlc2hseSBjcmVhdGVkIG9uZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBvbiBjYW52YXNcbiAgICAgKiBvbmNlIGNyZWF0ZWQgaXQgd2lsbCBiZSByZWZlcmVuY2VkIG9uIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCB0byBhdm9pZGUgY3JlYXRpbmcgYSBjYW52YXMgZm9yIGV2ZXJ5XG4gICAgICogdGV4dCBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX21lYXN1cmluZ0NvbnRleHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlbGluZSBzaGlmdCwgc3RseWVzIG9ubHksIGtlZXAgYXQgMCBmb3IgdGhlIG1haW4gdGV4dCBvYmplY3RcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVsdGFZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IGRlZmluZSBhIHN0eWxlIHVuaXQgKG9mICdzdHlsZXMnKS5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfc3R5bGVQcm9wZXJ0aWVzOiBbXG4gICAgICAnc3Ryb2tlJyxcbiAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAnZmlsbCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAndW5kZXJsaW5lJyxcbiAgICAgICdvdmVybGluZScsXG4gICAgICAnbGluZXRocm91Z2gnLFxuICAgICAgJ2RlbHRhWScsXG4gICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRhaW5zIGNoYXJhY3RlcnMgYm91bmRpbmcgYm94ZXNcbiAgICAgKi9cbiAgICBfX2NoYXJCb3VuZHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogdXNlIHRoaXMgc2l6ZSB3aGVuIG1lYXN1cmluZyB0ZXh0LiBUbyBhdm9pZCBJRTExIHJvdW5kaW5nIGVycm9yc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENBQ0hFX0ZPTlRfU0laRTogNDAwLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgdGhlIG1pbiB0ZXh0IHdpZHRoIHRvIGF2b2lkIGdldHRpbmcgMFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBNSU5fVEVYVF9XSURUSDogMixcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnN0eWxlcyA9IG9wdGlvbnMgPyAob3B0aW9ucy5zdHlsZXMgfHwgeyB9KSA6IHsgfTtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnNldHVwU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbnRleCBmb3IgbWVhc3VyZW1lbnQgb2YgdGV4dCBzdHJpbmcuXG4gICAgICogaWYgY3JlYXRlZCBpdCBnZXRzIHN0b3JlZCBmb3IgcmV1c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGdldE1lYXN1cmluZ0NvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCByZXR1cm4gd2UgaGF2ZSB0byBtZWFzdXJlIHNvbWV0aGluZy5cbiAgICAgIGlmICghZmFicmljLl9tZWFzdXJpbmdDb250ZXh0KSB7XG4gICAgICAgIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRDYWNoZSB8fFxuICAgICAgICAgIGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXZpZGVzIHRleHQgaW50byBsaW5lcyBvZiB0ZXh0IGFuZCBsaW5lcyBvZiBncmFwaGVtZXMuXG4gICAgICovXG4gICAgX3NwbGl0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3TGluZXMgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dExpbmVzID0gbmV3TGluZXMubGluZXM7XG4gICAgICB0aGlzLl90ZXh0TGluZXMgPSBuZXdMaW5lcy5ncmFwaGVtZUxpbmVzO1xuICAgICAgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzID0gbmV3TGluZXMuX3Vud3JhcHBlZExpbmVzO1xuICAgICAgdGhpcy5fdGV4dCA9IG5ld0xpbmVzLmdyYXBoZW1lVGV4dDtcbiAgICAgIHJldHVybiBuZXdMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvciB1cGRhdGUgdGV4dCBkaW1lbnNpb25zLlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3BsaXRUZXh0KCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jYWxjVGV4dFdpZHRoKCkgfHwgdGhpcy5jdXJzb3JXaWR0aCB8fCB0aGlzLk1JTl9URVhUX1dJRFRIO1xuICAgICAgaWYgKHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gb25jZSB0ZXh0IGlzIG1lYXN1cmVkIHdlIG5lZWQgdG8gbWFrZSBzcGFjZSBmYXR0ZXIgdG8gbWFrZSBqdXN0aWZpZWQgdGV4dC5cbiAgICAgICAgdGhpcy5lbmxhcmdlU3BhY2VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmxhcmdlIHNwYWNlIGJveGVzIGFuZCBzaGlmdCB0aGUgb3RoZXJzXG4gICAgICovXG4gICAgZW5sYXJnZVNwYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlmZlNwYWNlLCBjdXJyZW50TGluZVdpZHRoLCBudW1iZXJPZlNwYWNlcywgYWNjdW11bGF0ZWRTcGFjZSwgbGluZSwgY2hhckJvdW5kLCBzcGFjZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gJ2p1c3RpZnknICYmIChpID09PSBsZW4gLSAxIHx8IHRoaXMuaXNFbmRPZldyYXBwaW5nKGkpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgPSAwO1xuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoIDwgdGhpcy53aWR0aCAmJiAoc3BhY2VzID0gdGhpcy50ZXh0TGluZXNbaV0ubWF0Y2godGhpcy5fcmVTcGFjZXNBbmRUYWJzKSkpIHtcbiAgICAgICAgICBudW1iZXJPZlNwYWNlcyA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgZGlmZlNwYWNlID0gKHRoaXMud2lkdGggLSBjdXJyZW50TGluZVdpZHRoKSAvIG51bWJlck9mU3BhY2VzO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPD0gamxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGFyQm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtqXSkpIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLndpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmtlcm5lZFdpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSB0ZXh0IGxpbmUgaXMgZW5kZWQgd2l0aCBhbiBoYXJkIGJyZWFrXG4gICAgICogdGV4dCBhbmQgaXRleHQgZG8gbm90IGhhdmUgd3JhcHBpbmcsIHJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmRPZldyYXBwaW5nOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRleHQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5UZXh0ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRleHRcIjogXCInICsgdGhpcy50ZXh0ICsgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgICAgZGltcy53aWR0aCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVg7XG4gICAgICBkaW1zLmhlaWdodCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVk7XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICd1bmRlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ292ZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdsaW5ldGhyb3VnaCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvbnQgcGFyYW1ldGVyIG9mIHRoZSBjb250ZXh0IHdpdGggdGhlIG9iamVjdCBwcm9wZXJ0aWVzIG9yIHdpdGggY2hhclN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGFyU3R5bGVdIG9iamVjdCB3aXRoIGZvbnQgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRGYW1pbHldIEZvbnQgRmFtaWx5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjaGFyU3R5bGUuZm9udFNpemVdIEZvbnQgc2l6ZSBpbiBwaXhlbHMuICggd2l0aG91dCBweCBzdWZmaXggKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRXZWlnaHRdIEZvbnQgd2VpZ2h0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFN0eWxlXSBGb250IHN0eWxlIChpdGFsaWN8bm9ybWFsKVxuICAgICAqL1xuICAgIF9zZXRUZXh0U3R5bGVzOiBmdW5jdGlvbihjdHgsIGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgdGV4dCBXaWR0aCBtZWFzdXJpbmcgZWFjaCBsaW5lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTWF4aW11bSB3aWR0aCBvZiBmYWJyaWMuVGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjVGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIFRleHQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lIGluIGEgdGV4dFxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJDaGFycyhtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0ZXh0IGJhY2tncm91bmQgZm9yIGxpbmVzLCB0YWtpbmcgY2FyZSBvZiBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yICYmICF0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBoZWlnaHRPZkxpbmUsXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQsIG9yaWdpbmFsRmlsbCA9IGN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgbGluZSwgbGFzdENvbG9yLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgYm94U3RhcnQgPSAwLCBib3hXaWR0aCA9IDAsIGNoYXJCb3gsIGN1cnJlbnRDb2xvcjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RDb2xvcjtcbiAgICAgICAgICAgIGxhc3RDb2xvciAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgICB0b3BPZmZzZXQgKyBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvcikge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICB0b3BPZmZzZXQgKyBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjbCBzdHlsZSBkZWNsYXJhdGlvbiBmb3IgY2FjaGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250RmFtaWx5IGZvbnRGYW1pbHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250U3R5bGUgZm9udFN0eWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFdlaWdodCBmb250V2VpZ2h0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZWZlcmVuY2UgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBnZXRGb250Q2FjaGU6IGZ1bmN0aW9uKGRlY2wpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZGVjbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZSA9IGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0sXG4gICAgICAgICAgY2FjaGVQcm9wID0gZGVjbC5mb250U3R5bGUudG9Mb3dlckNhc2UoKSArICdfJyArIChkZWNsLmZvbnRXZWlnaHQgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghY2FjaGVbY2FjaGVQcm9wXSkge1xuICAgICAgICBjYWNoZVtjYWNoZVByb3BdID0geyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlUHJvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFwcGx5IGFsbCB0aGUgY2hhcmFjdGVyIHN0eWxlIHRvIGNhbnZhcyBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVjbF1cbiAgICAgKi9cbiAgICBfYXBwbHlDaGFyU3R5bGVzOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlRGVjbGFyYXRpb24pIHtcblxuICAgICAgdGhpcy5fc2V0RmlsbFN0eWxlcyhjdHgsIHN0eWxlRGVjbGFyYXRpb24pO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgc3R5bGVEZWNsYXJhdGlvbik7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKHN0eWxlRGVjbGFyYXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGFuZCByZXR1cm4gdGhlIHdpZHRoIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAgICAgKiBwb3NzaWJseSBvdmVycmlkZGVuIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBtZWFzdXJlIGxvZ2ljIG9yXG4gICAgICogdG8gaG9vayBzb21lIGV4dGVybmFsIGxpYiBmb3IgY2hhcmFjdGVyIG1lYXN1cmVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFyU3R5bGUgc3R5bGUgb2YgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldmlvdXNDaGFyXSBwcmV2aW91cyBjaGFyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcmV2Q2hhclN0eWxlXSBzdHlsZSBvZiBwcmV2aW91cyBjaGFyXG4gICAgICovXG4gICAgX21lYXN1cmVDaGFyOiBmdW5jdGlvbihfY2hhciwgY2hhclN0eWxlLCBwcmV2aW91c0NoYXIsIHByZXZDaGFyU3R5bGUpIHtcbiAgICAgIC8vIGZpcnN0IGkgdHJ5IHRvIHJldHVybiBmcm9tIGNhY2hlXG4gICAgICB2YXIgZm9udENhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY2hhclN0eWxlKSwgZm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSksXG4gICAgICAgICAgcHJldmlvdXNGb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24ocHJldkNoYXJTdHlsZSksIGNvdXBsZSA9IHByZXZpb3VzQ2hhciArIF9jaGFyLFxuICAgICAgICAgIHN0eWxlc0FyZUVxdWFsID0gZm9udERlY2xhcmF0aW9uID09PSBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiwgd2lkdGgsIGNvdXBsZVdpZHRoLCBwcmV2aW91c1dpZHRoLFxuICAgICAgICAgIGZvbnRNdWx0aXBsaWVyID0gY2hhclN0eWxlLmZvbnRTaXplIC8gdGhpcy5DQUNIRV9GT05UX1NJWkUsIGtlcm5lZFdpZHRoO1xuXG4gICAgICBpZiAocHJldmlvdXNDaGFyICYmIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRDYWNoZVtfY2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gZm9udENhY2hlW19jaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBmb250Q2FjaGVbY291cGxlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdXBsZVdpZHRoID0gZm9udENhY2hlW2NvdXBsZV07XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0TWVhc3VyaW5nQ29udGV4dCgpO1xuICAgICAgICAvLyBzZW5kIGEgVFJVRSB0byBzcGVjaWZ5IG1lYXN1cmluZyBmb250IHNpemUgQ0FDSEVfRk9OVF9TSVpFXG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4LCBjaGFyU3R5bGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChfY2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtfY2hhcl0gPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgJiYgc3R5bGVzQXJlRXF1YWwgJiYgcHJldmlvdXNDaGFyKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBjdHgubWVhc3VyZVRleHQocHJldmlvdXNDaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gPSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gd2UgY2FuIG1lYXN1cmUgdGhlIGtlcm5pbmcgY291cGxlIGFuZCBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICBjb3VwbGVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjb3VwbGUpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbY291cGxlXSA9IGNvdXBsZVdpZHRoO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCAqIGZvbnRNdWx0aXBsaWVyLCBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGggKiBmb250TXVsdGlwbGllciB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoZWlnaHQgb2YgY2hhcmFjdGVyIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmUgdGhlIGxpbmUgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXIgdGhlIGNoYXJhY3RlciBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGZvbnRTaXplIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkNoYXI6IGZ1bmN0aW9uKGxpbmUsIGNoYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmUsIGNoYXIsICdmb250U2l6ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGEgdGV4dCBsaW5lIG1lYXN1cmluZyBhbGwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVJbmZvID0gdGhpcy5fbWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVJbmZvLndpZHRoIDwgMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZUluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgZXZlcnkgZ3JhcGhlbWUgb2YgYSBsaW5lLCBwb3B1bGF0aW5nIF9fY2hhckJvdW5kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCB0b3RhbCB3aWR0aCBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGhPZlNwYWNlcyBsZW5ndGggb2YgY2hhcnMgdGhhdCBtYXRjaCB0aGlzLl9yZVNwYWNlc0FuZFRhYnNcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgaSwgZ3JhcGhlbWUsIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSwgcHJldkdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lSW5mbywgbnVtT2ZTcGFjZXMgPSAwLCBsaW5lQm91bmRzID0gbmV3IEFycmF5KGxpbmUubGVuZ3RoKTtcblxuICAgICAgdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XSA9IGxpbmVCb3VuZHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZSA9IGxpbmVbaV07XG4gICAgICAgIGdyYXBoZW1lSW5mbyA9IHRoaXMuX2dldEdyYXBoZW1lQm94KGdyYXBoZW1lLCBsaW5lSW5kZXgsIGksIHByZXZHcmFwaGVtZSk7XG4gICAgICAgIGxpbmVCb3VuZHNbaV0gPSBncmFwaGVtZUluZm87XG4gICAgICAgIHdpZHRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gZ3JhcGhlbWU7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxhdGVzdCBib3VuZCBib3ggcmVwcmVzZW50IHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgbGluZVxuICAgICAgLy8gdG8gc2ltcGxpZnkgY3Vyc29yIGhhbmRsaW5nIGluIGludGVyYWN0aXZlIG1vZGUuXG4gICAgICBsaW5lQm91bmRzW2ldID0ge1xuICAgICAgICBsZWZ0OiBncmFwaGVtZUluZm8gPyBncmFwaGVtZUluZm8ubGVmdCArIGdyYXBoZW1lSW5mby53aWR0aCA6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBrZXJuZWRXaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmZvbnRTaXplXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBudW1PZlNwYWNlczogbnVtT2ZTcGFjZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhbmQgcmV0dXJuIHRoZSBpbmZvIG9mIGEgc2luZ2xlIGdyYXBoZW1lLlxuICAgICAqIG5lZWRzIHRoZSB0aGUgaW5mbyBvZiBwcmV2aW91cyBncmFwaGVtZXMgYWxyZWFkeSBmaWxsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncmFwaGVtZSB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIGluIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2R3JhcGhlbWVdIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlIG9uZSB0byBiZSBtZWFzdXJlZFxuICAgICAqL1xuICAgIF9nZXRHcmFwaGVtZUJveDogZnVuY3Rpb24oZ3JhcGhlbWUsIGxpbmVJbmRleCwgY2hhckluZGV4LCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgcHJldlN0eWxlID0gcHJldkdyYXBoZW1lID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggLSAxKSA6IHsgfSxcbiAgICAgICAgICBpbmZvID0gdGhpcy5fbWVhc3VyZUNoYXIoZ3JhcGhlbWUsIHN0eWxlLCBwcmV2R3JhcGhlbWUsIHByZXZTdHlsZSksXG4gICAgICAgICAga2VybmVkV2lkdGggPSBpbmZvLmtlcm5lZFdpZHRoLFxuICAgICAgICAgIHdpZHRoID0gaW5mby53aWR0aCwgY2hhclNwYWNpbmc7XG5cbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIHdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgICBrZXJuZWRXaWR0aCArPSBjaGFyU3BhY2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmZvbnRTaXplLFxuICAgICAgICBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGgsXG4gICAgICAgIGRlbHRhWTogc3R5bGUuZGVsdGFZLFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFySW5kZXggPiAwICYmICFza2lwTGVmdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgICBib3gubGVmdCA9IHByZXZpb3VzQm94LmxlZnQgKyBwcmV2aW91c0JveC53aWR0aCArIGluZm8ua2VybmVkV2lkdGggLSBpbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBvZiBsaW5lIGF0ICdsaW5lSW5kZXgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiBsaW5lIHRvIGNhbGN1bGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICAvLyBjaGFyIDAgaXMgbWVhc3VyZWQgYmVmb3JlIHRoZSBsaW5lIGN5Y2xlIGJlY2F1c2UgaXQgbm5lZHMgdG8gY2hhclxuICAgICAgICAgIC8vIGVtcHR5bGluZXNcbiAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGxpbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5nZXRIZWlnaHRPZkNoYXIobGluZUluZGV4LCBpKSwgbWF4SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdID0gbWF4SGVpZ2h0ICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGV4dCBib3ggaGVpZ2h0XG4gICAgICovXG4gICAgY2FsY1RleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVIZWlnaHQsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaGVpZ2h0ICs9IChpID09PSBsZW4gLSAxID8gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCA6IGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExlZnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLndpZHRoIC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0VG9wT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtdGhpcy5oZWlnaHQgLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICovXG4gICAgX3JlbmRlclRleHRDb21tb246IGZ1bmN0aW9uKGN0eCwgbWV0aG9kKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHRzID0gMCwgbGVmdCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSwgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgbWV0aG9kID09PSAnZmlsbFRleHQnID8gdGhpcy5maWxsIDogdGhpcy5zdHJva2UpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGxlZnQgKyBsZWZ0T2Zmc2V0IC0gb2Zmc2V0cy5vZmZzZXRYLFxuICAgICAgICAgIHRvcCArIGxpbmVIZWlnaHRzICsgbWF4SGVpZ2h0IC0gb2Zmc2V0cy5vZmZzZXRZLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsICYmICF0aGlzLnN0eWxlSGFzKCdmaWxsJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ2ZpbGxUZXh0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0U3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICgoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnc3Ryb2tlVGV4dCcpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJPZmZzZXRcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgYWN0dWFsU3R5bGUsXG4gICAgICAgICAgbmV4dFN0eWxlLFxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJyxcbiAgICAgICAgICBjaGFyQm94LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICB0aW1lVG9SZW5kZXIsXG4gICAgICAgICAgc2hvcnRDdXQgPSAhaXNKdXN0aWZ5ICYmIHRoaXMuY2hhclNwYWNpbmcgPT09IDAgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKGxpbmVJbmRleCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0b3AgLT0gbGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24gLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBpZiAoc2hvcnRDdXQpIHtcbiAgICAgICAgLy8gcmVuZGVyIGFsbCB0aGUgbGluZSBpbiBvbmUgcGFzcyB3aXRob3V0IGNoZWNraW5nXG4gICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgMCwgdGhpcy50ZXh0TGluZXNbbGluZUluZGV4XSwgbGVmdCwgdG9wLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoIC0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBpID09PSBsZW4gfHwgdGhpcy5jaGFyU3BhY2luZztcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgbGVmdCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRoaXMuX2hhc1N0eWxlQ2hhbmdlZChhY3R1YWxTdHlsZSwgbmV4dFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBpLCBjaGFyc1RvUmVuZGVyLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgICAgICBsZWZ0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIF9jaGFyLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgZnVsbERlY2wgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc2hvdWxkRmlsbCA9IG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiBmdWxsRGVjbC5maWxsLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmIGZ1bGxEZWNsLnN0cm9rZSAmJiBmdWxsRGVjbC5zdHJva2VXaWR0aDtcblxuICAgICAgaWYgKCFzaG91bGRTdHJva2UgJiYgIXNob3VsZEZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVjbCAmJiBjdHguc2F2ZSgpO1xuXG4gICAgICB0aGlzLl9hcHBseUNoYXJTdHlsZXMobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgY2hhckluZGV4LCBmdWxsRGVjbCk7XG5cbiAgICAgIGlmIChkZWNsICYmIGRlY2wudGV4dEJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsICYmIGRlY2wuZGVsdGFZKSB7XG4gICAgICAgIHRvcCArPSBkZWNsLmRlbHRhWTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkRmlsbCAmJiBjdHguZmlsbFRleHQoX2NoYXIsIGxlZnQsIHRvcCk7XG4gICAgICBzaG91bGRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQoX2NoYXIsIGxlZnQsIHRvcCk7XG4gICAgICBkZWNsICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIHRoZSBjaGFyYWN0ZXIgaW50byBhICdzdXBlcmlvciBmaWd1cmUnIChpLmUuICdzdXBlcnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdXBlcnNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFNjcmlwdChzdGFydCwgZW5kLCB0aGlzLnN1cGVyc2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGFuICdpbmZlcmlvciBmaWd1cmUnIChpLmUuICdzdWJzY3JpcHQnKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBzZWxlY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHNlbGVjdGlvbiBlbmRcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3Vic2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3Vic2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyAnc2NoZW1hJyBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2hlbWFcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3NldFNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc2NoZW1hKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2ZvbnRTaXplJyksXG4gICAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsICdkZWx0YVknKSxcbiAgICAgICAgICBzdHlsZSA9IHsgZm9udFNpemU6IGZvbnRTaXplICogc2NoZW1hLnNpemUsIGRlbHRhWTogZHkgKyBmb250U2l6ZSAqIHNjaGVtYS5iYXNlbGluZSB9O1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdHlsZXMoc3R5bGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGVcbiAgICAgKi9cbiAgICBfaGFzU3R5bGVDaGFuZ2VkOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSkge1xuICAgICAgcmV0dXJuIHByZXZTdHlsZS5maWxsICE9PSB0aGlzU3R5bGUuZmlsbCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuc3Ryb2tlICE9PSB0aGlzU3R5bGUuc3Ryb2tlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2VXaWR0aCAhPT0gdGhpc1N0eWxlLnN0cm9rZVdpZHRoIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U2l6ZSAhPT0gdGhpc1N0eWxlLmZvbnRTaXplIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250RmFtaWx5ICE9PSB0aGlzU3R5bGUuZm9udEZhbWlseSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFdlaWdodCAhPT0gdGhpc1N0eWxlLmZvbnRXZWlnaHQgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTdHlsZSAhPT0gdGhpc1N0eWxlLmZvbnRTdHlsZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZGVsdGFZICE9PSB0aGlzU3R5bGUuZGVsdGFZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc1N0eWxlXG4gICAgICovXG4gICAgX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZzogZnVuY3Rpb24ocHJldlN0eWxlLCB0aGlzU3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNTdHlsZUNoYW5nZWQocHJldlN0eWxlLCB0aGlzU3R5bGUpIHx8XG4gICAgICAgIHByZXZTdHlsZS5vdmVybGluZSAhPT0gdGhpc1N0eWxlLm92ZXJsaW5lIHx8XG4gICAgICAgIHByZXZTdHlsZS51bmRlcmxpbmUgIT09IHRoaXNTdHlsZS51bmRlcmxpbmUgfHxcbiAgICAgICAgcHJldlN0eWxlLmxpbmV0aHJvdWdoICE9PSB0aGlzU3R5bGUubGluZXRocm91Z2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCB0ZXh0IGxpbmVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgbGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGluZUxlZnRPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInICYmIHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LXJpZ2h0JyAmJiB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHMgPSBbXTtcbiAgICAgIHRoaXMuX19saW5lSGVpZ2h0cyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYXJCb3VuZHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9mb3JjZUNsZWFyQ2FjaGU7XG4gICAgICBzaG91bGRDbGVhciB8fCAoc2hvdWxkQ2xlYXIgPSB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJykpO1xuICAgICAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRDbGVhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhIHNpbmdsZSBsaW5lIGdpdmVuIGl0cyBpbmRleC4gVXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWxcbiAgICAgKiB0ZXh0IGJvdW5kaW5nIGJveC4gVGhlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBhbmQgc3RvcmVkIGluIF9fbGluZVdpZHRocyBjYWNoZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBnZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLCBsaW5lSW5mbztcblxuICAgICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIHdpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsaW5lSW5mbyA9IHRoaXMubWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgICAgd2lkdGggPSBsaW5lSW5mby53aWR0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gPSB3aWR0aDtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgX2dldFdpZHRoT2ZDaGFyU3BhY2luZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250U2l6ZSAqIHRoaXMuY2hhclNwYWNpbmcgLyAxMDAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYXQgZ2l2ZW4gY2hhcmFjdGVyIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0aGUgbGluZSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHRoZSBjaGFyYXRlciBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgJ3Byb3BlcnR5J1xuICAgICAqL1xuICAgIGdldFZhbHVlT2ZQcm9wZXJ0eUF0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBjaGFyU3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIGlmIChjaGFyU3R5bGUgJiYgdHlwZW9mIGNoYXJTdHlsZVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3R5bGVbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKGN0eCwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsIHNpemUsIF9zaXplLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBkeSwgX2R5LFxuICAgICAgICAgIGxpbmUsIGxhc3REZWNvcmF0aW9uLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIHRvcCxcbiAgICAgICAgICBib3hTdGFydCwgYm94V2lkdGgsIGNoYXJCb3gsIGN1cnJlbnREZWNvcmF0aW9uLFxuICAgICAgICAgIG1heEhlaWdodCwgY3VycmVudEZpbGwsIGxhc3RGaWxsLFxuICAgICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICAgIGlmICghdGhpc1t0eXBlXSAmJiAhdGhpcy5zdHlsZUhhcyh0eXBlLCBpKSkge1xuICAgICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgbGFzdERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsIHR5cGUpO1xuICAgICAgICBsYXN0RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2ZpbGwnKTtcbiAgICAgICAgdG9wID0gdG9wT2Zmc2V0ICsgbWF4SGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIDApO1xuICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2RlbHRhWScpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgIGN1cnJlbnREZWNvcmF0aW9uID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCB0eXBlKTtcbiAgICAgICAgICBjdXJyZW50RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2ZpbGwnKTtcbiAgICAgICAgICBfc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIGopO1xuICAgICAgICAgIF9keSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2RlbHRhWScpO1xuICAgICAgICAgIGlmICgoY3VycmVudERlY29yYXRpb24gIT09IGxhc3REZWNvcmF0aW9uIHx8IGN1cnJlbnRGaWxsICE9PSBsYXN0RmlsbCB8fCBfc2l6ZSAhPT0gc2l6ZSB8fCBfZHkgIT09IGR5KSAmJlxuICAgICAgICAgICAgICBib3hXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0RmlsbDtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uICYmIGxhc3RGaWxsICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICAgIHRvcCArIHRoaXMub2Zmc2V0c1t0eXBlXSAqIHNpemUgKyBkeSxcbiAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgICAgbGFzdERlY29yYXRpb24gPSBjdXJyZW50RGVjb3JhdGlvbjtcbiAgICAgICAgICAgIGxhc3RGaWxsID0gY3VycmVudEZpbGw7XG4gICAgICAgICAgICBzaXplID0gX3NpemU7XG4gICAgICAgICAgICBkeSA9IF9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudEZpbGw7XG4gICAgICAgIGN1cnJlbnREZWNvcmF0aW9uICYmIGN1cnJlbnRGaWxsICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICB0b3AgKyB0aGlzLm9mZnNldHNbdHlwZV0gKiBzaXplICsgZHksXG4gICAgICAgICAgYm94V2lkdGggLSBjaGFyU3BhY2luZyxcbiAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgKTtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGZvbnQgZGVjbGFyYXRpb24gc3RyaW5nIGZvciBjYW52YXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPYmplY3RdIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZvbnQgZGVjbGFyYXRpb24gZm9ybWF0dGVkIGZvciBjYW52YXMgY29udGV4dC5cbiAgICAgKi9cbiAgICBfZ2V0Rm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbihzdHlsZU9iamVjdCwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZU9iamVjdCB8fCB0aGlzLCBmYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udElzR2VuZXJpYyA9IGZhYnJpYy5UZXh0LmdlbmVyaWNGb250cy5pbmRleE9mKGZhbWlseS50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmYW1pbHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1xcJycpID4gLTEgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcIicpID4gLTEgfHwgZm9udElzR2VuZXJpY1xuICAgICAgICA/IHN0eWxlLmZvbnRGYW1pbHkgOiAnXCInICsgc3R5bGUuZm9udEZhbWlseSArICdcIic7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBub2RlLWNhbnZhcyBuZWVkcyBcIndlaWdodCBzdHlsZVwiLCB3aGlsZSBicm93c2VycyBuZWVkIFwic3R5bGUgd2VpZ2h0XCJcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250V2VpZ2h0IDogc3R5bGUuZm9udFN0eWxlKSxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250U3R5bGUgOiBzdHlsZS5mb250V2VpZ2h0KSxcbiAgICAgICAgZm9yTWVhc3VyaW5nID8gdGhpcy5DQUNIRV9GT05UX1NJWkUgKyAncHgnIDogc3R5bGUuZm9udFNpemUgKyAncHgnLFxuICAgICAgICBmb250RmFtaWx5XG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGluc3RhbmNlIG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCBhcyBhbiBhcnJheSBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMge0FycmF5fSBMaW5lcyBpbiB0aGUgdGV4dFxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSxcbiAgICAgICAgICBuZXdMaW5lcyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpLFxuICAgICAgICAgIG5ld0xpbmUgPSBbJ1xcbiddLFxuICAgICAgICAgIG5ld1RleHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3TGluZXNbaV0gPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChsaW5lc1tpXSk7XG4gICAgICAgIG5ld1RleHQgPSBuZXdUZXh0LmNvbmNhdChuZXdMaW5lc1tpXSwgbmV3TGluZSk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LnBvcCgpO1xuICAgICAgcmV0dXJuIHsgX3Vud3JhcHBlZExpbmVzOiBuZXdMaW5lcywgbGluZXM6IGxpbmVzLCBncmFwaGVtZVRleHQ6IG5ld1RleHQsIGdyYXBoZW1lTGluZXM6IG5ld0xpbmVzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllcyA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICAgJ3VuZGVybGluZScsXG4gICAgICAgICdvdmVybGluZScsXG4gICAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICBdLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIHZhciBvYmogPSB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBhZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICBvYmouc3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMsIHRydWUpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB2YXIgbmVlZHNEaW1zID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2tleSBpbiBrZXkpIHtcbiAgICAgICAgICBuZWVkc0RpbXMgPSBuZWVkc0RpbXMgfHwgdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihfa2V5KSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZWVkc0RpbXMgPSB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKGtleSkgIT09IC0xO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzRGltcykge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlRleHQuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvdGV4dC5odG1sI1RleHRFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICd4IHkgZHggZHkgZm9udC1mYW1pbHkgZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUgbGV0dGVyLXNwYWNpbmcgdGV4dC1kZWNvcmF0aW9uIHRleHQtYW5jaG9yJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBTVkcgZm9udCBzaXplXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkUgPSAxNjtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50ICg8Yj5ub3QgeWV0IGltcGxlbWVudGVkPC9iPilcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcGFyc2VkQW5jaG9yID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0QW5jaG9yIHx8ICdsZWZ0JztcbiAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCgob3B0aW9ucyA/IGNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcyk7XG5cbiAgICBvcHRpb25zLnRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgaWYgKHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb24pIHtcbiAgICAgIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb247XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLm92ZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5saW5ldGhyb3VnaCA9IHRydWU7XG4gICAgICB9XG4gICAgICBkZWxldGUgb3B0aW9ucy50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gICAgaWYgKCdkeCcgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHg7XG4gICAgfVxuICAgIGlmICgnZHknIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMudG9wICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHk7XG4gICAgfVxuICAgIGlmICghKCdmb250U2l6ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250ZW50ID0gJyc7XG5cbiAgICAvLyBUaGUgWE1MIGlzIG5vdCBwcm9wZXJseSBwYXJzZWQgaW4gSUU5IHNvIGEgd29ya2Fyb3VuZCB0byBnZXRcbiAgICAvLyB0ZXh0Q29udGVudCBpcyB0aHJvdWdoIGZpcnN0Q2hpbGQuZGF0YS4gQW5vdGhlciB3b3JrYXJvdW5kIHdvdWxkIGJlXG4gICAgLy8gdG8gY29udmVydCBYTUwgbG9hZGVkIGZyb20gYSBmaWxlIHRvIGJlIGNvbnZlcnRlZCB1c2luZyBET01QYXJzZXIgKHNhbWUgd2F5IGxvYWRTVkdGcm9tU3RyaW5nKCkgZG9lcylcbiAgICBpZiAoISgndGV4dENvbnRlbnQnIGluIGVsZW1lbnQpKSB7XG4gICAgICBpZiAoJ2ZpcnN0Q2hpbGQnIGluIGVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgnZGF0YScgaW4gZWxlbWVudC5maXJzdENoaWxkICYmIGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskfFxcbisvZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB2YXIgb3JpZ2luYWxTdHJva2VXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgb3B0aW9ucy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICB2YXIgdGV4dCA9IG5ldyBmYWJyaWMuVGV4dCh0ZXh0Q29udGVudCwgb3B0aW9ucyksXG4gICAgICAgIHRleHRIZWlnaHRTY2FsZUZhY3RvciA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgLyB0ZXh0LmhlaWdodCxcbiAgICAgICAgbGluZUhlaWdodERpZmYgPSAodGV4dC5oZWlnaHQgKyB0ZXh0LnN0cm9rZVdpZHRoKSAqIHRleHQubGluZUhlaWdodCAtIHRleHQuaGVpZ2h0LFxuICAgICAgICBzY2FsZWREaWZmID0gbGluZUhlaWdodERpZmYgKiB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IsXG4gICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpICsgc2NhbGVkRGlmZixcbiAgICAgICAgb2ZmWCA9IDA7XG4gICAgLypcbiAgICAgIEFkanVzdCBwb3NpdGlvbmluZzpcbiAgICAgICAgeC95IGF0dHJpYnV0ZXMgaW4gU1ZHIGNvcnJlc3BvbmQgdG8gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0ZXh0IGJvdW5kaW5nIGJveFxuICAgICAgICBmYWJyaWMgb3V0cHV0IGJ5IGRlZmF1bHQgYXQgdG9wLCBsZWZ0LlxuICAgICovXG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCkgLyAyO1xuICAgIH1cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpO1xuICAgIH1cbiAgICB0ZXh0LnNldCh7XG4gICAgICBsZWZ0OiB0ZXh0LmxlZnQgLSBvZmZYLFxuICAgICAgdG9wOiB0ZXh0LnRvcCAtICh0ZXh0SGVpZ2h0IC0gdGV4dC5mb250U2l6ZSAqICgwLjA3ICsgdGV4dC5fZm9udFNpemVGcmFjdGlvbikpIC8gdGV4dC5saW5lSGVpZ2h0LFxuICAgICAgc3Ryb2tlV2lkdGg6IHR5cGVvZiBvcmlnaW5hbFN0cm9rZVdpZHRoICE9PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsU3Ryb2tlV2lkdGggOiAxLFxuICAgIH0pO1xuICAgIGNhbGxiYWNrKHRleHQpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHQgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG5cbiAgZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzID0gWydzYW5zLXNlcmlmJywgJ3NlcmlmJywgJ2N1cnNpdmUnLCAnZmFudGFzeScsICdtb25vc3BhY2UnXTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5UZXh0KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGluZUluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9ialtwMV1bcDJdW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjaGFyYWN0ZXJzIGluIGEgdGV4dCBoYXZlIGEgdmFsdWUgZm9yIGEgcHJvcGVydHlcbiAgICAgKiB3aG9zZSB2YWx1ZSBtYXRjaGVzIHRoZSB0ZXh0Ym94J3MgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuICBJZiBzbyxcbiAgICAgKiB0aGUgY2hhcmFjdGVyLWxldmVsIHByb3BlcnR5IGlzIGRlbGV0ZWQuICBJZiB0aGUgY2hhcmFjdGVyXG4gICAgICogaGFzIG5vIG90aGVyIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYWxzbyBkZWxldGVkLiAgRmluYWxseSxcbiAgICAgKiBpZiB0aGUgbGluZSBjb250YWluaW5nIHRoYXQgY2hhcmFjdGVyIGhhcyBubyBvdGhlciBjaGFyYWN0ZXJzXG4gICAgICogdGhlbiBpdCBhbHNvIGlzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNvbXBhcmUgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFuU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBzdHlsZXNDb3VudCA9IDAsIGxldHRlckNvdW50LCBzdHlsZVByb3BlcnR5VmFsdWUsXG4gICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSB0cnVlLCBncmFwaGVtZUNvdW50ID0gMCwgc3R5bGVPYmplY3Q7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBsZXR0ZXJDb3VudCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgdmFyIHN0eWxlT2JqZWN0ID0gb2JqW3AxXVtwMl0sXG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0ID0gc3R5bGVPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICAgICAgc3R5bGVzQ291bnQrKztcblxuICAgICAgICAgIGlmIChzdHlsZVByb3BlcnR5SGFzQmVlblNldCkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eVZhbHVlID0gc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldICE9PSBzdHlsZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSA9PT0gdGhpc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZU9iamVjdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBsZXR0ZXJDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdW3AyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV0dGVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW3AxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgZXZlcnkgZ3JhcGhlbWUgaGFzIHRoZSBzYW1lIHN0eWxlIHNldCB0aGVuXG4gICAgICAvLyBkZWxldGUgdGhvc2Ugc3R5bGVzIGFuZCBzZXQgaXQgb24gdGhlIHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JhcGhlbWVDb3VudCArPSB0aGlzLl90ZXh0TGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoICYmIHN0eWxlc0NvdW50ID09PSBncmFwaGVtZUNvdW50KSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gc3R5bGVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkgb3IgcHJvcGVydGllcyBmcm9tIGFsbCBpbmRpdmlkdWFsIGNoYXJhY3RlciBzdHlsZXNcbiAgICAgKiBpbiBhIHRleHQgb2JqZWN0LiAgRGVsZXRlcyB0aGUgY2hhcmFjdGVyIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBzdHlsZVxuICAgICAqIHByb3BzLiAgRGVsZXRlcyBhIGxpbmUgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcHMgVGhlIHByb3BlcnR5IHRvIHJlbW92ZSBmcm9tIGNoYXJhY3RlciBzdHlsZXMuXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHRoaXMuc3R5bGVzLCBsaW5lLCBsaW5lTnVtLCBjaGFyTnVtO1xuICAgICAgZm9yIChsaW5lTnVtIGluIG9iaikge1xuICAgICAgICBsaW5lID0gb2JqW2xpbmVOdW1dO1xuICAgICAgICBmb3IgKGNoYXJOdW0gaW4gbGluZSkge1xuICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZVtjaGFyTnVtXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbbGluZU51bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXh0ZW5kU3R5bGVzOiBmdW5jdGlvbihpbmRleCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGluZGV4KTtcblxuICAgICAgaWYgKCF0aGlzLl9nZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCkpIHtcbiAgICAgICAgdGhpcy5fc2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgsIHt9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgMmQgcmVwcmVzZW50YXRpb24gKGxpbmVJbmRleCBhbmQgY2hhckluZGV4KSBvZiBjdXJzb3IgKG9yIHNlbGVjdGlvbiBzdGFydClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlbGVjdGlvblN0YXJ0XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwV3JhcHBpbmddIGNvbnNpZGVyIHRoZSBsb2NhdGlvbiBmb3IgdW53cmFwcGVkIGxpbmVzLiB1c2VmdWxsIHRvIG1hbmFnZSBzdHlsZXMuXG4gICAgICovXG4gICAgZ2V0MkRDdXJzb3JMb2NhdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIHNraXBXcmFwcGluZykge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb25TdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVzID0gc2tpcFdyYXBwaW5nID8gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzIDogdGhpcy5fdGV4dExpbmVzO1xuICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0IDw9IGxpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lSW5kZXg6IGksXG4gICAgICAgICAgICBjaGFySW5kZXg6IHNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydCAtPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUluZGV4OiBpIC0gMSxcbiAgICAgICAgY2hhckluZGV4OiBsaW5lc1tpIC0gMV0ubGVuZ3RoIDwgc2VsZWN0aW9uU3RhcnQgPyBsaW5lc1tpIC0gMV0ubGVuZ3RoIDogc2VsZWN0aW9uU3RhcnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgKGF0IHRoZSBzdGFydCBwb3NpdGlvbilcbiAgICAgKiBpZiBzdGFydEluZGV4IG9yIGVuZEluZGV4IGFyZSBub3QgcHJvdmlkZWQsIHNsZWN0aW9uU3RhcnQgb3Igc2VsZWN0aW9uRW5kIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZ2V0IGZ1bGwgc3R5bGUgb3Igbm90XG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0eWxlcyBhbiBhcnJheSB3aXRoIG9uZSwgemVybyBvciBtb3JlIFN0eWxlIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25TdHlsZXM6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBjb21wbGV0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0eWxlcy5wdXNoKHRoaXMuZ2V0U3R5bGVBdFBvc2l0aW9uKGksIGNvbXBsZXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uICB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcGxldGVdIGZ1bGwgc3R5bGUgaWYgdHJ1ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgU3R5bGUgb2JqZWN0IGF0IGEgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTdHlsZUF0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbiksXG4gICAgICAgICAgc3R5bGUgPSBjb21wbGV0ZSA/IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpIDpcbiAgICAgICAgICAgIHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCk7XG4gICAgICByZXR1cm4gc3R5bGUgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbiwgaWYgbm8gc2VsZWN0aW9uIGV4aXN0LCBkbyBub3Qgc2V0IGFueXRoaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSBTdHlsZXMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XSBTdGFydCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gRW5kIGluZGV4IHRvIGdldCBzdHlsZXMgYXQsIGlmIG5vdCBzcGVjaWZpZWQgc2VsZWN0aW9uRW5kIG9yIHN0YXJ0SW5kZXggKyAxXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3R5bGVzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2V4dGVuZFN0eWxlcyhpLCBzdHlsZXMpO1xuICAgICAgfVxuICAgICAgLyogbm90IGluY2x1ZGVkIGluIF9leHRlbmRTdHlsZXMgdG8gYXZvaWQgY2xlYXJpbmcgY2FjaGUgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSByZWZlcmVuY2UsIG5vdCBhIGNsb25lLCBvZiB0aGUgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBsaW5lU3R5bGUgPSB0aGlzLnN0eWxlcyAmJiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgICAgaWYgKCFsaW5lU3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZVN0eWxlW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgdGhlIHN0eWxlIHByb3BlcnR5IGZvciBhIGNoYXJhY3RlclxuICAgICAqIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgbmV3bHkgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXJhY3RlciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gb2YgdGhlIGNoYXJhY3RlciBvbiB0aGUgbGluZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkgfHwgeyB9LFxuICAgICAgICAgIHN0eWxlT2JqZWN0ID0geyB9LCBwcm9wO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdHlsZVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuX3N0eWxlUHJvcGVydGllc1tpXTtcbiAgICAgICAgc3R5bGVPYmplY3RbcHJvcF0gPSB0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnID8gdGhpc1twcm9wXSA6IHN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4LCBzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlTGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBwYXJzZURlY29yYXRpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpID4gLTEgJiYgKG9iamVjdC51bmRlcmxpbmUgPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSA+IC0xICYmIChvYmplY3QubGluZXRocm91Z2ggPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpID4gLTEgJiYgKG9iamVjdC5vdmVybGluZSA9IHRydWUpO1xuICAgICAgZGVsZXRlIG9iamVjdC50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSVRleHQgY2xhc3MgKGludHJvZHVjZWQgaW4gPGI+djEuNDwvYj4pIEV2ZW50cyBhcmUgYWxzbyBmaXJlZCB3aXRoIFwidGV4dDpcIlxuICAgKiBwcmVmaXggd2hlbiBvYnNlcnZpbmcgY2FudmFzLlxuICAgKiBAY2xhc3MgZmFicmljLklUZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5UZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZmlyZXMgY2hhbmdlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNoYW5nZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZW50ZXJlZFxuICAgKiBAZmlyZXMgZWRpdGluZzpleGl0ZWRcbiAgICpcbiAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQga2V5IGNvbWJpbmF0aW9uczo8L3A+XG4gICAqIDxwcmU+XG4gICAqICAgTW92ZSBjdXJzb3I6ICAgICAgICAgICAgICAgICAgICBsZWZ0LCByaWdodCwgdXAsIGRvd25cbiAgICogICBTZWxlY3QgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIHNoaWZ0ICsgbGVmdCwgc2hpZnQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB0ZXh0IHZlcnRpY2FsbHk6ICAgICAgICAgc2hpZnQgKyB1cCwgc2hpZnQgKyBkb3duXG4gICAqICAgTW92ZSBjdXJzb3IgYnkgd29yZDogICAgICAgICAgICBhbHQgKyBsZWZ0LCBhbHQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB3b3JkczogICAgICAgICAgICAgICAgICAgc2hpZnQgKyBhbHQgKyBsZWZ0LCBzaGlmdCArIGFsdCArIHJpZ2h0XG4gICAqICAgTW92ZSBjdXJzb3IgdG8gbGluZSBzdGFydC9lbmQ6ICBjbWQgKyBsZWZ0LCBjbWQgKyByaWdodCBvciBob21lLCBlbmRcbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgbGluZTogIGNtZCArIHNoaWZ0ICsgbGVmdCwgY21kICsgc2hpZnQgKyByaWdodCBvciBzaGlmdCArIGhvbWUsIHNoaWZ0ICsgZW5kXG4gICAqICAgSnVtcCB0byBzdGFydC9lbmQgb2YgdGV4dDogICAgICBjbWQgKyB1cCwgY21kICsgZG93blxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgY21kICsgc2hpZnQgKyB1cCwgY21kICsgc2hpZnQgKyBkb3duIG9yIHNoaWZ0ICsgcGdVcCwgc2hpZnQgKyBwZ0Rvd25cbiAgICogICBEZWxldGUgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSB3b3JkOiAgICAgICAgICAgICAgICAgICAgYWx0ICsgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIGxpbmU6ICAgICAgICAgICAgICAgICAgICBjbWQgKyBiYWNrc3BhY2VcbiAgICogICBGb3J3YXJkIGRlbGV0ZTogICAgICAgICAgICAgICAgIGRlbGV0ZVxuICAgKiAgIENvcHkgdGV4dDogICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyBjXG4gICAqICAgUGFzdGUgdGV4dDogICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHZcbiAgICogICBDdXQgdGV4dDogICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgeFxuICAgKiAgIFNlbGVjdCBlbnRpcmUgdGV4dDogICAgICAgICAgICAgY3RybC9jbWQgKyBhXG4gICAqICAgUXVpdCBlZGl0aW5nICAgICAgICAgICAgICAgICAgICB0YWIgb3IgZXNjXG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQgbW91c2UvdG91Y2ggY29tYmluYXRpb248L3A+XG4gICAqIDxwcmU+XG4gICAqICAgUG9zaXRpb24gY3Vyc29yOiAgICAgICAgICAgICAgICBjbGljay90b3VjaFxuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2svdG91Y2ggJiBkcmFnXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljayAmIHNoaWZ0ICsgY2xpY2tcbiAgICogICBTZWxlY3Qgd29yZDogICAgICAgICAgICAgICAgICAgIGRvdWJsZSBjbGlja1xuICAgKiAgIFNlbGVjdCBsaW5lOiAgICAgICAgICAgICAgICAgICAgdHJpcGxlIGNsaWNrXG4gICAqIDwvcHJlPlxuICAgKi9cbiAgZmFicmljLklUZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpLXRleHQnLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gc3RhcnRzIChvciB3aGVyZSBjdXJzb3IgaXMgd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24pXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25TdGFydDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIGVuZHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkVuZDogMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogJ3JnYmEoMTcsMTE5LDI1NSwwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRleHQgaXMgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgdGV4dCBjYW4gYmUgZWRpdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBCb3JkZXIgY29sb3Igb2YgdGV4dCBvYmplY3Qgd2hpbGUgaXQncyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRpbmdCb3JkZXJDb2xvcjogJ3JnYmEoMTAyLDE1MywyNTUsMC4yNSknLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgY3Vyc29yIChpbiBweClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvcldpZHRoOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgZGVmYXVsdCBjdXJzb3IgKHdoZW4gbm90IG92ZXJ3cml0dGVuIGJ5IGNoYXJhY3RlciBzdHlsZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckNvbG9yOiAnIzMzMycsXG5cbiAgICAvKipcbiAgICAgKiBEZWxheSBiZXR3ZWVuIGN1cnNvciBibGluayAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEZWxheTogMTAwMCxcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIGN1cnNvciBmYWRlaW4gKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRHVyYXRpb246IDYwMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGludGVybmFsIHRleHQgY2hhciB3aWR0aHMgY2FuIGJlIGNhY2hlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlOiAvXFxzfFxcbi8sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jdXJyZW50Q3Vyc29yT3BhY2l0eTogMCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdGlvbkRpcmVjdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Fib3J0Q3Vyc29yQW5pbWF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX193aWR0aE9mU3BhY2U6IFtdLFxuXG4gICAgLyoqXG4gICAgICogSGVscHMgZGV0ZXJtaW5pbmcgd2hlbiB0aGUgdGV4dCBpcyBpbiBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGUgY3Vyc29yXG4gICAgICogcmVuZGVyaW5nIGlzIGFsdGVyZWQuXG4gICAgICovXG4gICAgaW5Db21wb3NpdGlvbk1vZGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIHRleHQsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gc3RhcnQgKGxlZnQgYm91bmRhcnkgb2YgYSBzZWxlY3Rpb24pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIHNldCBzZWxlY3Rpb24gc3RhcnQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuICAgICAgdGhpcy5fdXBkYXRlQW5kRmlyZSgnc2VsZWN0aW9uU3RhcnQnLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0aW9uIGVuZCAocmlnaHQgYm91bmRhcnkgb2YgYSBzZWxlY3Rpb24pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIHNldCBzZWxlY3Rpb24gZW5kIHRvXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uRW5kOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdGhpcy50ZXh0Lmxlbmd0aCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25FbmQnLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5ICdzZWxlY3Rpb25TdGFydCcgb3IgJ3NlbGVjdGlvbkVuZCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggbmV3IHBvc2l0aW9uIG9mIHByb3BlcnR5XG4gICAgICovXG4gICAgX3VwZGF0ZUFuZEZpcmU6IGZ1bmN0aW9uKHByb3BlcnR5LCBpbmRleCkge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICE9PSBpbmRleCkge1xuICAgICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluZGV4O1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGV2ZW4gb2Ygc2VsZWN0aW9uIGNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlU2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjaGFuZ2VkJyk7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OnNlbGVjdGlvbjpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGV4dCBkaW1lbnNpb25zLiBSZW5kZXIgYWxsIHRleHQgb24gZ2l2ZW4gY29udGV4dFxuICAgICAqIG9yIG9uIGEgb2Zmc2NyZWVuIGNhbnZhcyB0byBnZXQgdGhlIHRleHQgd2lkdGggd2l0aCBtZWFzdXJlVGV4dC5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXREaW1lbnNpb25zJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICAvLyBjbGVhciB0aGUgY3Vyc29yT2Zmc2V0Q2FjaGUsIHNvIHdlIGVuc3VyZSB0byBjYWxjdWxhdGUgb25jZSBwZXIgcmVuZGVyQ3Vyc29yXG4gICAgICAvLyB0aGUgY29ycmVjdCBwb3NpdGlvbiBidXQgbm90IGF0IGV2ZXJ5IGN1cnNvciBhbmltYXRpb24uXG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhbmQgY2xlYW4gdGhlIGNvbnRleHRUb3BcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHRUb3A6IGZ1bmN0aW9uKHNraXBSZXN0b3JlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ICYmIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGV4dEFyZWEoY3R4KTtcbiAgICAgICAgc2tpcFJlc3RvcmUgfHwgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKCksIGN0eDtcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRDb250YWluZXI7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3IoYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgX2NsZWFyVGV4dEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gd2UgYWRkIDQgcGl4ZWwsIHRvIGJlIHN1cmUgdG8gZG8gbm90IGxlYXZlIGFueSBwaXhlbCBvdXRcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggKyA0LCBoZWlnaHQgPSB0aGlzLmhlaWdodCArIDQ7XG4gICAgICBjdHguY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJzb3IgYm91bmRhcmllcyAobGVmdCwgdG9wLCBsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGFycyBBcnJheSBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVPZkJvdW5kYXJpZXNcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcblxuICAgICAgLy8gbGVmdC90b3AgYXJlIGxlZnQvdG9wIG9mIGVudGlyZSB0ZXh0IGJveFxuICAgICAgLy8gbGVmdE9mZnNldC90b3BPZmZzZXQgYXJlIG9mZnNldCBmcm9tIHRoYXQgbGVmdC90b3AgcG9pbnQgb2YgYSB0ZXh0IGJveFxuXG4gICAgICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLFxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyhwb3NpdGlvbik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0T2Zmc2V0OiBvZmZzZXRzLmxlZnQsXG4gICAgICAgIHRvcE9mZnNldDogb2Zmc2V0cy50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgJiYgJ3RvcCcgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICBsaW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4LFxuICAgICAgICAgIHRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgYm91bmRhcmllcyxcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXg7XG4gICAgICBsaW5lSW5kZXggPSBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cbiAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICAgIHZhciBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICAgIGJvdW5kICYmIChsZWZ0T2Zmc2V0ID0gYm91bmQubGVmdCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCAmJiBjaGFySW5kZXggPT09IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCkge1xuICAgICAgICBsZWZ0T2Zmc2V0IC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgdG9wOiB0b3BPZmZzZXQsXG4gICAgICAgIGxlZnQ6IGxpbmVMZWZ0T2Zmc2V0ICsgKGxlZnRPZmZzZXQgPiAwID8gbGVmdE9mZnNldCA6IDApLFxuICAgICAgfTtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSBib3VuZGFyaWVzO1xuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY3Vyc29yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvdW5kYXJpZXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRyYW5zZm9ybWVkIGNvbnRleHQgdG8gZHJhdyBvblxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvcjogZnVuY3Rpb24oYm91bmRhcmllcywgY3R4KSB7XG4gICAgICB2YXIgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4ID4gMCA/IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCAtIDEgOiAwLFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy5zY2FsZVggKiB0aGlzLmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgICAgY3Vyc29yV2lkdGggPSB0aGlzLmN1cnNvcldpZHRoIC8gbXVsdGlwbGllcixcbiAgICAgICAgICB0b3BPZmZzZXQgPSBib3VuZGFyaWVzLnRvcE9mZnNldCxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdkZWx0YVknKTtcblxuICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgIC0gY2hhckhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZmlsbCcpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBib3VuZGFyaWVzLmxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIHRvcE9mZnNldCArIGJvdW5kYXJpZXMudG9wICsgZHksXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kIDogdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZUluZGV4LFxuICAgICAgICAgIHN0YXJ0Q2hhciA9IHN0YXJ0LmNoYXJJbmRleCA8IDAgPyAwIDogc3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGVuZENoYXIgPSBlbmQuY2hhckluZGV4IDwgMCA/IDAgOiBlbmQuY2hhckluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFN0YXJ0ID0gMCwgYm94RW5kID0gMDtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgYm94U3RhcnQgPSB0aGlzLl9fY2hhckJvdW5kc1tzdGFydExpbmVdW3N0YXJ0Q2hhcl0ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBzdGFydExpbmUgJiYgaSA8IGVuZExpbmUpIHtcbiAgICAgICAgICBib3hFbmQgPSBpc0p1c3RpZnkgJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGkpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGkpIHx8IDU7IC8vIFdURiBpcyB0aGlzIDU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGlmIChlbmRDaGFyID09PSAwKSB7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyXS5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLmxlZnRcbiAgICAgICAgICAgICAgKyB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ud2lkdGggLSBjaGFyU3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29tcG9zaXRpb25Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGxpbmVPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgYm91bmRhcmllcy50b3BPZmZzZXQgKz0gcmVhbExpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJzb3IuXG4gICAgICogdGhlIGN1cnJlbnRDaGFyIGlzIHRoZSBvbmUgdGhhdCBwcmVjZWRlcyB0aGUgY3Vyc29yXG4gICAgICogUmV0dXJucyBmb250U2l6ZSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgY29sb3Igb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2hhcmFjdGVyIGNvbG9yIChmaWxsKVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZpbGwnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Vyc29yIHBvc2l0aW9uIGZvciB0aGUgZ2V0Q3VycmVudC4uIGZ1bmN0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnJlbnRDaGFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRydWUpLFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleCA+IDAgPyBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggLSAxIDogMDtcbiAgICAgIHJldHVybiB7IGw6IGN1cnNvclBvc2l0aW9uLmxpbmVJbmRleCwgYzogY2hhckluZGV4IH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuSVRleHQgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLklUZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLklUZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcGFyc2VEZWNvcmF0aW9uKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdC5zdHlsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqZWN0LnN0eWxlcykge1xuICAgICAgICBmb3IgKHZhciBqIGluIG9iamVjdC5zdHlsZXNbaV0pIHtcbiAgICAgICAgICBwYXJzZURlY29yYXRpb24ob2JqZWN0LnN0eWxlc1tpXVtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnSVRleHQnLCBvYmplY3QsIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFsbCB0aGUgaW50ZXJhY3RpdmUgYmVoYXZpb3Igb2YgSVRleHRcbiAgICAgKi9cbiAgICBpbml0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbml0QWRkZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRSZW1vdmVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbigpO1xuICAgICAgdGhpcy5tb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5tb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfSxcblxuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5leGl0RWRpdGluZygpO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcImFkZGVkXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRBZGRlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ2FkZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBpZiAoIWNhbnZhcy5faGFzSVRleHRIYW5kbGVycykge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9pbml0Q2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5wdXNoKF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXRSZW1vdmVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbigncmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5KGNhbnZhcy5faVRleHRJbnN0YW5jZXMsIF90aGlzKTtcbiAgICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBvYmouX19pc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2FudmFzLm9uKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLm9mZignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgPSB0aGlzLl9hbmltYXRlQ3Vyc29yKHRoaXMsIDEsIHRoaXMuY3Vyc29yRHVyYXRpb24sICdfb25UaWNrQ29tcGxldGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUN1cnNvcjogZnVuY3Rpb24ob2JqLCB0YXJnZXRPcGFjaXR5LCBkdXJhdGlvbiwgY29tcGxldGVNZXRob2QpIHtcblxuICAgICAgdmFyIHRpY2tTdGF0ZTtcblxuICAgICAgdGlja1N0YXRlID0ge1xuICAgICAgICBpc0Fib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgb2JqLmFuaW1hdGUoJ19jdXJyZW50Q3Vyc29yT3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRpY2tTdGF0ZS5pc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgIG9ialtjb21wbGV0ZU1ldGhvZF0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBhbmltYXRlIGEgc2VsZWN0aW9uLCBvbmx5IGN1cnNvclxuICAgICAgICAgIGlmIChvYmouY2FudmFzICYmIG9iai5zZWxlY3Rpb25TdGFydCA9PT0gb2JqLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb2JqLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRpY2tTdGF0ZS5pc0Fib3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRpY2tTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25UaWNrQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fY3Vyc29yVGltZW91dDEpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQxID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSA9IF90aGlzLl9hbmltYXRlQ3Vyc29yKF90aGlzLCAwLCB0aGlzLmN1cnNvckR1cmF0aW9uIC8gMiwgJ190aWNrJyk7XG4gICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBkZWxheWVkIGN1cnNvclxuICAgICAqL1xuICAgIGluaXREZWxheWVkQ3Vyc29yOiBmdW5jdGlvbihyZXN0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGRlbGF5ID0gcmVzdGFydCA/IDAgOiB0aGlzLmN1cnNvckRlbGF5O1xuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl90aWNrKCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFib3J0cyBjdXJzb3IgYW5pbWF0aW9uIGFuZCBjbGVhcnMgYWxsIHRpbWVvdXRzXG4gICAgICovXG4gICAgYWJvcnRDdXJzb3JBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUsXG4gICAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuYWJvcnQoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUuYWJvcnQoKTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0Mik7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIC8vIHRvIGNsZWFyIGp1c3QgaXRleHQgYXJlYSB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgY29udGV4dFxuICAgICAgLy8gaXQgbWF5IG5vdCBiZSB3b3J0aCBpdFxuICAgICAgaWYgKHNob3VsZENsZWFyICYmIGNhbnZhcykge1xuICAgICAgICBjYW52YXMuY2xlYXJDb250ZXh0KGNhbnZhcy5jb250ZXh0VG9wIHx8IGNhbnZhcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGVudGlyZSB0ZXh0XG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fdGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlbGVjdGVkIHRleHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0LnNsaWNlKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kKS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IHdvcmQgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBTdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRXb3JkQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBiZWZvcmUgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IHdvcmQgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRXb3JkQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBhZnRlciBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggY29ycmVzcG9uZGluZyB0byBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gMSBvciAtMVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICovXG4gICAgc2VhcmNoV29yZEJvdW5kYXJ5OiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggICAgID0gdGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMudGV4dC5jaGFyQXQoc2VsZWN0aW9uU3RhcnQpKSA/IHNlbGVjdGlvblN0YXJ0IC0gMSA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIF9jaGFyICAgICA9IHRoaXMudGV4dC5jaGFyQXQoaW5kZXgpLFxuICAgICAgICAgIHJlTm9uV29yZCA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuXG4gICAgICB3aGlsZSAoIXJlTm9uV29yZC50ZXN0KF9jaGFyKSAmJiBpbmRleCA+IDAgJiYgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgX2NoYXIgPSB0aGlzLnRleHQuY2hhckF0KGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU5vbldvcmQudGVzdChfY2hhcikgJiYgX2NoYXIgIT09ICdcXG4nKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgd29yZCBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBzZWxlY3RXb3JkOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIC0xKSwgLyogc2VhcmNoIGJhY2t3YXJkcyAqL1xuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAxKTsgLyogc2VhcmNoIGZvcndhcmQgKi9cblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIGxpbmUgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbGVjdExpbmU6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlMZWZ0KHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICBuZXdTZWxlY3Rpb25FbmQgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlSaWdodChzZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uRW5kO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW50ZXJzIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZW50ZXJFZGl0aW5nOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2FsY09mZnNldCgpO1xuICAgICAgICB0aGlzLmV4aXRFZGl0aW5nT25PdGhlcnModGhpcy5jYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuaW5pdEhpZGRlblRleHRhcmVhKGUpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLl9zYXZlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9zZXRFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3RleHRCZWZvcmVFZGl0ID0gdGhpcy50ZXh0O1xuXG4gICAgICB0aGlzLl90aWNrKCk7XG4gICAgICB0aGlzLmZpcmUoJ2VkaXRpbmc6ZW50ZXJlZCcpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmVkaXRpbmc6ZW50ZXJlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5pbml0TW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4aXRFZGl0aW5nT25PdGhlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvYmouZXhpdEVkaXRpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcIm1vdXNlbW92ZVwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0TW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNhbnZhcy5vbignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9faXNNb3VzZWRvd24gfHwgIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSksXG4gICAgICAgICAgY3VycmVudFN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBjdXJyZW50RW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoXG4gICAgICAgIChuZXdTZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gfHwgY3VycmVudFN0YXJ0ID09PSBjdXJyZW50RW5kKVxuICAgICAgICAmJlxuICAgICAgICAoY3VycmVudFN0YXJ0ID09PSBuZXdTZWxlY3Rpb25TdGFydCB8fCBjdXJyZW50RW5kID09PSBuZXdTZWxlY3Rpb25TdGFydClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPiB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IGN1cnJlbnRTdGFydCB8fCB0aGlzLnNlbGVjdGlvbkVuZCAhPT0gY3VycmVudEVuZCkge1xuICAgICAgICB0aGlzLnJlc3RhcnRDdXJzb3JJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gJ3RleHQnO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuY2FudmFzLm1vdmVDdXJzb3IgPSAndGV4dCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLmVkaXRpbmdCb3JkZXJDb2xvcjtcblxuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIHRleHRhcmVhIHRvIGdyYXBoZW1lIGluZGV4ZXNcbiAgICAgKi9cbiAgICBmcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSxcbiAgICAgICAgICBncmFwaGVtZVN0YXJ0ID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRTdGFydCkubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gdGV4dC5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICBncmFwaGVtZUVuZCA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHNtYWxsZXJUZXh0RW5kKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIGZhYnJpYyB0byB0ZXh0YXJlYSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX3RleHQpIHtcbiAgICAgIHZhciBzbWFsbGVyVGV4dFN0YXJ0ID0gX3RleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBzbWFsbGVyVGV4dFN0YXJ0LmpvaW4oJycpLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzbWFsbGVyVGV4dEVuZCA9IF90ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gc21hbGxlclRleHRFbmQuam9pbignJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCArIGdyYXBoZW1lRW5kIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLl90ZXh0KTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlRnJvbVRleHRBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLCB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUudG9wID0gc3R5bGUudG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgY29udGFpbnMgc3R5bGUgZm9yIGhpZGRlblRleHRhcmVhXG4gICAgICovXG4gICAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMSwgeTogMSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRlc2lyZWRQb3N0aW9uID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuY29tcG9zaXRpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoZGVzaXJlZFBvc3Rpb24pLFxuICAgICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGRlc2lyZWRQb3N0aW9uKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSAqIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gYm91bmRhcmllcy5sZWZ0T2Zmc2V0LFxuICAgICAgICAgIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgeDogYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICAgIHk6IGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBjaGFySGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cHBlckNhbnZhcyA9IHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgdXBwZXJDYW52YXNXaWR0aCA9IHVwcGVyQ2FudmFzLndpZHRoLFxuICAgICAgICAgIHVwcGVyQ2FudmFzSGVpZ2h0ID0gdXBwZXJDYW52YXMuaGVpZ2h0LFxuICAgICAgICAgIG1heFdpZHRoID0gdXBwZXJDYW52YXNXaWR0aCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdXBwZXJDYW52YXNIZWlnaHQgLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IHVwcGVyQ2FudmFzLmNsaWVudFdpZHRoIC8gdXBwZXJDYW52YXNXaWR0aCxcbiAgICAgICAgICBzY2FsZVkgPSB1cHBlckNhbnZhcy5jbGllbnRIZWlnaHQgLyB1cHBlckNhbnZhc0hlaWdodDtcblxuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0pO1xuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHAueCAqPSBzY2FsZVg7XG4gICAgICBwLnkgKj0gc2NhbGVZO1xuICAgICAgaWYgKHAueCA8IDApIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnggPiBtYXhXaWR0aCkge1xuICAgICAgICBwLnggPSBtYXhXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPCAwKSB7XG4gICAgICAgIHAueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHAueSA9IG1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhbnZhcyBvZmZzZXQgb24gZG9jdW1lbnRcbiAgICAgIHAueCArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3A7XG5cbiAgICAgIHJldHVybiB7IGxlZnQ6IHAueCArICdweCcsIHRvcDogcC55ICsgJ3B4JywgZm9udFNpemU6IGNoYXJIZWlnaHQgKyAncHgnLCBjaGFySGVpZ2h0OiBjaGFySGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2F2ZWRQcm9wcyA9IHtcbiAgICAgICAgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLFxuICAgICAgICBsb2NrTW92ZW1lbnRYOiB0aGlzLmxvY2tNb3ZlbWVudFgsXG4gICAgICAgIGxvY2tNb3ZlbWVudFk6IHRoaXMubG9ja01vdmVtZW50WSxcbiAgICAgICAgaG92ZXJDdXJzb3I6IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgIGRlZmF1bHRDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IsXG4gICAgICAgIG1vdmVDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLm1vdmVDdXJzb3JcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3RvcmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zYXZlZFByb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuaG92ZXJDdXJzb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5fc2F2ZWRQcm9wcy5oYXNDb250cm9scztcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLl9zYXZlZFByb3BzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRYO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRZID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRZO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuZGVmYXVsdEN1cnNvcjtcbiAgICAgICAgdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMubW92ZUN1cnNvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhpdHMgZnJvbSBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGV4aXRFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc1RleHRDaGFuZ2VkID0gKHRoaXMuX3RleHRCZWZvcmVFZGl0ICE9PSB0aGlzLnRleHQpO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5ibHVyICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuYmx1cigpO1xuICAgICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzpleGl0ZWQnKTtcbiAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm9mZignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzpleGl0ZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmNhbnZhcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuZCByZWZsb3cgYSBzdHlsZSBibG9jayBmcm9tIHN0YXJ0IHRvIGVuZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbGluZWFyIHN0YXJ0IHBvc2l0aW9uIGZvciByZW1vdmFsIChpbmNsdWRlZCBpbiByZW1vdmFsKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgbGluZWFyIGVuZCBwb3NpdGlvbiBmb3IgcmVtb3ZhbCAoIGV4Y2x1ZGVkIGZyb20gcmVtb3ZhbCApXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGVGcm9tVG86IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBjdXJzb3JTdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY3Vyc29yRW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGVuZCwgdHJ1ZSksXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY3Vyc29yU3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJTdGFydCA9IGN1cnNvclN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBsaW5lRW5kID0gY3Vyc29yRW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFyRW5kID0gY3Vyc29yRW5kLmNoYXJJbmRleCxcbiAgICAgICAgICBpLCBzdHlsZU9iajtcbiAgICAgIGlmIChsaW5lU3RhcnQgIT09IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gc3RlcDEgcmVtb3ZlIHRoZSB0cmFpbGluZyBvZiBsaW5lU3RhcnRcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyU3RhcnQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZVN0YXJ0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAyIG1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVFbmQgdG8gbGluZVN0YXJ0IGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUVuZF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyRW5kOyBpIDwgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVFbmRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVFbmRdW2ldO1xuICAgICAgICAgICAgaWYgKHN0eWxlT2JqKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gfHwgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gPSB7IH0pO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdW2NoYXJTdGFydCArIGkgLSBjaGFyRW5kXSA9IHN0eWxlT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwMyBkZXRlY3RzIGxpbmVzIHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBmb3IgKGkgPSBsaW5lU3RhcnQgKyAxOyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwNCBzaGlmdCByZW1haW5pbmcgbGluZXMuXG4gICAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVFbmQsIGxpbmVTdGFydCAtIGxpbmVFbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgc2hpZnQgbGVmdCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgc3R5bGVPYmogPSB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdO1xuICAgICAgICAgIHZhciBkaWZmID0gY2hhckVuZCAtIGNoYXJTdGFydCwgbnVtZXJpY0NoYXIsIF9jaGFyO1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IGNoYXJFbmQ7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9jaGFyIGluIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICAgIG51bWVyaWNDaGFyID0gcGFyc2VJbnQoX2NoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljQ2hhciA+PSBjaGFyRW5kKSB7XG4gICAgICAgICAgICAgIHN0eWxlT2JqW251bWVyaWNDaGFyIC0gZGlmZl0gPSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBhbnkgbnVtYmVyP1xuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSBvZmZzZXQgdXB3YXJkIG9yIGRvd253YXJkXG4gICAgICAvLyBkbyBub3QgY2xvbmUgZGVlcC4gd2UgbmVlZCBuZXcgYXJyYXksIG5vdCBuZXcgc3R5bGUgb2JqZWN0c1xuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKTtcbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIGlmICghY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lIC0gb2Zmc2V0XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdGFydEN1cnNvcklmTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmlzQWJvcnRlZFxuICAgICAgICB8fCAhdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5pc0Fib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgbmV3IHN0eWxlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXR5IG51bWJlciBvZiBsaW5lcyB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBBcnJheSBvZiBvYmplY3RzIHN0eWxlc1xuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJyZW50Q2hhclN0eWxlLFxuICAgICAgICAgIG5ld0xpbmVTdHlsZXMgPSB7fSxcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IGZhbHNlO1xuXG4gICAgICBxdHkgfHwgKHF0eSA9IDEpO1xuICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUluZGV4LCBxdHkpO1xuICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgY3VycmVudENoYXJTdHlsZSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ID09PSAwID8gY2hhckluZGV4IDogY2hhckluZGV4IC0gMV07XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGNsb25lIHN0eWxlcyBvZiBhbGwgY2hhcnNcbiAgICAgIC8vIGFmdGVyIGN1cnNvciBvbnRvIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgdmFyIG51bUluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bUluZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzW251bUluZGV4IC0gY2hhckluZGV4XSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIC8vIHJlbW92ZSBsaW5lcyBmcm9tIHRoZSBwcmV2aW91cyBsaW5lIHNpbmNlIHRoZXkncmUgb24gYSBuZXcgbGluZSBub3dcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb21ldGhpbmdBZGRlZCkge1xuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0gbmV3TGluZVN0eWxlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XTtcbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgb3RoZXIgbGluZXNcbiAgICAgIC8vIHdlIGNsb25lIGN1cnJlbnQgY2hhciBzdHlsZSBvbnRvIHRoZSBuZXh0IChvdGhlcndpc2UgZW1wdHkpIGxpbmVcbiAgICAgIHdoaWxlIChxdHkgPiAxKSB7XG4gICAgICAgIHF0eS0tO1xuICAgICAgICBpZiAoY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGVbcXR5XSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGNvcGllZFN0eWxlW3F0eV0pIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJTdHlsZSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGN1cnJlbnRDaGFyU3R5bGUpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbnRpdHkgbnVtYmVyIFN0eWxlIG9iamVjdCB0byBpbnNlcnQsIGlmIGdpdmVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWNzXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhclN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXVhbnRpdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudExpbmVTdHlsZXMgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY3VycmVudExpbmVTdHlsZXMgPyBjbG9uZShjdXJyZW50TGluZVN0eWxlcykgOiB7fTtcblxuICAgICAgcXVhbnRpdHkgfHwgKHF1YW50aXR5ID0gMSk7XG4gICAgICAvLyBzaGlmdCBhbGwgY2hhciBzdHlsZXMgYnkgcXVhbnRpdHkgZm9yd2FyZFxuICAgICAgLy8gMCwxLDIsMyAtPiAoY2hhckluZGV4PTIpIC0+IDAsMSwzLDQgLT4gKGluc2VydCAyKSAtPiAwLDEsMiwzLDRcbiAgICAgIGZvciAodmFyIGluZGV4IGluIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkKSB7XG4gICAgICAgIHZhciBudW1lcmljSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0luZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleCArIHF1YW50aXR5XSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgdGhlIHN0eWxlIGlmIHRoZXJlIHdhcyBub3RoaW5nIG1vdmVkIHRoZXJlXG4gICAgICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXggLSBxdWFudGl0eV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICB3aGlsZSAocXVhbnRpdHktLSkge1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoY29waWVkU3R5bGVbcXVhbnRpdHldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShjb3BpZWRTdHlsZVtxdWFudGl0eV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1N0eWxlID0gY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4ID8gY2hhckluZGV4IC0gMSA6IDFdO1xuICAgICAgd2hpbGUgKG5ld1N0eWxlICYmIHF1YW50aXR5LS0pIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShuZXdTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0KHMpXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5zZXJ0ZWRUZXh0IENoYXJhY3RlcnMgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHN0eWxlIGlzIGluc2VydGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGN1cnNvciBpbmRleCBmb3IgaW5zZXJ0aW5nIHN0eWxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvcGllZFN0eWxlXSBhcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGluc2VydC5cbiAgICAgKi9cbiAgICBpbnNlcnROZXdTdHlsZUJsb2NrOiBmdW5jdGlvbihpbnNlcnRlZFRleHQsIHN0YXJ0LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnNvckxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgYWRkZWRMaW5lcyA9IFswXSwgbGluZXNMZW5naHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRlZFRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluc2VydGVkVGV4dFtpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBsaW5lc0xlbmdodCsrO1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5naHRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhZGRlZExpbmVzW2xpbmVzTGVuZ2h0XSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWRkZWRMaW5lc1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCwgY3Vyc29yTG9jLmNoYXJJbmRleCwgYWRkZWRMaW5lc1swXSwgY29waWVkU3R5bGUpO1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbMF0gKyAxKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzTGVuZ2h0ICYmIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KFxuICAgICAgICBjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4ICsgYWRkZWRMaW5lc1swXSwgbGluZXNMZW5naHQpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lc0xlbmdodDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV1bMF0gPSBjb3BpZWRTdHlsZVswXTtcbiAgICAgICAgfVxuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbaV0gKyAxKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHVzZSBpIG91dHNpZGUgdGhlIGxvb3AgdG8gZ2V0IGl0IGxpa2UgbGluZXNMZW5ndGhcbiAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4ICsgaSwgMCwgYWRkZWRMaW5lc1tpXSwgY29waWVkU3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgYWNjb3JkaW5nIHRvIHRoZSBuZSBwb3N0aW9uIG9mIGN1cnNvclxuICAgICAqIG1pbWljIHRoZSBrZXkgLSBtb3VzZSBuYXZpZ2F0aW9uIHdoZW4gc2hpZnQgaXMgcHJlc3NlZC5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKSB7XG4gICAgICBpZiAobmV3U2VsZWN0aW9uIDw9IHN0YXJ0KSB7XG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChuZXdTZWxlY3Rpb24gPiBzdGFydCAmJiBuZXdTZWxlY3Rpb24gPCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZXdTZWxlY3Rpb24gaXMgPiBzZWxlY3Rpb24gc3RhcnQgYW5kIGVuZFxuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFNlbGVjdGlvbkluQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0IDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kIDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJkYmNsaWNrXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBmb3IgZG91YmxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIC8vIGZvciB0cmlwbGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IHsgfTtcblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgdG8gc2ltdWxhdGUgdHJpcGxlIGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fX25ld0NsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBuZXdQb2ludGVyID0gb3B0aW9ucy5wb2ludGVyO1xuICAgIGlmICh0aGlzLmlzVHJpcGxlQ2xpY2sobmV3UG9pbnRlcikpIHtcbiAgICAgIHRoaXMuZmlyZSgndHJpcGxlY2xpY2snLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N0b3BFdmVudChvcHRpb25zLmUpO1xuICAgIH1cbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSB0aGlzLl9fbGFzdENsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9IHRoaXMuX19uZXdDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0gbmV3UG9pbnRlcjtcbiAgICB0aGlzLl9fbGFzdElzRWRpdGluZyA9IHRoaXMuaXNFZGl0aW5nO1xuICAgIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICB9LFxuXG4gIGlzVHJpcGxlQ2xpY2s6IGZ1bmN0aW9uKG5ld1BvaW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fX25ld0NsaWNrVGltZSAtIHRoaXMuX19sYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci54ID09PSBuZXdQb2ludGVyLnggJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnkgPT09IG5ld1BvaW50ZXIueTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudCBoYW5kbGVycyByZWxhdGVkIHRvIGN1cnNvciBvciBzZWxlY3Rpb25cbiAgICovXG4gIGluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0TW91c2Vkb3duSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdE1vdXNldXBIYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGRvdWJsZSBhbmQgdHJpcGxlIGNsaWNrIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBpbml0Q2xpY2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRibGNsaWNrJywgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5zZWxlY3RXb3JkKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKCd0cmlwbGVjbGljaycsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2VsZWN0TGluZSh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gX21vdXNlRG93blxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiBmaW5kIHRoZSBjbGljayBwb3NpdGlvbiwgc2V0IHNlbGVjdGlvblN0YXJ0XG4gICAqIGZpbmQgc2VsZWN0aW9uRW5kLCBpbml0aWFsaXplIHRoZSBkcmF3aW5nIG9mIGVpdGhlciBjdXJzb3Igb3Igc2VsZWN0aW9uIGFyZWFcbiAgICovXG4gIF9tb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5lZGl0YWJsZSB8fCAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX19pc01vdXNlZG93biA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZXRDdXJzb3JCeUNsaWNrKG9wdGlvbnMuZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBtb3VzZWRvd246YmVmb3JlXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IHZlcmlmeSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgc2VsZWN0ZWQgd2hlbiBtb3VzaW5nIGRvd25cbiAgICovXG4gIF9tb3VzZURvd25IYW5kbGVyQmVmb3JlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5lZGl0YWJsZSB8fCAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNlZG93blwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZWRvd25IYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyKTtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd246YmVmb3JlJywgdGhpcy5fbW91c2VEb3duSGFuZGxlckJlZm9yZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2V1cFwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZXVwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMubW91c2VVcEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzdGFuZGFyZCBoYW5kZXIgZm9yIG1vdXNlIHVwLCBvdmVycmlkYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZWRpdGFibGUgfHxcbiAgICAgIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvcHRpb25zLnRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQpIHx8XG4gICAgICAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9fbGFzdFNlbGVjdGVkICYmICF0aGlzLl9fY29ybmVyKSB7XG4gICAgICB0aGlzLmVudGVyRWRpdGluZyhvcHRpb25zLmUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJzb3IgbG9jYXRpb24gaW4gYSB0ZXh0IGRlcGVuZGluZyBvbiBwYXNzZWQgcG9pbnRlciAoeC95KSBvYmplY3RcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHNldEN1cnNvckJ5Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKGUpLFxuICAgICAgICBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiBhIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAqL1xuICBnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlT2Zmc2V0ID0gdGhpcy5nZXRMb2NhbFBvaW50ZXIoZSksXG4gICAgICAgIHByZXZXaWR0aCA9IDAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgbGluZUluZGV4ID0gMCxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGxpbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaGVpZ2h0IDw9IG1vdXNlT2Zmc2V0LnkpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxpbmVJbmRleCA9IGk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGNoYXJJbmRleCArPSB0aGlzLl90ZXh0TGluZXNbaSAtIDFdLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgIHdpZHRoID0gbGluZUxlZnRPZmZzZXQgKiB0aGlzLnNjYWxlWDtcbiAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF07XG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgcHJldldpZHRoID0gd2lkdGg7XG4gICAgICAvLyBpIHJlbW92ZWQgc29tZXRoaW5nIGFib3V0IGZsaXBYIGhlcmUsIGNoZWNrLlxuICAgICAgd2lkdGggKz0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS5rZXJuZWRXaWR0aCAqIHRoaXMuc2NhbGVYO1xuICAgICAgaWYgKHdpZHRoIDw9IG1vdXNlT2Zmc2V0LngpIHtcbiAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQobW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGNoYXJJbmRleCwgamxlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0OiBmdW5jdGlvbihtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgaW5kZXgsIGpsZW4pIHtcbiAgICAvLyB3ZSBuZWVkIE1hdGguYWJzIGJlY2F1c2Ugd2hlbiB3aWR0aCBpcyBhZnRlciB0aGUgbGFzdCBjaGFyLCB0aGUgb2Zmc2V0IGlzIGdpdmVuIGFzIDEsIHdoaWxlIGlzIDBcbiAgICB2YXIgZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciA9IG1vdXNlT2Zmc2V0LnggLSBwcmV2V2lkdGgsXG4gICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPSB3aWR0aCAtIG1vdXNlT2Zmc2V0LngsXG4gICAgICAgIG9mZnNldCA9IGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPiBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yIHx8XG4gICAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA8IDAgPyAwIDogMSxcbiAgICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBpbmRleCArIG9mZnNldDtcbiAgICAvLyBpZiBvYmplY3QgaXMgaG9yaXpvbnRhbGx5IGZsaXBwZWQsIG1pcnJvciBjdXJzb3IgbG9jYXRpb24gZnJvbSB0aGUgZW5kXG4gICAgaWYgKHRoaXMuZmxpcFgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gamxlbiAtIG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTZWxlY3Rpb25TdGFydDtcbiAgfVxufSk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBoaWRkZW4gdGV4dGFyZWEgKG5lZWRlZCB0byBicmluZyB1cCBrZXlib2FyZCBpbiBpT1MpXG4gICAqL1xuICBpbml0SGlkZGVuVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnZGF0YS1mYWJyaWMtaGlkZGVudGV4dGFyZWEnLCAnJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3dyYXAnLCAnb2ZmJyk7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyBzdHlsZS50b3AgK1xuICAgICc7IGxlZnQ6ICcgKyBzdHlsZS5sZWZ0ICsgJzsgei1pbmRleDogLTk5OTsgb3BhY2l0eTogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxcHg7IGZvbnQtc2l6ZTogMXB4OycgK1xuICAgICcgbGluZS1oZWlnaHQ6IDFweDsgcGFkZGluZ++9sHRvcDogJyArIHN0eWxlLmZvbnRTaXplICsgJzsnO1xuICAgIGZhYnJpYy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuVGV4dGFyZWEpO1xuXG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2lucHV0JywgdGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb3B5JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjdXQnLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ3Bhc3RlJywgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25zdGFydCcsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnVwZGF0ZScsIHRoaXMub25Db21wb3NpdGlvblVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25lbmQnLCB0aGlzLm9uQ29tcG9zaXRpb25FbmQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd25cbiAgICogTWFwIGEgc3BlY2lhbCBrZXkgdG8gYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UvcHJvdG90eXBlXG4gICAqIElmIHlvdSBuZWVkIGRpZmZlcmVudCBiZWhhdmlvdXIgZm9yIEVTQyBvciBUQUIgb3IgYXJyb3dzLCB5b3UgaGF2ZSB0byBjaGFuZ2VcbiAgICogdGhpcyBtYXAgc2V0dGluZyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgeW91IGJ1aWxkIG9uIHRoZSBmYWJyaWMuSXRleHQgb3JcbiAgICogeW91ciBwcm90b3R5cGUuXG4gICAqIHRoZSBtYXAgY2hhbmdlIHdpbGwgYWZmZWN0IGFsbCBJbnN0YW5jZXMgdW5sZXNzIHlvdSBuZWVkIGZvciBvbmx5IHNvbWUgdGV4dCBJbnN0YW5jZXNcbiAgICogaW4gdGhhdCBjYXNlIHlvdSBoYXZlIHRvIGNsb25lIHRoaXMgb2JqZWN0IGFuZCBhc3NpZ24geW91ciBJbnN0YW5jZS5cbiAgICogdGhpcy5rZXlzTWFwID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMua2V5c01hcCk7XG4gICAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIGluIGZhYnJpYy5JdGV4dC5wcm90b3R5cGUubXlGdW5jdGlvbiBBbmQgd2lsbCByZWNlaXZlIGV2ZW50IGFzIGFyZ3NbMF1cbiAgICovXG4gIGtleXNNYXA6IHtcbiAgICA5OiAgJ2V4aXRFZGl0aW5nJyxcbiAgICAyNzogJ2V4aXRFZGl0aW5nJyxcbiAgICAzMzogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzQ6ICdtb3ZlQ3Vyc29yRG93bicsXG4gICAgMzU6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM2OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM3OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM4OiAnbW92ZUN1cnNvclVwJyxcbiAgICAzOTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgNDA6ICdtb3ZlQ3Vyc29yRG93bicsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5VXAgKyBjdHJsIHx8IGNtZFxuICAgKi9cbiAgY3RybEtleXNNYXBVcDoge1xuICAgIDY3OiAnY29weScsXG4gICAgODg6ICdjdXQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93biArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcERvd246IHtcbiAgICA2NTogJ3NlbGVjdEFsbCdcbiAgfSxcblxuICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAvLyBObyBuZWVkIHRvIHRyaWdnZXIgY2xpY2sgZXZlbnQgaGVyZSwgZm9jdXMgaXMgZW5vdWdoIHRvIGhhdmUgdGhlIGtleWJvYXJkIGFwcGVhciBvbiBBbmRyb2lkXG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSAmJiB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5RG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlIGluIHRoaXMua2V5c01hcCkge1xuICAgICAgdGhpc1t0aGlzLmtleXNNYXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcERvd24pICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLmN0cmxLZXlzTWFwRG93bltlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLmtleUNvZGUgPj0gMzMgJiYgZS5rZXlDb2RlIDw9IDQwKSB7XG4gICAgICAvLyBpZiBpIHByZXNzIGFuIGFycm93IGtleSBqdXN0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXl1cCBldmVudFxuICAgKiBXZSBoYW5kbGUgS2V5VXAgYmVjYXVzZSBpZTExIGFuZCBlZGdlIGhhdmUgZGlmZmljdWx0aWVzIGNvcHkvcGFzdGluZ1xuICAgKiBpZiBhIGNvcHkvY3V0IGV2ZW50IGZpcmVkLCBrZXl1cCBpcyBkaXNtaXNzZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5VXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8IHRoaXMuX2NvcHlEb25lIHx8IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgIHRoaXMuX2NvcHlEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuY3RybEtleXNNYXBVcCkgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBVcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBvbklucHV0IGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbklucHV0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZyb21QYXN0ZSA9IHRoaXMuZnJvbVBhc3RlO1xuICAgIHRoaXMuZnJvbVBhc3RlID0gZmFsc2U7XG4gICAgZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVjaXNpb25zIGFib3V0IHN0eWxlIGNoYW5nZXMuXG4gICAgdmFyIG5leHRUZXh0ID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpLmdyYXBoZW1lVGV4dCxcbiAgICAgICAgY2hhckNvdW50ID0gdGhpcy5fdGV4dC5sZW5ndGgsXG4gICAgICAgIG5leHRDaGFyQ291bnQgPSBuZXh0VGV4dC5sZW5ndGgsXG4gICAgICAgIHJlbW92ZWRUZXh0LCBpbnNlcnRlZFRleHQsXG4gICAgICAgIGNoYXJEaWZmID0gbmV4dENoYXJDb3VudCAtIGNoYXJDb3VudDtcbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0geyB9O1xuICAgICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRhcmVhU2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWVcbiAgICApO1xuICAgIHZhciBiYWNrRGVsZXRlID0gdGhpcy5zZWxlY3Rpb25TdGFydCA+IHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgICAgY2hhckRpZmYgKz0gdGhpcy5zZWxlY3Rpb25FbmQgLSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0Q2hhckNvdW50IDwgY2hhckNvdW50KSB7XG4gICAgICBpZiAoYmFja0RlbGV0ZSkge1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25FbmQgKyBjaGFyRGlmZiwgdGhpcy5zZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvblN0YXJ0IC0gY2hhckRpZmYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRlZFRleHQgPSBuZXh0VGV4dC5zbGljZSh0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQgLSBjaGFyRGlmZiwgdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uRW5kKTtcbiAgICBpZiAocmVtb3ZlZFRleHQgJiYgcmVtb3ZlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21Ubyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIC8vIGRldGVjdCBkaWZmZXJlbmNpZXMgYmV0d2VlbiBmb3J3YXJkRGVsZXRlIGFuZCBiYWNrRGVsZXRlXG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8odGhpcy5zZWxlY3Rpb25FbmQgLSByZW1vdmVkVGV4dC5sZW5ndGgsIHRoaXMuc2VsZWN0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLnNlbGVjdGlvbkVuZCArIHJlbW92ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoZnJvbVBhc3RlICYmIGluc2VydGVkVGV4dC5qb2luKCcnKSA9PT0gZmFicmljLmNvcGllZFRleHQpIHtcbiAgICAgICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGluc2VydGVkVGV4dCwgdGhpcy5zZWxlY3Rpb25TdGFydCwgZmFicmljLmNvcGllZFRleHRTdHlsZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGluc2VydGVkVGV4dCwgdGhpcy5zZWxlY3Rpb25TdGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBzdGFydFxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gZW5kXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gIH0sXG5cbiAgLy8gLyoqXG4gIC8vICAqIENvbXBvc2l0aW9uIHVwZGF0ZVxuICAvLyAgKi9cbiAgb25Db21wb3NpdGlvblVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHRoaXMuY29tcG9zaXRpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQ7XG4gICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyBzZWxlY3RlZCB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIC8vZG8gbm90IGN1dC1jb3B5IGlmIG5vIHNlbGVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5jb3BpZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICBmYWJyaWMuY29waWVkVGV4dFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXModGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRydWUpO1xuICAgIHRoaXMuX2NvcHlEb25lID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzdGVzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHBhc3RlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gQ2xpcGJvYXJkIGRhdGEgb2JqZWN0XG4gICAqL1xuICBfZ2V0Q2xpcGJvYXJkRGF0YTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLmNsaXBib2FyZERhdGEpIHx8IGZhYnJpYy53aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIHdpZHRoIGluIHBpeGVscyBiZWZvcmUgdGhlIGN1cnNvciBvbiB0aGUgc2FtZSBsaW5lXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoQmVmb3JlQ3Vyc29yIHdpZHRoIGJlZm9yZSBjdXJzb3JcbiAgICovXG4gIF9nZXRXaWR0aEJlZm9yZUN1cnNvcjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLCBib3VuZDtcblxuICAgIGlmIChjaGFySW5kZXggPiAwKSB7XG4gICAgICBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICB3aWR0aEJlZm9yZUN1cnNvciArPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aEJlZm9yZUN1cnNvcjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBzdGFydCBvZmZzZXQgb2YgYSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldERvd25DdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICAvLyBpZiBvbiBsYXN0IGxpbmUsIGRvd24gY3Vyc29yIGdvZXMgdG8gZW5kIG9mIGxpbmVcbiAgICBpZiAobGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMSB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNCkge1xuICAgICAgLy8gbW92ZSB0byB0aGUgZW5kIG9mIGEgdGV4dFxuICAgICAgcmV0dXJuIHRoaXMuX3RleHQubGVuZ3RoIC0gc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggKyAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRBZnRlckN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKGNoYXJJbmRleCk7XG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMjtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KTtcbiAgICAvLyByZXR1cm4gYSBuZWdhdGl2ZSBvZmZzZXRcbiAgICByZXR1cm4gLXRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXggLSAxXS5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lIC0gdGV4dEJlZm9yZUN1cnNvci5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvciBhIGdpdmVuIHdpZHRoIGl0IGZvdW5kcyB0aGUgbWF0Y2hpbmcgY2hhcmFjdGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEluZGV4T25MaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgsIHdpZHRoKSB7XG5cbiAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksXG4gICAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSA9IGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBpbmRleE9uTGluZSA9IDAsIGNoYXJXaWR0aCwgZm91bmRNYXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIGNoYXJXaWR0aCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ud2lkdGg7XG4gICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHdpZHRoT2ZDaGFyc09uTGluZSA+IHdpZHRoKSB7XG4gICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUgLSBjaGFyV2lkdGgsXG4gICAgICAgICAgICByaWdodEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUsXG4gICAgICAgICAgICBvZmZzZXRGcm9tTGVmdEVkZ2UgPSBNYXRoLmFicyhsZWZ0RWRnZSAtIHdpZHRoKSxcbiAgICAgICAgICAgIG9mZnNldEZyb21SaWdodEVkZ2UgPSBNYXRoLmFicyhyaWdodEVkZ2UgLSB3aWR0aCk7XG5cbiAgICAgICAgaW5kZXhPbkxpbmUgPSBvZmZzZXRGcm9tUmlnaHRFZGdlIDwgb2Zmc2V0RnJvbUxlZnRFZGdlID8gaiA6IChqIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlYWNoZWQgZW5kXG4gICAgaWYgKCFmb3VuZE1hdGNoKSB7XG4gICAgICBpbmRleE9uTGluZSA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhPbkxpbmU7XG4gIH0sXG5cblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGRvd25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdEb3duJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdVcCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgb3IgZG93biwgZmlyZXMgdGhlIGV2ZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdVcCcgb3IgJ0Rvd24nXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvclVwT3JEb3duOiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICAvLyBnZXRVcEN1cnNvck9mZnNldFxuICAgIC8vIGdldERvd25DdXJzb3JPZmZzZXRcbiAgICB2YXIgYWN0aW9uID0gJ2dldCcgKyBkaXJlY3Rpb24gKyAnQ3Vyc29yT2Zmc2V0JyxcbiAgICAgICAgb2Zmc2V0ID0gdGhpc1thY3Rpb25dKGUsIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyk7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhvdXRTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbkluQm91bmRhcmllcygpO1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3Igd2l0aCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCdcbiAgICAgID8gdGhpcy5zZWxlY3Rpb25TdGFydCArIG9mZnNldFxuICAgICAgOiB0aGlzLnNlbGVjdGlvbkVuZCArIG9mZnNldDtcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCB3aXRob3V0IHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnTGVmdCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBfbW92ZTogZnVuY3Rpb24oZSwgcHJvcCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5ld1ZhbHVlO1xuICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kV29yZEJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM1IHx8ICBlLmtleUNvZGUgPT09IDM2ICkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kTGluZUJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1twcm9wXSArPSBkaXJlY3Rpb24gPT09ICdMZWZ0JyA/IC0xIDogMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld1ZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpc1twcm9wXSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlTGVmdDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdMZWZ0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZVJpZ2h0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ1JpZ2h0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG5cbiAgICAvLyBvbmx5IG1vdmUgY3Vyc29yIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0aW9uLFxuICAgIC8vIG90aGVyd2lzZSB3ZSBkaXNjYXJkIGl0LCBhbmQgbGVhdmUgY3Vyc29yIG9uIHNhbWUgcGxhY2VcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPT09IHRoaXMuc2VsZWN0aW9uU3RhcnQgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gMCkge1xuICAgICAgY2hhbmdlID0gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG5cbiAgICB9XG4gICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0IHdoaWxlIGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gMCl7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMuX3RleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnUmlnaHQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IG9yIExlZnQsIGZpcmVzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ0xlZnQnLCAnUmlnaHQnXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvckxlZnRPclJpZ2h0OiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICB2YXIgYWN0aW9uTmFtZSA9ICdtb3ZlQ3Vyc29yJyArIGRpcmVjdGlvbiArICdXaXRoJztcbiAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgYWN0aW9uTmFtZSArPSAnU2hpZnQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjdGlvbk5hbWUgKz0gJ291dFNoaWZ0JztcbiAgICB9XG4gICAgaWYgKHRoaXNbYWN0aW9uTmFtZV0oZSkpIHtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdoaWxlIGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0JyAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgIT09IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG5cbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIGNoYW5nZWQgPSB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBjaGFyYWN0ZXJzIGZyb20gc3RhcnQvZW5kXG4gICAqIHN0YXJ0L2VuZCBhciBwZXIgZ3JhcGhlbWUgcG9zaXRpb24gaW4gX3RleHQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICByZW1vdmVDaGFyczogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3RleHQuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKCcnKTtcbiAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGluc2VydCBjaGFyYWN0ZXJzIGF0IHN0YXJ0IHBvc2l0aW9uLCBiZWZvcmUgc3RhcnQgcG9zaXRpb24uXG4gICAqIHN0YXJ0ICBlcXVhbCAxIGl0IG1lYW5zIHRoZSB0ZXh0IGdldCBpbnNlcnRlZCBiZXR3ZWVuIGFjdHVhbCBncmFwaGVtZSAwIGFuZCAxXG4gICAqIGlmIHN0eWxlIGFycmF5IGlzIHByb3ZpZGVkLCBpdCBtdXN0IGJlIGFzIHRoZSBzYW1lIGxlbmd0aCBvZiB0ZXh0IGluIGdyYXBoZW1lc1xuICAgKiBpZiBlbmQgaXMgcHJvdmlkZWQgYW5kIGlzIGJpZ2dlciB0aGFuIHN0YXJ0LCBvbGQgdGV4dCBpcyByZXBsYWNlZC5cbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGV4dCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtBcnJheX0gc3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBkZWZhdWx0IHRvIHN0YXJ0ICsgMVxuICAgKi9cbiAgaW5zZXJ0Q2hhcnM6IGZ1bmN0aW9uKHRleHQsIHN0eWxlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICB2YXIgZ3JhcGhlbWVzID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQodGV4dCk7XG4gICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGdyYXBoZW1lcywgc3RhcnQsIHN0eWxlKTtcbiAgICB0aGlzLl90ZXh0ID0gW10uY29uY2F0KHRoaXMuX3RleHQuc2xpY2UoMCwgc3RhcnQpLCBncmFwaGVtZXMsIHRoaXMuX3RleHQuc2xpY2UoZW5kKSk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKCcnKTtcbiAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH0sXG5cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIG11bHRpcGxlU3BhY2VzUmVnZXggPSAvICArL2c7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCgpLFxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cygpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgdGhpcy5fd3JhcFNWR1RleHRBbmRCZyhtYXJrdXAsIHRleHRBbmRCZyk7XG5cbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMZWZ0VG9wT2Zmc2V0czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0TGVmdDogLXRoaXMud2lkdGggLyAyLFxuICAgICAgICB0ZXh0VG9wOiAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsaW5lVG9wOiB0aGlzLmdldEhlaWdodE9mTGluZSgwKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd3JhcFNWR1RleHRBbmRCZzogZnVuY3Rpb24obWFya3VwLCB0ZXh0QW5kQmcpIHtcbiAgICAgIHZhciBub1NoYWRvdyA9IHRydWUsIGZpbHRlciA9IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgc3R5bGUgPSBmaWx0ZXIgPT09ICcnID8gJycgOiAnIHN0eWxlPVwiJyArIGZpbHRlciArICdcIicsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHRoaXMpO1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICdcXHQ8ZyAnLCB0aGlzLmdldFN2Z0lkKCksICd0cmFuc2Zvcm09XCInLCB0aGlzLmdldFN2Z1RyYW5zZm9ybSgpLCB0aGlzLmdldFN2Z1RyYW5zZm9ybU1hdHJpeCgpLCAnXCInLFxuICAgICAgICBzdHlsZSwgJz5cXG4nLFxuICAgICAgICB0ZXh0QW5kQmcudGV4dEJnUmVjdHMuam9pbignJyksXG4gICAgICAgICdcXHRcXHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsXG4gICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyB0aGlzLmZvbnRTdHlsZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAodGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksICcgPicsXG4gICAgICAgIHRleHRBbmRCZy50ZXh0U3BhbnMuam9pbignJyksXG4gICAgICAgICc8L3RleHQ+XFxuJyxcbiAgICAgICAgJ1xcdDwvZz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0VG9wT2Zmc2V0IFRleHQgdG9wIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0TGVmdE9mZnNldCBUZXh0IGxlZnQgb2Zmc2V0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRUb3BPZmZzZXQsIHRleHRMZWZ0T2Zmc2V0KSB7XG4gICAgICB2YXIgdGV4dFNwYW5zID0gW10sXG4gICAgICAgICAgdGV4dEJnUmVjdHMgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSB0ZXh0VG9wT2Zmc2V0LCBsaW5lT2Zmc2V0O1xuICAgICAgLy8gYm91bmRpbmctYm94IGJhY2tncm91bmRcbiAgICAgIHRoaXMuX3NldFNWR0JnKHRleHRCZ1JlY3RzKTtcblxuICAgICAgLy8gdGV4dCBhbmQgdGV4dC1iYWNrZ3JvdW5kXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEJhY2tncm91bmRDb2xvciB8fCB0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJywgaSkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUJnKHRleHRCZ1JlY3RzLCBpLCB0ZXh0TGVmdE9mZnNldCArIGxpbmVPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVUZXh0KHRleHRTcGFucywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRTcGFuczogdGV4dFNwYW5zLFxuICAgICAgICB0ZXh0QmdSZWN0czogdGV4dEJnUmVjdHNcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRleHRDaGFyU3BhbjogZnVuY3Rpb24oX2NoYXIsIHN0eWxlRGVjbCwgbGVmdCwgdG9wKSB7XG4gICAgICB2YXIgc2hvdWxkVXNlV2hpdGVzcGFjZSA9IF9jaGFyICE9PSBfY2hhci50cmltKCkgfHwgX2NoYXIubWF0Y2gobXVsdGlwbGVTcGFjZXNSZWdleCksXG4gICAgICAgICAgc3R5bGVQcm9wcyA9IHRoaXMuZ2V0U3ZnU3BhblN0eWxlcyhzdHlsZURlY2wsIHNob3VsZFVzZVdoaXRlc3BhY2UpLFxuICAgICAgICAgIGZpbGxTdHlsZXMgPSBzdHlsZVByb3BzID8gJ3N0eWxlPVwiJyArIHN0eWxlUHJvcHMgKyAnXCInIDogJycsXG4gICAgICAgICAgZHkgPSBzdHlsZURlY2wuZGVsdGFZLCBkeVNwYW4gPSAnJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgaWYgKGR5KSB7XG4gICAgICAgIGR5U3BhbiA9ICcgZHk9XCInICsgdG9GaXhlZChkeSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8dHNwYW4geD1cIicsIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJywgZHlTcGFuLFxuICAgICAgICBmaWxsU3R5bGVzLCAnPicsXG4gICAgICAgIGZhYnJpYy51dGlsLnN0cmluZy5lc2NhcGVYbWwoX2NoYXIpLFxuICAgICAgICAnPC90c3Bhbj4nXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbih0ZXh0U3BhbnMsIGxpbmVJbmRleCwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCwgc3R5bGUsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICB0aW1lVG9SZW5kZXI7XG5cbiAgICAgIHRleHRUb3BPZmZzZXQgKz0gbGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nO1xuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaV07XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICBpZiAoYm94V2lkdGggPT09IDApIHtcbiAgICAgICAgICB0ZXh0TGVmdE9mZnNldCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRoaXMuX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZyhhY3R1YWxTdHlsZSwgbmV4dFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSkgfHwgeyB9O1xuICAgICAgICAgIHRleHRTcGFucy5wdXNoKHRoaXMuX2NyZWF0ZVRleHRDaGFyU3BhbihjaGFyc1RvUmVuZGVyLCBzdHlsZSwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpKTtcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9wdXNoVGV4dEJnUmVjdDogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGNvbG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKGNvbG9yKSxcbiAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgdG9GaXhlZChsZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKHRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgIHRvRml4ZWQod2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgdG9GaXhlZChoZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGksIGxlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBib3hTdGFydCA9IDAsXG4gICAgICAgICAgY2hhckJveCwgY3VycmVudENvbG9yLFxuICAgICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgIGxhc3RDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgbGFzdENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgbGFzdENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgY3VycmVudENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgIHRleHRUb3BPZmZzZXQsIGJveFdpZHRoLCBoZWlnaHRPZkxpbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZG9iZSBJbGx1c3RyYXRvciAoYXQgbGVhc3QgQ1M1KSBpcyB1bmFibGUgdG8gcmVuZGVyIHJnYmEoKS1iYXNlZCBmaWxsIHZhbHVlc1xuICAgICAqIHdlIHdvcmsgYXJvdW5kIGl0IGJ5IFwibW92aW5nXCIgYWxwaGEgY2hhbm5lbCBpbnRvIG9wYWNpdHkgYXR0cmlidXRlIGFuZCBzZXR0aW5nIGZpbGwncyBhbHBoYSB0byAxXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgX2dldEZpbGxBdHRyaWJ1dGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZpbGxDb2xvciA9ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IG5ldyBmYWJyaWMuQ29sb3IodmFsdWUpIDogJyc7XG4gICAgICBpZiAoIWZpbGxDb2xvciB8fCAhZmlsbENvbG9yLmdldFNvdXJjZSgpIHx8IGZpbGxDb2xvci5nZXRBbHBoYSgpID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnZmlsbD1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ29wYWNpdHk9XCInICsgZmlsbENvbG9yLmdldEFscGhhKCkgKyAnXCIgZmlsbD1cIicgKyBmaWxsQ29sb3Iuc2V0QWxwaGEoMSkudG9SZ2IoKSArICdcIic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xpbmVUb3BPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBsYXN0SGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUluZGV4OyBqKyspIHtcbiAgICAgICAgbGluZVRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIH1cbiAgICAgIGxhc3RIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVUb3A6IGxpbmVUb3BPZmZzZXQsXG4gICAgICAgIG9mZnNldDogKHRoaXMuX2ZvbnRTaXplTXVsdCAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogbGFzdEhlaWdodCAvICh0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBTaGFkb3cgYSBib29sZWFuIHRvIHNraXAgc2hhZG93IGZpbHRlciBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbihza2lwU2hhZG93KSB7XG4gICAgICB2YXIgc3ZnU3R5bGUgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5nZXRTdmdTdHlsZXMuY2FsbCh0aGlzLCBza2lwU2hhZG93KTtcbiAgICAgIHJldHVybiBzdmdTdHlsZSArICcgd2hpdGUtc3BhY2U6IHByZTsnO1xuICAgIH0sXG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSk7XG5cbiAgLyoqXG4gICAqIFRleHRib3ggY2xhc3MsIGJhc2VkIG9uIElUZXh0LCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzaXplIHRoZSB0ZXh0IHJlY3RhbmdsZVxuICAgKiBhbmQgd3JhcHMgbGluZXMgYXV0b21hdGljYWxseS4gVGV4dGJveGVzIGhhdmUgdGhlaXIgWSBzY2FsaW5nIGxvY2tlZCwgdGhlXG4gICAqIHVzZXIgY2FuIG9ubHkgY2hhbmdlIHdpZHRoLiBIZWlnaHQgaXMgYWRqdXN0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGVcbiAgICogd3JhcHBpbmcgb2YgbGluZXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dGJveFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSVRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0Ym94I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5JVGV4dCwgZmFicmljLk9ic2VydmFibGUsIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndGV4dGJveCcsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHdpZHRoIG9mIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pbldpZHRoOiAyMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gY2FsY3VsYXRlZCB3aWR0aCBvZiBhIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBmaXhlZCB0byAyIHNvIHRoYXQgYW4gZW1wdHkgdGV4dGJveCBjYW5ub3QgZ28gdG8gMFxuICAgICAqIGFuZCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgdGV4dC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGR5bmFtaWNNaW5XaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBhcnJheSBvZiB0ZXh0IHdyYXBwaW5nLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgX19jYWNoZWRMaW5lczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ0ZsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICogVGV4dGJveCBuZWVkcyB0aGlzIG9uIGZhbHNlXG4gICAgICovXG4gICAgbm9TY2FsZUNhY2hlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuY29uY2F0KCd3aWR0aCcpLFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICAvLyBjbGVhciBkeW5hbWljTWluV2lkdGggYXMgaXQgd2lsbCBiZSBkaWZmZXJlbnQgYWZ0ZXIgd2UgcmUtd3JhcCBsaW5lXG4gICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IDA7XG4gICAgICAvLyB3cmFwIGxpbmVzXG4gICAgICB0aGlzLl9zdHlsZU1hcCA9IHRoaXMuX2dlbmVyYXRlU3R5bGVNYXAodGhpcy5fc3BsaXRUZXh0KCkpO1xuICAgICAgLy8gaWYgYWZ0ZXIgd3JhcHBpbmcsIHRoZSB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gZHluYW1pY01pbldpZHRoLCBjaGFuZ2UgdGhlIHdpZHRoIGFuZCByZS13cmFwXG4gICAgICBpZiAodGhpcy5keW5hbWljTWluV2lkdGggPiB0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMuX3NldCgnd2lkdGgnLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGNhY2hlIGFuZCByZS1jYWxjdWxhdGUgaGVpZ2h0XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKHRleHRJbmZvKSB7XG4gICAgICB2YXIgcmVhbExpbmVDb3VudCAgICAgPSAwLFxuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMCxcbiAgICAgICAgICBjaGFyQ291bnQgICAgICAgICA9IDAsXG4gICAgICAgICAgbWFwICAgICAgICAgICAgICAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwICYmICF0aGlzLmlzV3JhcHBpbmcpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5UZXh0LnByb3RvdHlwZS5zdHlsZUhhcy5jYWxsKHRoaXMsIHByb3BlcnR5LCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgbmV4dExpbmVJbmRleCA9IGxpbmVJbmRleCArIDEsIG5leHRPZmZzZXQsIG9iaiwgc2hvdWxkTGltaXQgPSBmYWxzZTtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgdmFyIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgsIHN0eWxlKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbWFwLmxpbmVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggICAgICAgID0gMCxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzICAgID0gW10sXG4gICAgICAgICAgbGluZSAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgIC8vIHNwYWNlcyBpbiBkaWZmZXJlbnQgbGFuZ3VnZXM/XG4gICAgICAgICAgd29yZHMgICAgICAgICAgICA9IF9saW5lLnNwbGl0KHRoaXMuX3JlU3BhY2VBbmRUYWIpLFxuICAgICAgICAgIHdvcmQgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgICAgICAgICAgID0gMCxcbiAgICAgICAgICBpbmZpeCAgICAgICAgICAgID0gJyAnLFxuICAgICAgICAgIHdvcmRXaWR0aCAgICAgICAgPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggICAgICAgPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcblxuICAgICAgZGVzaXJlZFdpZHRoIC09IHJlc2VydmVkU3BhY2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGkgd291bGQgYXZvaWQgcmVzcGxpdHRpbmcgdGhlIGdyYXBoZW1lc1xuICAgICAgICB3b3JkID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQod29yZHNbaV0pO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlV29yZCh3b3JkLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB3b3JkLmxlbmd0aDtcblxuICAgICAgICBsaW5lV2lkdGggKz0gaW5maXhXaWR0aCArIHdvcmRXaWR0aCAtIGFkZGl0aW9uYWxTcGFjZTtcblxuICAgICAgICBpZiAobGluZVdpZHRoID49IGRlc2lyZWRXaWR0aCAmJiAhbGluZUp1c3RTdGFydGVkKSB7XG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBsaW5lLnB1c2goaW5maXgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBsaW5lLmNvbmNhdCh3b3JkKTtcblxuICAgICAgICBpbmZpeFdpZHRoID0gdGhpcy5fbWVhc3VyZVdvcmQoW2luZml4XSwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGdyYXBoZW1lTGluZXMucHVzaChsaW5lKTtcblxuICAgICAgaWYgKGxhcmdlc3RXb3JkV2lkdGggKyByZXNlcnZlZFNwYWNlID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlICsgcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyBsaW5lcyBvZiB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgVGV4dGJveC4gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzXG4gICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbmV3VGV4dCA9IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fc3BsaXRUZXh0SW50b0xpbmVzLmNhbGwodGhpcywgdGV4dCksXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IHRoaXMuX3dyYXBUZXh0KG5ld1RleHQubGluZXMsIHRoaXMud2lkdGgpLFxuICAgICAgICAgIGxpbmVzID0gbmV3IEFycmF5KGdyYXBoZW1lTGluZXMubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gZ3JhcGhlbWVMaW5lc1tpXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQubGluZXMgPSBsaW5lcztcbiAgICAgIG5ld1RleHQuZ3JhcGhlbWVMaW5lcyA9IGdyYXBoZW1lTGluZXM7XG4gICAgICByZXR1cm4gbmV3VGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ21pbldpZHRoJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHRib3ggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHRib3guZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dGJveCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBfc2V0T2JqZWN0U2NhbGUgYW5kIGFkZCBUZXh0Ym94IHNwZWNpZmljIHJlc2l6aW5nIGJlaGF2aW9yLiBSZXNpemluZ1xuICAgKiBhIFRleHRib3ggZG9lc24ndCBzY2FsZSB0ZXh0LCBpdCBvbmx5IGNoYW5nZXMgd2lkdGggYW5kIG1ha2VzIHRleHQgd3JhcCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgdmFyIHNldE9iamVjdFNjYWxlT3ZlcnJpZGRlbiA9IGZhYnJpYy5DYW52YXMucHJvdG90eXBlLl9zZXRPYmplY3RTY2FsZTtcblxuICBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5fc2V0T2JqZWN0U2NhbGUgPSBmdW5jdGlvbihsb2NhbE1vdXNlLCB0cmFuc2Zvcm0sXG4gICAgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pIHtcblxuICAgIHZhciB0ID0gdHJhbnNmb3JtLnRhcmdldDtcbiAgICBpZiAoYnkgPT09ICd4JyAmJiB0IGluc3RhbmNlb2YgZmFicmljLlRleHRib3gpIHtcbiAgICAgIHZhciB0dyA9IHQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgICB2YXIgdyA9IHQud2lkdGggKiAobG9jYWxNb3VzZS54IC8gdHcpO1xuICAgICAgaWYgKHcgPj0gdC5nZXRNaW5XaWR0aCgpKSB7XG4gICAgICAgIHQuc2V0KCd3aWR0aCcsIHcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gc2V0T2JqZWN0U2NhbGVPdmVycmlkZGVuLmNhbGwoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIGxvY2FsTW91c2UsIHRyYW5zZm9ybSxcbiAgICAgICAgbG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1ksIGJ5LCBsb2NrU2NhbGluZ0ZsaXAsIF9kaW0pO1xuICAgIH1cbiAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fc3R5bGVNYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gIH0pO1xufSkoKTtcblxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBTRUxFQ1RPUjogMCxcbiAgQ0lSQ0xFOiAxLFxuICBURVhUOiAyLFxuICBQRU46IDMsXG4gIE1BUktQRU46IDQsXG4gIEVSQVNFUjogNVxufSIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTbGljZTtcbiIsInZhciBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAqL1xuZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0U2xpY2U7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVRvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlVG9BcnJheTtcbiIsInZhciBhc2NpaVRvQXJyYXkgPSByZXF1aXJlKCcuL19hc2NpaVRvQXJyYXknKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVUb0FycmF5ID0gcmVxdWlyZSgnLi9fdW5pY29kZVRvQXJyYXknKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9BcnJheTtcbiIsInZhciBjYXN0U2xpY2UgPSByZXF1aXJlKCcuL19jYXN0U2xpY2UnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHN0cmluZ1RvQXJyYXkgPSByZXF1aXJlKCcuL19zdHJpbmdUb0FycmF5JyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYXNlRmlyc3Q7XG4iLCJ2YXIgY3JlYXRlQ2FzZUZpcnN0ID0gcmVxdWlyZSgnLi9fY3JlYXRlQ2FzZUZpcnN0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVwcGVyRmlyc3Q7XG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyksXG4gICAgdXBwZXJGaXJzdCA9IHJlcXVpcmUoJy4vdXBwZXJGaXJzdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICogdG8gbG93ZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICovXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhcGl0YWxpemU7XG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG52YXIgaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICpcbiAqIF8udW5pcXVlSWQoKTtcbiAqIC8vID0+ICcxMDUnXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVJZDtcbiIsImltcG9ydCB1bmlxdWVJZCBmcm9tICdsb2Rhc2gvdW5pcXVlSWQnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5cbmNvbnN0IHBhdGhFdmVudHMgPSBbe1xuICBvcmlnaW46ICdtb3ZpbmcnLFxuICBpbnN0YW5jZTogJ29uTW92aW5nSGFuZGxlJ1xufSwge1xuICBvcmlnaW46ICdzY2FsaW5nJyxcbiAgaW5zdGFuY2U6ICdvblNjYWxpbmdIYW5kbGUnXG59LCB7XG4gIG9yaWdpbjogJ3JvdGF0aW5nJyxcbiAgaW5zdGFuY2U6ICdvblJvdGF0aW5nSGFuZGxlJ1xufV1cblxuY2xhc3MgVG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjYW52YXMsIHN0eWxlKSB7XG4gICAgdGhpcy5jeHQgPSBjYW52YXM7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLmhhc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgfVxuXG4gIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgIHRoaXMudG9vbEFjdGl2ZSA9IHNlbGVjdGVkO1xuICB9XG5cbiAgYmluZEV2ZW50KCkge1xuICAgIC8vIHRoaXMuY3h0Lm9uKCd0ZXh0OmNoYW5nZWQnLCAoe1xuICAgIC8vICAgdGFyZ2V0XG4gICAgLy8gfSkgPT4ge1xuICAgIC8vICAgY29uc29sZS5sb2codGFyZ2V0LnRleHQpO1xuICAgIC8vIH0pO1xuICB9XG5cbiAgb25Nb3VzZWRvd25IYW5kbGUoZXZlbnQpIHtcbiAgICB0aGlzLmlzTW91c2VEb3duID0gdHJ1ZTtcbiAgfVxuXG4gIG9uTW91c2V1cEhhbmRsZShldmVudCkge1xuICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgfVxuXG4gIG9uTW91c2Vtb3ZlSGFuZGxlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgbW92ZW1lbnRYLFxuICAgICAgbW92ZW1lbnRZXG4gICAgfSA9IGV2ZW50WzBdLmU7XG4gICAgaWYgKG1vdmVtZW50WCA8IDAgJiYgbW92ZW1lbnRZIDwgMCkge1xuICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnbGVmdFRvcCc7XG4gICAgfSBlbHNlIGlmIChtb3ZlbWVudFggPCAwICYmIG1vdmVtZW50WSA+IDApIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2xlZnRCb3R0b20nO1xuICAgIH0gZWxzZSBpZiAobW92ZW1lbnRYID4gMCAmJiBtb3ZlbWVudFkgPCAwKSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9ICdyaWdodFRvcCc7XG4gICAgfSBlbHNlIGlmIChtb3ZlbWVudFggPiAwICYmIG1vdmVtZW50WSA+IDApIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ3JpZ2h0Qm90dG9tJztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgIHRoaXMub25Nb3VzZURyYWdIYW5kbGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEcmFnSGFuZGxlKGV2ZW50KSB7XG5cbiAgfVxuXG4gIG9uTW92aW5nSGFuZGxlKGUpIHt9XG4gIG9uUm90YXRpbmdIYW5kbGUoZSkge31cbiAgb25TY2FsaW5nSGFuZGxlKGUpIHt9XG5cbiAgcmVuZGVyUGF0aChwYXRoLCBpZ25vcmVSZW5kZXIgPSBmYWxzZSkge1xuICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgIHBhdGguaWQgPSB1bmlxdWVJZCgnd2JQYXRoJyk7XG4gICAgcGF0aC50b29sVHlwZSA9IHRoaXMudG9vbFR5cGU7XG4gICAgIWlnbm9yZVJlbmRlciAmJiB0aGlzLmN4dC5hZGQocGF0aCk7XG4gICAgdGhpcy5iaW5kRXZlbnQocGF0aCk7XG4gIH1cblxuICBiaW5kRXZlbnQocGF0aCkge1xuICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgIHBhdGhFdmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBwYXRoLm9uKGV2ZW50Lm9yaWdpbiwgdGhpc1tldmVudC5pbnN0YW5jZV0pO1xuICAgIH0pO1xuICAgIHBhdGgub24oJ3NlbGVjdGVkJywgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2cocGF0aClcbiAgICAgIHBhdGguaGFzQ29udHJvbHMgPSB0cnVlO1xuICAgIH0pO1xuICAgIHBhdGgub24oJ2Rlc2VsZWN0ZWQnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5oYXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgcGF0aC5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUb29sQmFzZTsiLCJpbXBvcnQgVG9vbEJhc2UgZnJvbSAnLi9Ub29sQmFzZSc7XG5pbXBvcnQge1xuICBmYWJyaWNcbn0gZnJvbSAnZmFicmljJztcbmltcG9ydCB0b29sVHlwZXMgZnJvbSAnLi4vY29uc3RhbnRzL3Rvb2xzJztcblxuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgVG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciguLi5hcmcpIHtcbiAgICBzdXBlciguLi5hcmcpO1xuICAgIHRoaXMudG9vbFR5cGUgPSB0b29sVHlwZXMuQ0lSQ0xFO1xuICB9XG5cbiAgb25Nb3VzZWRvd25IYW5kbGUoZXZlbnQpIHtcbiAgICBzdXBlci5vbk1vdXNlZG93bkhhbmRsZShldmVudCk7XG4gICAgdGhpcy5kb3duUG9pbnRlciA9IGV2ZW50WzBdLnBvaW50ZXI7XG4gIH1cblxuICBvbk1vdXNlRHJhZ0hhbmRsZShldmVudCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3RlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kb3duUG9pbnRlcjtcbiAgICAgIGlmICh0aGlzLmNpcmNsZSkge1xuICAgICAgICB0aGlzLmN4dC5yZW1vdmUodGhpcy5jaXJjbGUpO1xuICAgICAgICB0aGlzLmNpcmNsZSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5hYnMoZXZlbnRbMF0ucG9pbnRlci55IC0gdGhpcy5kb3duUG9pbnRlci55KTtcbiAgICAgIGxldCBiZWdpblBvaW50ZXIgPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gKCdsZWZ0VG9wJyB8fCAnbGVmdEJvdHRvbScpKSB7XG4gICAgICAgIGJlZ2luUG9pbnRlciA9IHtcbiAgICAgICAgICBsZWZ0OiBldmVudFswXS5wb2ludGVyLngsXG4gICAgICAgICAgdG9wOiBldmVudFswXS5wb2ludGVyLnksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0eWxlLCB7XG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgbGVmdDogYmVnaW5Qb2ludGVyLmxlZnQsXG4gICAgICAgIHRvcDogYmVnaW5Qb2ludGVyLnRvcCxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKG9wdGlvbnMpO1xuICAgICAgdGhpcy5yZW5kZXJQYXRoKHRoaXMuY2lyY2xlKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdXNldXBIYW5kbGUoZSkge1xuICAgIHN1cGVyLm9uTW91c2V1cEhhbmRsZShlKTtcbiAgICBpZiAoIXRoaXMuY2lyY2xlKSByZXR1cm47XG4gICAgdGhpcy5yZW5kZXJQYXRoKHRoaXMuY2lyY2xlKTtcbiAgICB0aGlzLmNpcmNsZSA9IG51bGw7XG4gICAgdGhpcy5kb3duUG9pbnRlciA9IG51bGw7XG4gIH1cblxuICBnZXRMaW5lTGVuZ3RoKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHN0YXJ0LnggLSBlbmQueCwgMikgKyBNYXRoLnBvdyhzdGFydC55IC0gZW5kLnksIDIpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGU7IiwiaW1wb3J0IFRvb2xCYXNlIGZyb20gJy4vVG9vbEJhc2UnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4uL2NvbnN0YW50cy90b29scyc7XG5cbmNsYXNzIFRleHQgZXh0ZW5kcyBUb29sQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLmJpbmRMaW50ZW5lcigpO1xuICAgIHRoaXMudG9vbFR5cGUgPSB0b29sVHlwZXMuVEVYVDtcbiAgfVxuXG4gIG9uTW91c2Vkb3duSGFuZGxlKGV2ZW50KSB7XG4gICAgc3VwZXIub25Nb3VzZWRvd25IYW5kbGUoZXZlbnQpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy50ZXh0ID0gbmV3IGZhYnJpYy5UZXh0Ym94KCcgJywge1xuICAgICAgICBsZWZ0OiBldmVudFswXS5wb2ludGVyLngsXG4gICAgICAgIHRvcDogZXZlbnRbMF0ucG9pbnRlci55LFxuICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICBsaW5lSGVpZ2h0OiAwLjksXG4gICAgICAgIGhlaWdodDogNDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGJpbmRMaW50ZW5lcigpIHtcbiAgICB0aGlzLmN4dC5vbigndGV4dDpjaGFuZ2VkJywgKHtcbiAgICAgIHRhcmdldFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNldXBIYW5kbGUoZXZlbnQpIHtcbiAgICBzdXBlci5vbk1vdXNldXBIYW5kbGUoZXZlbnQpO1xuICAgIHRoaXMucmVuZGVyUGF0aCh0aGlzLnRleHQpO1xuICAgIHRoaXMudGV4dC5lbnRlckVkaXRpbmcoZXZlbnQpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDsiLCJpbXBvcnQgVG9vbEJhc2UgZnJvbSAnLi9Ub29sQmFzZSc7XG5pbXBvcnQge1xuICBmYWJyaWNcbn0gZnJvbSAnZmFicmljJztcbmltcG9ydCB0b29sVHlwZXMgZnJvbSAnLi4vY29uc3RhbnRzL3Rvb2xzJztcblxuY2xhc3MgUGVuIGV4dGVuZHMgVG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciguLi5hcmcpIHtcbiAgICBzdXBlciguLi5hcmcpO1xuICAgIHRoaXMudG9vbFR5cGUgPSB0b29sVHlwZXMuUEVOO1xuICAgIHRoaXMuY3h0Lm9uKCdwYXRoOmNyZWF0ZWQnLCAob2JqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy50b29sQWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChvYmplY3QucGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICB0aGlzLnRvb2xBY3RpdmUgPSBzZWxlY3RlZDtcbiAgICB0aGlzLmN4dC5pc0RyYXdpbmdNb2RlID0gc2VsZWN0ZWQ7XG4gIH1cblxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLmN4dC5mcmVlRHJhd2luZ0JydXNoLmNvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgdGhpcy5jeHQuZnJlZURyYXdpbmdCcnVzaC53aWR0aCA9IHN0eWxlLndpZHRoO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBlbjsiLCJpbXBvcnQgVG9vbEJhc2UgZnJvbSAnLi9Ub29sQmFzZSc7XG5pbXBvcnQge1xuICBmYWJyaWNcbn0gZnJvbSAnZmFicmljJztcbmltcG9ydCB0b29sVHlwZXMgZnJvbSAnLi4vY29uc3RhbnRzL3Rvb2xzJztcblxuY2xhc3MgTWFya1BlbiBleHRlbmRzIFRvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLnRvb2xUeXBlID0gdG9vbFR5cGVzLk1BUktQRU47XG4gICAgdGhpcy5jeHQub24oJ3BhdGg6Y3JlYXRlZCcsIChvYmplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnRvb2xBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQYXRoKG9iamVjdC5wYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgIHRoaXMudG9vbEFjdGl2ZSA9IHNlbGVjdGVkO1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5jeHQuaXNEcmF3aW5nTW9kZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5jeHQuZnJlZURyYXdpbmdCcnVzaC5jb2xvciA9IHN0eWxlLmNvbG9yO1xuICAgIHRoaXMuY3h0LmZyZWVEcmF3aW5nQnJ1c2gud2lkdGggPSBzdHlsZS53aWR0aDtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtQZW47IiwiaW1wb3J0IFRvb2xCYXNlIGZyb20gJy4vVG9vbEJhc2UnO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4uL2NvbnN0YW50cy90b29scyc7XG5cbmNsYXNzIEVyYXNlciBleHRlbmRzIFRvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJnKSB7XG4gICAgc3VwZXIoLi4uYXJnKTtcbiAgICB0aGlzLnRvb2xUeXBlID0gdG9vbFR5cGVzLkVSQVNFUjtcbiAgICB0aGlzLmN4dC5vbigncGF0aDpjcmVhdGVkJywgKG9iamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMudG9vbEFjdGl2ZSkge1xuICAgICAgICBvYmplY3QucGF0aC5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChvYmplY3QucGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICB0aGlzLnRvb2xBY3RpdmUgPSBzZWxlY3RlZDtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuY3h0LmZyZWVEcmF3aW5nQnJ1c2guY29sb3IgPSAnI2ZmZic7XG4gICAgICB0aGlzLmN4dC5pc0RyYXdpbmdNb2RlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLmN4dC5mcmVlRHJhd2luZ0JydXNoLndpZHRoID0gc3R5bGUud2lkdGg7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFcmFzZXI7IiwiaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnbG9kYXNoL2NhcGl0YWxpemUnO1xuXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4vQ2lyY2xlJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dCc7XG5pbXBvcnQgUGVuIGZyb20gJy4vUGVuJztcbmltcG9ydCBNYXJrUGVuIGZyb20gJy4vTWFya1Blbic7XG5pbXBvcnQgRXJhc2VyIGZyb20gJy4vRXJhc2VyJztcblxuY2xhc3MgVG9vbHMge1xuICBjb25zdHJ1Y3RvcihjYW52YXMsIHN0eWxlKSB7XG4gICAgdGhpcy5jeHQgPSBjYW52YXM7XG4gICAgdGhpcy5zdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgfSwgc3R5bGUpO1xuICAgIHRoaXMuaW5pdFRvb2xzKCk7XG4gIH1cblxuICBkcmF3SlNPTiA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBjYXBpdGFsaXplKGRhdGEudHlwZSk7XG4gICAgZmFicmljW2NvbnN0cnVjdG9yXS5mcm9tT2JqZWN0KGRhdGEsIChwYXRoKSA9PiB7XG4gICAgICB0aGlzLmN4dC5hZGQocGF0aCk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0VG9vbHMoKSB7XG4gICAgdGhpcy50b29sTGlzdCA9IFtcbiAgICAgIG5ldyBDaXJjbGUodGhpcy5jeHQsIHRoaXMuc3R5bGUpLFxuICAgICAgbmV3IFRleHQodGhpcy5jeHQsIHRoaXMuc3R5bGUpLFxuICAgICAgbmV3IFBlbih0aGlzLmN4dCwgdGhpcy5zdHlsZSksXG4gICAgICBuZXcgTWFya1Blbih0aGlzLmN4dCwgdGhpcy5zdHlsZSksXG4gICAgICBuZXcgRXJhc2VyKHRoaXMuY3h0LCB0aGlzLnN0eWxlKVxuICAgIF07XG4gIH1cblxuICBnZXQgdG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbExpc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbHM7IiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCIvKipcbiAqIHByb3BzIFtyZW5kZXJQYXRoID0gYWRkIHBhdGggb24gY2FuY2FzIGZ1bmMsIF1cbiAqL1xuaW1wb3J0IGZpbHRlciBmcm9tICdsb2Rhc2gvZmlsdGVyJztcbmltcG9ydCB7XG4gIGZhYnJpY1xufSBmcm9tICdmYWJyaWMnO1xuY2xhc3MgU3RvcmUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlclBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5jeHQgPSBwcm9wcy5jeHQ7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMucmVkb3MgPSBbXTtcbiAgICB0aGlzLnVuZG9zID0gW107XG4gIH1cblxuICBhZGQocGF0aEluZm8pIHtcbiAgICB0aGlzLml0ZW1zLnB1c2gocGF0aEluZm8pO1xuICB9XG5cbiAgZHJhd1BhdGgocHRhaCkge1xuICAgIHRoaXMuY3h0LmFkZChwYXRoKTtcbiAgfVxuXG4gIGRlbGV0ZShpZCkge1xuICAgIGxldCBwYXRocyA9IFtdXG4gICAgaWYgKCFpZCkgeyAvL2RlbGV0ZSBzZWxlY3RlZFxuICAgICAgcGF0aHMgPSBmaWx0ZXIodGhpcy5pdGVtcywgKGl0ZW0pID0+IGl0ZW0uaGFzQ29udHJvbHMpO1xuICAgIH07XG4gICAgcGF0aHMgPSBmaWx0ZXIodGhpcy5pdGVtcywgKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICB0aGlzLml0ZW1zID0gZmlsdGVyKHRoaXMuaXRlbXMsIChpdGVtKSA9PiBpdGVtLmlkICE9PSBpZCk7XG4gICAgcGF0aHMubWFwKChwYXRoKSA9PiB0aGlzLmN4dC5yZW1vdmUocGF0aCkpO1xuICB9XG5cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuY3h0LmNsZWFyKCk7XG4gIH1cblxuICByZWRvKCkge1xuICAgIGRlYnVnZ2VyXG4gICAgaWYgKHRoaXMucmVkb3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWRvcy5sZW5ndGg7XG4gICAgICBjb25zdCByZWRvUGF0aCA9IHRoaXMucmVkb3NbbGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLmN4dC5hZGQocmVkb1BhdGgpO1xuICAgICAgdGhpcy5hZGQocmVkb1BhdGgpO1xuICAgICAgdGhpcy5yZWRvcyA9IGZpbHRlcih0aGlzLnJlZG9zLCAoaXRlbSkgPT4gaXRlbS5pZCAhPT0gcmVkb1BhdGguaWQpO1xuICAgIH1cbiAgfVxuXG4gIHVuZG8oKSB7XG4gICAgZGVidWdnZXJcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgdW5kb1BhdGggPSB0aGlzLml0ZW1zW2xlbmd0aCAtIDFdO1xuICAgIHRoaXMucmVkb3MgPSBbLi4udGhpcy5yZWRvcywgdW5kb1BhdGhdO1xuICAgIHRoaXMuZGVsZXRlKHVuZG9QYXRoLmlkKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yZTsiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwiaW1wb3J0IHtcbiAgZmluZERvbVxufSBmcm9tICcuL3V0aWxzL2RvbSc7XG5pbXBvcnQgbG9nIGZyb20gJy4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHtcbiAgZmFicmljXG59IGZyb20gJ2ZhYnJpYyc7XG5pbXBvcnQgdG9vbFR5cGVzIGZyb20gJy4vY29uc3RhbnRzL3Rvb2xzJztcbmltcG9ydCBUb29scyBmcm9tICcuL3Rvb2xzJztcbmltcG9ydCBTdG9yZSBmcm9tICcuL1N0b3JlJztcblxuaW1wb3J0IGZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGlkOiAnd2hpdGVib2FyZCdcbn1cblxuY29uc3QgbW91c2VFdmVudHMgPSBbe1xuICBvcmlnaW46ICdtb3VzZTp1cCcsXG4gIGluc3RhbmNlOiAnb25Nb3VzZXVwSGFuZGxlJ1xufSwge1xuICBvcmlnaW46ICdtb3VzZTpkb3duJyxcbiAgaW5zdGFuY2U6ICdvbk1vdXNlZG93bkhhbmRsZSdcbn0sIHtcbiAgb3JpZ2luOiAnbW91c2U6bW92ZScsXG4gIGluc3RhbmNlOiAnb25Nb3VzZW1vdmVIYW5kbGUnXG59XVxuXG5jbGFzcyB3aGl0ZWJvYXJkIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoID0gMTAwMCxcbiAgICAgIGhlaWdodCA9IDcwMFxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5vcmlnaW5DYW52YXMgPSBmaW5kRG9tKGAjJHtpZH1gKTtcbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBmYWJyaWMuQ2FudmFzKGlkLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNlbGVjdGlvbjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IFN0b3JlKHtcbiAgICAgIGN4dDogdGhpcy5jYW52YXNcbiAgICB9KTtcbiAgICB3aW5kb3cuY3h0ID0gdGhpcy5jYW52YXM7IC8vIG5lZWQgZGVsZXRlXG4gICAgd2luZG93LnN0b3JlID0gdGhpcy5zdG9yZTtcblxuICAgIHRoaXMudG9vbEdyb3VwID0gbmV3IFRvb2xzKHRoaXMuY2FudmFzLCB7XG4gICAgICBib3JkZXJDb2xvcjogJyMwMEI4RkMnLFxuICAgICAgY29ybmVyQ29sb3I6ICcjRkY0QjU5JyxcbiAgICAgIGNvcm5lclNpemU6IDYsXG4gICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgaGFzQ29udHJvbHM6IGZhbHNlLFxuICAgICAgZm9udFNpemU6IDIwLFxuICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzOiB0cnVlLFxuICAgICAgY29sb3I6ICdyZ2JhKDI2LCAyMDksIDI1NSwgLjcpJyxcbiAgICAgIHdpZHRoOiAxMFxuICAgIH0pO1xuICAgIHdpbmRvdy5jaGFuZ2VUb29sID0gdGhpcy5jaGFuZ2VUb29sO1xuICAgIHdpbmRvdy5jdXJyZW50VG9vbCA9ICgpID0+IHRoaXMuY3VycmVudFRvb2w7XG5cbiAgICB0aGlzLmJpbmRMaXN0ZW5lcigpO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMoKTtcbiAgfVxuXG4gIHJlZG8oKSB7XG4gICAgdGhpcy5zdG9yZS5yZWRvKCk7XG4gIH1cblxuICB1bmRvKCkge1xuICAgIHRoaXMuc3RvcmUudW5kbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRvb2wgaXMgb25lIG9mIHRvb2xUeXBlc1xuICAgKi9cbiAgY2hhbmdlVG9vbCA9ICh0b29sKSA9PiB7XG4gICAgZm9yRWFjaCh0aGlzLnRvb2xHcm91cC50b29scywgKGl0ZW1Ub29sKSA9PiB7XG4gICAgICBpZiAodG9vbCA9PT0gaXRlbVRvb2wudG9vbFR5cGUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9vbCA9IGl0ZW1Ub29sO1xuICAgICAgICBpdGVtVG9vbC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtVG9vbC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuY3VycmVudFRvb2wpXG4gIH1cbiAgLyoqXG4gICAqIFxuICAgKiBAcGFyYW0ge0pBU09OfSBkYXRhIHBhdGggaW5zdGFuY2UganNvblxuICAgKiBkcmF3IHJlY2VpdmUgZGF0YVxuICAgKi9cbiAgZHJhd0pTT04oZGF0YSkge1xuICAgIHRoaXMudG9vbEdyb3VwLmRyYXdKU09OKGRhdGEpO1xuICB9XG5cbiAgZGVsZXRlQWxsKCkge1xuICAgIHRoaXMuc3RvcmUuY2xlYXJBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJhbVtpZF0gcGF0aCBpbnN0YW5jZSBpZFxuICAgKi9cbiAgZGVsZXRlKGlkKSB7XG4gICAgdGhpcy5zdG9yZS5kZWxldGUoaWQpO1xuICB9XG5cbiAgc2V0IGN1cnJlbnRUb29sSW5mbyh0b29sSW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvb2xcbiAgICB9ID0gdG9vbEluZm87XG4gICAgdGhpcy5jaGFuZ2VUb29sKHRvb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIOiuvue9ruWPr+mAiVxuICAgKi9cbiAgc2V0IHNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICB0aGlzLmNhbnZhcyAmJiAodGhpcy5jYW52YXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uKTtcbiAgfVxuXG4gIGJpbmRMaXN0ZW5lcigpIHtcbiAgICBtb3VzZUV2ZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5jYW52YXMub24oaXRlbS5vcmlnaW4sICguLi5hcmcpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9vbCAmJiB0aGlzLmN1cnJlbnRUb29sW2l0ZW0uaW5zdGFuY2VdICYmIHRoaXMuY3VycmVudFRvb2xbaXRlbS5pbnN0YW5jZV0oYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgdGhpcy5jYW52YXMub24oJ3BhdGg6Y3JlYXRlZCcsIChvYmplY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF0aFxuICAgICAgfSA9IG9iamVjdDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRvb2xUeXBlXG4gICAgICB9ID0gcGF0aDtcbiAgICAgIHRoaXMuc3RvcmUuYWRkKHBhdGgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLm9uKCdzZWxlY3Rpb246Y3JlYXRlZCcsIChwYXRoKSA9PiB7fSlcbiAgICB0aGlzLmNhbnZhcy5vbignb2JqZWN0Om1vdmluZycsIChwYXRoKSA9PiB7fSk7XG4gICAgdGhpcy5jYW52YXMub24oJ29iamVjdDpyb3RhdGluZycsIChwYXRoKSA9PiB7fSk7XG4gICAgdGhpcy5jYW52YXMub24oJ29iamVjdDpza2V3aW5nJywgKHBhdGgpID0+IHt9KVxuICB9XG5cbiAgY2hlY2tQYXJhbXMoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmlkKSB7XG4gICAgICBsb2cuZXJyb3IoJ25lZWQgd2hpdGVib2FyZCBJRCcpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2hpdGVib2FyZDsiLCJpbXBvcnQgd2hpdGVib3JkIGZyb20gJy4vV2hpdGVib2FyZCc7XG4vLyBUT0RPOiBjaGVjayBFTlYgcHJvZHVjdGlvbiBkZXZlbG9wbWVudFxud2luZG93LndoaXRlYm9yZCA9IHdoaXRlYm9yZDtcbmV4cG9ydCBkZWZhdWx0IHdoaXRlYm9yZDsiXSwibmFtZXMiOlsiZmluZERvbSIsInNlbCIsImVsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwibG9nTXNnIiwiY29uc29sZSIsImxvZyIsIm1zZyIsImVycm9yIiwiZ2xvYmFsIiwicmVhZCIsIndyaXRlIiwiYmFzZTY0LmZyb21CeXRlQXJyYXkiLCJpZWVlNzU0LnJlYWQiLCJpZWVlNzU0LndyaXRlIiwiYmFzZTY0LnRvQnl0ZUFycmF5IiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiU0VMRUNUT1IiLCJDSVJDTEUiLCJURVhUIiwiUEVOIiwiTUFSS1BFTiIsIkVSQVNFUiIsImZyZWVHbG9iYWwiLCJTeW1ib2wiLCJyb290IiwiaXNBcnJheSIsIm9iamVjdFByb3RvIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiaXNPYmplY3RMaWtlIiwiYmFzZUdldFRhZyIsImFycmF5TWFwIiwiaXNTeW1ib2wiLCJ0b1N0cmluZyIsImJhc2VUb1N0cmluZyIsImJhc2VTbGljZSIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJoYXNVbmljb2RlIiwidW5pY29kZVRvQXJyYXkiLCJhc2NpaVRvQXJyYXkiLCJzdHJpbmdUb0FycmF5IiwiY2FzdFNsaWNlIiwiY3JlYXRlQ2FzZUZpcnN0IiwidXBwZXJGaXJzdCIsInBhdGhFdmVudHMiLCJvcmlnaW4iLCJpbnN0YW5jZSIsIlRvb2xCYXNlIiwiY2FudmFzIiwic3R5bGUiLCJjeHQiLCJpc01vdXNlRG93biIsImhhc1NlbGVjdGVkIiwiYmluZEV2ZW50IiwiZXZlbnQiLCJlIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwiZGlyZWN0aW9uIiwib25Nb3VzZURyYWdIYW5kbGUiLCJwYXRoIiwiaWdub3JlUmVuZGVyIiwiaWQiLCJ1bmlxdWVJZCIsInRvb2xUeXBlIiwiYWRkIiwiZm9yRWFjaCIsIm9uIiwiaGFzQ29udHJvbHMiLCJzZWxlY3RlZCIsInRvb2xBY3RpdmUiLCJDaXJjbGUiLCJhcmciLCJ0b29sVHlwZXMiLCJkb3duUG9pbnRlciIsInBvaW50ZXIiLCJ4IiwieSIsImNpcmNsZSIsInJlbW92ZSIsInJhZGl1cyIsIk1hdGgiLCJhYnMiLCJiZWdpblBvaW50ZXIiLCJsZWZ0IiwidG9wIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImZhYnJpYyIsInJlbmRlclBhdGgiLCJzdGFydCIsImVuZCIsInNxcnQiLCJwb3ciLCJUZXh0IiwiYmluZExpbnRlbmVyIiwidGV4dCIsIlRleHRib3giLCJ3aWR0aCIsImxpbmVIZWlnaHQiLCJoZWlnaHQiLCJ0YXJnZXQiLCJlbnRlckVkaXRpbmciLCJQZW4iLCJvYmplY3QiLCJpc0RyYXdpbmdNb2RlIiwiZnJlZURyYXdpbmdCcnVzaCIsImNvbG9yIiwiTWFya1BlbiIsIkVyYXNlciIsInNlbGVjdGFibGUiLCJUb29scyIsImRyYXdKU09OIiwiZGF0YSIsImNvbnN0cnVjdG9yIiwiY2FwaXRhbGl6ZSIsInR5cGUiLCJmcm9tT2JqZWN0IiwiZmlsbCIsImluaXRUb29scyIsInRvb2xMaXN0IiwiY3JlYXRlQmFzZUZvciIsImhhc093blByb3BlcnR5IiwiYmFzZUlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiTUFYX1NBRkVfSU5URUdFUiIsImFyZ3NUYWciLCJpc0xlbmd0aCIsIm5vZGVVdGlsIiwiYmFzZVVuYXJ5IiwiYmFzZUlzVHlwZWRBcnJheSIsImlzQXJndW1lbnRzIiwiaXNCdWZmZXIiLCJpc1R5cGVkQXJyYXkiLCJiYXNlVGltZXMiLCJpc0luZGV4Iiwib3ZlckFyZyIsImlzUHJvdG90eXBlIiwibmF0aXZlS2V5cyIsImZ1bmNUYWciLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJpc0FycmF5TGlrZSIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5cyIsImJhc2VGb3IiLCJrZXlzIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiYmFzZUVhY2giLCJlcSIsImFzc29jSW5kZXhPZiIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiY29yZUpzRGF0YSIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsImlzTWFza2VkIiwidG9Tb3VyY2UiLCJnZXRWYWx1ZSIsImJhc2VJc05hdGl2ZSIsIk1hcCIsImdldE5hdGl2ZSIsIm5hdGl2ZUNyZWF0ZSIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhcnJheVNvbWUiLCJjYWNoZUhhcyIsIlVpbnQ4QXJyYXkiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsInN5bWJvbFByb3RvIiwibWFwVG9BcnJheSIsInNldFRvQXJyYXkiLCJlcXVhbEFycmF5cyIsImFycmF5UHVzaCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic3R1YkFycmF5IiwiYXJyYXlGaWx0ZXIiLCJiYXNlR2V0QWxsS2V5cyIsImdldFN5bWJvbHMiLCJnZXRBbGxLZXlzIiwiUHJvbWlzZSIsIm9iamVjdFRhZyIsIndlYWtNYXBUYWciLCJEYXRhVmlldyIsIlNldCIsIldlYWtNYXAiLCJhcnJheVRhZyIsImdldFRhZyIsIlN0YWNrIiwiZXF1YWxCeVRhZyIsImVxdWFsT2JqZWN0cyIsImJhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiZ2V0TWF0Y2hEYXRhIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJiYXNlSXNNYXRjaCIsIm1lbW9pemUiLCJtZW1vaXplQ2FwcGVkIiwiaXNLZXkiLCJzdHJpbmdUb1BhdGgiLCJJTkZJTklUWSIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiaGFzUGF0aCIsImJhc2VIYXNJbiIsImdldCIsImhhc0luIiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsImlkZW50aXR5IiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VNYXRjaGVzIiwicHJvcGVydHkiLCJiYXNlRmlsdGVyIiwiYmFzZUl0ZXJhdGVlIiwiU3RvcmUiLCJwcm9wcyIsIml0ZW1zIiwicmVkb3MiLCJ1bmRvcyIsInBhdGhJbmZvIiwicHVzaCIsInB0YWgiLCJwYXRocyIsImZpbHRlciIsIml0ZW0iLCJtYXAiLCJjbGVhciIsImxlbmd0aCIsInJlZG9QYXRoIiwidW5kb1BhdGgiLCJkZWxldGUiLCJhcnJheUVhY2giLCJjYXN0RnVuY3Rpb24iLCJtb3VzZUV2ZW50cyIsIndoaXRlYm9hcmQiLCJjaGFuZ2VUb29sIiwidG9vbCIsInRvb2xHcm91cCIsInRvb2xzIiwiaXRlbVRvb2wiLCJjdXJyZW50VG9vbCIsIm9yaWdpbkNhbnZhcyIsIkNhbnZhcyIsInNlbGVjdGlvbiIsInN0b3JlIiwid2luZG93IiwiYm9yZGVyQ29sb3IiLCJjb3JuZXJDb2xvciIsImNvcm5lclNpemUiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsImZvbnRTaXplIiwidHJhbnNwYXJlbnRDb3JuZXJzIiwiYmluZExpc3RlbmVyIiwiY2hlY2tQYXJhbXMiLCJyZWRvIiwidW5kbyIsImNsZWFyQWxsIiwidG9vbEluZm8iLCJ3aGl0ZWJvcmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMERPLElBQU1BLFVBQVUsU0FBVkEsT0FBVSxDQUFVQyxHQUFWLEVBQThCO0VBQUEsTUFBZkMsRUFBZSx1RUFBVkMsUUFBVTtFQUNuRCxTQUFPRCxHQUFHRSxhQUFILENBQWlCSCxHQUFqQixDQUFQO0VBQ0QsQ0FGTTs7QUMxRFAsWUFBZTtFQUNiLFNBQU8sYUFBVUksTUFBVixFQUFrQjtFQUN2QkMsWUFBUUMsR0FBUixDQUFZRixNQUFaO0VBQ0QsR0FIWTtFQUliLFdBQVMsZUFBQ0csR0FBRCxFQUFTO0VBQ2hCRixZQUFRRyxLQUFSLENBQWNELEdBQWQ7RUFDRDtFQU5ZLENBQWY7O0FDQUEsaUJBQWUsQ0FBQyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTTtFQUN0RCxZQUFZLE9BQU8sSUFBSSxLQUFLLFdBQVcsR0FBRyxJQUFJO0VBQzlDLFlBQVksT0FBTyxNQUFNLEtBQUssV0FBVyxHQUFHLE1BQU0sR0FBRyxFQUFFLEVBQUU7O0VDRHpELElBQUksTUFBTSxHQUFHLEdBQUU7RUFDZixJQUFJLFNBQVMsR0FBRyxHQUFFO0VBQ2xCLElBQUksR0FBRyxHQUFHLE9BQU8sVUFBVSxLQUFLLFdBQVcsR0FBRyxVQUFVLEdBQUcsTUFBSztFQUNoRSxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7RUFDbkIsU0FBUyxJQUFJLElBQUk7RUFDakIsRUFBRSxNQUFNLEdBQUcsSUFBSSxDQUFDO0VBQ2hCLEVBQUUsSUFBSSxJQUFJLEdBQUcsbUVBQWtFO0VBQy9FLEVBQUUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRTtFQUNuRCxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFDO0VBQ3ZCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFDO0VBQ3JDLEdBQUc7O0VBRUgsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUU7RUFDbkMsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUU7RUFDbkMsQ0FBQzs7QUFFRCxFQUFPLFNBQVMsV0FBVyxFQUFFLEdBQUcsRUFBRTtFQUNsQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUU7RUFDZixJQUFJLElBQUksRUFBRSxDQUFDO0VBQ1gsR0FBRztFQUNILEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLElBQUc7RUFDckMsRUFBRSxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTTs7RUFFdEIsRUFBRSxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0VBQ25CLElBQUksTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQztFQUNyRSxHQUFHOztFQUVIO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxFQUFFLFlBQVksR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEVBQUM7O0VBRXhFO0VBQ0EsRUFBRSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsWUFBWSxFQUFDOztFQUUzQztFQUNBLEVBQUUsQ0FBQyxHQUFHLFlBQVksR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFHOztFQUV0QyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUM7O0VBRVgsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtFQUM1QyxJQUFJLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQztFQUN0SyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLEVBQUUsSUFBSSxLQUFJO0VBQ2pDLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLEtBQUk7RUFDaEMsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsS0FBSTtFQUN6QixH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RyxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRTs7RUFFNUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7RUFDZixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBSztFQUNqQixHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFO0VBQ3pCLElBQUksT0FBTyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxRQUFRLENBQUM7RUFDOUMsR0FBRyxNQUFNO0VBQ1QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBQztFQUM3QixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBSztFQUNqQixHQUFHO0VBQ0gsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztFQUNqRCxDQUFDOztBQUVELEVBQU8sU0FBUyxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUU7RUFDbEUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQztFQUNiLEVBQUUsSUFBSSxJQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsRUFBQztFQUNsQyxFQUFFLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFDO0VBQzVCLEVBQUUsSUFBSSxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUM7RUFDdkIsRUFBRSxJQUFJLEVBQUUsSUFBSSxJQUFJLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMs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R0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUM7O0VBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxZQUFZLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtJQUN2RSxJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUM7SUFDbEQsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDOUM7O0VBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxZQUFZLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtJQUN2RSxJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUM7O0lBRWxELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDaEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDbkM7O0VBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxZQUFZLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtJQUN2RSxJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUM7O0lBRWxELE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsU0FBUztPQUM3QixDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRTtPQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJ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QUFDLENBQUMsSUFBSSxFQUFFLENBQUM7T0FDdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNyQjs7RUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0lBQ3JFLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBQztJQUNsRCxPQUFPQyxJQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMvQzs7RUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0lBQ3JFLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBQztJQUNsRCxPQUFPQSxJQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNoRDs7RUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxTQUFTLFlBQVksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0lBQ3ZFLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBQztJQUNsRCxPQUFPQSxJQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMvQzs7RUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxTQUFTLFlBQVksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0lBQ3ZFLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxD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RyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDN0MsQ0FBQztPQUNIOzs7Ozs7Ozs7TUFTRCxXQUFXLEVBQUUsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekIsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbkMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDcEIsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU07WUFDOUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDckQsT0FBTztVQUNMLEtBQUssRUFBRSxLQUFLLElBQUksT0FBTztVQUN2QixNQUFNLEVBQUUsTUFBTTtVQUNkLE1BQU0sRUFBRSxNQUFNO1VBQ2QsS0FBSyxFQUFFLEtBQUssR0FBRyxPQUFPO1VBQ3RCLEtBQUssRUFBRSxDQUFDO1VBQ1IsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDaEIsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakIsQ0FBQztPQUNIOztNQUVELHFCQUFxQixFQUFFLFNBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7UUFDckQs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VSxDQUFDLEVBQUU7UUFDbEMsT0FBTyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztPQUN2Qzs7TUFFRCxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxPQUFPLEdBQUcsRUFBRSxHQUFHLEdBQUc7VUFDckMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztVQUMzQixLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1VBQzNCLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQzs7TUFFekIsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7TUFDbEIsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7O01BRWxCLElBQUksRUFBRSxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHO1VBQzNDLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztVQUMzQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUU7VUFDMUQsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztVQUN0QyxJQUFJLEdBQUcsQ0FBQyxDQUFDOztNQUViLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRTtRQUNWLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN4QyxFQUFF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QztVQUNkLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1VBQ2QsSUFBSSxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO1VBQ3ZCLFFBQVEsR0FBRyxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQzs7TUFFMUUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNuRCxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDdkM7S0FDRixDQUFDOzs7Ozs7Ozs7Ozs7OztJQWNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7O01BRS9FLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsRUFBRTtVQUN4QyxJQUFJLEdBQUcsYUFBYSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7O01BRXRFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsS0FBSyxHQUFHLGdCQUFnQixDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEQsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkIsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUNwQjtNQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2YsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7SUFjRixTQUFTLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7TUFDeEQsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztNQUN2QyxJQUFJLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQ2xDLE9BQU8sa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7T0FDdkM7O01BRUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUk7VUFDaEIsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHO1VBQzlCLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU8sR0FBRyxFQUFFO1VBQzVCLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7VUFDakIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQzs7TUFFdkMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO01BQzlCLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7TUFDdkMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQzs7TUFFcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7VUFDVCxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7VUFDOUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztVQUN2QyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3JCOztRQUVELElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRTtVQUNsQixJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUU7WUFDbEIsU0FBUztXQUNWO1VBQ0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztVQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7V0FDakI7VUFDRCxTQUFTO1NBQ1Y7UUFDRCxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7VUFDWixTQUFTO1NBQ1Y7UUFDRCxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RCLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7VUFDcEIsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNsQjtRQUNELEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7VUFDcEIsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNsQjtPQUNGOztNQUVELElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQztNQUMzQyxPQUFPLENBQUMsRUFBRSxFQUFFO1FBQ1YsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNmLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDNUYsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7UUFFakIsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDNUYsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUNsQjs7TUFFRCxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO01BQ3JCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7TUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7TUFDekIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7TUFDekIsSUFBSSxNQUFNLEdBQUc7UUFDWDtVQUNFLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDN0IsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUNEO1VBQ0UsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUM3QixDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzlCO09BQ0YsQ0FBQztNQUNGLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztNQUN4QyxPQUFPLE1BQU0sQ0FBQztLQUNmOztJQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7O0dBRWpELEdBQUcsQ0FBQzs7O0VBR0wsQ0FBQyxXQUFXOztJQUVWLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDOzs7Ozs7Ozs7SUFTbEMsU0FBUyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtNQUM3QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDO01BQ2pELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDaEQsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUNwRztNQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7Ozs7Ozs7OztJQVNELFNBQVMsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUU7TUFDOUIsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxTQUFTLE1BQU0sRUFBRSxNQUFNLEVBQUU7UUFDdEQsT0FBTyxNQUFNLElBQUksTUFBTSxDQUFDO09BQ3pCLENBQUMsQ0FBQztLQUNKOzs7Ozs7Ozs7SUFTRCxTQUFTLEdBQUcsQ0FBQyxLQUFLLEVBQUUsVUFBVSxFQUFFO01BQzlCLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsU0FBUyxNQUFNLEVBQUUsTUFBTSxFQUFFO1FBQ3RELE9BQU8sTUFBTSxHQUFHLE1BQU0sQ0FBQztPQUN4QixDQUFDLENBQUM7S0FDSjs7Ozs7SUFLRCxTQUFTLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFO01BQzFCLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7TUFDckIsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNWLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7T0FDbEI7TUFDRCxPQUFPLEtBQUssQ0FBQztLQUNkOzs7OztJQUtELFNBQVMsSUFBSSxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFO01BQzFDLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDaEMsT0FBTztPQUNSOztNQUVELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQztVQUNwQixNQUFNLEdBQUcsVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDMUQsSUFBSSxVQUFVLEVBQUU7UUFDZCxPQUFPLENBQUMsRUFBRSxFQUFFO1VBQ1YsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQzNDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7V0FDL0I7U0FDRjtPQUNGO1dBQ0k7UUFDSCxPQUFPLENBQUMsRUFBRSxFQUFFO1VBQ1YsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7V0FDbkI7U0FDRjtPQUNGO01BQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjs7Ozs7SUFLRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRztNQUNsQixJQUFJLEVBQUUsSUFBSTtNQUNWLE1BQU0sRUFBRSxNQUFNO01BQ2QsR0FBRyxFQUFFLEdBQUc7TUFDUixHQUFHLEVBQUUsR0FBRztLQUNULENBQUM7O0dBRUgsR0FBRyxDQUFDOzs7RUFHTCxDQUFDLFdBQVc7Ozs7Ozs7Ozs7SUFVVixTQUFTLE1BQU0sQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7OztNQUl6QyxJQUFJLElBQUksRUFBRTtRQUNSLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxJQUFJLE1BQU0sWUFBWSxPQUFPLEVBQUU7O1VBRXJELFdBQVcsR0FBRyxNQUFNLENBQUM7U0FDdEI7YUFDSSxJQUFJLE1BQU0sWUFBWSxLQUFLLEVBQUU7VUFDaEMsV0FBVyxHQUFHLEVBQUUsQ0FBQztVQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2pELFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztXQUMvQztTQUNGO2FBQ0ksSUFBSSxNQUFNLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1VBQzdDLEtBQUssSUFBSSxRQUFRLElBQUksTUFBTSxFQUFFO1lBQzNCLElBQUksTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTtjQUNuQyxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDN0Q7V0FDRjtTQUNGO2FBQ0k7O1VBRUgsV0FBVyxHQUFHLE1BQU0sQ0FBQztTQUN0QjtPQUNGO1dBQ0k7UUFDSCxLQUFLLElBQUksUUFBUSxJQUFJLE1BQU0sRUFBRTtVQUMzQixXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzFDO09BQ0Y7TUFDRCxPQUFPLFdBQVcsQ0FBQztLQUNwQjs7Ozs7Ozs7O0lBU0QsU0FBUyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRTtNQUMzQixPQUFPLE1BQU0sQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ2xDOzs7SUFHRCxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRztNQUNuQixNQUFNLEVBQUUsTUFBTTtNQUNkLEtBQUssRUFBRSxLQUFLO0tBQ2IsQ0FBQztJQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUMzRCxHQUFHLENBQUM7OztFQUdMLENBQUMsV0FBVzs7Ozs7Ozs7SUFRVixTQUFTLFFBQVEsQ0FBQyxNQUFNLEVBQUU7TUFDeEIsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxTQUFTLEtBQUssRUFBRSxTQUFTLEVBQUU7UUFDMUQsT0FBTyxTQUFTLEdBQUcsU0FBUyxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQztPQUNqRCxDQUFDLENBQUM7S0FDSjs7Ozs7Ozs7Ozs7SUFXRCxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUUsZUFBZSxFQUFFO01BQzNDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUU7U0FDbEMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0tBQ3ZFOzs7Ozs7OztJQVFELFNBQVMsU0FBUyxDQUFDLE1BQU0sRUFBRTtNQUN6QixPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztTQUNqQyxPQUFPLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztTQUN2QixPQUFPLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztTQUN2QixPQUFPLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQztTQUNyQixPQUFPLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQzFCOzs7Ozs7OztJQVFELFNBQVMsYUFBYSxDQUFDLFVBQVUsRUFBRTtNQUNqQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsR0FBRyxFQUFFLENBQUM7TUFDL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMzQyxJQUFJLENBQUMsR0FBRyxHQUFHLFlBQVksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxFQUFFO1VBQ2pELFNBQVM7U0FDVjtRQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDckI7TUFDRCxPQUFPLFNBQVMsQ0FBQztLQUNsQjs7O0lBR0QsU0FBUyxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRTtNQUM1QixJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDOztNQUU3QixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNmLE9BQU8sRUFBRSxDQUFDO09BQ1g7TUFDRCxJQUFJLElBQUksR0FBRyxNQUFNLElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRTtRQUNsQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDdEI7Ozs7TUFJRCxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLE1BQU0sRUFBRTtRQUNwQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1VBQ3pCLE1BQU0sZ0RBQWdELENBQUM7U0FDeEQ7UUFDRCxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNqQyxJQUFJLE1BQU0sR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRTtVQUNsQyxNQUFNLGdEQUFnRCxDQUFDO1NBQ3hEO1FBQ0QsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO09BQzFDOztNQUVELElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNYLE1BQU0sZ0RBQWdELENBQUM7T0FDeEQ7TUFDRCxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7OztNQUlqQyxJQUFJLE1BQU0sR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRTtRQUNsQyxNQUFNLGdEQUFnRCxDQUFDO09BQ3hEOzs7TUFHRCxPQUFPLEtBQUssQ0FBQztLQUNkOzs7Ozs7O0lBT0QsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUc7TUFDbkIsUUFBUSxFQUFFLFFBQVE7TUFDbEIsVUFBVSxFQUFFLFVBQVU7TUFDdEIsU0FBUyxFQUFFLFNBQVM7TUFDcEIsYUFBYSxFQUFFLGFBQWE7S0FDN0IsQ0FBQztHQUNILEdBQUcsQ0FBQzs7O0VBR0wsQ0FBQyxXQUFXOztJQUVWLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLGFBQWEsR0FBRyxXQUFXLEdBQUc7O1FBRTdELGlCQUFpQixHQUFHLENBQUMsV0FBVztVQU05QixPQUFPLElBQUksQ0FBQztTQUNiLEdBQUc7OztRQUdKLFVBQVUsR0FBRyxTQUFTLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO1VBQzNDLEtBQUssSUFBSSxRQUFRLElBQUksTUFBTSxFQUFFOztZQUUzQixJQUFJLFFBQVEsSUFBSSxLQUFLLENBQUMsU0FBUztnQkFDM0IsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLFVBQVU7Z0JBQy9DLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7O2NBRXJELEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLFFBQVEsRUFBRTtnQkFDOUMsT0FBTyxXQUFXOztrQkFFaEIsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUM7a0JBQzdDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztrQkFDckMsSUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7a0JBQzFELElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQzs7a0JBRXpDLElBQUksUUFBUSxLQUFLLFlBQVksRUFBRTtvQkFDN0IsT0FBTyxXQUFXLENBQUM7bUJBQ3BCO2lCQUNGLENBQUM7ZUFDSCxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ2Q7aUJBQ0k7Y0FDSCxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5Qzs7WUFFRCxJQUFJLGlCQUFpQixFQUFFO2NBQ3JCLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTtnQkFDakQsS0FBSyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztlQUM1QztjQUNELElBQUksTUFBTSxDQUFDLE9BQU8sS0FBSyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRTtnQkFDL0MsS0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztlQUMxQzthQUNGO1dBQ0Y7U0FDRixDQUFDOztJQUVOLFNBQVMsUUFBUSxHQUFHLEdBQUc7O0lBRXZCLFNBQVMsU0FBUyxDQUFDLFVBQVUsRUFBRTtNQUM3QixJQUFJLFlBQVksR0FBRyxJQUFJO1VBQ25CLEtBQUssR0FBRyxJQUFJLENBQUM7OztNQUdqQixPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFO1FBQ25DLElBQUksZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzFFLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLGdCQUFnQixFQUFFO1VBQzFDLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQztVQUNoQyxNQUFNO1NBQ1A7O1FBRUQsS0FBSyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztPQUNoRDs7TUFFRCxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ2pCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsR0FBRyxVQUFVLEdBQUcsdUNBQXVDLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDeEc7O01BRUQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQztVQUN4QixZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztVQUNsRCxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzdCOzs7Ozs7Ozs7SUFTRCxTQUFTLFdBQVcsR0FBRztNQUNyQixJQUFJLE1BQU0sR0FBRyxJQUFJO1VBQ2IsVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDOztNQUUxQyxJQUFJLE9BQU8sVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLFVBQVUsRUFBRTtRQUN2QyxNQUFNLEdBQUcsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO09BQzdCO01BQ0QsU0FBUyxLQUFLLEdBQUc7UUFDZixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7T0FDeEM7O01BRUQsS0FBSyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7TUFDMUIsS0FBSyxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7O01BRXRCLElBQUksTUFBTSxFQUFFO1FBQ1YsUUFBUSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBQ3RDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUNqQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztPQUMvQjtNQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDM0QsVUFBVSxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7T0FDMUM7TUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUU7UUFDL0IsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDO09BQzVDO01BQ0QsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO01BQ3BDLEtBQUssQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztNQUN0QyxPQUFPLEtBQUssQ0FBQztLQUNkOztJQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztHQUN2QyxHQUFHLENBQUM7OztFQUdMLENBQUMsWUFBWTs7SUFFWCxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUM7Ozs7SUFJeEIsU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFO01BQzlCLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1VBQ3RELENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7TUFDbkMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDeEIsQ0FBQyxHQUFHLE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxDQUFDLCtCQUErQixFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtVQUM5QyxPQUFPLEtBQUssQ0FBQztTQUNkO09BQ0Y7TUFDRCxPQUFPLElBQUksQ0FBQztLQUNiOzs7SUFHRCxJQUFJLFVBQVU7UUFDVixVQUFVO1FBQ1YsV0FBVyxHQUFHLENBQUMsWUFBWTtVQUN6QixJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7VUFDWixPQUFPLFVBQVUsT0FBTyxFQUFFO1lBQ3hCLE9BQU8sT0FBTyxDQUFDLFVBQVUsS0FBSyxPQUFPLENBQUMsVUFBVSxHQUFHLFlBQVksR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1dBQzFFLENBQUM7U0FDSCxHQUFHLENBQUM7O0lBRVQsQ0FBQyxZQUFZO01BQ1gsSUFBSSxRQUFRLEdBQUcsR0FBRyxDQUFDOztNQUVuQixVQUFVLEdBQUcsVUFBVSxHQUFHLEVBQUU7UUFDMUIsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdEIsQ0FBQzs7TUFFRixVQUFVLEdBQUcsVUFBVSxHQUFHLEVBQUUsT0FBTyxFQUFFO1FBQ25DLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7T0FDekIsQ0FBQztLQUNILEdBQUcsQ0FBQzs7SUFFTCxTQUFTLGNBQWMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFO01BQ3BDLE9BQU87UUFDTCxPQUFPLEVBQUUsT0FBTztRQUNoQixjQUFjLEVBQUUsb0JBQW9CLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQztPQUNuRCxDQUFDO0tBQ0g7O0lBRUQsU0FBUyxvQkFBb0IsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFO01BQzFDLE9BQU8sVUFBVSxDQUFDLEVBQUU7UUFDbEIsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7T0FDekQsQ0FBQztLQUNIOztJQUVELFNBQVMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRTtNQUN4QyxPQUFPLFVBQVUsQ0FBQyxFQUFFO1FBQ2xCLElBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRTtVQUM3QyxJQUFJLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztVQUNoRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDM0QsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztXQUMxRDtTQUNGO09BQ0YsQ0FBQztLQUNIOztJQUVELElBQUksa0NBQWtDO1VBQ2hDLGNBQWMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxrQkFBa0IsRUFBRSxxQkFBcUIsQ0FBQztVQUMxRixjQUFjLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDOztRQUUzRSwrQkFBK0I7VUFDN0IsY0FBYyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxhQUFhLENBQUM7VUFDN0UsY0FBYyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDOzs7UUFHOUQsU0FBUyxHQUFHLEdBQUc7OztRQUdmLFFBQVEsR0FBRyxHQUFHOztRQUVkLFdBQVcsRUFBRSxjQUFjLENBQUM7O0lBRWhDLElBQUksa0NBQWtDLEVBQUU7O01BRXRDLFdBQVcsR0FBRyxVQUFVLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTs7UUFFNUQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLCtCQUErQixHQUFHLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBQztPQUM1RyxDQUFDOztNQUVGLGNBQWMsR0FBRyxVQUFVLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtRQUMvRCxPQUFPLElBQUksT0FBTyxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsK0JBQStCLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDO09BQy9HLENBQUM7S0FDSDs7U0FFSSxJQUFJLCtCQUErQixFQUFFOztNQUV4QyxXQUFXLEdBQUcsVUFBVSxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRTtRQUNuRCxJQUFJLENBQUMsT0FBTyxFQUFFO1VBQ1osT0FBTztTQUNSO1FBQ0QsSUFBSSxHQUFHLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9CLFVBQVUsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRTtVQUNuQixTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ3RCO1FBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRTtVQUM5QixTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDOztTQUVoQztRQUNELElBQUksUUFBUSxHQUFHLGNBQWMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDNUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxTQUFTLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDO09BQ2hFLENBQUM7O01BRUYsY0FBYyxHQUFHLFVBQVUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7UUFDdEQsSUFBSSxDQUFDLE9BQU8sRUFBRTtVQUNaLE9BQU87U0FDUjtRQUNELElBQUksR0FBRyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLENBQUM7UUFDekMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1VBQy9DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDcEUsUUFBUSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QyxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtjQUM1QyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxTQUFTLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2NBQy9ELFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7YUFDckM7V0FDRjtTQUNGO09BQ0YsQ0FBQztLQUNIO1NBQ0k7O01BRUgsV0FBVyxHQUFHLFVBQVUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7UUFDbkQsSUFBSSxDQUFDLE9BQU8sRUFBRTtVQUNaLE9BQU87U0FDUjtRQUNELElBQUksR0FBRyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1VBQ2xCLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDckI7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1VBQzdCLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7VUFDOUIsSUFBSSxlQUFlLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsQ0FBQztVQUNoRCxJQUFJLGVBQWUsRUFBRTtZQUNuQixRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1dBQ2hEO1VBQ0QsT0FBTyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDOUQ7UUFDRCxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO09BQ3hDLENBQUM7O01BRUYsY0FBYyxHQUFHLFVBQVUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7UUFDdEQsSUFBSSxDQUFDLE9BQU8sRUFBRTtVQUNaLE9BQU87U0FDUjtRQUNELElBQUksR0FBRyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvQixJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUU7VUFDN0MsSUFBSSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7VUFDaEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNELElBQUksZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTyxFQUFFO2NBQ25DLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDL0I7V0FDRjtTQUNGO09BQ0YsQ0FBQztLQUNIOzs7Ozs7Ozs7O0lBVUQsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDOzs7Ozs7Ozs7O0lBVXRDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQzs7Ozs7OztJQU81QyxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUU7TUFDekIsS0FBSyxLQUFLLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDOztNQUV2QyxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTTtxQkFDWCxPQUFPLEtBQUssQ0FBQyxVQUFVLEtBQUssT0FBTyxHQUFHLEtBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDOztVQUV6RSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztNQUNuRCxPQUFPO1FBQ0wsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSTtRQUNoQyxDQUFDLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHO09BQ2hDLENBQUM7S0FDSDs7SUFFRCxJQUFJLFFBQVEsR0FBRyxTQUFTLEtBQUssRUFBRTtVQUN6QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUM7U0FDdEI7O1FBRUQsUUFBUSxHQUFHLFNBQVMsS0FBSyxFQUFFO1VBQ3pCLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQztTQUN0QixDQUFDOztJQUVOLFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFO01BQ2hELElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxJQUFJLEtBQUssVUFBVSxHQUFHLGdCQUFnQixHQUFHLFNBQVMsQ0FBQztNQUN6RSxJQUFJLE9BQU8sRUFBRSxjQUFjLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztNQUUvQyxJQUFJLGNBQWMsSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDdkMsT0FBTyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztPQUN6Qzs7TUFFRCxJQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtRQUNsQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQzdCOztNQUVELE9BQU8sT0FBTyxDQUFDO0tBQ2hCOztJQUVELElBQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO01BQzNCLFFBQVEsR0FBRyxTQUFTLEtBQUssRUFBRTtRQUN6QixPQUFPLFdBQVcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO09BQy9DLENBQUM7TUFDRixRQUFRLEdBQUcsU0FBUyxLQUFLLEVBQUU7UUFDekIsT0FBTyxXQUFXLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztPQUMvQyxDQUFDO0tBQ0g7O0lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDOztHQUVyQyxHQUFHLENBQUM7OztFQUdMLENBQUMsWUFBWTs7Ozs7Ozs7O0lBU1gsU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRTtNQUNqQyxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO01BQ2pDLElBQUksQ0FBQyxZQUFZLEVBQUU7UUFDakIsT0FBTyxPQUFPLENBQUM7T0FDaEI7TUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtRQUM5QixPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDO1FBQ3RDLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUQsT0FBTyxDQUFDO09BQ2I7TUFDRCxLQUFLLElBQUksUUFBUSxJQUFJLE1BQU0sRUFBRTtRQUMzQixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7VUFDMUIsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUN2QzthQUNJO1VBQ0gsSUFBSSxrQkFBa0IsR0FBRyxDQUFDLFFBQVEsS0FBSyxPQUFPLElBQUksUUFBUSxLQUFLLFVBQVU7ZUFDcEUsT0FBTyxZQUFZLENBQUMsVUFBVSxLQUFLLFdBQVcsR0FBRyxVQUFVLEdBQUcsWUFBWTtjQUMzRSxRQUFRLENBQUM7VUFDYixZQUFZLENBQUMsa0JBQWtCLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDckQ7T0FDRjtNQUNELE9BQU8sT0FBTyxDQUFDO0tBQ2hCOztJQUVELElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztRQUM5QyxlQUFlLEdBQUcsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxRQUFRO1FBQzNELGVBQWUsR0FBRyxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLFFBQVE7UUFDMUQsU0FBUyxHQUFHLHVDQUF1Qzs7O1FBR25ELFVBQVUsR0FBRyxVQUFVLE9BQU8sRUFBRSxFQUFFLE9BQU8sT0FBTyxDQUFDLEVBQUUsQ0FBQzs7SUFFeEQsSUFBSSxlQUFlLEVBQUU7O01BRW5CLFVBQVUsR0FBRyxTQUFTLE9BQU8sRUFBRSxLQUFLLEVBQUU7UUFDcEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQzlCLE9BQU8sT0FBTyxDQUFDO09BQ2hCLENBQUM7S0FDSDtTQUNJLElBQUksZUFBZSxFQUFFOztNQUV4QixVQUFVLEdBQUcsU0FBUyxPQUFPLEVBQUUsS0FBSyxFQUFFO1FBQ3BDLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDdkIsSUFBSSxPQUFPLENBQUMsWUFBWSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUU7VUFDM0QsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7U0FDYjtRQUNELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUU7VUFDN0IsS0FBSyxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsRUFBRSxJQUFJLGdCQUFnQixJQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztVQUN4RSxFQUFFLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNqRDthQUNJO1VBQ0gsRUFBRSxDQUFDLE1BQU0sSUFBSSxpQkFBaUIsSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ3REO1FBQ0QsT0FBTyxPQUFPLENBQUM7T0FDaEIsQ0FBQztLQUNIOztJQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQzs7R0FFakMsR0FBRyxDQUFDOzs7RUFHTCxDQUFDLFdBQVc7O0lBRVYsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7Ozs7Ozs7O0lBUW5DLFNBQVMsT0FBTyxDQUFDLEVBQUUsRUFBRTtNQUNuQixPQUFPLE9BQU8sRUFBRSxLQUFLLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekU7O0lBRUQsSUFBSSx3QkFBd0I7Ozs7Ozs7UUFPeEIsT0FBTyxHQUFHLFNBQVMsU0FBUyxFQUFFO1VBQzVCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDbEMsQ0FBQzs7SUFFTixJQUFJO01BQ0Ysd0JBQXdCLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFlBQVksS0FBSyxDQUFDO0tBQ2pGO0lBQ0QsT0FBTyxHQUFHLEVBQUUsR0FBRzs7SUFFZixJQUFJLENBQUMsd0JBQXdCLEVBQUU7TUFDN0IsT0FBTyxHQUFHLFNBQVMsU0FBUyxFQUFFO1FBQzVCLElBQUksR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUM1RCxPQUFPLENBQUMsRUFBRSxFQUFFO1VBQ1YsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN2QjtRQUNELE9BQU8sR0FBRyxDQUFDO09BQ1osQ0FBQztLQUNIOzs7Ozs7Ozs7SUFTRCxTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFO01BQ3hDLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO01BQ2hELEtBQUssSUFBSSxJQUFJLElBQUksVUFBVSxFQUFFO1FBQzNCLElBQUksSUFBSSxLQUFLLE9BQU8sRUFBRTtVQUNwQixFQUFFLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQzthQUNJLElBQUksSUFBSSxLQUFLLEtBQUssRUFBRTtVQUN2QixFQUFFLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMvQjthQUNJO1VBQ0gsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDekM7T0FDRjtNQUNELE9BQU8sRUFBRSxDQUFDO0tBQ1g7Ozs7Ozs7O0lBUUQsU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtNQUNwQyxJQUFJLE9BQU8sSUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsRUFBRSxPQUFPLENBQUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNwRixPQUFPLENBQUMsU0FBUyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQztPQUNqRTtLQUNGOzs7Ozs7Ozs7O0lBVUQsU0FBUyxXQUFXLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUU7TUFDakQsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7UUFDL0IsT0FBTyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7T0FDNUM7TUFDRCxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7UUFDdEIsT0FBTyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ25EO01BQ0QsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztNQUM3QixPQUFPLE9BQU8sQ0FBQztLQUNoQjs7Ozs7Ozs7SUFRRCxTQUFTLGdCQUFnQixDQUFDLE9BQU8sRUFBRTs7TUFFakMsSUFBSSxJQUFJLEdBQUcsQ0FBQztVQUNSLEdBQUcsR0FBRyxDQUFDO1VBQ1AsVUFBVSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsZUFBZTtVQUM1QyxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUk7WUFDN0IsVUFBVSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQztXQUM1QixDQUFDOzs7Ozs7TUFNTixPQUFPLE9BQU8sS0FBSyxPQUFPLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTs7O1FBR3RELE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUM7O1FBRTdDLElBQUksT0FBTyxLQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUU7VUFDL0IsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUM7VUFDckQsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLEtBQUssVUFBVSxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUM7U0FDcEQ7YUFDSTtVQUNILElBQUksSUFBSSxPQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQztVQUNoQyxHQUFHLElBQUksT0FBTyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUM7U0FDL0I7O1FBRUQsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7VUFDaEUsTUFBTTtTQUNQO09BQ0Y7O01BRUQsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0tBQ2pDOzs7Ozs7Ozs7SUFTRCxTQUFTLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtNQUNqQyxJQUFJLE9BQU87VUFDUCxHQUFHLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxhQUFhO1VBQ3RDLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRTtVQUN6QixNQUFNLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUU7VUFDNUIsYUFBYTtVQUNiLGdCQUFnQixHQUFHO1lBQ2pCLGVBQWUsRUFBRSxNQUFNO1lBQ3ZCLGNBQWMsR0FBRyxLQUFLO1lBQ3RCLFdBQVcsTUFBTSxNQUFNO1lBQ3ZCLFVBQVUsT0FBTyxLQUFLO1dBQ3ZCLENBQUM7O01BRU4sSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE9BQU8sTUFBTSxDQUFDO09BQ2Y7O01BRUQsS0FBSyxJQUFJLElBQUksSUFBSSxnQkFBZ0IsRUFBRTtRQUNqQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDckY7O01BRUQsT0FBTyxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQUM7TUFDOUIsS0FBSyxPQUFPLE9BQU8sQ0FBQyxxQkFBcUIsS0FBSyxXQUFXLEdBQUc7UUFDMUQsR0FBRyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO09BQ3ZDOztNQUVELGFBQWEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7TUFFMUMsT0FBTztRQUNMLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSTtRQUM3RSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxhQUFhLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEdBQUc7T0FDMUUsQ0FBQztLQUNIOzs7Ozs7Ozs7SUFTRCxJQUFJLGVBQWUsQ0FBQztJQUNwQixJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFO01BQy9FLGVBQWUsR0FBRyxTQUFTLE9BQU8sRUFBRSxJQUFJLEVBQUU7UUFDeEMsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7T0FDeEMsQ0FBQztLQUNIO1NBQ0k7TUFDSCxlQUFlLEdBQUcsU0FBUyxPQUFPLEVBQUUsSUFBSSxFQUFFO1FBQ3hDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEMsSUFBSSxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO1VBQ2xDLEtBQUssR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsT0FBTyxLQUFLLENBQUM7T0FDZCxDQUFDO0tBQ0g7O0lBRUQsQ0FBQyxZQUFZO01BQ1gsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsS0FBSztVQUM3QyxVQUFVLEdBQUcsWUFBWSxJQUFJLEtBQUs7Y0FDOUIsWUFBWTtjQUNaLGVBQWUsSUFBSSxLQUFLO2dCQUN0QixlQUFlO2dCQUNmLGtCQUFrQixJQUFJLEtBQUs7a0JBQ3pCLGtCQUFrQjtrQkFDbEIsaUJBQWlCLElBQUksS0FBSztvQkFDeEIsaUJBQWlCO29CQUNqQixFQUFFLENBQUM7Ozs7Ozs7O01BUWpCLFNBQVMsdUJBQXVCLENBQUMsT0FBTyxFQUFFO1FBQ3hDLElBQUksT0FBTyxPQUFPLENBQUMsYUFBYSxLQUFLLFdBQVcsRUFBRTtVQUNoRCxPQUFPLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO1NBQ25EO1FBQ0QsSUFBSSxVQUFVLEVBQUU7VUFDZCxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztTQUNwQzthQUNJLElBQUksT0FBTyxPQUFPLENBQUMsWUFBWSxLQUFLLFFBQVEsRUFBRTtVQUNqRCxPQUFPLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUM3QjtRQUNELE9BQU8sT0FBTyxDQUFDO09BQ2hCOzs7Ozs7OztNQVFELFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFO1FBQ3RDLElBQUksT0FBTyxPQUFPLENBQUMsYUFBYSxLQUFLLFdBQVcsRUFBRTtVQUNoRCxPQUFPLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztTQUM5QjtRQUNELElBQUksVUFBVSxFQUFFO1VBQ2QsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDaEM7YUFDSSxJQUFJLE9BQU8sT0FBTyxDQUFDLFlBQVksS0FBSyxRQUFRLEVBQUU7VUFDakQsT0FBTyxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7U0FDM0I7UUFDRCxPQUFPLE9BQU8sQ0FBQztPQUNoQjs7TUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLHVCQUF1QixDQUFDO01BQzlELE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEdBQUcscUJBQXFCLENBQUM7S0FDM0QsR0FBRyxDQUFDOztJQUVMLENBQUMsV0FBVzs7Ozs7Ozs7TUFRVixTQUFTLFNBQVMsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFO1FBQ2hDLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hELFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFDbEQsT0FBTyxHQUFHLElBQUksQ0FBQzs7O1FBR25CLFFBQVEsQ0FBQyxNQUFNLGtCQUFrQixRQUFRLENBQUMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDLEVBQUU7VUFDekUsSUFBSSxPQUFPLEVBQUU7WUFDWCxJQUFJLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyxRQUFRO2dCQUNuQyxJQUFJLENBQUMsVUFBVSxLQUFLLFFBQVE7Z0JBQzVCLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO2NBQ2xDLE9BQU87YUFDUjtZQUNELE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDaEIsUUFBUSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25DLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7V0FDakU7U0FDRixDQUFDO1FBQ0YsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDbkIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O09BRzlCOztNQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztLQUNuQyxHQUFHLENBQUM7O0lBRUwsU0FBUyxhQUFhLENBQUMsT0FBTyxFQUFFO01BQzlCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztNQUMvQyxPQUFPLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQztJQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ3RDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUNoQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7SUFDdEMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztJQUNoRCxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0lBQ2hELE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUM5QyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7O0dBRTNDLEdBQUcsQ0FBQzs7O0VBR0wsQ0FBQyxXQUFXOztJQUVWLFNBQVMsYUFBYSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUU7TUFDakMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQ25EOztJQUVELElBQUksT0FBTyxHQUFHLENBQUMsV0FBVztNQUN4QixJQUFJLFNBQVMsR0FBRztRQUNkLFdBQVcsRUFBRSxPQUFPLElBQUksYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUMsRUFBRTtRQUM3RCxXQUFXLEVBQUUsT0FBTyxJQUFJLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUU7UUFDMUQsV0FBVyxFQUFFLE9BQU8sSUFBSSxhQUFhLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxFQUFFO1FBQzlELFdBQVcsRUFBRSxPQUFPLElBQUksY0FBYyxFQUFFLENBQUMsRUFBRTtPQUM1QyxDQUFDO01BQ0YsS0FBSyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJO1FBQ3BDLElBQUk7VUFDRixJQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztVQUN6QixJQUFJLEdBQUcsRUFBRTtZQUNQLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1dBQ3JCO1NBQ0Y7UUFDRCxPQUFPLEdBQUcsRUFBRSxHQUFHO09BQ2hCO0tBQ0YsR0FBRyxDQUFDOztJQUVMLFNBQVMsT0FBTyxHQUFHLEdBQUc7Ozs7Ozs7Ozs7Ozs7SUFhdEIsU0FBUyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRTs7TUFFN0IsT0FBTyxLQUFLLE9BQU8sR0FBRyxHQUFHLENBQUMsQ0FBQzs7TUFFM0IsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxHQUFHLEtBQUs7VUFDOUQsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLElBQUksV0FBVyxHQUFHO1VBQ2pELEdBQUcsR0FBRyxPQUFPLEVBQUU7VUFDZixJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDOzs7TUFHOUMsR0FBRyxDQUFDLGtCQUFrQixHQUFHLFdBQVc7UUFDbEMsSUFBSSxHQUFHLENBQUMsVUFBVSxLQUFLLENBQUMsRUFBRTtVQUN4QixVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7VUFDaEIsR0FBRyxDQUFDLGtCQUFrQixHQUFHLE9BQU8sQ0FBQztTQUNsQztPQUNGLENBQUM7O01BRUYsSUFBSSxNQUFNLEtBQUssS0FBSyxFQUFFO1FBQ3BCLElBQUksR0FBRyxJQUFJLENBQUM7UUFDWixJQUFJLE9BQU8sT0FBTyxDQUFDLFVBQVUsS0FBSyxRQUFRLEVBQUU7VUFDMUMsR0FBRyxHQUFHLGFBQWEsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQzlDO09BQ0Y7O01BRUQsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDOztNQUU1QixJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLEtBQUssRUFBRTtRQUN6QyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxFQUFFLG1DQUFtQyxDQUFDLENBQUM7T0FDM0U7O01BRUQsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztNQUNmLE9BQU8sR0FBRyxDQUFDO0tBQ1o7O0lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0dBQy9CLEdBQUcsQ0FBQzs7Ozs7OztFQU9MLE1BQU0sQ0FBQyxHQUFHLEdBQUcsV0FBVyxHQUFHLENBQUM7Ozs7OztFQU01QixNQUFNLENBQUMsSUFBSSxHQUFHLFdBQVcsR0FBRyxDQUFDOzs7RUFHN0IsSUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLEVBQUU7O0lBRWxDLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLFVBQVUsRUFBRTs7TUFFM0MsSUFBSSxPQUFPLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxXQUFXO1VBQzFDLE9BQU8sT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssS0FBSyxVQUFVLEVBQUU7O1FBRW5ELE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxXQUFXO1VBQzlCLE9BQU8sT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDdEQsQ0FBQztPQUNIO0tBQ0YsQ0FBQyxDQUFDO0dBQ0o7Ozs7RUFJRCxDQUFDLFdBQVc7O0lBRVYsU0FBUyxJQUFJLEdBQUc7TUFDZCxPQUFPLEtBQUssQ0FBQztLQUNkOzs7Ozs7Ozs7Ozs7OztJQWNELFNBQVMsT0FBTyxDQUFDLE9BQU8sRUFBRTs7TUFFeEIsZ0JBQWdCLENBQUMsU0FBUyxTQUFTLEVBQUU7UUFDbkMsT0FBTyxLQUFLLE9BQU8sR0FBRyxHQUFHLENBQUMsQ0FBQzs7UUFFM0IsSUFBSSxLQUFLLEdBQUcsU0FBUyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7WUFDaEMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLElBQUksR0FBRztZQUNsQyxNQUFNLEdBQUcsS0FBSyxHQUFHLFFBQVEsRUFBRSxJQUFJO1lBQy9CLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxJQUFJLElBQUk7WUFDbkMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSTtZQUM3QixVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsSUFBSSxJQUFJO1lBQ3ZDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN0RyxVQUFVLEdBQUcsWUFBWSxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxHQUFHLENBQUM7WUFDN0QsUUFBUSxHQUFHLFVBQVUsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHO1lBQ3pELE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLFFBQVEsR0FBRyxVQUFVLENBQUM7O1FBRXZELE9BQU8sQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDOztRQUVyQyxDQUFDLFNBQVMsSUFBSSxDQUFDLFFBQVEsRUFBRTtVQUN2QixJQUFJLEtBQUssRUFBRSxFQUFFO1lBQ1gsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0IsT0FBTztXQUNSO1VBQ0QsSUFBSSxHQUFHLFFBQVEsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7VUFDL0IsSUFBSSxXQUFXLEdBQUcsSUFBSSxHQUFHLE1BQU0sR0FBRyxRQUFRLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQztjQUN2RCxRQUFRLEdBQUcsV0FBVyxHQUFHLFFBQVE7Y0FDakMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUM7Y0FDNUQsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEdBQUcsVUFBVSxJQUFJLE9BQU8sQ0FBQyxDQUFDO1VBQzNELFFBQVEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1VBQ3ZDLElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRTtZQUNqQixPQUFPLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUMzQyxPQUFPO1dBQ1I7VUFDRCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QixFQUFFLEtBQUssQ0FBQyxDQUFDO09BQ1gsQ0FBQyxDQUFDOztLQUVKOztJQUVELElBQUksaUJBQWlCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUI7NEJBQ25DLE1BQU0sQ0FBQyxNQUFNLENBQUMsMkJBQTJCOzRCQUN6QyxNQUFNLENBQUMsTUFBTSxDQUFDLHdCQUF3Qjs0QkFDdEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxzQkFBc0I7NEJBQ3BDLE1BQU0sQ0FBQyxNQUFNLENBQUMsdUJBQXVCOzRCQUNyQyxTQUFTLFFBQVEsRUFBRTs4QkFDakIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDOzZCQUN0RCxDQUFDOztJQUUxQixJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsb0JBQW9CLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUM7Ozs7Ozs7OztJQVN4RixTQUFTLGdCQUFnQixHQUFHO01BQzFCLE9BQU8saUJBQWlCLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDMUQ7O0lBRUQsU0FBUyxlQUFlLEdBQUc7TUFDekIsT0FBTyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztLQUN6RDs7SUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztJQUNoRCxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7R0FDL0MsR0FBRyxDQUFDOzs7RUFHTCxDQUFDLFdBQVc7Ozs7SUFJVixTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtNQUN2QyxJQUFJLEtBQUssR0FBRyxPQUFPO1lBQ2IsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUc7WUFDMUQsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUc7WUFDMUQsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDOztNQUUzRCxLQUFLLElBQUksR0FBRyxJQUFJLEtBQUssSUFBSSxHQUFHLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7TUFDckYsS0FBSyxJQUFJLEdBQUcsQ0FBQztNQUNiLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7Ozs7Ozs7Ozs7Ozs7SUFhRCxTQUFTLFlBQVksQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUU7TUFDM0QsSUFBSSxVQUFVLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsRUFBRTtVQUNwRCxRQUFRLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDOztNQUVyRCxPQUFPLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQzs7TUFFeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTtRQUNyRCxRQUFRLEVBQUUsUUFBUSxJQUFJLEdBQUc7UUFDekIsVUFBVSxFQUFFLFVBQVU7UUFDdEIsUUFBUSxFQUFFLFFBQVE7UUFDbEIsT0FBTyxFQUFFLFFBQVE7UUFDakIsTUFBTSxFQUFFLFVBQVUsV0FBVyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFO1VBQzVELElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFXO2NBQzlCLE9BQU8sQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQztjQUMxQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsUUFBUSxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztVQUN6RCxPQUFPLGNBQWMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ3REO09BQ0YsQ0FBQyxDQUFDLENBQUM7S0FDTDs7SUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7O0dBRXpDLEdBQUcsQ0FBQzs7O0VBR0wsQ0FBQyxXQUFXOztJQUVWLFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUM3QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ25CLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDTixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUNYO1dBQ0k7O1FBRUgsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7VUFDdEIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEM7YUFDSTtVQUNILENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUMxQztPQUNGO01BQ0QsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztLQUNuQzs7SUFFRCxTQUFTLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUMzQixPQUFPLElBQUksQ0FBQyxDQUFDO1FBQ1gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO0tBQ3pEOzs7Ozs7SUFNRCxTQUFTLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7TUFDaEMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDOUM7Ozs7OztJQU1ELFNBQVMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUNsQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNULE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDOUI7TUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzNDOzs7Ozs7SUFNRCxTQUFTLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7TUFDL0IsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNyQzs7Ozs7O0lBTUQsU0FBUyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO01BQ2hDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ25EOzs7Ozs7SUFNRCxTQUFTLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7TUFDbEMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDWCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUNsQztNQUNELE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDaEQ7Ozs7OztJQU1ELFNBQVMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUMvQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN6Qzs7Ozs7O0lBTUQsU0FBUyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO01BQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDdEQ7Ozs7OztJQU1ELFNBQVMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUNsQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNULE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUN0QztNQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNuRDs7Ozs7O0lBTUQsU0FBUyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO01BQzlCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3JEOzs7Ozs7SUFNRCxTQUFTLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7TUFDL0IsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDaEQ7Ozs7OztJQU1ELFNBQVMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUNqQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNyRDs7Ozs7O0lBTUQsU0FBUyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO01BQzlCLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDOUQ7Ozs7OztJQU1ELFNBQVMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUMvQixPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDcEU7Ozs7OztJQU1ELFNBQVMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUNqQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQztPQUNWO01BQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ1gsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQ2Q7TUFDRCxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNULE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzlDO01BQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENB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LENBQUM7TUFDWCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDN0Q7TUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3hFOzs7Ozs7SUFNRCxTQUFTLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7TUFDaEMsT0FBTyxDQUFDLEdBQUcsYUFBYSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDL0M7Ozs7OztJQU1ELFNBQVMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtNQUNqQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDekIsT0FBTyxDQUFDLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDakM7V0FDSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDdkIsT0FBTyxDQUFDLElBQUksTUFBTSxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzFEO1dBQ0ksSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLElBQUks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QUFTLEtBQUssRUFBRTtNQUMzQyxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztNQUN0QyxJQUFJLEtBQUssRUFBRTtRQUNULElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzlGLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUM5RixDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQzs7UUFFbkcsT0FBTztVQUNMLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1VBQ2YsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7VUFDZixRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztVQUNmLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztTQUNwQyxDQUFDO09BQ0g7S0FDRixDQUFDOzs7Ozs7Ozs7O0lBVUYsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7Ozs7Ozs7SUFRdEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxLQUFLLEVBQUU7TUFDckMsT0FBTyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUNyRCxDQUFDOzs7Ozs7Ozs7O0lBVUYsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsU0FBUyxLQUFLLEVBQUU7TUFDM0MsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7TUFDdEMsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE9BQU87T0FDUjs7TUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztVQUN0RCxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztVQUMxRCxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztVQUMxRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7TUFFWixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDWCxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFD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QUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1VBQy9CLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQ3JCLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUMxQjs7OztRQUlELEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2IsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO09BQ2Y7Ozs7Ozs7TUFPRCxzQkFBc0IsRUFBRSxTQUFTLE1BQU0sRUFBRTtRQUN2QyxJQUFJLElBQUksR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUk7WUFDdkMsRUFBRSxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0MsRUFBRSxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0MsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFFLFVBQVUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDOztRQUU1RSxJQUFJLFVBQVUsRUFBRTtVQUNkLFNBQVMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMs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QUFFLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQztZQUNqQixFQUFFLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQztZQUN0QixFQUFFLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQztZQUNqQixFQUFFLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQztZQUN0QixFQUFFLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQztZQUN0QixFQUFFLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQztXQUNsQjtVQUNELElBQUksRUFBRSxJQUFJLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2NBQzVELEVBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztjQUM1RCxFQUFFLElBQUksSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7Y0FDNUQsRUFBRSxJQUFJLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2NBQzVELEdBQUcsR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxD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QUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztVQUNoQixJQUFJLFVBQVUsRUFBRTtZQUNkLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3RELElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUMxRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7V0FDL0Q7ZUFDSTtZQUNILENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDakUsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxD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LE1BQU07WUFDUixLQUFLLFNBQVM7Y0FDWixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Y0FDMUIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztjQUM5QixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2NBQzlCLE1BQU07WUFDUixLQUFLLFNBQVM7Y0FDWixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2NBQ25GLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2NBQ3ZGLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2NBQ3ZGLE1BQU07WUFDUixLQUFLLFdBQVc7Y0FDZCxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFB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
